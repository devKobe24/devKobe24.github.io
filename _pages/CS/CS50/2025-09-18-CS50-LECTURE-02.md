---
title: "🏛️ [CS50] Lecture 2 요약: 메모리와 배열"
tags:
    - CS
    - Harvard
    - CS50
date: "2025-09-18"
thumbnail: "/assets/img/thumbnail/cs50.jpeg"
---

# 🏛️ [CS50] Lecture 2 요약: 메모리와 배열

> 하버드 대학교 CS50 세 번째 강의 - David Malan 교수

---

## 📋 강의 개요

### 텍스트 읽기 수준 분석
- 1학년 수준: "One fish, two fish, red fish, blue fish"
- 3학년 수준: "Congratulations. Today is your day..."
- 10학년 수준: 조지 오웰의 1984 첫 구절
- **텍스트 특성 분석**: 단어 길이, 문장 길이, 구두점으로 읽기 수준 판단 가능

### 이번 주 핵심 주제
- **컴파일 과정의 심화 이해**: 소스코드에서 기계어까지의 4단계
- **메모리 구조**: 컴퓨터가 데이터를 저장하는 방법
- **배열과 문자열**: 연속된 데이터 구조의 이해
- **암호화 기초**: 데이터 보안의 기본 원리

---

## 🔧 컴파일 과정의 4단계

### 기존 이해: make의 진실
```bash
# 기존 방식
make hello
./hello

# 실제로는 이렇게 동작
clang hello.c -o hello
./hello
```

#### Clang 컴파일러 직접 사용하기
```bash
# 기본 컴파일 (a.out 생성)
clang hello.c

# 출력 파일명 지정
clang -o hello hello.c

# CS50 라이브러리 링크
clang -o hello hello.c -l cs50
```

### 컴파일의 4단계 분해

#### 1단계: 전처리 (Preprocessing)
```c
#include <stdio.h>  // 이 라인이
// 실제로는 printf의 프로토타입으로 교체됨:
// int printf(const char *format, ...);

#include <cs50.h>   // 이 라인이
// 실제로는 get_string의 프로토타입으로 교체됨:
// string get_string(const char *prompt);
```

**전처리기 역할:**
- `#include` 지시문을 찾아 해당 파일 내용을 복사-붙여넣기
- 헤더 파일의 함수 프로토타입을 소스코드에 삽입

#### 2단계: 컴파일 (Compiling)
- C 소스코드를 **어셈블리 언어**로 변환
- 어셈블리: 기계어보다는 읽기 쉽지만 여전히 저수준 언어
- 과거에는 프로그래머가 직접 어셈블리로 코딩

#### 3단계: 어셈블링 (Assembling)
- 어셈블리 코드를 **기계어(0과 1)**로 변환
- `a.out` 파일명의 유래: "assembler output"

#### 4단계: 링킹 (Linking)
- 여러 개의 기계어 파일을 하나로 결합
- `hello.c`, `cs50.c`, `stdio.c`의 기계어를 연결
- 최종 실행 가능한 파일 생성

---

## 🐛 디버깅 기법

### 1. printf 디버깅 (기초)
```c
for (int i = 0; i <= 3; i++)  // 버그: <= 사용
{
    printf("i is %i\n", i);   // 디버깅용 출력
    printf("#\n");
}
// 출력: i=0,1,2,3 총 4번 (의도: 3번)
```

**printf의 한계:**
- 매번 재컴파일 필요
- 임시 코드 추가/삭제의 번거로움
- 복잡한 버그에는 비효율적

### 2. debug50 사용 (권장)
```bash
# 디버거 실행
debug50 ./program_name
```

**디버거 사용법:**
1. **브레이크포인트 설정**: 코드 왼쪽 여백 클릭
2. **Step Over**: 현재 라인 실행 후 다음 라인으로
3. **Step Into**: 함수 내부로 들어가기
4. **변수 모니터링**: 실시간으로 변수 값 확인

**디버거의 장점:**
- 코드 수정 없이 실행 상태 확인
- 변수 값의 실시간 추적
- 단계별 실행으로 논리 오류 발견

### 3. 러버덕 디버깅
- **개념**: 무생물(고무 오리)에게 코드 설명하기
- **효과**: 말로 설명하는 과정에서 논리적 오류 발견
- **CS50 Duck**: cs50.ai에서 AI 도움 받기

---

## 💾 메모리와 데이터 타입

### 데이터 타입별 메모리 크기
```c
bool     // 1 byte (비효율적: 1 bit면 충분하지만)
char     // 1 byte
int      // 4 bytes (32 bits)
float    // 4 bytes
double   // 8 bytes
long     // 8 bytes
string   // 가변 크기 (문자 수 + 1)
```

### 메모리 주소 개념
```
메모리 = 거대한 격자 (캔버스)
각 바이트는 고유한 주소(인덱스)를 가짐

주소:  0  1  2  3  4  5  6  7  ...
데이터: H  e  l  l  o  \0 72 73 ...
```

### 점수 프로그램 예제
```c
// 나쁜 방법: 변수 개별 선언
int score1 = 72;
int score2 = 73;
int score3 = 33;
float average = (score1 + score2 + score3) / 3.0;

// 개선된 방법: 배열 사용
int scores[3];
scores[0] = 72;
scores[1] = 73;
scores[2] = 33;
```

---

## 📊 배열 (Arrays)

### 배열의 기본 개념
```c
// 배열 선언과 초기화
int scores[3];          // 크기 3인 정수 배열
scores[0] = 72;         // 첫 번째 요소 (인덱스 0)
scores[1] = 73;         // 두 번째 요소 (인덱스 1)
scores[2] = 33;         // 세 번째 요소 (인덱스 2)

// 사용자 입력으로 배열 채우기
for (int i = 0; i < 3; i++)
{
    scores[i] = get_int("Score: ");
}
```

### 배열의 장단점
**장점:**
- 관련 데이터를 논리적으로 그룹화
- 반복문으로 효율적 처리
- 메모리에 연속적으로 저장되어 빠른 접근

**단점:**
- C에서는 배열 크기를 자동으로 알 수 없음
- 배열 경계를 벗어나는 접근 시 위험
- 크기가 고정적 (컴파일 시점에 결정)

### 상수와 전역 변수 활용
```c
#include <stdio.h>

const int N = 3;  // 전역 상수 (대문자 관례)

int main(void)
{
    int scores[N];
    
    // 배열 입력
    for (int i = 0; i < N; i++)
    {
        scores[i] = get_int("Score: ");
    }
    
    // 평균 계산
    float average = 0;
    for (int i = 0; i < N; i++)
    {
        average += scores[i];
    }
    average /= N;
    
    printf("Average: %.2f\n", average);
}
```

### 함수에 배열 전달하기
```c
float calculate_average(int array[], int length)
{
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        sum += array[i];
    }
    return (float) sum / length;
}

int main(void)
{
    int scores[3] = {72, 73, 33};
    float avg = calculate_average(scores, 3);
    printf("Average: %.2f\n", avg);
}
```

---

## 🔤 문자열 (Strings)

### 문자의 본질 이해
```c
// 문자는 숫자다
char c1 = 'H';  // ASCII 72
char c2 = 'I';  // ASCII 73
char c3 = '!';  // ASCII 33

printf("%c%c%c\n", c1, c2, c3);  // HI!
printf("%i %i %i\n", c1, c2, c3); // 72 73 33
```

### 문자열 = 문자 배열
```c
// 문자열의 실제 구조
string s = "HI!";
// 메모리: ['H']['I']['!']['\0']
//          72   73   33    0

// 배열로 접근 가능
printf("%c\n", s[0]);  // H
printf("%c\n", s[1]);  // I
printf("%c\n", s[2]);  // !
printf("%c\n", s[3]);  // '\0' (null terminator)
```

### NUL 종료 문자 (\0)
- **목적**: 문자열의 끝을 표시
- **값**: 8개의 0 비트 (ASCII 0)
- **중요성**: 문자열 길이 결정, 메모리 오버런 방지
- **크기**: 문자열 길이 + 1바이트

### 문자열 길이 계산
```c
#include <string.h>

// 수동으로 길이 계산
int string_length(string s)
{
    int length = 0;
    while (s[length] != '\0')
    {
        length++;
    }
    return length;
}

// 라이브러리 함수 사용 (권장)
int main(void)
{
    string name = get_string("Name: ");
    int len = strlen(name);  // string.h의 strlen 함수
    printf("Length: %i\n", len);
}
```

### 문자열 처리 예제
```c
#include <string.h>

// 문자열 각 문자 출력
string s = get_string("Input: ");
printf("Output: ");

for (int i = 0, n = strlen(s); i < n; i++)
{
    printf("%c", s[i]);
}
printf("\n");
```

**효율성 개선:**
```c
// 비효율적: strlen을 매번 호출
for (int i = 0; i < strlen(s); i++)

// 효율적: 한 번만 계산
for (int i = 0, n = strlen(s); i < n; i++)
```

---

## 🔄 문자열 조작

### 대문자 변환 프로그램
```c
#include <ctype.h>

// 방법 1: ASCII 값 직접 조작
for (int i = 0, n = strlen(s); i < n; i++)
{
    if (s[i] >= 'a' && s[i] <= 'z')
    {
        printf("%c", s[i] - 32);  // 소문자를 대문자로
    }
    else
    {
        printf("%c", s[i]);       // 그대로 출력
    }
}

// 방법 2: ctype 라이브러리 사용 (권장)
for (int i = 0, n = strlen(s); i < n; i++)
{
    printf("%c", toupper(s[i]));  // 자동으로 대문자 변환
}
```

### 2차원 배열: 문자열 배열
```c
// 문자열 배열 선언
string words[2];
words[0] = "HI!";
words[1] = "BYE!";

// 2차원적 접근
printf("%c", words[0][0]);  // 'H' (첫 번째 단어의 첫 번째 문자)
printf("%c", words[1][2]);  // 'E' (두 번째 단어의 세 번째 문자)
```

---

## ⌨️ 명령줄 인수 (Command Line Arguments)

### 기본 구조
```c
#include <stdio.h>

int main(int argc, string argv[])
{
    // argc: argument count (인수 개수)
    // argv: argument vector (인수 배열)
}
```

### 간단한 인사 프로그램
```c
int main(int argc, string argv[])
{
    if (argc == 2)
    {
        printf("Hello, %s!\n", argv[1]);
    }
    else
    {
        printf("Hello, world!\n");
    }
    return 0;
}
```

**실행 예시:**
```bash
./greet David        # Hello, David!
./greet             # Hello, world!
./greet David Malan # Hello, world! (argc = 3이므로)
```

### argv 배열 구조
```
명령어: ./greet David Malan

argv[0] = "./greet"    (프로그램 이름, 항상 포함)
argv[1] = "David"      (첫 번째 인수)
argv[2] = "Malan"      (두 번째 인수)
argc = 3               (총 인수 개수)
```

### 모든 인수 출력하기
```c
int main(int argc, string argv[])
{
    for (int i = 0; i < argc; i++)
    {
        printf("argv[%i]: %s\n", i, argv[i]);
    }
    return 0;
}
```

### 종료 상태 (Exit Status)
```c
int main(int argc, string argv[])
{
    if (argc != 2)
    {
        printf("Missing command-line argument\n");
        return 1;  // 오류 상태
    }
    
    printf("Hello, %s!\n", argv[1]);
    return 0;  // 성공 상태
}
```

**종료 상태 확인:**
```bash
./status David
echo $?  # 0 (성공)

./status
echo $?  # 1 (실패)
```

---

## 🔐 암호화 기초 (Cryptography)

### 암호화의 개념
```
평문(Plaintext) → [암호화 알고리즘 + 키] → 암호문(Ciphertext)
```

**핵심 요소:**
- **평문**: 원래 메시지 (예: "HI!")
- **암호문**: 암호화된 메시지 (예: "IJ!")
- **키**: 암호화/복호화에 사용되는 비밀 값
- **알고리즘**: 암호화 방법 (예: Caesar cipher)

### Caesar Cipher (시저 암호)
```c
// 암호화: 각 문자를 키만큼 이동
char plaintext = 'H';  // ASCII 72
int key = 1;
char ciphertext = plaintext + key;  // 'I' (ASCII 73)

// 복호화: 키만큼 역방향 이동
char decrypted = ciphertext - key;  // 'H'
```

### ROT13 암호화
```c
#include <ctype.h>

void rot13(string text)
{
    for (int i = 0, n = strlen(text); i < n; i++)
    {
        if (isalpha(text[i]))
        {
            if (islower(text[i]))
            {
                // 소문자 처리 (a=97, z=122)
                printf("%c", (text[i] - 'a' + 13) % 26 + 'a');
            }
            else
            {
                // 대문자 처리 (A=65, Z=90)
                printf("%c", (text[i] - 'A' + 13) % 26 + 'A');
            }
        }
        else
        {
            printf("%c", text[i]);  // 문자가 아닌 경우 그대로
        }
    }
}
```

### 암호화 프로그램 예제
```c
int main(int argc, string argv[])
{
    if (argc != 2)
    {
        printf("Usage: ./caesar key\n");
        return 1;
    }
    
    int key = atoi(argv[1]);  // 문자열을 정수로 변환
    string plaintext = get_string("Plaintext: ");
    
    printf("Ciphertext: ");
    for (int i = 0, n = strlen(plaintext); i < n; i++)
    {
        if (isalpha(plaintext[i]))
        {
            // 알파벳 문자만 암호화
            char base = isupper(plaintext[i]) ? 'A' : 'a';
            printf("%c", (plaintext[i] - base + key) % 26 + base);
        }
        else
        {
            printf("%c", plaintext[i]);  // 그 외는 그대로
        }
    }
    printf("\n");
    
    return 0;
}
```

---

## 🎯 프로그래밍 원칙과 모범 사례

### 효율적인 코드 작성
```c
// 비효율적: 함수를 반복 호출
for (int i = 0; i < strlen(s); i++)
{
    // strlen이 매번 호출됨
}

// 효율적: 한 번만 계산
for (int i = 0, n = strlen(s); i < n; i++)
{
    // strlen이 한 번만 호출됨
}
```

### 상수 사용하기
```c
// 나쁜 예: 매직 넘버
int scores[3];
for (int i = 0; i < 3; i++) { /* ... */ }
float average = sum / 3.0;

// 좋은 예: 상수 사용
const int N = 3;
int scores[N];
for (int i = 0; i < N; i++) { /* ... */ }
float average = sum / (float) N;
```

### 범위(Scope) 관리
```c
// 전역 변수 (모든 함수에서 접근 가능)
const int MAX_STUDENTS = 50;

int main(void)
{
    // 지역 변수 (main 함수에서만 접근 가능)
    int scores[MAX_STUDENTS];
    
    for (int i = 0; i < MAX_STUDENTS; i++)  // i는 루프에서만 유효
    {
        scores[i] = get_int("Score: ");
    }
    // printf("%d", i);  // 오류: i는 여기서 접근 불가
}
```

---

## 🚀 다음 단계

### 이번 주차에서 배운 핵심 개념
1. **컴파일 과정**: 전처리 → 컴파일 → 어셈블 → 링킹
2. **메모리 구조**: 바이트 단위의 주소 체계
3. **배열**: 연속된 메모리에 같은 타입 데이터 저장
4. **문자열**: null 종료 문자 배열
5. **디버깅**: printf, debugger, rubber duck
6. **명령줄 인수**: 프로그램 실행 시 매개변수 전달
7. **암호화**: 데이터 보안의 기본 원리

### 앞으로 배울 내용
- **포인터**: 메모리 주소 직접 조작
- **동적 메모리 할당**: malloc과 free
- **자료구조**: 연결 리스트, 스택, 큐
- **알고리즘**: 정렬, 검색, 재귀
- **파일 입출력**: 데이터 영속성

### 실무 연결점
- **시스템 프로그래밍**: 운영체제, 드라이버 개발
- **임베디드 시스템**: IoT, 마이크로컨트롤러
- **게임 개발**: 메모리 최적화, 성능 튜닝
- **보안**: 암호화, 해시 함수, 디지털 서명

---

## 💡 마무리 메시지

이번 강의에서는 **컴퓨터의 내부 동작 원리**를 깊이 있게 살펴보았습니다. 소스코드가 어떻게 실행 가능한 프로그램이 되는지, 메모리에서 데이터가 어떻게 저장되고 관리되는지 이해하게 되었습니다.

**배열과 문자열은 프로그래밍의 기초 중의 기초**입니다. 이들을 잘 이해하면 더 복잡한 자료구조도 쉽게 이해할 수 있습니다. C언어에서 문자열이 단순히 문자 배열이라는 사실을 이해했다면, 다른 언어의 문자열 처리도 훨씬 명확해질 것입니다.

**디버깅은 프로그래밍 실력의 핵심**입니다. printf로 시작해서 전문적인 디버거 사용법까지 익혔다면, 복잡한 버그도 체계적으로 해결할 수 있습니다. 러버덕 디버깅처럼 간단한 기법도 놀라울 정도로 효과적임을 기억하세요.

**메모리 관리와 효율성 고려**는 좋은 프로그래머의 필수 덕목입니다. strlen을 반복 호출하지 않기, 상수 사용하기 등의 작은 습관들이 모여 큰 차이를 만듭니다.

마지막으로 **암호화는 현대 디지털 세상의 필수 요소**입니다. 간단한 Caesar cipher부터 시작했지만, 이것이 RSA, AES 같은 현대 암호화 기술의 기초가 됩니다. 데이터 보안의 중요성을 항상 염두에 두고 프로그램을 작성하세요.

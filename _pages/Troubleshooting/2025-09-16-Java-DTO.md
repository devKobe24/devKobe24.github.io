---
title: "🔍[Troubleshooting] 🚀 Java DTO 문제."
tags:
    - Troubleshooting
    - Backend Development
    - Spring Boot
    - DTO
    - SOLID
date: "2025-09-16"
thumbnail: "/assets/img/thumbnail/troubleshooting.jpg"
---

# 🚀 Java DTO Troubleshooting

## 📋 목차
1. [문제 상황](#문제-상황)
2. [해결 방법](#해결-방법)
3. [@NoArgsConstructor 이해하기](#noargsconstructor-이해하기)
4. [리플렉션의 역할](#리플렉션의-역할)
5. [실무 적용 팁](#실무-적용-팁)

---

## 🚨 문제 상황

DTO 클래스에서 `final` 필드와 `@NoArgsConstructor`를 함께 사용할 때 발생하는 컴파일 에러

**에러 메시지**: `variable might not have been initialized`

---

## ✅ 해결 방법

### Before (문제 코드)
```java
@Getter
@Setter
public class CategoryDto {
    private final Long id;        // ❌ final 키워드 문제
    private final String name;    // ❌ final 키워드 문제
    // ...
}
```

### After (수정된 코드)
```java
@Getter
@Setter
@NoArgsConstructor  // ✅ 기본 생성자 자동 생성
public class CategoryDto {
    private Long id;        // ✅ final 제거
    private String name;    // ✅ final 제거
    // ...
}
```

### 🔍 수정 이유

**DTO는 데이터 전송 객체**로서 여러 계층에서 값이 할당되는 경우가 많습니다. 따라서 `final`보다는 일반 필드로 선언하는 것이 일반적입니다.

---

## 🔧 @NoArgsConstructor 이해하기

### 기본 개념

`@NoArgsConstructor`는 **Lombok 어노테이션**으로, 매개변수가 없는 기본 생성자를 자동으로 생성합니다.

### Lombok 사용 전/후 비교

#### 수동 작성 (Before)
```java
public class CategoryDto {
    private Long id;
    private String name;

    // 개발자가 직접 작성해야 하는 기본 생성자
    public CategoryDto() {
    }
    
    // getter, setter 메서드들...
}
```

#### Lombok 사용 (After)
```java
import lombok.NoArgsConstructor;

@NoArgsConstructor  // 기본 생성자를 컴파일 시점에 자동 생성
public class CategoryDto {
    private Long id;
    private String name;
    
    // public CategoryDto() {} 가 자동으로 생성됨
}
```

### 🚫 final과의 충돌 이유

- `final` 필드는 **선언과 동시에 초기화** 또는 **생성자에서 초기화** 필수
- `@NoArgsConstructor`는 매개변수가 **없는** 생성자를 생성
- 매개변수 없는 생성자에서는 `final` 필드를 초기화할 방법이 없음

---

## 🔍 리플렉션의 역할

### 리플렉션이란?

**프로그램이 실행 중(Runtime)에 자기 자신을 들여다보고 조작할 수 있게 해주는 기능**

### 🏗️ Spring/JPA에서의 활용

#### 1. Spring DI (의존성 주입)
```java
@Service
public class PostService {
    // Spring이 리플렉션으로 기본 생성자를 호출하여 Bean 생성
}
```

#### 2. JPA 엔티티 생성
```java
@Entity
public class Post {
    // JPA가 DB 조회 결과를 객체로 변환할 때 기본 생성자 사용
}
```

#### 3. JSON 역직렬화
```java
@RestController
public class PostController {
    
    @PostMapping("/posts")
    public void createPost(@RequestBody PostSaveRequestDto dto) {
        // Jackson이 JSON → DTO 변환 시 기본 생성자 사용
    }
}
```

### 🔄 리플렉션 동작 과정

1. **객체 생성**: 기본 생성자로 빈 객체 생성
2. **필드 탐색**: 리플렉션으로 클래스의 필드 정보 수집
3. **값 주입**: 각 필드에 데이터 할당

### ⚠️ 리플렉션의 단점

| 단점 | 설명 |
|------|------|
| **성능 저하** | 일반적인 메서드 호출보다 느림 |
| **캡슐화 저해** | private 필드에도 접근 가능 |
| **컴파일 시점 체크 불가** | 실행 전까지 문제 발견 어려움 |

---

## 💡 실무 적용 팁

### 1. DTO 설계 가이드라인

```java
// ✅ 권장하는 DTO 구조
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor  // 모든 필드를 받는 생성자도 함께 제공
public class UserDto {
    private Long id;
    private String username;
    private String email;
    private LocalDateTime createdAt;
}
```

### 2. 엔티티 vs DTO 구분

| 구분 | Entity | DTO |
|------|--------|-----|
| **목적** | DB 테이블 매핑 | 데이터 전송 |
| **final 사용** | 가능 (ID 등) | 지양 |
| **생성자** | `@NoArgsConstructor` 필수 | `@NoArgsConstructor` 권장 |

### 3. Lombok 어노테이션 조합

```java
// 실무에서 자주 사용하는 조합
@Data  // @Getter + @Setter + @ToString + @EqualsAndHashCode
@NoArgsConstructor
@AllArgsConstructor
@Builder  // 빌더 패턴 지원
public class ProductDto {
    private Long id;
    private String name;
    private BigDecimal price;
}
```

### 4. 검증 어노테이션과 함께 사용

```java
@Getter
@Setter
@NoArgsConstructor
public class CreateUserRequestDto {
    
    @NotBlank(message = "사용자명은 필수입니다")
    private String username;
    
    @Email(message = "올바른 이메일 형식이 아닙니다")
    private String email;
    
    @Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다")
    private String password;
}
```

---

## 📝 요약

1. **DTO에서는 `final` 키워드 지양** - 데이터 전송 특성상 값 변경이 필요
2. **`@NoArgsConstructor` 필수** - Spring/JPA의 리플렉션 기반 동작을 위해
3. **리플렉션 이해** - 프레임워크가 동적으로 객체를 생성하고 조작하는 원리
4. **실무 팁 활용** - Lombok 조합과 검증 어노테이션으로 효율적인 DTO 설계

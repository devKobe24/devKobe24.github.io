<!DOCTYPE html>
<html lang="en">
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
    
        Home
    
</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Index | devkobe24.com</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="Index">
<meta property="og:locale" content="en_US">
<meta name="description" content="Kobe - Developer blog">
<meta property="og:description" content="Kobe - Developer blog">
<meta property="og:site_name" content="devkobe24.com">
<meta property="og:type" content="article">
<meta property="article:published_time" content="1900-01-01T00:00:00+09:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Index">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","dateModified":"1900-01-01T00:00:00+09:00","datePublished":"1900-01-01T00:00:00+09:00","description":"Kobe - Developer blog","headline":"Index","name":"devkobe24.com","url":"/"}</script>
<!-- End Jekyll SEO tag -->


<link rel="shortcut icon" type="image/png" href="/assets/img/favicon.webp">
<style>
@font-face {
    font-family: 'Nunito Sans';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Nunito Sans'),
         url("/assets/fonts/NunitoSans-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Righteous';
    font-style: normal;
    font-weight: 600;
    font-display: optional;
    src: local('Righteous'),
         url("/assets/fonts/Righteous-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Lato';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Lato'),
         url("/assets/fonts/Lato-Regular.woff2") format("woff2");
}
</style>

<script src="/assets/js/fontfaceobserver.js" type="text/javascript"></script>
<script type="text/javascript">
    const nunitoObserver = new FontFaceObserver('Nunito Sans');
    const righteousObserver = new FontFaceObserver('Righteous');
    const latoObserver = new FontFaceObserver('Lato');
  
    Promise.all([
        nunitoObserver.load(),
        righteousObserver.load(),
        latoObserver.load(),
    ]).then(function(){
        document.documentElement.className += " fonts-loaded";
    });
</script>

<meta name="baseurl" content="">
<meta name="description" content="Kobe - Developer blog">
        <link rel="preload" href="/assets/img/profile.jpg" as="image">
        <link rel="stylesheet" href="/assets/css/style.css">
        
    </head>
    <body>
        <script type="text/javascript">
            let currentTheme = localStorage.getItem('theme');
        
            document.body.classList[currentTheme === 'dark' ? 'add' : 'remove']('dark-theme');
        </script>
        <canvas id="stars" width="100%" height="100%"></canvas>
        <div class="sidebar sidebar-left">
    <div class="side-banner">
        <h1 class="site-tab">
            <a href="/" class="site-name">
                <img src="/assets/img/icon/house.webp" alt="" loading="lazy">
                <mark>devkobe24.com</mark>
            </a>
            <button id="btn-brightness" aria-label="brightness-button">
                <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
                <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
            </button>
            <button id="btn-search" aria-label="search-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
            </button>
            <button id="btn-nav" aria-pressed="false" aria-label="menu-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"></path></svg>
            </button>
        </h1>
        <a href="/" class="site-avatar" aria-label="site-avatar">
            <img src="/assets/img/profile.jpg" loading="lazy" alt="homepage" aria-label="homepage-button">
        </a>
    </div>
    <div class="side-info">
        <nav id="navigation">
    
    
    

    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

    
    
    

    <ul class="nav-list">
<li id="nav-first" aria-label="2024">
            <div class="nav-item">
                <a href="/2024/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>2024</span>
                </a><button class="nav-list-expander" aria-label="toggle items in 2024 category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="AWS">
                    <div class="nav-item">
                        <a href="/2024/AWS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>AWS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CPP_DS">
                    <div class="nav-item">
                        <a href="/2024/CPP_DS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CPP_DS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CS">
                    <div class="nav-item">
                        <a href="/2024/CS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="DataStructure">
                    <div class="nav-item">
                        <a href="/2024/DataStructure/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>DataStructure</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Database">
                    <div class="nav-item">
                        <a href="/2024/Database/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Database</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="HackTheSwift">
                    <div class="nav-item">
                        <a href="/2024/HackTheSwift/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>HackTheSwift</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/2024/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Leet-Code">
                    <div class="nav-item">
                        <a href="/2024/Leet-Code/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Leet-Code</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="MySQL">
                    <div class="nav-item">
                        <a href="/2024/MySQL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>MySQL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Network">
                    <div class="nav-item">
                        <a href="/2024/Network/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Network</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="OS">
                    <div class="nav-item">
                        <a href="/2024/OS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>OS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Read English Book">
                    <div class="nav-item">
                        <a href="/2024/Read%20English%20Book/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Read English Book</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="SQL">
                    <div class="nav-item">
                        <a href="/2024/SQL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>SQL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Spring &amp; Spring Boots">
                    <div class="nav-item">
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Spring &amp; Spring Boots</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="TIL">
                    <div class="nav-item">
                        <a href="/2024/TIL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>TIL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Web">
                    <div class="nav-item">
                        <a href="/2024/Web/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Web</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Backend">
            <div class="nav-item">
                <a href="/Backend/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Backend</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Backend category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="AWS">
                    <div class="nav-item">
                        <a href="/Backend/AWS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>AWS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="AnD">
                    <div class="nav-item">
                        <a href="/Backend/AnD/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>AnD</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CS">
                    <div class="nav-item">
                        <a href="/Backend/CS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="DB">
                    <div class="nav-item">
                        <a href="/Backend/DB/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>DB</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="ENG">
                    <div class="nav-item">
                        <a href="/Backend/ENG/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>ENG</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java多識">
                    <div class="nav-item">
                        <a href="/Backend/Java%E5%A4%9A%E8%AD%98/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java多識</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/Backend/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Math">
                    <div class="nav-item">
                        <a href="/Backend/Math/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Math</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Network">
                    <div class="nav-item">
                        <a href="/Backend/Network/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Network</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Post">
                    <div class="nav-item">
                        <a href="/Backend/Post/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Post</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="TIL">
                    <div class="nav-item">
                        <a href="/Backend/TIL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>TIL</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Metacognition">
            <div class="nav-item">
                <a href="/Metacognition/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Metacognition</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Metacognition category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list"><li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/Metacognition/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li></ul>
</li>
<li id="nav-first" aria-label="Home">
            <div class="nav-item">
                <a href="/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Home</span>
                </a>
</div>
</li>
</ul>
</nav>
        <div id="contact">
            <hr>
            <h3>Contact</h3>
            <ul class="contact-list">
                
                    <li><a aria-label="My Github" href="https://github.com/devKobe24">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Email" href="mailto:dev.skyachieve91@gmail.com">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48H48zM0 176V384c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V176L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"></path></svg>
                    </a></li>
                
                <!-- 
                    <li><a aria-label="My Twitter" href="https://twitter.com/twitter">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.4 151.7c.3 4.5 .3 9.1 .3 13.6 0 138.7-105.6 298.6-298.6 298.6-59.5 0-114.7-17.2-161.1-47.1 8.4 1 16.6 1.3 25.3 1.3 49.1 0 94.2-16.6 130.3-44.8-46.1-1-84.8-31.2-98.1-72.8 6.5 1 13 1.6 19.8 1.6 9.4 0 18.8-1.3 27.6-3.6-48.1-9.7-84.1-52-84.1-103v-1.3c14 7.8 30.2 12.7 47.4 13.3-28.3-18.8-46.8-51-46.8-87.4 0-19.5 5.2-37.4 14.3-53 51.7 63.7 129.3 105.3 216.4 109.8-1.6-7.8-2.6-15.9-2.6-24 0-57.8 46.8-104.9 104.9-104.9 30.2 0 57.5 12.7 76.7 33.1 23.7-4.5 46.5-13.3 66.6-25.3-7.8 24.4-24.4 44.8-46.1 57.8 21.1-2.3 41.6-8.1 60.4-16.2-14.3 20.8-32.2 39.3-52.6 54.3z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Instagram" href="https://www.instagram.com/instagram">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Facebook" href="https://www.facebook.com/facebook">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M512 256C512 114.6 397.4 0 256 0S0 114.6 0 256C0 376 82.7 476.8 194.2 504.5V334.2H141.4V256h52.8V222.3c0-87.1 39.4-127.5 125-127.5c16.2 0 44.2 3.2 55.7 6.4V172c-6-.6-16.5-1-29.6-1c-42 0-58.2 15.9-58.2 57.2V256h83.6l-14.4 78.2H287V510.1C413.8 494.8 512 386.9 512 256h0z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My LinkedIn" href="https://www.linkedin.com/in/linkedin">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
                    </a></li>
                 -->
            </ul>
            <hr>
            <span>
                Copyright © 2024 | <a href="https://github.com/byanko55/jekyll-theme-satellite">Yankos</a>
            </span>
        </div>
    </div>
</div>
<div class="sidebar sidebar-right">
    <div class="tools">
        <button id="btn-brightness" aria-label="brightness-button">
            <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
            <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
        </button>
        <button id="btn-search" aria-label="search-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
        </button>
    </div>
</div>

        <div id="post">
            <div class="inner-header">
                <span class="dot" style="background-color: #F86158;"></span>
                <span class="dot" style="background-color: #FBBF2D;"></span>
                <span class="dot" style="background-color: #2ACB45;"></span>
            </div>
            <div class="inner-content">
                <div class="category-tree">
<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 576 512"><path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"></path></svg>
    <p>
                <a href="/">Home</a>
                &gt;
            </p>
</div>
                
                    <div id="loading">
    <div class="loading_box">
        <img src="/assets/img/loading.webp" loading="lazy">
        <p>Now Loading ...</p>
    </div>
</div>
                    <h1 class="category-header">
    
        All Posts
    
</h1>
<div id="category-list">
    <ul class="paginated-list" data-current-page="1" aria-live="polite">
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-16-system-basic-term.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-16-system-basic-term.html"><h1 class="title_post">🌐[Network] 시스템 기초 용어.</h1></a>
                        <a href="/Backend/Network/2024-08-16-system-basic-term.html" class="txt_post">
                            🌐[Network] 시스템 기초 용어.


  위 그림과 같이 네트워크는 외형적으로 시스템과 전송 매체의 조합으로 구성됩니다.
  데이터 통신을 위한 전송 매체는 전송 대역, 전송 속도, 전송 오류율과 같은 물리적인 특성이 주 관심사이므로 논리적인 기능은 비교적 단순합니다.
  시스템은 전송 매체를 이용해 다양한 연동 형태로 구성할 수 있으므로 개념의 폭이 넓고 복잡합니다.


1️⃣ 시스템의 구분.

  네트워크를 구성하는 시스템이 반드시 일반 컴퓨터처럼 복잡한 기능을 수행해야 하는 것은 아니지만, 데이터 전송 기능을 포함하여 일정 정도의 컴퓨팅 기능을 보유합니다.
  네트워크 시스템은 수행 기능에 따라 다음과 같이 다양한 명칭으로 부를 수 있습니다.
    
      노드, 라우터, 호스트, 클라이언트, 서버
    
  


1️⃣ 노드(Node)

  노드(Node)는 컴퓨터 이론 분야에서 특정 시스템을 가리키는 가장 일반적인 용어로 사용됩니다.
  인터넷에서도 상호 연결된 시스템을 표현할 수 있는 가장 포괄적 의미로 사용되므로 데이터를 주고받을 수 있는 모든 시스템을 통칭합니다.
  노드는 인터넷 내부를 구성하는 라우터와 인터넷 바깥쪽에 연결되어 데이터를 주고받는 호스트로 구분됩니다.


2️⃣ 라우터(Router)

  라우터(Router)는 인터넷 내부를 구성하며, 기본으로 데이터 전송 기능을 포함합니다.
  라우터의 주요 역할은 데이터 중개 기능이며, 인터넷 바깥쪽에 연결된 호스트들 사이의 데이터 전송이 인터넷 내부에서 최적의 경로를 통하여 이루어지도록 합니다.


3️⃣ 호스트(Host)

  호스트(Host)는 인터넷 바깥쪽에 연결되어 일반 사용자들의 네트워크 접속 창구 역할을 합니다.
  일반적인 컴퓨팅 기능을 갖춘 호스트는 네트워크 응용 프로그램을 실행할 수 있고, 사용자는 이 프로그램을 이용하여 다양한 인터넷 서비스를 제공받습니다.
  호스트는 로스트 사이에 제공되는 서비스를 기준으로 클라이언트와 서버로 나눌 수 있습니다.


4️⃣ 클라이언트(Client)와 서버(Server)

  클라이언트(Client)는 임의의 인터넷 서비스를 이용하는 응용 프로그램이고, 서버(Server)는 서비스를 제공하는 응용 프로그램입니다.
  클라이언트와 서버의 개념은 서비스 단위로 이루어지므로 임의의 호스트가 클라이언트나 서버로 고정되지 않습니다.
    
      이용하는 서비스의 종류에 따라서 클라이언트가 될 수도 있고, 서버가 될 수도 있습니다.
        
          그러므로 특정 서비스를 기준으로 상대적인 관점에서 클라이언트와 서버라는 용어를 사용합니다.
        
      
    
  
  일반적으로 응용 프로그램 혹은 서비스 단위가 아닌 호스트 단위로도 클라이언트와 서버를 사용하기도 합니다.
    
      즉, 다양한 서비스를 제공하는 목적으로 특화된 호스트의 경우 호스트 자체를 서버라 부르기도 합니다.
    
  
  서버는 클라이언트보다 먼저 실행 상태가 되어 클라이언트의 요청에 대기해야 합니다.
    
      그리고 영원히 종료하지 않으면서 클라이언트의 요청이 있을 때마다 서비스를 반복해서 제공합니다.
    
  


2️⃣ 클라이언트(Client)와 서버(Server)


  위 그림은 임의의 응용 서비스를 기준으로 클라이언트와 서버의 상대적인 관계를 설명합니다.
  FTP(File Transfer Protocol)는 원격 호스트끼리 파일 송수신 기능을 제공하는 서비스이고, 텔넷(Telnet)은 원격 호스트에 로그인하는 서비스를 제공합니다.
  호스트 2는 FTP 서비스를 제공하고, 호스트 3은 텔넷 서비스를 제공합니다.
  먼저, FTP 서비스를 살펴보면 호스트 1은 호스트 2에 FTP 서비스를 요청합니다.
    
      따라서 FTP 서비스를 기준으로 하면 호스트 1이 클라이언트가 되고, 호스트 2는 서버가 됩니다.
      반면, 텔넷 서비스는 호스트 2가 호스트 3에 서비스를 요청합니다.
        
          텔넷 서비스를 기준으로 하면 호스트 2가 클라이언트이고, 호스트 3은 서버입니다.
            
              따라서 호스트 2는 사용하는 응용 서비스의 종류에 따라 클라이언트가 되기도 하고 서버가 되기도 합니다.
                
                  결론적으로 클라이언트와 서버라는 용어는 서비스 이용의 상대적 위치에 따라 결정됨을 알 수 있습니다.
                
              
            
          
        
      
    
  
  서버의 명칭을 특정 호스트에 전용으로 부여해서 사용할 수도 있습니다.
  특히 다양한 서비스 기능을 제공하는 대형 시스템을 서버로 설정해 다수의 클라이언트가 접속해서 서비스를 이용하도록 할 수 있습니다.
    
      그러나 기능적인 관점에서는 위 그림에서처럼 호스트에서 실행되는 응용 서비스별로 구분하는 것이 더 정확합니다.
    
  
  인터넷에서 네트워크 서비스의 기능은 대부분 응용 프로그램으로 구현되므로 보통 클라이언트 프로세스, 서버 프로세스라는 호칭이 더 자연스러울 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240815_AWS_ServerlessAndOpenAndClosedClould.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240815_AWS_ServerlessAndOpenAndClosedClould.html"><h1 class="title_post">☁️[AWS] 서버리스, 개방형 클라우드와 폐쇄형 클라우드</h1></a>
                        <a href="/Backend/AWS/240815_AWS_ServerlessAndOpenAndClosedClould.html" class="txt_post">
                            ☁️[AWS] 서버리스.

  클라우드 서비스에서는 서버리스(Serverless) 라는 단어를 자주 사용합니다.
    
      직역하면 ‘서버가 없다’는 의미로 서비스가 이용될 때만 서버를 가동하는 방식을 가리켜 ‘서버리스 서비스’라고 합니다.
    
  
  클라우드 서비스는 보통 서버를 사용하는 시간만큼 요금이 발생하므로 요금이 부과되는 시간을 줄여 비용을 낮출 수 있다는 장점이 있습니다.




☁️[AWS] 개방형 클라우드와 폐쇄형 클라우드.

  클라우드 서비스는 사용 형태에 따라 ‘개방형 클라우드’ 와 ‘폐쇄형 클라우드’ 로 나눌 수 있습니다.
    
      이 둘을 섞은 혼합형 클라우드(Hybrid Clould)도 존재합니다.
    
  
  폐쇄형 클라우드
    
      기업 내부의 비밀을 유지하기 위해 외부에 공개하지 않도록 기업 내부에 구축하는 형태입니다.
    
  
  개방형 클라우드
    
      모든 사람이 쓸 수 있게끔 공개된 형태입니다.
    
  
  AWS는 모든 사람이 사용할 수 있는 개방형 클라우드 서비스입니다.
    
      좀 더 자세히 말하자면 AWS에는 전용 기기를 사용자에게 할당하는 베어메탈(Bare Metal) 서비스, 가상으로 사용자의 점유 공간을 제공하는 VPN(Virtual Private Clould) 서비스가 있습니다.
        
          이용이 끝나면 대여한 서버를 다른 사용자에게 다시 대여할 수 있으므로 개방형 클라우드입니다.
        
      
    
  
  폐쇄형 클라우드는 온프레미스에 가깝습니다.
    
      사용자는 시설 내부에 클라우드 컨테이너를 두고 전용 클라우드 환경을 구축해서 사용합니다.
    
  
  하지만 VPC와 같은 가상 독점 공간에서도 보안을 충분히 확보할 수 있고 온프레미스에 가까운 형태인 폐쇄형 클라우드는 초기 투자 비용이 크기 때문에 현재는 개방형 클라우드를 선택하는 경우가 많습니다.




                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240815_AWS_RULES.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240815_AWS_RULES.html"><h1 class="title_post">☁️[AWS] 인바운드 규칙(Inbounds Rules)와 아웃바운드 규칙(Outbound Rules)</h1></a>
                        <a href="/Backend/AWS/240815_AWS_RULES.html" class="txt_post">
                            ☁️[AWS] 인바운드 규칙(Inbounds Rules)와 아웃바운드 규칙(Outbound Rules).

  AWS EC2 인스턴스의 보안 그룹은 인스턴스에 대한 네트워크 트래픽을 제어하는 가상 방화벽 역할을 합니다.
  보안 그룹에는 인바운드(들어오는 트래픽) 및 아웃바운드(나가는 트래픽) 규칙이 있으며, 각 규칙은 특정 유형의 트래픽을 허용하거나 차단할 수 있습니다.


1️⃣ 인바운드 규칙(Inbound Rules)
인바운드 규칙은 외부에서 인스턴스로 들어오는 트래픽을 제어합니다.
이 규칙에 따라 특정 IP 주소나 IP 범위에서 오는 트래픽만 허용됩니다.

  예시
    
      SSH 접속을 허용하기 위해 포트 22번에서 들어오는 트래픽을 허용할 수 있습니다.
        
          이 경우, 특정 IP 주소(예: 203.0.113.0/24)에서 SSH 접속이 가능하도록 설정할 수 있습니다.
        
      
      웹 서버를 운영 중이라면 HHTP(포트 80) 또는 HTTPS(포트 443) 트래픽을 허용할 수 있습니다.
    
  
  중요한 점
    
      보안 그룹은 허용 규칙만 존재하며, 명시적으로 허용된 트래픽만 인스턴스로 들어올 수 있습니다.
      기본적으로, 보안 그룹에 명시되지 않은 모든 인바운드 트래픽은 차단됩니다.
    
  


2️⃣ 아웃바운드 규칙(Outbound Rules)
아웃바운드 규칙은 인스턴스에서 외부로 나가는 트래픽을 제어합니다.
기본적으로 모든 아웃바운드 트래픽이 허용되지만, 필요에 따라 이를 제한할 수 있습니다.

  예시
    
      인스턴스가 특정 외부 서비스로의 연결을 허용하도록, 해당 서비스의 IP 주소나 포트로 나가는 트래픽을 허용할 수 있습니다.
      만약 인스턴스가 외부로 데이터를 보내는 것을 제한하고자 한다면, 특정 포트나 IP 주소로의 나가는 트래픽을 차단할 수 있습니다.
    
  
  중요한 점
    
      기본적으로 아웃바운드 트래픽은 모두 허용되지만, 아웃바운드 규칙을 설정하여 특정 트래픽만 허용하도록 제한할 수 있습니다.
    
  


3️⃣ 보안 그룹 작동 방식

  보안 그룹은 상태 정보를 가지고 있습니다. 즉, 인스턴스로 들어오는 요청이 허용되었다면, 그 요청에 대한 응답은 아웃바운드 규칙과 관계없이 허용됩니다.
  보안 그룹은 AWS 계정 수준에서 관리되며, 여러 인스턴스에 동일한 보안 그룹을 적용할 수 있습니다.
  보안 그룹의 변경 사항은 즉시 적용되므로, 보안 그룹을 수정하면 해당 인스턴스에 바로 반영됩니다.


🙋‍♂️ 마무리
보안 그룹을 올바르게 설정하는 것은 EC2 인스턴스를 안전하게 운영하기 위해 매우 중요합니다.
인바운드 규칙을 통해 접근을 제한하고, 필요에 따라 아웃바운드 규칙을 설정하여 인스턴스의 네트워크 트래픽을 제어할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/2024_08_15_AWS_CLOULD_CLASSIFICATION.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/2024_08_15_AWS_CLOULD_CLASSIFICATION.html"><h1 class="title_post">☁️[AWS] 서비스 제공 형태에 따른 클라우드 분류.</h1></a>
                        <a href="/Backend/AWS/2024_08_15_AWS_CLOULD_CLASSIFICATION.html" class="txt_post">
                            ☁️[AWS] 서비스 제공 형태에 따른 클라우드 분류.

  클라우드 서비스는 제공하는 서비스에 따라 SasS, PaaS, IaaS 로 나눌 수 있습니다.
  SaaS(Software as a Service)
    
      응용 프로그램을 서비스로 제공하는 형태입니다.
      많은 사람이 사용하는 Gmail, Dropbox, Office365, Zoom이 대표적인 SaaS 입니다.
    
  
  PaaS(Platform as a Service), IaaS(Infrastructure as a Service)
    
      응용 프로그램을 만들기 위한 기능을 서비스로 제공합니다.
      이 서비스는 직접 응용 프로그램을 개발하는 사용자를 위한 서비스로, 사용자는 제공 받은 기능을 조합해 응용 프로그램을 개발합니다.
    
  
  PaaS와 IaaS의 차이는 클라우드 서비스 제공자가 관리하는 범위입니다.
    
      PaaS
        
          클라우드 서비스 제공자는 OS 및 미들웨어까지 관리하고, 필수 기능만 사용자에게 제공합니다.
          AWS에서 관리형 서비스로 제공하는 RDS나 DynamoDB, Lambda 등이 여기에 해당합니다.
          유지보수는 AWS가 담당하며 사용자는 AWS에서 제공하는 범위 안에서 자유롭게 기능을 이용할 수 있습니다.
        
      
      IaaS
        
          서버 및 네트워크 기능만 제공하며 설정과 관리는 사용자의 몫입니다.
          AWS의 EC2와 VPC, EBS와 같이 사용자가 자유롭게 설정할 수 있는 서비스가 IaaS에 해당합니다.

        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240815_AWS_BASTION_HOST.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240815_AWS_BASTION_HOST.html"><h1 class="title_post">☁️[AWS] Bastion Host란?</h1></a>
                        <a href="/Backend/AWS/240815_AWS_BASTION_HOST.html" class="txt_post">
                            ☁️[AWS] Bastion Host란?

  Bastion Host는 AWS와 같은 클라우드 환경에서 VPC(Virtual Private Clould) 내부의 다른 인스턴스나 리소스에 접근하기 위한 보안 게이트웨이 역할을 하는 EC2 인스턴스를 의미합니다.
  일반적으로 Bastion Host는 보안과 접근 제어를 강화하기 위해 사용됩니다.


1️⃣ Bastion Host의 주요 개념과 기능.

  1. 보안적인 역할
    
      Bastion Host는 VPC 내에서 퍼블릭 서브넷에 위치하며, 외부 인터넷에 직접적으로 노출되는 유일한 인스턴스입니다.
        
          이 인스턴스에 SSH 또는 RDP(Windows의 경우)를 통해 접근한 다음, VPC 내의 다른 프라이빗 서브넷에 있는 인스턴스들을 접근할 수 있습니다.
        
      
      VPC의 다른 인스턴스들은 프라이빗 서브넷에 위치하며, 직접 외부 인터넷에 노출되지 않도록 설정되어 있습니다.
        
          이로 인해 프라이빗 서브넷의 인스턴스들은 직접 외부에서 접근할 수 없고, Bastion Host를 통해서만 접근이 가능합니다.
        
      
    
  
  2. 접근 제어
    
      Bastion Host는 일반적으로 매우 엄격한 보안 정책을 적용하여 접근을 제어합니다.
        
          예를 들어, 특정 IP 주소에서만 SSH 접근을 허용하거나, 다단계 인증(MFA)을 요구할 수 있습니다.
        
      
      또한, Bastion Host에서 다른 인스턴스에 접근할 때는 추가적인 인증 절차나 SSH 키를 사용하여 안전하게 접근할 수 있습니다.
    
  
  3. 로그 및 모니터링
    
      Bastion Host를 통해 이루어진 모든 접근 기록을 로깅하여 누가 언제 어떤 리소스에 접근했는지 추적할 수 있습니다. 이를 통해 보안 사고 발생 시 신속하게 대응할 수 있습니다.
      이러한 접근 로그는 AWS CloudWatch, S3 버킷 등을 통해 저장 및 분석할 수 있습니다.
    
  


2️⃣ 사용 예시.

  개발팀이 운영 중인 여러 서버에 접근해야 할 때, Bastion Host를 통해 접근하면 직접적으로 서버들이 인터넷에 노출되지 않으면서도 필요한 작업을 수행할 수 있습니다.
  데이터베이스 서버와 같은 중요한 리소스가 있는 프라이빗 서브넷에 대한 접근을 Bastion Host를 통해서만 허용함으로써 보안을 강화할 수 있습니다.
  
    
      외부의 사용자는 Bastion Host에 SSH 접속.
    
  
  
    
      Bastion Host에서 VPC 내부의 프라이빗 서브넷에 있는 서버들에 SSH 접속.
        
          이러한 구조를 통해 VPC 내부의 인스턴스들이 외부로부터 보호되면서도 관리자는 필요한 작업을 수행할 수 있게 됩니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-15-network-basic-term.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-15-network-basic-term.html"><h1 class="title_post">🌐[Network] 네트워크 기초 용어.</h1></a>
                        <a href="/Backend/Network/2024-08-15-network-basic-term.html" class="txt_post">
                            🌐[Network] 네트워크 기초 용어.

  이미 수많은 사람이 익숙하게 사용하고 있는 인터넷(Internet)은 연구소, 기업, 학교 등의 소규모 조직에서 사용하기 시작한 작은 단위의 네트워크(Network)들을 서로 연결하면서 발전하였습니다.
    
      그 과정에서 자연스럽게 연결 방식의 표준화를 요구하게 되었고, 오늘날 전 세계로 확산되어 거대한 인터넷으로 성장하였습니다.
    
  
  네트워크를 이해하려면 시스템, 인터페이스, 전송 매체, 프로토콜, 네트워크, 인터넷과 같은 용어를 먼저 이해해야 합니다.
  네트워크(Network)는 하드웨어적인 전송 매체(Transmission Media)를 매개로 서로 연결되어 데이터를 교환하는 시스템(System)의 모음이며, 시스템과 전송 매체의 연결 지점에 대한 규격이 인터페이스(Interface)입니다.
  시스템이 데이터를 교환할 때는 소프트웨어적으로 동작하는 통신 규칙인 프로토콜(Protocol)이 필요합니다.
  인터페이스와 프로토콜은 서로 다른 시스템을 상호 연동해 동작시키기 위함이니 반드시 연동 형식의 통일이 필요하고, 이를 표준화(Standardization)라 합니다.




  위 그림은 여러 시스템이 전송 매체로 연결되어 네트워크를 구성한 예입니다.
  시스템은 반드시 일반 컴퓨터일 필요는 없으며, 보통 컴퓨팅 기능을 보유한 네트워크 장비들을 의미합니다.
  그림과 같은 네트워크의 가장 바깥쪽에 스마트폰을 포함한 일반 사용자들의 컴퓨터가 연결되어 데이터 교환 작업을 수행합니다.
  시스템들은 물리적으로 공유하는 전송 매체에 의하여 서로 연결되지만, 시스템이 전송 매체를 통해 데이터를 교환하려면 반드시 표준화된 프로토콜을 사용해야 합니다.
  우리가 알고 있는 인터넷은 IP(Internet Protocol)라는 네트워크 프로토콜이 핵심적인 역할을 하는 네트워크의 집합체입니다.
    
      여기서 IP는 프로토콜의 의미가 포함된 약자이지만 보통 IP 프로토콜이라 부릅니다.
    
  


1️⃣ 시스템(System)

  내부 규칙에 따라 자율적으로 동작하는 대상을 가리킵니다.
    
      자동차, 커피 자판기, 컴퓨터, 마이크로프로세서, 하드디스크 등과 같은 물리적인 대상뿐 아니라, 신호등으로 교통을 제어하는 운영 시스템, Mac OS 등의 운영체제, 프로그램의 실행 상태를 의미하는 프로세스와 같은 소프트웨어적인 대상들도 시스템입니다.
        
          🤩 TIP: 네트워크 환경에서 동작하는 임의의 시스템은 다른 시스템과 데이터를 교환하는 기능이 필수적입니다.
        
      
    
  
  시스템의 동작에 필요한 외부 입력이 있을 수 있으며, 내부 정보와 외부 입력의 조합에 따른 출력(시스템 실행의 결과물)이 있을 수 있습니다.
  한편, 작은 시스템이 여러 개 모여 더 큰 시스템을 구성할 수 있으므로 크기를 기준으로 시스템을 나누지는 않습니다.
  우리가 알고 있는 인터넷은 수많은 소규모 네트워크들이 서로 연동되는 반복적인 과정을 거쳐서 형성된 거대 연합체의 네트워크를 의미합니다.


2️⃣ 인터페이스(Interface)

  시스템과 시스템을 연결하기 위한 표준화된 접촉 지점을 의미하며, 하드웨어적인 관점과 소프트웨어적인 관점이 모두 존재합니다.
    
      하드웨어적인 예로서, 컴퓨터 본체와 키보드를 연결하여 제대로 동작하게 하려면 키보드의 잭을 본체의 정해진 위치에 꽂아야 합니다.
        
          이렇게 하려면 상호 간의 데이터 교환을 위한 RS-232C, USB 등과 같은 논리적인 규격뿐만 아니라, 잭의 크기와 모양 같은 물리적인 규격도 표준화되어야 합니다.
        
      
      소프트웨어적인 예로서, 프로그래밍 언어에서 함수 설계자는 함수 이름과 매개변수를 표준화하여 정의해야 하고, 함수 사용자는 이 정의에 맞게 함수 이름과 인수를 지정하여 사용할 수 있습니다.
    
  
  인터페이스를 논리적인 상하 구조의 개념으로 이해할 필요는 없지만, 양방향으로 데이터를 주고 받는 경우와 한쪽에서 다른 쪽의 단방향으로 데이터를 보내는 경우로 나눌 수 있습니다.


3️⃣ 전송 매체(Transmission Media)

  시스템끼리 정해진 인터페이스를 연동해 데이터를 전달하려면 물리적인 전송 수단인 전송 매체(Transmission Media)가 반드시 있어야 합니다.
  전송 매체는 사람의 눈으로 볼 수 있는 동축 케이블을 포함하여 소리를 전파하는 공기, 무선 신호 등 다양하게 존재합니다.
  인터페이스는 시스템 간의 물리적인 연동을 위한 논리적인 규격이고 인터페이스로 정해진 규격은 전송 매체를 통해 물리적으로 구현되며, 시스템끼리 데이터 전송을 가능하게 합니다.


4️⃣ 프로토콜(Protocol)

  논리적으로 상호 연동되는 시스템이 전송 매체를 통해 데이터를 교환할 때는 표준화된 대화 규칙을 따르는데, 이 규칙을 프로토콜(Protocol)이라 합니다.
  일반적으로 프로토콜은 상하 관계가 아닌 동등한 위치에 있는 시스템 사이의 규칙이라는 측면이 강조되어 인터페이스와 구분이 됩니다.
  인터페이스는 위 그림과 같이 두 시스템이 연동하기 위한 특정한 접촉 지점(Access Point)을 의미하는 경우가 많지만, 프로토콜과 비교하여 인용될 때는 상하 개념이 적용됩니다.
    
      즉, 네트워크의 계층 모델 구조에서 인터페이스는 상하 계층 사이의 관계를 다루고, 프로토콜은 동등 계층 사이의 관계를 다룹니다.
        
          일반적으로 프로토콜은 주고받는 데이터의 형식과 그 과정에서 발생하는 일련의 절차적 순서에 무게를 둡니다.
        
      
    
  


5️⃣ 네트워크(Network)

  통신용 전송 매체로 연결된 여러 시스템이 프로토콜을 사용하여 데이터를 주고받을 때, 이들을 하나의 단위로 통칭하여 네트워크(Network)라 부릅니다.
  일반적인 컴퓨터 네트워크에서는 물리적인 전송 매체로 연결된 컴퓨터들이 동일한 프로토콜을 이용해 서로 데이터를 주고 받습니다.
  소규모 네트워크가 모여 더 큰 네트워크를 구성할 수 있는데, 네트워크끼리는 라우터(Router)라는 중개 장비를 사용해서 연결합니다.


6️⃣ 인터넷(Internet)

  전 세계의 모든 네트워크가 유기적으로 연결되어 동작하는 통합 네트워크입니다.
  인터넷에서 사용되는 시스템, 인터페이스, 전송 매체, 프로토콜들은 그 종류가 매우 복잡하고 다양하지만, 데이터 전달 기능에 한해서는 공통으로 IP(Internet Protocol) 프로토콜을 사용합니다.
    
      즉, ISO의 OSI 7계층 모델에서 계층 3인 네트워크 계층의 기능을 IP 프로토콜이 수행하며 인터넷이라는 용어의 IP의 첫 단어인 Internet에서 유래했습니다.
    
  


7️⃣ 표준화(Standardization)

  서로 다른 시스템이 상호 연동해 동작하려면 표준화(Standardization)라는 연동 형식의 통일이 필요합니다.
    
      예를 들어, 프린트 용지를 생각해봅시다.
        
          일반적으로 프린터와 프린트 용지를 만드는 회사는 다릅니다.
          하지만 사전에 A4 규격이라는 통일된 틀을 만들어두었기 때문에 서로 다른 회사에서 생산한 프린터와 프린트 용지를 자유롭게 사용할 수 있습니다.

        
      
    
  
  현대 산업사회가 눈부시게 성장한 배경에는 증기기관의 개발에 따른 에너지 동력원의 발전이 있었습니다.
  지금은 인간의 노동력이라는 한계를 넘어 인공지능으로 대표되는 새로운 차원의 사회 발전 단계인 4차 산업혁명이 진행되고 있습니다.
    
      그러나 이와 다른 관점에서 더 근원적인 발전 배경을 살펴보면, 표준화 원리를 바탕으로 한 레고의 조합 개념이 산업 전반에 존재해왔기 때문임을 알 수 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240815_AWS_Virtualization.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240815_AWS_Virtualization.html"><h1 class="title_post">☁️[AWS] 가상화</h1></a>
                        <a href="/Backend/AWS/240815_AWS_Virtualization.html" class="txt_post">
                            ☁️[AWS] 가상화.

  클라우드 서비스에서도 사용자는 서버를 임대해 사용합니다.
  사용자가 사용하고 싶은 사양으로 서버를 선택하면 가상화 기술을 이용해 해당 사양의 서버를 가상으로 생성해 사용합니다.
  가상 서버 는 하나 또는 클러스터링 된 물리 서버 내에 만들어집니다.
    
      🙋‍♂️ 클러스터링(Clustering, Computer Cluster)
여러 대의 컴퓨터가 연결돼 하나의 시스템처럼 동작하는 컴퓨터들의 집합을 말합니다.
    
  
  가상 서버는 물리 서버의 CPU나 메모리 같은 컴퓨터 자원을 일부 독점해 물리적으로 독립된 서버와 같이 동작합니다.





  서버만 가상화 기술을 사용할 수 있는 것이 아닙니다.
    
      스토리지나 네트워크 장비 등도 1대의 기기를 가상화 기술로 여러 기기처럼 취급할 수 있습니다.
    
  
  기본적으로 가상화 기술을 통해 생성된 기기들을 ‘가상 OO’ 라고 합니다.




                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-14-network-ip.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-14-network-ip.html"><h1 class="title_post">🌐[Network] IP주소(Address)는 네트워크의 번지(주소)</h1></a>
                        <a href="/Backend/Network/2024-08-14-network-ip.html" class="txt_post">
                            🌐[Network] IP주소(Address)는 네트워크의 번지(주소).

  브라우저를 통해 웹 사이트에 접속할 때 우리에게 보이는 웹 페이지는 실제로 어느 주소에 존재하는 ‘웹 사이트를 호스팅하는 서버(웹 서버)’ 에 접속해서 취득한 웹 페이지 정보입니다.
  웹 서버는 데이터 센터에 있을 수도 있고 AWS와 같은 클라우드 서비스에 있을 수도 있습니다.
    
      그리고 웹 서버에 접근하기 위해서는 웹 서버가 그곳에 있다는 특정 정보가 필요합니다.
        
          이것이 IP 주소 입니다.
        
      
    
  
  웹 사이트에 접속할 때는 이 IP 주소를 바탕으로 위치를 특정해 그곳에 있는 웹 서버에 접속합니다.
  웹 서버뿐만 아니라 PC, 스마트폰 등 네트워크와 연결된 모든 장치에는 IP 주소가 할당됩니다.
    
      일반적으로 IPv4가 표준으로 사용됩니다.
        192.168.1.1
        
      
    
  
  (위 예시에서 ‘192’) 1개의 숫자는 0~255까지 256(2⁸)개의 범위를 갖습니다.
  IPv4는 네 개의 숫자가 마침표로 구분된 형식입니다.
  2⁸개의 숫자가 4개 있는 조합이므로 있는 조합이므로 2⁸ˣ⁴=2³²개의 IPv4 주소가 존재합니다.
  IP(v4) 주소는 4개의 숫자를 점으로 구분해 표시합니다.
  IPv4 외에 IPv6도 있습니다.
    
      IPv4는 주소가 2³²(약 43억 개) 존재하는 데 비해 IPv6 주소는 2¹²⁸개(약 340억 개)가 존재합니다.
    
  
  최근 IPv4 주소만으로는 주소를 할당할 수 없을 정도로 서버나 인터넷에 접속하는 기기가 많아져서 대체할 수 있는 IPv6가 주목받고 있습니다.
    
      하지만 IPv6는 아직 보편적으로 보급되지 않았고 기존에 사용하던 기기가 IPv4만 지원하는 경우가 대부분입니다.
    
  


1️⃣ 퍼블릭 IP 주소와 프라이빗 IP 주소.

  IP 주소는 두 가지로 구분할 수 있습니다.
    
      하나는 한국 또는 전 세계에서 ‘이 주소는 인터넷에서 이곳’이라고 특정할 수 있는 주소입니다.
        
          이를 퍼블릭 IP 주소 또는 글로벌 IP 주소라고 합니다.
        
      
    
  
  다른 하나는 프라이빗 IP 주소 입니다.
    
      퍼블릭 IP 주소는 전 세계에서 식별할 수 있는 주소지만, 프라이빗 주소는 닫힌 네트워크(근거리 통신-LAN) 내에서만 식별할 수 있는 IP 주소입니다.
        
          프라이빗 IP 주소로 사용할 수 있는 범위는 다음과 같습니다.
            
              10.0.0.0 ~ 10.255.255.255(10.0.0.0/8)
              172.16.0.0 ~ 172.31.255.255(172.16.0.0/12)
              192.168.0.0 ~ 192.168.255.255(192.168.0.0/16)
                
                  퍼블릭 IP 주소는 이 주소를 제외한 나머지 주소입니다.
                
              
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-08-11-Nginx.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-08-11-Nginx.html"><h1 class="title_post">📝[Post] Nginx 설치방법.</h1></a>
                        <a href="/Backend/Post/2024-08-11-Nginx.html" class="txt_post">
                            🙋‍♂️ Nginx 를 소스에서 직접 컴파일하여 설치하는 방법.

  이 방법은 Homebrew를 사용하지 않고도 Nginx를 설치하는 방법입니다.
  이 방법은 macOS를 기반으로 설치하는 방법을 설명합니다.


1️⃣ 필요한 도구 설치.

  Nginx를 컴파일하려면 Xcode 와 Xcode Command Line Tools 가 필요합니다.
    
      Xcode Command Line Tools 설치.
    
  


xcode-select --install


  프롬프트가 나타나면 설치를 진행합니다.


2️⃣ 소스 코드 다운로드.


  Nginx의 최신 소스 코드를 Nginx 공식 사이트에서 다운로드하거나 wget 명령어를 사용하여 다운로드할 수 있습니다.


curl -O http://nginx.org/download/nginx-1.26.1.tar.gz



  위 명령어에서 nginx-1.26.1 은 설치할 Nginx 버전에 따라 달라질 수 있습니다.
    
      최신 버전을 사용하려면 공식 사이트에서 최신 버전 번호를 확인하세요.
    
  


3️⃣ 소스 코드 압축 해제.

  다운로드한 소스 코드를 압축 해제합니다.


tar -zxvf nginx-1.26.1.tar.gz
cd nginx-1.26.1


4️⃣ Nginx 컴파일 및 설치.

  Nginx를 컴파일하기 위해 몇 가지 옵션을 지정한 후, make 명령어를 사용하여 컴파일하고 설치합니다.


./configure
make
sudo make install



  이 명령어는 기본 설정으로 Nginx를 컴파일하고 /usr/local/nginx 에 설치합니다.
  ./configure 명령어에 다양한 옵션을 추가하여 컴파일 설정을 조정할 수 있습니다.


5️⃣ Nginx 실행.

  컴파일이 완료되면, Nginx를 다음 명령어로 실행할 수 있습니다.


sudo /usr/local/nginx/sbin/nginx



  이제 Nginx가 실행 중일 것입니다.
    
      http://localhost 에 접속하여 Nginx 기본 환영 페이지를 확인할 수 있습니다.
    
  


6️⃣ Nginx 설정 파일

  소스에서 설치한 Nginx의 설정 파일은 /usr/local/nginx/conf/nginx.conf 에 있습니다.
    
      이 파일을 편집하여 설정을 변경할 수 있습니다.
    
  


sudo vi /usr/local/nginx/conf/nginx.conf



  설정을 변경한 후 Nginx를 재시작하여 변경 사항을 적용해야 합니다.


sudo /usr/local/nginx/sbin/nginx -s reload


7️⃣ Nginx 서비스 관리

  Nginx를 시작하고 중지하는 명령어는 다음과 같습니다.
    
      
        
          Nginx 시작.
              sudo /usr/local/nginx/sbin/nginx
            
          
        
      
      
        
          Nginx 중지.
              sudo /usr/local/nginx/sbin/nginx -s stop
            
          
        
      
      
        
          Nginx 재시작.
              sudo /usr/local/nginx/sbin/nginx -s reload
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240809_AWS_EC2_UPLOAD.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240809_AWS_EC2_UPLOAD.html"><h1 class="title_post">☁️[AWS] 로컬 파일을 EC2 서버에 올리는 방법.</h1></a>
                        <a href="/Backend/AWS/240809_AWS_EC2_UPLOAD.html" class="txt_post">
                            ☁️[AWS] 로컬 파일을 EC2 서버에 올리는 방법.
“저의 상황을 예로 들어 설명하도록 하겠습니다.”


  로컬 macBook에서 Amazon Linux 2023 EC2 서버로 파일을 업로드하는 방법 중 가장 일반적인 방법은 scp(secure copy) 를 사용하는 것 입니다.
    
      이 명령을 통해 안전하게 파일을 복사할 수 있습니다.
    
  



  🙋‍♂️ 아래 설명하는 단계들은 로컬에서 이루어져야 합니다.


1️⃣ EC2 인스턴스 연결 정보 확인.

  먼저 EC2 인스턴스의 퍼블릭 IP 주소와 연결에 사용하는 키 페어 파일(.pem)을 확인합니다.


2️⃣ 로컬 macBook에서 scp 명령어 사용.

  scp 명령어를 사용하여 로컬 파일을 EC2 인스턴스로 업로드합니다.
    
      예를 들어, 로컬 파일 localfile.txt 를 EC2 인스턴스의 /home/ec2-user/ 디렉토리에 업로드하려면 다음과 같이 합니다.
    
  


scp -i /path/to/your-key-pair.pem /path/to/localfile.txt ec2-uesr@&lt;EC2-Instance-Public-IP&gt;:/home/ec2-user/


👉 예제.

  키 페어 파일 경로 : /Users/bingGu/.ssh/my-key-pair.pem
  로컬 파일 경로 : /Users/bingGu/Documents/localfile.txt
  EC2 퍼블릭 IP : 43.201.230.99


/Users/bingGu/Documents/localfile.txt ec2-user@43.201.230.99:/home/ec2-user/


3️⃣ 디렉토리 업로드.

  만약 디렉토리를 업로드 하고 싶다면 -r 옵션을 사용하여 디렉토리를 재귀적으로 업로드할 수 있습니다.
    
      예를 들어, 로컬 디렉토리 localdir 을 EC2 인스턴스의 /home/ec2-user/ 디렉토리에 업로드하려면 다음과 같이 합니다.
    
  


scp -r -i /path/to/your-key-pair.pem /path/to/localdir ec2-user@&lt;EC2-Instance-Public-IP&gt;:/home/ec2-user/


4️⃣ 업로드 확인.

  EC2 인스턴스에 SSH로 접속하여 파일이나 디렉토리가 정상적으로 업로드되었는지 확인합니다.


ssh -i /path/to/your-key-pair.pem ec2-user@&lt;EC2-Instance-Public-IP&gt;
ls /home/ec2-user/


🎯 Troubleshooting

  Permission Denied : 키 파일의 권한이 적절하지 않을 때 발생할 수 있습니다.
    
      다음 명령어로 권한을 조정합니다.
        chmod 400 /path/to/your-key-pair.pem
        
      
    
  
  Host Key Verification Failed : 로컬 머신의 SSH 설정에서 이전에 연결한 적 없는 서버에 대해 경고가 뜨는 경우, 다음 명령어로 knows_hosts 파일을 업데이트할 수 있습니다.
    ssh-keygen -R &lt;EC2-Instance-Public-IP&gt;
    
  



  🙋‍♂️ 이 단계를 따르면 로컬 macBook에서 Amazon Linux 2023 EC2 인스턴스로 파일을 성골적으로 업로드할 수 있을 것입니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-09-network-cidr.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-09-network-cidr.html"><h1 class="title_post">🌐[Network] CIDR이란?</h1></a>
                        <a href="/Backend/Network/2024-08-09-network-cidr.html" class="txt_post">
                            🌐[Network] CIDR이란?

  CIDR(Classless Inter-Domain Routing) 은 IP 주소와 관련된 라우팅 방법을 정의하는 표기법입니다.
  CIDR 표기법은 IPv4 주소를 네트워크와 호스트 부분으로 나누고, 네트워크의 크기(서브넷 크기)를 정의하는 데 사용됩니다.
    
      CIDR 표기법은 다음과 같은 형식으로 표현됩니다.
        192.168.0.0/24
        
      
    
  
  이 표기법은 두 부분으로 나뉩니다.
    
      IP 주소 부분 : 192.168.0.0
      서브넷 마스크 부분: /24
        
          여기서 /24 는 서브넷 마스크의 길이를 나타내며, 이는 네트워크 부분의 비트 수를 의미합니다.
            
              즉, 192.168.0.0/24 는 24비트가 네트워크를 정의하고 나머지 8비트(총 32비트 중)가 호스트를 정의하는 서브넷을 나타냅니다.
            
          
        
      
    
  


1️⃣ IPv4 CIDR의 구조.

  IPv4 주소는 32비트로 구성되어 있으며, 이를 네 개의 8비트 옥텟으로 표현합니다.
    
      예를 들어 다음과 같습니다.
        11000000.10101000.00000000.00000000 (이진)
192.168.0.0 (십진)
        
      
    
  
  CIDR 표기법에서 /24 는 첫 번째 24비트(세 개의 옥텟)가 네트워크 주소를 나타낸다는 것을 의미합니다.
    
      이 경우 192.168.0.0 네트워크에는 192.168.0.1 에서 192.168.0.254 까지의 호스트 주소를 가질 수 있습니다.
    
  


2️⃣ IPv4 CIDR의 용도.

  서브네팅 : 큰 네트워크를 작은 서브넷으로 나누기 위해 CIDR을 사용합니다.
  라우팅 : 인터넷 서비스 제공자(ISP) 및 네트워크 관리자는 CIDR을 사용하여 라우팅 테이블을 관리하고, IP 주소 공간을 효율적으로 사용합니다.
  IP 주소 관리 : CIDR은 IP 주소를 할당하고 네트워크를 관리하는 데 사용됩니다.


3️⃣ CIDR 블록의 생성 기준.

  CIDR 블록을 생성할 때는 네트워크 크기와 필요한 IP 주소 수를 고려해야 합니다. 일반적인 기준은 다음과 같습니다.
    
      1. 네트워크 크기 계산 :
        
          /24 서브넷은 256개의 IP 주소(호스트)를 제공합니다. 이 중 두개의 주소(네트워크 주소와 브로드캐스트 주소)를 제외하고, 254개의 호스트 IP 주소를 사용할 수 있습니다.
          /16 서브넷은 65,536개의 IP 주소를 사용할 수 있습니다.
          /32 는 단일 IP 주소를 나타냅니다.
        
      
      2. 필요한 IP 주소 수에 따라 결정 :
        
          만약 50개의 장치를 연결해야 한다면, /26(64개 IP 주소 제공) 서브넷을 사용할 수 있습니다.
          큰 네트워크에는 /16 이나 /12 처럼 더 작은 서브넷 마스크를 사용할 수 있습니다.
        
      
      3. 보안 및 관리 :
        
          더 작은 서브넷(CIDR 블록)을 사용하면 네트워크 트래픽을 보다 효율적으로 관리하고, 보안을 강화할 수 있습니다.
        
      
    
  


4️⃣ 예시.

  /32 : 단일 IP 주소. 예: 192.168.0.1/32
  /24 : 256개의 IP 주소 제공, 주로 작은 네트워크에서 사용. 예: 192.168.0.0/24
  /16 : 65,536개의 IP 주소 제공, 더 큰 네트워크에 사용. 예: 192.168.0.0/16
  /8 : 16,777,216개의 IP 주소 제공, 매우 큰 네트워크에서 사용. 예: 10.0.0.0/8


5️⃣ 결론.

  CIDR 표기법은 IP 주소와 서브넷 마스크를 결합한 표준입니다.
  네트워크의 크기와 IP 주소와 필요 수를 기준으로 CIDR 블록을 생성합니다.
  CIDR을 사용하면 네트워크를 보다 효율적으로 관리하고 라우팅 테이블을 최적화할 수 있습니다.



  🙋‍♂️ CIDR 블록을 설계할 때, 사용하려는 네트워크 규모와 IP 주소 요구 사항을 염두에 두고, 적절한 서브넷 마스크 길이를 선택하는 것이 중요합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240807_AWS_ON-PREMISE.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240807_AWS_ON-PREMISE.html"><h1 class="title_post">☁️[AWS] 온프레미스(on-premise)란?</h1></a>
                        <a href="/Backend/AWS/240807_AWS_ON-PREMISE.html" class="txt_post">
                            ☁️[AWS] 온프레미스(on-premise)란?


  온프레미스(on-premise)란 사용자가 관리하는 시설 내에 서버 등의 기기를 설치해 운용하는 환경입니다.
  AWS와 같은 클라우드 서비스가 등장하기 전까지는 정보 시스템을 구축하기 위해 다음 그림과 같이 자체적으로 관련 기기를 준비하고 설정해야 했습니다.
  이런 기기를 설치하고 운용하는 시설을 일반적으로 데이터 센터(Data Center) 라고 합니다.





  구매, 물리적 설치, 케이블 배선, 네트워크의 설정이 필요하지만 이러한 작업은 전문 업체에 위탁할 수 있습니다.
    
      결과적으로 기기 구매비, 작업에 필요한 인건비 같은 초기 투자 비용이 커지고 설치나 설정에도 시간이 걸리므로 정보 시스템을 구축하기 위한 준비 기간이 길어집니다.
        
          그 대신 기기는 사용자가 자유롭게 이용할 수 있고 이용 형태에 맞게 자유롭게 구성할 수 있습니다.
          초기 투자 비용은 많이 들지만, 이후에 들어가는 비용은 전기 요금과 인터넷 회선 이용 요금 정도이므로 전체 비용에서 운용 비용의 비율이 비교적 낮습니다.
            
              그러나 기기 고장 등 예측하지 못한 상황이 발생해 추가 비용이 발생하는 때도 있습니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240807_AWS_CLOUD.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240807_AWS_CLOUD.html"><h1 class="title_post">☁️[AWS] 클라우드(Cloud)란?</h1></a>
                        <a href="/Backend/AWS/240807_AWS_CLOUD.html" class="txt_post">
                            ☁️[AWS] 클라우드(Cloud)란?


  클라우드(Cloud) 는 클라우드 서비스 제공자가 서버 등의 기기를 준비하고 거기에 구축된 가상 서버나 응용 프로그램 등을 사용자에게 제공하여 이용료를 받는 형태입니다.
  물리적인 기기나 네트워크는 서비스 제공자가 준비해 놨으므로 사용자는 바로 정보 시스템을 구축할 수 있습니다.
  클라우드의 정식 명칭은 클라우드 컴퓨팅(cloud computing) 입니다.
  클라우드의 어원은 단어 뜻 그대로 구름입니다.
    
      보이지 않는 컴퓨팅 자원을 활용한다는 것에서 유래했습니다.
        
          이 말을 풀어 써보면 ‘사용자에게는 보이지 않지만 중앙의 서버 컴퓨팅 자원을 활용해 서비스를 받을 수 있게 하는 플랫폼’ 입니다.
        
      
    
  





  서비스 제공자는 서버나 응용 프로그램을 제공할 뿐만 아니라 내부의 모든 하드웨어를 관리하므로 사용자는 하드웨어 장애에 대해 신경 쓰지 않아도 됩니다.
    
      하지만 사용자는 제공되는 서비스 범위 내에서만 시스템을 이용할 수 있으므로 시스템 구성 자유도는 낮습니다.
      그리고 매원 각종 서비스 사용료를 지불해야 하므로 전체 비용이 커질 수 있습니다.
        
          하지만 기기 노후화나 고장 걱정 없이 안정적으로 컴퓨팅 자원을 사용할 수 있다는 장점이 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-08-07-webpage.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-08-07-webpage.html"><h1 class="title_post">📝[Post] 정적 웹사이트와 동적 웹사이트.</h1></a>
                        <a href="/Backend/Post/2024-08-07-webpage.html" class="txt_post">
                            🙋‍♂️ 정적 웹사이트와 동적 웹사이트.

  정적 웹사이트와 동적 웹사이트는 웹페이지를 생성하고 제공하는 방식에서 큰 차이를 보입니다.
  각각의 특징을 이해하면 어떤 상황에서 어떤 타입의 웹사이트를 사용해야 하는지 결정하는 데 도움이 됩니다.


1️⃣ 정적 웹사이트.

  정적 웹사이트는 미리 만들어진 HTML 파일들을 그대로 웹 서버에서 사용자의 브라우저로 전송하여 보여주는 웹사이트입니다.
    
      이 파일들은 서버에 미리 저장되어 있으며, 사용자의 요청에 따라 변하지 않고 그대로 제공됩니다.
    
  


👍 정적 웹사이트의 장점.

  단순성과 속도.
    
      복잡한 서버 측 처리 없이 바로 파일을 전송하기 때문에 로딩 시간이 빠릅니다.
    
  
  호스팅 비용.
    
      낮은 서버 자원 사용으로 인해 비용이 저렴합니다.
    
  
  보안.
    
      동적 콘텐츠를 처리하는 서버 측 스크립트가 없어 보안 리스크가 상대적으로 낮습니다.
    
  


👎 정적 웹사이트의 단점.

  유연성 부족.
    
      각 페이지를 수동으로 업데이트해야 하며, 대규모 사이트에서는 유지 관리가 어려울 수 있습니다.
    
  
  사용자 상호작용 부족.
    
      사용자 입력에 따라 내용이 바뀌지 않으므로, 폼 제출이나 검색과 같은 기능을 직접 구현하기 어렵습니다.
    
  


2️⃣ 정적 웹사이트의 예시.

  1. 포트폴리오 웹사이트.
    
      웹 개발자, 디자이너, 사진작가 등의 포트폴리오를 위한 웹사이트들은 주로 정적입니다.
      이 웹사이트들은 작품을 보여주는 갤러리, 연락처 정보, 이력서 등의 고정된 내용을 포함합니다.
    
  
  2. 기업 정보 페이지.
    
      소규모 기업이나 스타트업이 회사 정보, 제품 설명, 연락처 정보 등을 제공하는 단순한 웹사이트를 운영할 때, 이는 종종 정적 웹사이트로 구성됩니다.
    
  
  3. 이벤트 안내 페이지.
    
      특정 이벤트의 일시, 장소, 등록 방법 등을 안내하는 웹페이지로, 주로 내용의 변경이 적고, 정보의 전달이 주 목적일 때 정적 웹사이트로 구현됩니다.
    
  


3️⃣ 동적 웹사이트.

  동적 웹사이트는 서버 측 프로그래밍 언어를 사용하여 사용자의 요청에 따라 실시간으로 웹페이지를 생성하고 제공합니다.
  데이터베이스와의 상호작용을 통해 컨텐츠를 동적으로 생성하고 사용자의 요청에 맞춰 개별적으로 내용을 조정할 수 있습니다.


👍 동적 웹사이트의 장점.

  유연성.
    
      사용자의 입력이나 상호작용에 따라 내용을 쉽게 변경할 수 있습니다.
    
  
  기능성.
    
      데이터베이스에 정보를 저장하고 검색하는 등의 복잡한 기능을 구현할 수 있습니다.
    
  
  개인화.
    
      사용자의 선호나 행동에 따라 개인화된 경험을 제공할 수 있습니다.
    
  


👎 동적 웹사이트의 단점.

  비용과 복잡성.
    
      서버 측 처리를 위한 추가적인 자원이 필요하며, 구현과 유지 관리가 복잡해질 수 있습니다.
    
  
  보안 위험.
    
      데이터베이스와 서버 측 스크립트를 사용함으로써 보안 취약점이 발생할 수 있습니다.
    
  
  속도.
    
      페이지를 실시간으로 생성하므로 처리 시간이 길어질 수 있습니다.
    
  


4️⃣ 동적 웹사이트의 예시.

  1. 전자 상거래 플랫폼.
    
      Amazon, eBay 등의 쇼핑 웹사이트는 사용자의 검색, 구매 이력, 상품의 재고 상태 등에 따라 실시간으로 정보를 업데이트하고 표시해야 합니다.
        
          이런 기능은 동적 웹사이트 기술을 필요로 합니다.
        
      
    
  
  2. 소셜 네트워킹 서비스.
    
      Facebook, Twitter와 같은 소셜 미디어 플랫폼은 사용자의 상호 작용에 기반하여 내용이 계속 업데이트 되며, 이러한 동적 상호 작용을 지원합니다.
    
  
  3. 온라인 교육 플랫폼.
    
      Coursera, Udemy, Inflearn와 같은 교육 플랫폼은 사용자가 선택한 강좌에 따라 개인화된 학습 내용을 제공하고, 퀴즈 점수를 기록하며, 진행 상태를 추적합니다.
    
  


🙋‍♂️ 마무리

  정적 웹사이트와 동적 웹사이트 선택은 프로젝트의 요구 사항, 예산, 기대하는 사용자 경험 등에 따라 달라집니다.
    
      간단한 정보 제공 사이트의 경우 정적 웹사이트가 적합할 수 있고, 사용자 상호작용과 데이터 처리가 중요하 서비스는 동적 웹사이트가 더 적합할 수 있습니다.
    
  
  이러한 예시들을 통해 정적 웹사이트가 주로 고정된 내용을 제공하는 반면, 동적 웹사이트는 사용자의 입력과 상호작용에 따라 콘텐츠가 변경되는 복잡한 기능을 필요로 함을 알 수 있습니다.
    
      각각의 사례에서 요구하는 기능과 특성에 맞춰 웹사이트의 형태를 결정합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-08-05-RequiredArgsConstructor.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-08-05-RequiredArgsConstructor.html"><h1 class="title_post">☕️[Java] @RequiredArgsConstructor의 역할.</h1></a>
                        <a href="/Backend/Java/2024-08-05-RequiredArgsConstructor.html" class="txt_post">
                            ☕️[Java] @RequiredArgsConstructor 역할.


  RequiredArgsConstructor 어노테이션은 Lombok 라이브러리에서 제공하는 기능 중 하나로, 클래스에 필수적인 생성자를 자동으로 생성하는 역할을 합니다.
  이 어노테이션을 클래스에 적용하면, Lombok 이 그 클래스의 final 필드 또는 @NonNull 어노테이션이 붙은 필드를 인자로 받는 생성자를 자동으로 생성합니다.


1️⃣ @RequiredArgsConstructor의 주요 기능.

  1. 자동 생성자 생성
    
      클래스 내의 모든 final 필드와 @NonNull 어노테이션이 붙은 필드에 대한 생성자를 자동으로 생성합니다.
      이 생성자는 이 필드들을 초기화하는 데 필요한 파라미터를 요구합니다.
    
  
  2. 코드 간결화
    
      수동으로 생성자를 작성하는 번거로움을 줄여줍니다.
      특히 많은 필드를 가진 클래스에서 유용하게 사용될 수 있습니다.
    
  
  3. 불변성 강화
    
      final 필드를 사용함으로써 클래스의 불변성을 강화할 수 있습니다.
      생성자를 통해 한 번 설정되면, 이 필드들의 값은 변경될 수 없습니다.
    
  
  4. 의존성 주입 용이
    
      Spring과 같은 프레임워크에서 생성자를 통한 의존성 주입을 사용할 때 유용합니다.
      필요한 의존성을 생성자를 통해 주입받기 때문에, 컴포넌트 간의 결합도를 낮출 수 있습니다.
    
  


2️⃣ 사용 예시.


  다음은 @RequiredArgsConstructor 어노테이션을 사용한 간단한 클래스 예제입니다.


import lombok.RequiredArgsConstructor;
import lombok.NonNull;

@RequiredArgsConstructor
public class UserData {
    private final String username; // final 필드에 대한 생성자 파라미터 자동 포함.
    @NonNull private String email; // @NonNull 필드에 대한 생성자 파라미터 자동 포함.
    
    // 추가 메소드 등
}



  위 코드에서 UserData 클래스에는 username 과 email 두 필드가 있으며, username 은 final 로 선언되어 수정할 수 없고, email 은 @NonNull 어노테이션이 붙어 null 값을 허용하지 않습니다.
  Lombok은 이 두 필드를 초기화하는 생성자를 자동으로 생성합니다.


3️⃣ 주의 사항.

  @RequiredArgsConstructor 는 필드가 많고, 특히 final 또는 @NonNull 필드가 있는 경우 유용합니다.
    
      그러나 생성자를 통한 초기화가 필요하지 않은 필드에는 적용되지 않습니다.
    
  
  Lombok을 사용하면 코드가 간결해지고 가독성이 향상되지만, 코드의 명시성이 다소 떨어질 수 있습니다.
    
      따라서 Lombok 사용 시, 팀 내에서 Lombok에 대한 이해도가 충분한지 확인하는 것이 좋습니다.
    
  





  Lombok 의 @RequiredArgsConstructor 는 반복적인 코드 작성을 줄여주고, 오류 가능성을 감소시키며, 더 깔끔하고 관리하기 쉬운 코드베이스를 유지하는 데 도움을 줄 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240804_AWS_JAVA8_INSTALL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240804_AWS_JAVA8_INSTALL.html"><h1 class="title_post">☁️[AWS] Amazon Linux 2에 Java8 설치하는 방법.</h1></a>
                        <a href="/Backend/AWS/240804_AWS_JAVA8_INSTALL.html" class="txt_post">
                            1️⃣ EC2 인스턴스에 로그인.

  SSH를 통해 EC2 인스턴스에 로그인 합니다.
    ssh -i "your-key.pem" ec2-user@your-instance-ip
// 또는
ssh "config에 등록한 서비스명" 
    
  


2️⃣ 업데이트 및 패키지 매니저 설치 확인.

  인스턴스의 패키지 리스트를 업데이트하고 , yum 패키지 매니저가 최신 상태인지 확인합니다.
    sudo yum update -y
    
  


3️⃣ OpenJDK 8 설치.

  OpenJDK 8은 Amazon Linux 2의 기본 레포지토리에서 사용할 수 있습니다.
    
      다음 명령어를 사용하여 설치할 수 있습니다.
        sudo yum install -y java-1.8.0-openjdk
        
      
    
  


4️⃣ 설치된 Java 버전 확인.

  설치가 성공적으로 완료되었는지 확인하기 위해 Java 버전을 확인합니다.
    java -version
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-08-02-Transactional.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-08-02-Transactional.html"><h1 class="title_post">☕️[Java] @Transactional의 역할과 의미.</h1></a>
                        <a href="/Backend/Java/2024-08-02-Transactional.html" class="txt_post">
                            ☕️[Java] @Transactional의 역할과 의미.


  @Transaction 어노테이션은 스프링 프레임워크에서 제공하는 선언적 트랜젝션 관리 기능을 활용하기 위해 사용됩니다.
  이 어노테이션을 사용함으로써, 특정 메서드 또는 클래스 전체에 걸쳐 데이터베이스 트랜잭션의 경계를 설정할 수 있습니다.
  트랜잭션은 일련의 연산들이 전부 성공적으로 완료되거나, 하나라도 실패할 경우 전체를 취소(롤백)하여 데이터의 일관성과 정합성을 보장하는 것을 목적으로 합니다.


1️⃣ @Transactional의 주요 기능과 특징.


  1. 자동 롤백
    
      @Transactional 이 적용된 메서드에서 런타임 예외(RuntimeException)가 발생하면, 그 트랜잭션에서 수행된 모든 변경이 자동으로 롤백됩니다.
      이는 데이터의 일관성을 유지하는 데 필수적입니다.
    
  
  2. 프로파게이션(Propagation)
    
      트랜잭션의 전파 행위를 제어합니다.
        
          예를 들어, 이미 진행 중인 트랜잭션이 있을 때 새로운 트랜잭션을 시작할 것인지, 아니면 기존 트랜잭션을 참여할 것인지 결정할 수 있습니다.
            
              REQUIRED(기본값) : 이미 진행 중인 트랜잭션이 있다면 그 트랜잭션이 참여하고, 없다면 새로운 트랜잭션을 시작합니다.
              REQUIRED_NEW : 항상 새로운 트랜잭션을 시작합니다. 이미 진행 중인 트랜잭션이 있다면 잠시 보류합니다.
            
          
        
      
    
  
  3. 격리 수준(Isolation Level)
    
      다른 트랜잭션이 데이터에 동시에 접근했을 때 발생할 수 있는 문제를 제어합니다.
        
          예를 들어, READ_COMMITTEED, REPEATED_READ, SERIALIZABLE 등 다양한 격리 수준을 지정할 수 있습니다.
        
      
    
  
  4. 읽기 전용(Read-Only)
    
      트랜잭션을 읽기 전용으로 설정할 수 있어, 데이터 수정이 이루어지지 않는다는 것을 데이터베이스 최적화 엔진에 알려 성능을 향상시킬 수 있습니다.
    
  
  5. 롤백 규칙(Rollback Rules)
    
      특정 예외가 발생했을 때 롤백을 수행할지 아니면 커밋을 수행할지를 세밀하게 제어할 수 있습니다.
      기본적으로 런타임 예외에서는 롤백을 수행하고, 체크 예외에서는 커밋을 수행합니다.
    
  


2️⃣ 사용 예제.
import org.springframework.transaction.annotation.Transactional;
import org.springframework.stereotype.Service;

@Service
public class TransactionalService {
    
    @Transactional(readOnly = true)
    public User getUser(Long id) {
        return userRepository.findById(id);
    }
    
    @Transactional(rollbackFor = Exception.class)
    public User updateUser(User user) {
        return userRepository.save(user);
    }
}


  위 예시처럼, getUser 메서드는 데이터를 변경하지 않고 조회만 수행하기 때문에 readOnly = true 로 설정했습니다.
  반면, updateUser 메서드는 데이터를 변경할 가능성이 있으므로, 모든 예외(Exception)가 발생할 경우 롤백하도록 설정했습니다.




@Transactional 을 사용함으로써 개발자는 복잡한 트랜잭션 관리 코드를 직접 작성하지 않고도, 스프링 프레임워크가 제공하는 선언적 방식을 통해 간단하게 트랜잭션을 관리할 수 있게 됩니다.
이는 애플리케이션의 데이터 처리 로직을 더욱 안정적이고 효율적으로 만듭니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-08-01-SerializationAndDeserialization.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-08-01-SerializationAndDeserialization.html"><h1 class="title_post">☕️[Java] ObjectMapper 클래스, 직렬화와 역직렬화</h1></a>
                        <a href="/Backend/Java/2024-08-01-SerializationAndDeserialization.html" class="txt_post">
                            ☕️[Java] ObjectMapper 클래스, 직렬화와 역직렬화.


  ObjectMapper 는 주로 JSON 데이터를 처리하기 위해 사용되는 Jackson 라이브러리의 핵심 클래스입니다.
  이 클래스는 자바 객체와 JSON 형식 간의 직렬화(Serialization)와 역직렬화(Deserialization)를 수행합니다.
  ObjectMapper 는 JSON 데이터를 자바 객체로 변환하거나 자바 객체를 JSON 데이터로 변환하는 등의 작업을 매우 효율적으로 처리할 수 있게 해줍니다.


1️⃣ 직렬화(Serialization)


  ObjectMapper 를 사용하여 자바 객체를 JSON 문자열로 직렬화하는 과정은 다음과 같습니다.


import com.fasterxml.jackson.databind.ObjectMapper;

// 예시 자바 객체
pulbic class User {
    public String name;
    public int age;
}

// 직렬화 예제
ObjectMapper mapper = new ObjectMapper();
User user = new User();
user.name = "Kobe";
user.age = "30";

String json = mapper.writeValueAsString(user); // 자바 객체를 JSON 문자열로 변환

System.out.println(json);


2️⃣ 역직렬화(Deserialization)


  ObjectMapper 를 사용하여 JSON 문자열을 자바 객체로 역직렬화하는 과정은 다음과 같습니다.


import com.fasterxml.jackson.databind.ObjectMapper;

// 예시 자바 객체
public class User {
    public String name;
    public int age;
}

// 역직렬화 예제
ObjectMapper mapper = new ObjectMapper();
String json = "{\"name\":\"Kobe\", \"age\":30}";

User user = mapper.readValue(json, User.class); // JSON 문자열을 자바 객체로 변환

Systeom.out.println(user.name + " is" + user.age + " year old.");


3️⃣ 주요 기능


  
    다양한 데이터 포맷 지원 :  ObjectMapper 는 JSON 외에도 XML, CSV 등 여러 데이터 포맷을 지원합니다.(Jackson 데이터 포맷 모듈 설치 필요).
  
  유연성과 설정 : ObjectMapper 는 맞춤 설정이 가능하여, 다양한 JSON 직렬화/역직렬화 방법을 지원합니다.
    
      예를 들어, 필드 이름의 자동 감지, 날짜 형식 지정, 무시할 필드 설정 등을 조정할 수 있습니다.
    
  
  성능 : Jackson은 JSON 처리를 위해 최적화된 라이브러리 중 하나로, 대용량 데이터 처리에도 뛰어난 성능을 보입니다.




🤔 직렬화와 역직렬화란?


  직렬화(Serialization)와 역직렬화(Deserialization)는 데이터 구조 또는 객체 상태를 저장하고 전송하기 위해 다루기 쉬운 데이터 포맷으로 변환하는 과정을 의미합니다.
    
      컴퓨터 과학의 맥락에서 이 개념은 특히 중요하며, 객체 지향 프로그래밍에서 널리 사용됩니다.
    
  


1️⃣ 직렬화(Serialization)

  직렬화는 객체의 상태(즉, 객체가 가진 데이터와 그 구조)를 일련의 바이트로 변환하는 과정입니다.
    
      이 바이트 스트림은 나중에 파일, 데이터베이스 또는 네트워크를 통해 쉽게 저장하거나 전송할 수 있습니다.
        
          예를 들어, 자바에서는 Serialization 인터페이스를 구현한 객체를 바이트 스트림으로 변환하여 파일 시스템에 저장하거나 네트워크를 통해 다른 시스템으로 보낼 수 있습니다.
        
      
    
  


2️⃣ 직렬화의 주요 목적.

  
    
      영속성 : 객체의 상태를 영구적으로 저장하여 나중에 다시 로드할 수 있습니다.
    
  
  
    
      네트워크 전송 : 객체를 네트워크를 통해 다른 시스템으로 전송하기 위해 사용됩니다.
    
  
  
    
      데이터 교환 : 다양한 언어나 플랫폼 간의 데이터 교환이 가능하도록 합니다.
    
  


3️⃣ 역직렬화(Deserialization)

  역직렬화는 직렬화된 바이트 스트림을 다시 원래의 객체 상태로 복원하는 과정입니다.
    
      즉, 파일, 데이터베이스 또는 네트워크로부터 바이트 스트림을 읽어 들여서 실행 중인 프로그램에서 사용할 수 있는 실제 객체로 변환합니다.
      이 과정은 직렬화의 반대 과정으로, 복원된 객체는 원복 객체와 동일한 상태를 가집니다.
    
  


4️⃣ 역직렬화의 주요 사용 사례.

  
    
      객체 복원 : 저장되거나 전송된 데이터로부터 객체를 재구성합니다.
    
  
  
    
      상태 복구 : 애플리케이션의 이전 상태를 복구하는 데 사용됩니다.
    
  
  
    
      데이터 접근 : 다른 시스템에서 전송된 데이터를 로컬 시스템에서 접근하고 사용할 수 있게 합니다.
    
  


5️⃣ 데이터 포맷과 직렬화 도구

  다양한 데이터 포맷(JSON, XML, YAML 등)과 여러 프로그래밍 언어 또는 라이브러리에서 직렬화와 역직렬화를 지원합니다.
  자바에서는 ObjectMapper 를 사용해 JSON 데이터 포맷으로의 직렬화와 역직렬화를 처리하며, 이는 데이터를 쉽게 읽고 쓸 수 있는 구조로 만드는 데 유용합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/DB/2024-08-01-Transaction.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/DB/2024-08-01-Transaction.html"><h1 class="title_post">💾[Database] 트랜잭션의 의미와 역할.</h1></a>
                        <a href="/Backend/DB/2024-08-01-Transaction.html" class="txt_post">
                            💾[Database] 트랜잭션의 의미와 역할.

  트랜잭션은 데이터베이스 관리 시스템(DBMS)에서 데이터의 일관성과 정확성을 유지하기 위해 사용되는 기본 단위입니다.
  데이터베이스에서 수행하는 작업들을 안전하게 실행하여, 여러 작업이 모두 성공하거나 모두 실패하도록 보장하는 역할을 합니다.


1️⃣ 트랜잭션의 주요 특징(ACID).


  1. 원자성(Atomicity)
    
      트랜잭션 내의 모든 연산은 원자적으로 처리됩니다. 즉, 연산들은 모두 완벽하게 수행되거나 아예 수행되지 않아야 합니다.
      트랜잭션 중 하나라도 실패하면 전체 트랜잭션은 롤백(취소)되어 원래 상태로 복구됩니다.
    
  
  2. 일관성(Consistency)
    
      트랜잭션이 실행되지 전과 후에 데이터베이스의 상태는 일관된 상태를 유지해야 합니다.
      트랜잭션은 데이터베이스의 일관된 상태를 받아 변경 후에도 그 일관성을 유지하는 변경만을 수행해야 합니다.
        
          이는 데이터의 무결성 제약 조건들을 준수함을 의미합니다.
        
      
    
  
  3. 독립성(Isolation)
    
      동시에 여러 트랜잭션이 실행될 때, 각 트랜잭션이 다른 트랜잭션의 연산에 영향을 받지 않아야 합니다. 이를 통해 데이터베이스의 안정성을 보장합니다.
      DBMS는 이러한 독립성을 보장하기 위해 다양한 격리 수준(Isolation Level)을 제공합니다.
    
  
  4. 지속성(Durability)
    
      트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 데이터베이스에 반영도어야 합니다.
      시스템 장애가 발생해도 이러한 트랜잭션 결과는 손실되지 않습니다.
    
  


2️⃣ 트랜잭션의 역할.


  데이터 무결성 유지
    
      트랜잭션은 데이터의 정확성과 일관성을 유지하며 데이터베이스 시스템의 신뢰성을 보장합니다.
    
  
  시스템 장애 대응
    
      시스템 오류나 장애 발생 시, 트랜잭션은 롤백을 통해 데이터베이스를 안정적인 상태로 복구할 수 있게 돕습니다.
    
  
  동시성 제어
    
      다수의 사용자가 데이터베이스에 동시에 접근할 때, 트랜잭션은 각각의 사용자가 데이터를 안전하게 읽고, 쓸 수 있도록 관리합니다.
    
  




트랜잭션은 데이터베이스 시스템에서 꼭 필요한 기능으로, 데이터의 일관성과 안정성을 보장하는 중요한 메커니즘 입니다. 이를 통해 사용자는 데이터베이스의 신뢰성 있는 동작을 기대할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-31-attribute.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-31-attribute.html"><h1 class="title_post">☕️[Java] attribute의 의미와 역할</h1></a>
                        <a href="/Backend/Java/2024-07-31-attribute.html" class="txt_post">
                            ☕️[Java] attribute의 의미와 역할.


  Java 백엔드 개발에서 “attribute”라는 용어는 몇 가지 다른 맥락에서 사용될 수 있습니다.
  주로 두 가지 의미로 사용되는 경우가 많은데, 클래스의 속성 을 의미하는 경우와 웹 개발에서 HTTP 요청이나 세션과 관련된 데이터를 지칭하는 경우입니다.


1️⃣ 클래스의 속성(Field or Property)

  Java에서 클래스의 “attribute” 는 해당 클래스의 상태를 정의하는 변수를 말합니다.
    
      이러한 변수들은 객체의 데이터이터를 저장하고, 클래스의 인스턴스들이 갖는 특징과 상태 정보를 나타냅니다.
        
          예를 들어, ‘Person’ 클래스가 있다면, ‘name’, ‘age’ 같은 필드들이 이 클래스의 “attribute” 가 됩니다.
        
      
    
  


public class Person {
    private String name; // Attribute
    private int age; // Attribute
    
    // Constructors, getters, setters 등
}


2️⃣ 웹 개발에서의 Attribute

  웹 개발에서 “attribute” 는 주로 세션(Session)이나 요청(Request) 객체에 저장된 데이터를 지칭 합니다.
    
      이 데이터는 사용자가 웹 사이트를 이용하는 동안 지속되거나 요청 동안에만 존재할 수 있습니다.
        
          예를 들어, 사용자가 로그인을 하면 그 사용자의 정보를 세션 attribute로 저장하여 다른 페이지에서도 사용자 정보를 유지할 수 있게 합니다.
        
      
    
  


// 세션에 사용자 정보 저장
request.getSession().setAttribute("user", userObject);

// 세션에서 사용자 정보 가져오기
User user = (User) request.getSession().getAttribute("user");



  이 두 가지 사용 사례는 Java 백엔드 개발에서 매우 흔하게 접할 수 있으며, 각각의 맥락에서 attribute가 가지는 의미와 역할을 이해하는 것은 중요합니다.
    
      첫 번째 경우는 객체 지향 프로그래밍의 핵심 요소로 클래스의 속성을 정의합니다.
      두 번째 경우에는 웹 애플리케이션의 상태 관리를 돕는 수단으로서 활용됩니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-31-MainBuildFail.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-31-MainBuildFail.html"><h1 class="title_post">☕️[Java] Main 클래스 생성 후 오류 대처.</h1></a>
                        <a href="/Backend/Java/2024-07-31-MainBuildFail.html" class="txt_post">
                            ☕️[Java] Main 클래스 생성 후 오류 대처.

1️⃣ 메인 클래스 생성.

  모든 프로젝트에는 메인 클래스가 있어야 합니다.
    
      직접 만든 클래스를 메인 클래스로 사용하기 위해 다음과 같이 코드를 입력했다고 가정해봅시다.
    
  


// PortfolioBolgApplication.java

package com.devkobe.portfolioBlog;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PortfolioBolgApplication {
    public static void main(String[] args) {
        SpringApplication.run(PortfolioBolgApplication.class, args);
    }
}



  코드 작성이 끝났다면 클래스 왼쪽에 실행 아이콘 ▶︎을 누르고, [RUN] 버튼을 눌러 클래스를 실행했을 경우 콘솔창에서 애플리케이션이 실행되면 성공입니다.


2️⃣ 실패했을 경우.

Process 'command...bin/java 'finshed with non-zero exit value 1'


  콘솔창에 위와 같은 오류 발생시에는 다음과 같이 순차적으로 해결하면 됩니다.
    
      
        
          Settings 로 들어갑니다.
        
      
      
        
          Build, Excecution, Deplyment 카테고리를 찾아 펼칩니다.
        
      
      
        
          하위에 Gradle을 클릭합니다.
        
      
      
        
          ‘Build and run using’ 이라는 색션을 찾습니다.
            
              이것의 선택값이 ‘Gradle(default)’ 일 것입니다.
            
            
              이 값을 ‘IntelliJ IDEA’ 로 바꿔 프로젝트를 다시 시작합니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-31-EntityListeners.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-31-EntityListeners.html"><h1 class="title_post">☕️[Java] @EntityListeners 어노테이션.</h1></a>
                        <a href="/Backend/Java/2024-07-31-EntityListeners.html" class="txt_post">
                            ☕️[Java] @EntityListeners 어노테이션.

1️⃣ 사용 방법.


  @EntityListeners 어노테이션은 엔티티 클래스 또는 매핑된 슈퍼클래스에서 사용할 수 있으며, 하나 이상의 리스너 클래스를 지정할 수 있습니다.
    
      이 리스너 클래스들은 앞서 언급한 이벤트를 처리할 메소드들을 포함하고 있어야 합니다.
    
  


import javax.persistence.EntityListeners;
import javax.persistence.PostPersist;

@EntityListeners(MyEntityListner.class)
public class MyEntity {
    // 엔티티 필드와 메서드
}

public class MyEntityListner {
    @PostPersist
    public void afterPersist(Object entity) {
        System.out.println("Entity has been persisted: " + entity);
    }
}


2️⃣ 사용 사례.

  엔티티 리스너는 로깅, 유효성 검사, 보안 검사, 비즈니스 로직 실행 등 다양한 목적으로 사용할 수 있습니다.
    
      
        예를 들어, 사용자 계정의 엔티티가 데이터베이스에 저장될 때 비밀번호 강도를 자동으로 검증하거나, 엔티티가 업데이트 될 때 특정 필드의 변경을 추적할 수 있습니다.
      
    
  


이처럼 @EntityListeners는 JPA 엔티티의 생명주기에 자동으로 반응하는 메소드를 구현함으로써, 엔티티와 관련된 비즈니스 로직을 분리하고 관리하는 데 큰 도움을 줍니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-07-28-ipAndport.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-07-28-ipAndport.html"><h1 class="title_post">📝[Post] 아이피와 포트</h1></a>
                        <a href="/Backend/Post/2024-07-28-ipAndport.html" class="txt_post">
                            🙋‍♂️ 아이피와 포트

1️⃣ 아이피(IP)

  인터넷에서 컴퓨터 또는 기기들이 서로를 식별하고 통신하기 위한 주소입니다.
    
      그래서 아이피를 알면 서버를 찾을 수 있습니다.
        
          하지만 서버를 이용하려면 아이피만 알아서는 안 됩니다. 포트까지 알아야 합니다.
        
      
    
  


2️⃣ 포트(Port)

  아이피가 서버를 찾기 위한 번호라면 포트는 그 서버에서 운용되고 있는 서비스를 구분하기 위한 번호입니다.
    
      쉽게 말해서 아이피가 백화점이라면 포트는 각자 다른 물건을 살 수 있는 매장이라고 생각하면 됩니다.
    
  


3️⃣ 예시

  예를 들어 우리가 흔히 사용하는 웹 브라우저에 주소에는 사실 아이피와 포트가 들어 있습니다.
    
      www.google.com과 같은 주소는 아이피트를 쉽게 알아보기 위해 이름표를 붙인 것입니다.
      그 앞에 있는 https:// 라는 것은 서버의 443번 포트를 사용하기 위한 입력입니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240726_AWS_JAVA_INSTALL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240726_AWS_JAVA_INSTALL.html"><h1 class="title_post">☁️[AWS] Amazon Linux 2023에 Java8 설치하는 방법.</h1></a>
                        <a href="/Backend/AWS/240726_AWS_JAVA_INSTALL.html" class="txt_post">
                            1️⃣ 시스템 패키지 업데이트

  먼저 시스템 패키지를 업데이트 합니다.


sudo dnf update -y


2️⃣ Amazon Corretto 8 저장소 추가.

  Amazon Corretto는 Amazon에서 제공하는 무료, 멀티플랫폼, 생산성 사용 준비가 된 OpenJDK 배포판입니다.
    
      Correttio 8은 Java 8과 호환됩니다.
    
  


sudo dnf install -y java-1.8.0-amazon-corretto


3️⃣ Java 8 설치 확인

  Java 8이 설치되었는지 확인하려면 다음 명령어를 사용합니다.


java -version



  이 명령어를 실행하면 Java 버전 정보가 출력됩니다. openjdk version "1.8.0_xxx" 와 같이 Java 8이 설치된 것을 확인할 수 있습니다.


4️⃣ 기본 Java 버전 설정


  시스템에 여러 버전의 Java가 설치되어 있을 수 있습니다.
    
      기본으로 사용할 Java 버전을 설정하려면 alternatives 명령어를 사용합니다.
    
  
  먼저 현재 사용 가능한 Java 버전을 확인합니다.


sudo alternatives --config java


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/DB/2024-07-26-korean-mysql.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/DB/2024-07-26-korean-mysql.html"><h1 class="title_post">💾[Database] MySQL DB에 한글 삽입.</h1></a>
                        <a href="/Backend/DB/2024-07-26-korean-mysql.html" class="txt_post">
                            💾[Database] MySQL DB에 한글 삽입.


  한글을 MySQL 데이터베이스에 삽입하려고 할 때 발생하는 오류는 주로 데이터베이스, 테이블 또는 열의 문자 세트와 관련 있습니다.
    
      이 문제를 해결하기 위해서는 데이터베이스와 테이블의 문자 세트를 UTF-8로 설정해야 합니다.
    
  


🙋‍♂️ 데이터베이스와 테이블의 문자 세트를 UTF-8로 설정하는 방법.

1️⃣ 데이터베이스 생성 시 문자 세트 설정.

CREATE DATABASE {데이터베이스 이름} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


2️⃣ 기존 데이터베이스의 문자 세트 변경.

ALTER DATABASE {데이터베이스 이름} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


3️⃣ 테이블 생성 시 문자 세트 설정.

CREATE TABLE test (
    id INT AUTO_INCREMENT PRIMARY KEY,
    content TEXT
) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


4️⃣ 기존 테이블의 문자 세트 변경.

ALTER TABLE test CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


5️⃣ 각 열의 문자 세트 확인 및 변경.

ALTER TABLE test MODIFY content TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


6️⃣ MySQL 서버의 기본 문자 세트를 변경.

  my.cnf(또는 my.ini) 파일을 수정하여 기본 문자 세트를 utf8mb4로 설정합니다.
    
      보통 이 파일은 /etc/my.cnf 또는 /etc/mysql/my.cnf 에 위치해 있습니다.
    
  
  my.cnf 파일에 다음 내용을 추가합니다.
```ini
[client]
default-character-set = utf8mb4


[mysql]
default-character-set = utf8mb4

[mysqld]
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci

### 7️⃣ MySQL 서버 재시작.
```shell
sudo systemctl restart mysqld



  이제 한글을 포함한 데이터를 데이터베이스에 삽입할 수 있을 것입니다.
    
      예를 들어, 한글 데이터를 삽입하려면:
        INSERT INTO test (content) VALUES ('테스트 데이터');
        
      
    
  
  이 방법으로 UTF-8 설정을 적용하면 한글 데이터를 MySQL 데이터베이스에 문제 없이 저장할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no2.html"><h1 class="title_post">📝[Post] 자바다식(Java多識) - 2</h1></a>
                        <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no2.html" class="txt_post">
                            자바다식(Java多識) 2편.

1. @AfterEach 어노테이션.


  @AfterEach 어노테이션은 JUnit 5에서 제공하는 기능입니다.
  각 테스트 메서드가 실행된 후에 수행되어야 하는 작업을 지정하는 데 사용됩니다.
  이 어노테이션은 테스트 클래스 내의 메서드에 적용하여 테스트 메서드가 끄탄 후 필요한 정리 작업(cleanup)을 수행할 수 있도록 합니다.


주요 역할

1. 자원 해제 : 테스트 메서드가 사용한 자원(예: 파일, 데이터베이스 연결, 네트워크 연결 등)을 해제하는 데 사용됩니다.

2. 상태 초기화 : 테스트가 완료된 후 상태를 초기화하여 다음 테스트가 깨끗한 환경에서 실행될 수 있도록 합니다.

3. 로그 기록 : 테스트 실행 결과를 로그에 기록하거나 추가적인 분석을 위해 데이터를 저장하는 데 사용할 수 있습니다.

예제 코드

아래는 @AfterEach 어노테이션을 사용한 간단한 예제입니다.

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class MyTest {
    
    @BeforeEach
    void setUp() {
        System.out.println("Setting up before each test");
    }
    
    @Test
    void testMethod1() {
        System.out.println("Executing test method 1");
    }
    
    @Test
    void testMethod2() {
        Systemo.out.println("Executing test method 2");
    }
    
    @AfterEach
    void tearDown() {
        System.out.println("Tearing down after each test")
    }
}


실행 순서


  
    setUp() : 각 테스트 메서드 실행 전 @BeforeEach 메서드가 호출됩니다.
  
  
    testMethod1() : 첫 번째 테스트 메서드가 실행됩니다.
  
  
    tearDown() : 첫 번째 테스트 메서드 실행 후 @AfterEach 메서드가 호출됩니다.
  
  
    setUp() : 두 번째 테스트 메서드 실행 전 @BeforeEach 메서드가 다시 호출됩니다.
  
  
    testMethod2() : 두 번째 테스트 메서드가 실행됩니다.
  
  
    tearDown() : 두 번째 테스트 메서드 실행 후 @AfterEach 메서드가 호출됩니다.
  


요약


  @AfterEach 어노테이션은 각 테스트 메서드 실행 후 호출되는 메서드를 지정합니다.
  주로 자원 해제, 상태 초기화, 로그 기록 등의 작업을 수행하는 데 사용됩니다.
  각 테스트 메서드마다 실행되므로, 테스트 간의 독립성을 유지하고 깨끗한 테스트 환경을 보장할 수 있습니다.




2. @Builder 어노테이션.


  @Builder 는 Lombok 라이브러리에서 제공하는 어노테이션으로, 빌더 패턴을 간편하게 사용할 수 있도록 지원합니다.
  빌더 패턴은 객체의 생성과 관련된 복잡성을 줄이고, 가독성을 높이며, 가변 객체를 만들지 않도록 도와줍니다.
    
      특히, 많은 필드를 가진 객체를 생성할 때 유용합니다.
    
  


주요 특징 및 역할.


  유연한 객체 생성
    
      빌더 패턴을 사용하면 객체를 생성할 때 생성자나 정적 팩토리 메서드보다 더 유연하게 객체를 구성할 수 있습니다.
      필요한 필드만 설정할 수 있고, 설정 순서에 구애받지 않습니다.
    
  
  가독성 향상
    
      많은 필드를 가진 객체를 생성할 때, 빌더 패턴을 사용하면 코드의 가독성이 높아집니다.
      각 필드의 이름을 명시적으로 설정할 수 있어 어떤 값이 어떤 필드에 설정되는지 쉽게 할 수 있습니다.
    
  
  불변 객체 생성
    
      빌더 패턴을 사용하면 불변 객체를 쉽게 생성할 수 있습니다.
      객체가 생성된 후에는 필드 값을 변경할 수 없습니다.
    
  


사용 예시

Lombok 없이 빌더 패턴 구현
public class User {
    private final String name;
    private final int age;
    private final String email;

    private User(UserBuilder builder) {
        this.name = builder.name;
        this.age = builder.age;
        this.email = builder.email;
    }

    public static class UserBuilder {
        private String name;
        private int age;
        private String email;

        public UserBuilder setName(String name) {
            this.name = name;
            return this;
        }

        public UserBuilder setAge(int age) {
            this.age = age;
            return this;
        }

        public UserBuilder setEmail(String email) {
            this.email = email;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}


Lombok을 사용한 빌더 패턴 구현

Lombok의 @Builder 어노테이션을 사용하면 위의 코드가 크게 단축됩니다.

import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
public class User {
    private String name;
    private int age;
    private String email;
}


객체 생성 예시

위의 Lombok을 사용한 User 클래스를 이용해 객체를 생성하는 예시입니다.

public class Main {
    public static void main(String[] args) {
        User user = User.builder()
                        .name("devKobe")
                        .age(77)
                        .email(devKobe@gamil.com)
                        .build();
        
        System.out.println(user.getName()); // devKobe
        System.out.println(user.getAge()); // 77
        System.out.println(user.getEmail()) // devKobe@gmail.com
    }
}


위 예시처럼 Lombok의 @Builder 를 사용하면 빌더 패턴을 간단하게 구현하고 사용할 수 있습니다.
이로 인해 객체 생성 코드가 더 깔끔하고 직관적으로 변합니다.



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no1.html"><h1 class="title_post">📝[Post] 자바다식(Java多識) - 1</h1></a>
                        <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no1.html" class="txt_post">
                            자바다식(Java多識) 1편.

1. ‘mainClassName’ 속성 추가.

메인 클래스의 경로를 지정해주는 속성을 추가하는 방법입니다.
초기 진입점을 지정해준다고 생각하면 됩니다.


  application 블록 안에 메인 클래스 이름을 지정합니다. 예를 들어, 메인 클래스가 com.example.Main 이라고 가정합니다.
  아래의 코드는 bundle.gradle 파일 내부에서 수정해야 합니다.


plugins {
    id 'java'
    id 'application'
}

application {
    mainClassName = 'com.example.Main' // 여기에 메인 클래스의 경로를 입력합니다.
    applicationDefaultJvmArgs = [
        "-XX:+EnableDynamicAgentLoading",
        "-Djdk.instrument.traceUsage"
    ]
}

repositories {
    mavenCentral()
}

dependencies {
    // Your dependencies here
}


메인 클래스 예시


  예를 들어, 메인 클래스는 다음과 같이 생겼을 수 있습니다.


package com.example;

public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}




2. @ExtendWith 어노테이션.


  @ExtendWith 어노테이션은 Junit 5에서 제공하는 기능으로, 테스트 클래스나 메서드에 확장 기능을 추가할 수 있도록 해줍니다.
  JUnit 5의 확장 모델은 다양한 확장 기능을 통해 테스트 실행의 특정 지점에서 사용자 정의 동작을 수행할 수 있게 합니다.


@ExtendWith 어노테이션의 역할


  확장 클래스 지정 : @ExtendWith 어노테이션은 확장 클래스를 지정할 수 있습니다. 지정된 확장 클래스는 테스트 라이프사이클의 특정 지점에서 호출됩니다.
    
      예를 들어, 테스트 실행 전후, 각 테스트 메서드 전후 등 다양한 시점에서 특정 동작을 추가할 수 있습니다.
    
  
  
    컨텍스트 설정 및 주입 : 확장 기능을 통해 테스트 컨텍스트를 설정하고, 테스트 메서드에 필요한 객체나 리소스를 주입할 수 있습니다. 이를 통해 테스트 코드를 더 간결하고 모듈화할 수 있습니다.
  
  조건부 실행 : 특정 조건에 따라 테스트 메서드를 실행하거나 건너뛸 수 있도록 지원합니다.
    
      예를 들어, 특정 환경 설정이나 시스템 상태에 따라 테스트 실행 여부를 결정할 수 있습니다.
    
  
  커스텀 어서션 및 보고 : 확장을 통해 사용자 정의 어서션 로직을 추가하거나 테스트 결과를 커스텀 방식으로 보고할 수 있습니다.


예제 코드

아래는 @ExtendWith 어노테이션을 사용한 간단한 예제입니다.

import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.extension.BeforeEachCallback;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.Test;

class MyExtension implements BeforeEachCallback {
    @Override
    public void beforeEach(ExtensionContext context) {
        System.out.println("Before each test method");
    }
}

@ExtendWith(MyExtension.class)
public class MyTest {
    
    @Test
    void testMethod1() {
        System.out.println("Test method 1");
    }
    
    @Test
    void testMethod2() {
        System.out.println("Test method 2");
    }
}



  위 코드에서 MyExtension 클래스는 BeforeEachCallback 인터페이스를 구현하여 각 테스트 메서드가 실행되기 전에 메시지를 출력합니다.
  @ExtendWith(MyExtension.class) 어노테이션을 통해 MyTest 클래스에 이 확장 기능을 추가했습니다.
    
      따라서 각 테스트 메서드 실행 전에 “Before each test method” 메시지가 출력됩니다.
    
  
  이처럼 @ExtendWith 어노테이션은 JUnit 5의 확장 모델을 활용하여 테스트에 필요한 다양한 기능을 추가할 수 있게 해줍니다.




3. 어서션(Assertion)


  어서션(Assertion)은 프로그래밍 및 소프트웨어 테스트에서 코드의 특정 상태나 조건이 참인지 확인하는 데 사용되는 문장이나 명령문을 의미합니다.
  어서션을 통해 코드의 논리적 일관성과 정확성을 검증할 수 있으며, 주로 디버깅과 테스트에 사용됩니다.


주요 기능과 목적.


  
    조건 검증 : 어서션(Assertion)은 특정 조건이 참인지 검증합니다. 조건이 거짓이면 프로그램은 즉시 실행을 중단하고 오류를 보고합니다.
  
  
    디버깅 도구 : 어서션(Assertion)은 개발 중에 코드의 오류를 조기에 발견하고 수정하는 데 도움이 됩니다. 코드의 가정이 잘못된 경우 어서션을 통해 문제를 빨리 찾을 수 있습니다.
  
  
    문서화 : 어서션(Assertion)은 코드의 논리적 전제 조건을 명시적으로 표현하여, 코드가 어떤 상태에 작동해야 하는지 명확하게 나타냅니다.
  


어서션(Assertion)의 예


  자바(Java)
    public void setAge(int age) {
 assert age &gt; 0 : "Age must be positive";
 this.age = age;
}
    
  
  JUnit (Java)
```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;


public class MyTest {

@Test
void testAddition() {
    int result = 2 + 3;
    assertEquals(5, result, "2 + 3 should equal 5");
} } ```


어서션 사용 시기

  개발 중 : 개발자가 코드의 논리적 일관성을 검증하기 위해 사용합니다. 디버깅 과정에서 주로 사용되며, 프로덕션 환경에서는 보통 비활성화합니다.
  테스트 코드 : 테스트 프레임워크(JUnit, TestNG 등)를 사용하여 테스트를 작성할 때, 특정 조건이 기대한 대로 동작하는지 확인합니다.


주의 사항

  프로덕션 코드에서의 사용 : 어서션은 주로 개발 및 테스트 환경에서 사용되며, 프로덕션 환경에서는 비활성화되는 경우가 많습니다. 프로덕션 환경에서 조건 검증이 필요한 경우에는 예외 처리를 사용합니다.
  부작용 없는 코드 : 어서션 내부에서는 부작용이 없는 코드를 사용하는 것이 좋습니다. 어서션은 상태를 변경하지 않고 조건만 검증해야 합니다.


요약.


  어서션은 코드의 특정 조건이 참임을 검증하는 도구로, 디버깅과 테스트 과정에서 코드의 논리적 일관성을 유지하는데 중요한 역할을 합니다.
    
      이를 통해 개발자는 코드의 가정과 실제 동작이 일치하는지 확인하고, 문제를 조기에 발견하여 수정할 수 있습니다.
    
  




                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-16-Variable.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-16-Variable.html"><h1 class="title_post">☕️[Java] 프로그래밍 언어와 자바</h1></a>
                        <a href="/Backend/Java/2024-07-16-Variable.html" class="txt_post">
                            변수 선언.


  컴퓨터 메모리(RAM)은 수많은 번지들로 구성된 데이터 저장 공간입니다.
  프로그램은 데이터를 메모리에 저장하고 읽는 작업을 비번히 수행합니다.
    
      이때 데이터를 어디에, 어떤 방식으로 저장할지 정해져 있지 않다면 메모리 관리가 무척 어려워집니다.
        
          이 문제를 해결하기 위해 변수(Variable)을 사용합니다.
        
      
    
  
  변수(Variable)는 하나의 값을 저장할 수 있는 메모리 번지에 붙여진 이름입니다.
  변수를 통해 프로그램은 메모리 번지에 값을 저장하고 읽을 수 있습니다.
  자바의 변수는 다양한 타입의 값을 저장할 수 없습니다.
    
      즉, 정수형 변수에는 정수값만 저장할 수 있고, 실수형 변수에는 실수값만 저장할 수 있습니다.
    
  
  변수를 사용하려면 변수 선언이 필요합니다.
    
      변수 선언은 어떤 타입의 데이터를 저장할 것인지 그리고 변수 이름이 무었인지 결정하는 것입니다.
        int age; // 정수(int) 값을 저장할 수 있는 age 변수 선언
double value; // 실수(double) 값을 저장할 수 있는 value 변수 선언
        
      
    
  
  변수 이름의 첫 번째 글자가 문자여야 하고, 중간부터는 문자, 숫자, $, _를 포함할 수 있습니다.
    
      또한, 첫 문자를 소문자로 시작하되 캐멀 케이스로 작성하는 것이 관례입니다.
    
  
  변수가 선언 되었다면 값을 저장할 수 있습니다.
    
      이때 대입 연산자인 =를 사용합니다.
      수학에서 등호(=)는 ‘같다’라는 의미이지만, 자바에서는 우측 값을 좌측 변수에 대입하는 연산자로 사용됩니다.
        int score; // 변수 선언
score = 60; // 값 대입
        
      
    
  
  변수 선언은 저장되는 값의 타입과 이름만 결정한 것이지, 아직 메모리에 할당된 것은 아닙니다.
    
      변수에 최초로 값이 대입될 때 메모리에 할당되고, 해당 메모리에 값이 저장됩니다.
    
  
  변수에 최초로 값을 대입하는 행위를 변수 초기화라고 하고, 이때의 값을 초기값이라고 합니다.
    
      초기 값은 다음과 같이 변수를 선언함과 동시에 대입할 수도 있습니다.
        int score = 90;
        
      
    
  
  초기화되지 않은 변수는 아직 메모리에 할당되지 않았기 때문에 변수를 통해 메모리 값을 읽을 수 없습니다.
    
      따라서 다음은 잘못된 코딩입니다.
        int value; // &lt;- 1.변수 value 선언
int result = value + 10; // &lt;- 2.변수 value 값을 읽고 10을 더해서 변수 result에 저장
        
      
    
  
  1 에서 변수 value가 선언되었지만, 초기화되지 않았기 때문엔 2 value + 10에서 value 변수값은 읽어올 수 없습니다.
    
      따라서 위 코드는 다음과 같이 변경해야 합니다.
        int value = 30; // 변수 value가 30으로 초기화됨
int result = value + 10; // 변수 value 값(30)을 읽고 10을 더해서 변수 result에 저장
        
      
    
  
  다음 예제는 초기화되지 않은 변수를 연산식에 사용할 경우 컴파일 에러(The local variable value may not have been initializer)가 발생하는 것을 보여줍니다.
    public class VariableInitializationExample {
  public static void main(String[] args) {
      // 변수 value 선언
      int value;
        
      // 연산 결과를 변수 result의 초기값으로 대입
      int result = value + 10; // &lt;------- 컴파일 오류
        
      // 변수 result 값을 읽고 콘솔에 출력
      System.out.println(result);
  }
}
    
  
  변수는 출력문이나 연산식에 사용되어 변수값을 활용합니다.
  
    다음 예제는 변수를 문자열과 결합 후 출력하거나 연산식에서 활용하는 모습을 보여줍니다.
```java
public class VariableUseExample {
  public static void main(String[] args) {
      int hour = 3;
      int minute = 5;
      System.out.println(hour + “시간” + minute + “분”);

      int totalMinute = (hour*60) + minute;
  System.out.println("총" + totalMinute + "분");   } }
    
  


// 실행 결과
// 3시간 5분
// 총 185분
- 변수는 또 다른 변수에 대입되어 메모리 간에 값을 복사할 수 있습니다.
    - 다음 코드는 변수 x 값을 변수 y 값으로 복사합니다.
```java
int x = 10; // 변수 x에 10을 대입
int y = x; // 변수 y에 변수 x값을 대입


  다음 예제는 두 변수의 값을 교환하는 방법을 보여줍니다.
    
      
        두 변수의 값을 교환하기 위해서 새로운 변수 temp를 선언한 것에 주목합시다.
```java
public class VariableExchangeExample {
  public static void main(String[] args) {
  int x = 3;
  int y = 5;
  System.out.println(“x:” + x + “, y:” + y);

        int temp = x;
  x = y;
  y = temp;
  System.out.println(“x:” + x + “, y:” + y);
  }
}
      
    
  


// 실행 결과
// x:3, y:5
// x:5, y:3
```

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html"><h1 class="title_post">💾[Database] 데이터베이스의 정의와 특징.</h1></a>
                        <a href="/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html" class="txt_post">
                            💾[Database] 데이터베이스의 정의와 특징.

1️⃣ 데이터베이스 : 여러 사용자나 응용 프로그램이 공유하고 동시에 접근 가능한 ‘데이터의 집합’ 이라고 정의할 수 있습니다.

2️⃣ DBMS(DataBase Management System) : ‘데이터베이스’를 ‘관리,운영하는 소프트웨어’ 입니다.


  🙋‍♂️ 데이터베이스
  
    ‘데이터 저장 공간’ 자체를 의미하기도 합니다.

    DBMS 중 하나인 MySQL에서는 ‘데이터베이스’를 ‘자료가 저장되는 디스크 공간(주로 파일로 구성됨)’으로 취급합니다.
  




위 그림은 데이터베이스, DBMS, 사용자, 응용 프로그램의 관계를 보여줍니다.

위 그림에서 보듯이 DBMS는 데이터베이스를 관리하는 역할을 하는 소프트웨어입니다.

여러 사용자나 응용 프로그램은 DBMS가 관리하는 데이터에 동시에 접속하여 데이터를 공유합니다.

👉 즉, DBMS에서는 데이터베이스에서 사용되는 데이터가 집중 관리됩니다.


  🙋‍♂️ 데이터베이스와 DBMS
  
    데이터베이스를 DBMS와 혼용해서 같은 용어처럼 사용하는 경우도 흔히 있습니다.
바라보는 시각에 따라 그렇게 사용하는 것이 틀린 것은 아니지만
저는 데이터베이스를 ‘데이터의 집합’ 또는 ‘데이터의 저장 공간’으로 보고,
DBMS는 데이터베이스를 운영하는 ‘소프트웨어’라는 의미로 공부하겠습니다.
  


DBMS에는 MySQL 외에도 많은 종류의 프로그램이 있습니다.

  MySQL
  MariaDB
  PostgreSQL
  Oracle
  SQL Server
  DB2
  Access
  SQLite
  …



  🙋‍♂️ 위 명시된 리스트는 2018년 기준 많이 사용되는 DBMS입니다.


3️⃣ DBMS 또는 데이터베이스의 몇 가지 중요한 특징.


  👉 데이터 무결성
    
      데이터베이스 안의 데이터는 어떤 경로를 통해 들어왔든 오류가 있어서는 안 되는데 이를 무결성(Integrity)이라고 합니다.
      무결성을 지키기 위해 데이터베이스는 제약 조건(constraint)을 따릅니다.
        
          예를 들어 학생 데이터에서 모든 학생은 학번이 반드시 있어야 하고 학번이 중복되면 안 된다는 제약 조건을 생각해봅시다.
          이 제약 조건을 충실히 지킨다면 학번으로도 학번으로도 학생 데이터에서 학생을 정확히 찾을 수 있습니다.
            
              즉, 학번은 무결한 데이터를 보장하는 요소이며, 자동 발급기로 성적 증명서나 재학 증명서를 뗄 떼 학번만 조회해도 정확한 자료를 줄력할 수 있습니다.
            
          
        
      
    
  
  👉 데이터의 독립성
    
      데이터베이스의 크기를 변경하거나 데이터 파일의 저장소를 변경하더라도 기존에 작성된 응용 프로그램은 전혀 영향을 받지 않습니다.
        
          즉 데이터베이스와 응용 프로그램은 서로 의존적인 관계가 아니라 독립적인 관계입니다.
            
              예를 들어 데이터베이스가 저장된 디스크가 새것으로 변경되어도 기존에 사용하던 응용 프로그램은 아무런 변경 없이 계속 사용할 수 있습니다.
            
          
        
      
    
  
  👉 보안
    
      데이터베이스 안에 데이터는 아무나 접근할 수 있는 것이 아니라 데이터를 소유한 사람이나 데이터에 접근이 허가된 사람만 접근할 수 있습니다.
      또한, 같은 데이터에 접근할 때도 사용자의 계정에 따라서 각각 다른 권한을 갖습니다.
      최근 들어 고객 정보 유출 사고가 빈번하여 보안(Security)은 데이터베이스에서 더욱 중요한 이슈가 되고 있습니다.
    
  
  👉 데이터 중복 최소화
    
      데이터베이스에서는 동일한 데이터가 여러 군데 중복 저장되는 것을 방지합니다.
        
          학교를 예로 들면, 학생 정보를 이용하는 교직원들(학생처, 교무처, 과사무실 등)이 각 직원마다 별도의 엑셀 파일로 학생 정보를 관리하면 한 명의 학생 정보가 각각의 엑셀 파일에 중복 저장됩니다.
          그러나 데이터베이스에 통합하여 관리하면 하나의 테이블에 데이터를 저장한 후 응용 프로그램마다 이를 공유하여 사용할 수 있어 데이터의 중복을 최소화할 수 있습니다.
        
      
    
  
  👉 응용 프로그램 제작 및 수정 용이
    
      기존 파일 시스템에서는 각각의 파일 포맷에 맞춰 응용 프로그램을 개발했습니다.
      그러나 데이터베이스를 이용하면 통일된 방식으로 응용 프로그램을 작성할 수 있고 유지,보수 또한 쉽습니다.
    
  
  👉 데이터의 안전성 향상
    
      대부분의 DBMS는 데이터의 백업/복원 기능을 제공합니다.
      따라서 데이터가 손상되는 문제가 발생하더라도 원래의 상태로 복원 또는 복구할 수 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240714_AWS_GRADLEW.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240714_AWS_GRADLEW.html"><h1 class="title_post">☁️[AWS] .gradlew 빌드 실패시 확인해야 할 것들</h1></a>
                        <a href="/Backend/AWS/240714_AWS_GRADLEW.html" class="txt_post">
                            1️⃣ Amazon Corretto JDK 8이 올바르게 설치되었는지 확인하기.

$ls -l /usr/lib/jvm/ava-1.8.0-amazon-corretto.x86_64


위 명령어를 통해 내부를 들여다보니 디렉토리 안에는 jre 디렉토리만 있고, JDK 디렉토리 구조가 포함되어 있지 않아서 JAVA_HOME 으로 설정할 수 없는 오류가 발생했었습니다.

이는 java-1.8.0-amazon-corretto-devel 패키지가 올바르게 설치되지 않았음을 의미할 수 있습니다.

🙋‍♂️ Amazon Corretto JDK 8 설치 및 확인.

먼저, Amazon Corretto JDK 8이 올바르게 설치되었는지 확인하고, 제대로 설치되지 않았다면 다시 설치합니다.


  기존 JDK 제거(필요시)
    sudo dnf remove -y java-1.8.0-amazon-corretto java-1.8.0-amazon-corretto-devel
    
  
  Amazon Corretto JDK 8 설치
    sudo dnf install -y java-1.8.0-amazon-corretto-devel
    
  
  설치된 디렉토리 확인.
    ls -l /usr/lib/jvm/
    
  
  JDK 디렉토리 구조 확인.
    
      JDK 디렉토리 구조가 포함되어 있는지 확인합니다.
        ls -l /usr/lib/jvm/java-1.8.0-amazon-corretto.x86_64/
        
      
    
  


🙋‍♂️ 올바른 JAVA_HOME 설정 및 빌드

  JAVA_HOME 및 PATH 설정
    export JAVA_HOME=/usr/lib/jvm/java-1.8.0-amazon-corretto.x86_64
export PATH=$JAVA_HOME/bin:$PATH
    
  
  설정확인
    echo $JAVA_HOME
java -version
javac -version
    
  
  Gradl 빌드 실행
    ./gradlew clean
./gradlew build
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-07-11-SpringAndSpringBoot.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-07-11-SpringAndSpringBoot.html"><h1 class="title_post">📝[Post] Spring과 SpringBoot의 개념.</h1></a>
                        <a href="/Backend/Post/2024-07-11-SpringAndSpringBoot.html" class="txt_post">
                            



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240710_AWS_MYSQL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240710_AWS_MYSQL.html"><h1 class="title_post">☁️[AWS] Amazon Linux 2023 플랫폼에 MySQL 설치하는 방법.</h1></a>
                        <a href="/Backend/AWS/240710_AWS_MYSQL.html" class="txt_post">
                            Amazon Linux 2023 플랫폼에 MySQL이 기본적으로 설정되어 있지 않습니다.

그러므로 따로 설치해줘야 합니다.

기본적인 방법은 아래와 같습니다.

1️⃣ RPM 파일 다운로드.
sudo wget https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm


위 명령어를 사용하여 RPM 파일을 다운로드 받아줍니다.


  🙋‍♂️ 모든 파일의 설정은 ec2 cli에서 설정해야 합니다.


2️⃣ GPC 퍼블릭 키 설정
sudo dnf install mysql80-community-release-el9-1.noarch.rpm -y


mysql 설치를 위해 퍼블릭 키를 import하는 과정입니다.

sudo dnf update -y


3️⃣ MySQL 설치.

이 부분은 mysql-client와 mysql-server로 나뉩니다.

먼저 mysql-client 설치부터 합니다.

1️⃣ mysql-client 설치.
sudo dnf install mysql-community-client -y


이후에 mysql-server를 설치합니다.

2️⃣ mysql-server 설치.
sudo dnf install mysql-community-server -y


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240709_AWS_HOSTNAME.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240709_AWS_HOSTNAME.html"><h1 class="title_post">☁️[AWS] HOSTNAME 바꾸는 방법</h1></a>
                        <a href="/Backend/AWS/240709_AWS_HOSTNAME.html" class="txt_post">
                            EC2 인스턴스의 호스트 이름을 바꾸는 방법.

🙋‍♂️ 모든 과정은 EC2에 접속 후에 이루어집니다.

1️⃣ 호스트 이름 설정.
hostnamectl 명령어를 사용하여 호스트 이름을 설정합니다.

sudo hostnamectl set-hostname {my-new-hostname}


2️⃣ /etc/sysconfig/network 파일 수정.
/etc/sysconfig/network 파일에 새로운 호스트 이름을 추가합니다.

sudo vi /etc/sysconfig/network


HOSTNAME 항목을 추가하거나 수정합니다.

NETWORKING=yes
HOSTNAME={my-new-hostname}


3️⃣ /etc/hosts 파일 수정.
/etc/hosts 파일을 열어 호스트 이름을 추가합니다.

sudo vi /etc/hosts


파일 내용은 다음과 같이 수정합니다.

127.0.0.1 localhost localhost.localdomain
::1       localhost localhost.localdomain
127.0.0.1 {my-new-hostname}


4️⃣ 즉시 호스트 이름 변경.
호스트 이름을 즉시 적용합니다.

sudo hostname {my-new-hostname}


5️⃣ 셸 프롬프트 구성.
셸 프롬프트에 새로운 호스트 이름이 표시되도록 .bashrc 파일을 수정합니다.

vi ~/.bashrc


다음 줄을 추가하거나 수정합니다.

PS1='[\u@\h \W]\$ '


변경 사항을 적용합니다.

source ~/.bashrc


6️⃣ 인스턴스 재부팅

위의 모든 단계를 수행한 후 인스턴스를 재부팅합니다.

sudo reboot


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-06-27-ServerAndClient-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-06-27-ServerAndClient-1.html"><h1 class="title_post">📝[Post] 서버와 클라이언트의 개념(1)</h1></a>
                        <a href="/Backend/Post/2024-06-27-ServerAndClient-1.html" class="txt_post">
                            🙋‍♂️ Preview

이번 포스트에서는 컴퓨터 과학에서 말하는 서버와 클라이언트의 개념을 크게 세 가지로 나눠 살펴보겠습니다.

  이것은 이해를 돕기 위한 분류로, 서버와 클라이언트라는 개념에 익숙해지고 난 후에 다시 보면 왜 이렇게 나누었는지 이해가 될 것 입니다.


1️⃣ 네트워크에서의 서버와 클라이언트.


  서버(Server) : “서비스를 제공하는 쪽”
  클라이언트(Client) : “서비스를 제공받는 쪽”





  그림에서 서버는 실제 존재하는 물리적인 고성능 컴퓨터이고, 클라이언트는 데스크톱이나 노트북, 스마트폰 등과 같은 사용자들의 단말기를 나타냅니다.
    
      즉, 물리적 장치와 또 다른 물리적 장치 사이의 관계를 의미합니다.
        
          이렇게 물리적인 장치 간에 서로 통신이 이루어지기 위해서는 “통신을 시작하는 쪽”이 “상대방의 네트워크 주소인 IP 주소를 알고 있어야 합니다.”
            
              “클라이언트가 서버의 IP주소를 알고있어야 서버와 클라이언트로서의 관계를 맺을 수 있습니다.”
            
          
        
      
    
  


1️⃣ 트래픽(Traffic) 처리 방법.

우리가 컴퓨터나 스마트폰으로 이용하는 서비스들은 수백만 명 이상의 사용자가 동시에 사용하고 있는 경우가 대부분입니다.
그렇다면 이러한 서비스를 운영하는 서버가 모두 고성능일까요? 🤔

당연히 그렇지 않습니다 ❌

한꺼번에 수백만 명 이상의 사용자로부터 생기는 “트래픽(Traffic)”을 처리하기 위한 방법은 여러가지가 있습니다.

여기서는 가장 범용적이고 직관적인 방법 두 가지, “로드 밸런싱” 과 “캐시”에 대해 간단히 설명하겠습니다.

1️⃣ 로드 밸런싱(Load Balancing).


  “로드 밸런싱(Load Balancing)” : 부하 분산.
    
      즉, 서버에 가해지는 부하(Load)를 분산하는 것입니다.
        
          사용자들의 트래픽을 여러 서버가 나눠 받도록 구성하며, 일반적으로 네트워크 장비인 “스위치(Switch)” 를 할당해 “로드 밸런싱”할 수 있습니다.
            
              스위치에서 어떤 서버로 로드 밸런싱이 되도록 할지는 소프트웨어적으로 제어할 수 있습니다.
            
          
        
      
    
  





  “로드 밸런싱” 은 “스위치” 라는 장비가 “클라이언트의 트래픽을 먼저 받아” 서 여러 대의 서버로 “분산” 해 주는 방식입니다.
    
      이렇게 하면 부하가 분산되는 효과 외에도 스위치 뒤에 연결된 서버들을 필요에 따라 추가하거나 삭제할 수 있어 편리합니다.
    
  


2️⃣ 캐시(Cache).


  “캐시(Cache)” : 비용이 큰 작업의 결과를 어딘가에 저장하여 비용이 작은 작업으로 동일한 효과를 내는 것.
    
      캐시를 이용하면 매번 요청이 들어올 때마다 비용이 큰 작업을 다시 수행할 필요 없이 미리 저장된 결과로 응답하면 됩니다.
        
          물론 이렇게 하면 가장 최신의 데이터는 아닐 수 있지만, 성능을 극대화시키고자 하는 캐시의 목적을 생각해 데이터의 실시간성을 조금 포기해도 되는 경우가 많습니다.
        
      
    
  



  ✏️ Example
  
    음원 서비스

    데이터베이스에 저장된 수많은 음원의 다운로드 수, 스트리밍 수, 추천 수 등으로 인기 점수를 계산하려 100갸의 곡을 오름차순 순위로 제공합니다.

    만약 사용자가 한 번 음원을 조회할 때마다 모든 음원의 인기 점수를 계산해 순위를 매긴다면 아마 사용자가 수백 명만 되어도 서버 부하로 응답 시간이 매우 느려질 것입니다.

    이렇게 수많은 음원의 인기 점수를 매번 계산하여 순위를 매기는 작업이 바로 ‘비용이 큰 작업’ 입니다.

    

    매시 정각마다 TOP 100을 계산한 결과를 저장했다가 사용자의 요청이 들어왔을 때 응답해주면 ‘비용이 작은 작업’으로 대체할 수 있습니다.

    사용자는 16시 30분에 16시에 저장된 TOP 100 결과로도 큰 불편함을 느끼지 않습니다.

    이렇게 사용자가 캐시된 과거의 데이터를 보더라도 서비스 시용에 지장이 없다면 캐시 사용을 충분히 고려할 만합니다.

    
  



  “캐시” 는 다양한 상황에서 비슷한 뜻으로 사용되지만, 공통적으로, ‘비용이 큰 작업을 비용이 작은 작업으로 대신하는 것’이라고 정리할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html"><h1 class="title_post">☕️[Java] 프로그래밍 언어와 자바</h1></a>
                        <a href="/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html" class="txt_post">
                            1️⃣ 프로그래밍 언어와 자바.


  기계어(Machine language)
    
      0과 1로 이루어진 이진 코드를 사용합니다.
      사람이 이해하기에는 어렵습니다.
    
  
  프로그래밍 언어(Programming language)
    
      고급 언어(High-level language)와 저급 언어(Low-level language)로 구분됩니다.
    
  
  고급 언어(High-level language)
    
      컴퓨터와 대화할 수 있도록 만든 언어 중에서 사람이 쉽게 이해할 수 있는 언어를 말합니다.
      고급 언어로 작성된 소스 파일(Source file)은 컴퓨터가 바로 이해할 수 없기 때문에 컴파일(Compile)이라는 과정을 통해서 컴퓨터가 이해할 수 있는 0과 1로 이루어진 기계어(Machine language)로 변환한 후 컴퓨터가 사용하게 됩니다.
    
  



  🤔 MORE : 소스 파일(Source file).
프로그래밍 언어에서 “소스 파일(Source file)” 이란 특정 프로그래밍 언어로 작성된 텍스트 파일을 의미합니다.
이 파일에는 개발자가 작성한 코드가 포함되어 있으며, 컴퓨터가 이를 이해하고 실행할 수 있도록 하기 위해서는 보통 컴파일러나 인터프리터가 필요합니다.



  저급 언어(Low-level language)
    
      기계어에 가까운 언어를 말하는데, 대표적으로 어셈블리어가 저급언어에 속합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/ENG/240621-ENG-STUDY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ENG.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/ENG/240621-ENG-STUDY.html"><h1 class="title_post">📚[ENG][240621] 제목만 해석하는 영어 공부 :)</h1></a>
                        <a href="/Backend/ENG/240621-ENG-STUDY.html" class="txt_post">
                            1️⃣ Why You Should Stop Using @Value Annotations In Spring (And Use This Instead)

  🙋‍♂️ 해석: “Spring에서 @Value 어노테이션(주석)을 사용을 중단하고 (대신 이를 사용해야 하는 이유)”
  📝Reference


2️⃣ Be part of a better internet

  🙋‍♂️ 해석: “더 나은 인터넷의 일원이 되세요.”
    
      Be part of : “일원이 되다” 또는 “참여하다” 라는 뜻을 가지고 있습니다. 어떤 단체나 활동, 또는 상황에 참여하거나 속하는 것을 의미합니다.
        
          예를 들어 “Be part of team”은 “팀의 일원이 되다”라는 뜻이 됩니다.
        
      
    
  
  📝Reference


3️⃣ Unpacking the “Day Job”

  🙋‍♂️ 해석: "’본업’을 해부하기”
    
      “Unpacking” : 문자 그대로는 “짐을 풀다”라는 뜻이지만, 비유적으로는 어떤 주제나 개념을 자세히 분석하거나 설명하는 것을 의미합니다.
        
          예를 들어, “Unpacking the ‘Day Job’“은 “본업에 대해 자세히 분석하기” 또는 “본업을 해부하기”라는 의미로 이해할 수 있습니다.
        
      
    
  
  📝Reference


4️⃣ 10 Cheap Desk Upgrades Every Programmer Needs #DeskSeries

  🙋‍♂️ 해석: “모든 프로그래머가 필요한 저렴한 책상 업그레이드 10가지”
  📝Reference


5️⃣ These Dividend Sell-Offs Could Mean Higher Starting Yields For You!

  🙋‍♂️ 해석: “이 배당금 매도는 더 높은 초기 수익률을 의미할 수 있습니다!”
    
      “Dividend” : 주식시장에서 “배당금” 을 의미합니다.
        
          이는 기업이 이익의 일부를 주주들에게 분배하는 금액입니다. 배당금은 주로 보통 현금으로 지급되지만, 주식 형태로 지급되기도 합니다. 배당금은 주로 정기적으로, 예를 들어 분기별이나 연간으로 지급됩니다.
        
      
      “Sell-Offs” : 금융 시장에서 “대규모 매도” 를 의미합니다.
        
          이는 투자자들이 대량으로 자산을 매도하여 시장에 공급이 급증하고, 그로 인해 가격이 하락하는 상황을 말합니다. 주식, 채권, 상품 등 다양한 자산에서 발생할 수 있습니다.
        
      
      “Yields” : 금융 및 투자 분야에서 “수익률” 을 의미합니다.
        
          이는 투자로부터 얻을 수 있는 수익의 비율을 나타내며, 보통 퍼센트로 표시됩니다. 수익률은 다양한 방식으로 계산될 수 있으며, 주식의 경우 배당금 수익률, 채권의 경우 이자 수익률 등이 이에 해당합니다. 일반적으로 수익률은 투자자에게 해당 자산이 얼마나 수익을 창출할 수 있는지를 보여주는 중요한 지표입니다.
        
      
    
  
  📝Reference


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-18-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-18-TIL.html"><h1 class="title_post">📝 [TIL] 240618 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-18-TIL.html" class="txt_post">
                            
  [AWS] 클라우드 컴퓨팅의 유형 정리
  [ENGLISH STUDY] 제목만 해석하는 영어 공부
  [배열 학습]


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/ENG/240618_ENG_STUDY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ENG.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/ENG/240618_ENG_STUDY.html"><h1 class="title_post">📚[ENG] 제목만 해석하는 영어 공부 :) </h1></a>
                        <a href="/Backend/ENG/240618_ENG_STUDY.html" class="txt_post">
                            1️⃣ Which IDE/Code Editor is best for Java Developer 2024

  🙋‍♂️ 해석: “2024년도 Java 개발자들에게 가장 적합한 IDE/코드 편집기는 무엇입니까?”
    
      best for : ~에 가장 적합
    
  
  📝Reference


2️⃣ A Third of My Online College Students are AI-Powered Spambots. Now what?

  🙋‍♂️ 해석: “온라인 대학 수강생의 3분의 1이 AI 스팸봇입니다. 이제 어떻게 해야 할까요?”
  📝Reference


3️⃣ Check your team for get-there-itis

  🙋‍♂️ 해석: “당신의 팀이 ‘목적지 집착증’에 걸렸는지 확인하세요.”
    
      “Get-there-itis” 는 주로 항공 및 해양 분야에서 사용되는 용어로, 목표에 너무 집중한 나머지 안전이나 절차를 무시하고 빨리 도착하려는 경향을 의미합니다.
        
          이 용어는 공식적인 의학 용어는 아니지만, 비공식적으로 목표 지향적인 강박증을 나타냅니다.
          따라서 “Check your team for get-there-itis” 라는 문구는 “당신의 팀이 ‘목적지 집착증’에 걸렸는지 확인하세요” 라는 번역이 개념적으로 맞다고 할 수 있습니다.
        
      
    
  
  💭 나의 생각 : 조금 더 자연스럽게 번역한다면 나라면 “당신의 팀이 너무 ‘목표에 집착’하고 있는지 확인해보세요.” 라고 번역할 것 같다.
  📝Reference


4️⃣ The unsexy problem problem

  🙋‍♂️ 해석: “매력적이지 않은 문제에 대한 문제”
  💭 나의 생각 : “problem” 이라는 단어가 두 번 나와서 어떻게 번역/해석을 해야 하는지 갈피를 못잡았다. 그래서 ChatGPT의 도움을 받았다.
    
      나의 친구(ChatGPT)가 말하길 “The unsexy problem problem” 이라는 문장에서 “problem” 이라는 단어가 두 번 나오기 때문에, 이 표현을 한국어로 번역시, 이를 고려하여 자연스럽게 전달해야 한다고 말해줬다.
      나의 친구는 의미를 좀 더 명확하게 전달하기 위해 “섹시하지 않은 문제라는 문제” 또는 “매력적이지 않은 문제에 대한 문제” 라는 두 번역 예시를 나에게 추천해줬다.
      그 이유를 설명하길 “이렇게 번역하면 원문에서 ‘problem’이 두 번 나오는 이유를 더 잘 반영하면서 의미를 명확하게 전달할 수 있습니다.” 라고 말해줬다. :)
    
  
  📝Reference


5️⃣ Why are my Java virtual threads slower than the platform threads?

  🙋‍♂️ 해석: “왜 나의 자바 가상 스레드는 플랫폼 스레드보다 느릴까?”
  📝Reference


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240615_Types_of_Clould_Computing.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240615_Types_of_Clould_Computing.html"><h1 class="title_post">☁️[AWS] 클라우드 컴퓨팅의 유형</h1></a>
                        <a href="/Backend/AWS/240615_Types_of_Clould_Computing.html" class="txt_post">
                            



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-17-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-17-TIL.html"><h1 class="title_post">📝 [TIL] 240617 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-17-TIL.html" class="txt_post">
                            
  수학, 필요.충분 조건


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-06-17-Math.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-06-17-Math.html"><h1 class="title_post">[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.</h1></a>
                        <a href="/Backend/Math/2024-06-17-Math.html" class="txt_post">
                            












                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Metacognition/Java/2024-06-16-Meta-Java-PrimitiveType.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/META.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Metacognition/Java/2024-06-16-Meta-Java-PrimitiveType.html"><h1 class="title_post">💭 [Metacognition] 240616 JAVA의 정석</h1></a>
                        <a href="/Metacognition/Java/2024-06-16-Meta-Java-PrimitiveType.html" class="txt_post">
                            1️⃣ Primitive type(기본형)의 종류와 크기.

Java의 Primitive Type(기본형)은 총 8가지가 있습니다.

1️⃣ 각 Type의 크기와 특징.

1️⃣ byte


  크기 : 1 byte(8 bits)
  범위 : -128 ~ 127



  📚 NOTE: bit

  binary digit의 약자.
이진수(0 또는 1) 하나의 자리수를 의미합니다.

  즉, 1 bit은 0 또는 1을 표현할 수 있습니다.


2️⃣ short


  크기 : 2 bytes (16 bits)
  범위 : -32,768 ~ 32,767


3️⃣ int


  크기 : 4 bytes (32 bits)
  범위 : - 2,147,483,648 ~ 2,147,483,647


4️⃣ long


  크기 : 8 bytes (64 bits)
  범위 : - 9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807


5️⃣ float


  크기 : 4 bytes (32 bits)
  범위 : 1.4E-45 ~ 3.4E+38 (단정밀도 부동소수점)


6️⃣ double


  크기 : 8 bytes(64 bits)
  범위 : 4.9E-324 ~ 1.8E+308 (배정밀도 부동소수점)


7️⃣ char


  크기 : 2 bytes(4 bits)
  범위 : '\u0000' ~ '\uffff' (유니코드 문자)


8️⃣ boolean


  크기 : Java 언어 명세서에 따르면 boolean의 크기는 명시되어 있지 않으며, 일반적으로 1 bit으로 표현됩니다.
  값: true 또는 false


이러한 primitive type은 Java에서 기본 데이터 타입으로 사용되며, 각 타입은 고정된 크기를 가지고 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Metacognition" class="category">Metacognition</a>
                            
                                <span class="date">· 2024-06-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-16-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-16-TIL.html"><h1 class="title_post">📝 [TIL] 240616 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-16-TIL.html" class="txt_post">
                            
  Studing English through Newsletters
  Metacognition JAVA의 정석 - 기본형 크기와 특징
  [수학] 명제와 증명 학습


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/ENG/240616-ENG-STUDY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ENG.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/ENG/240616-ENG-STUDY.html"><h1 class="title_post">📚[ENG] 240616 Studing English through Newsletters</h1></a>
                        <a href="/Backend/ENG/240616-ENG-STUDY.html" class="txt_post">
                            1️⃣ AI’s Going to Cost Us

  “AI로 인해 비용이 발생할 것”
  📝Reference


2️⃣ Has the AI Revolution Crashed?

  “AI 혁명은 무너졌는가?”
  📝Reference


3️⃣ Do NOT Make This Navigation Mistake in Jetpack Compose

  “Jetpack Compose에서 이러한 Navigation 실수를 저지르지 마세요”
  📝Reference


4️⃣ Obsidian Plugins Review

  “옵시디언 플러그인 리뷰”
  📝Reference


5️⃣ Software Architecture is Hard

  “소프트웨어 아키텍처는 어렵다.”
  📝Reference


6️⃣ Whenever I Forget Someone’s Name, I Always Use This Brilliant Hack

  “누군가의 이름을 잊어버릴 때마다 나는 항상 이 놀라운 꿀팁을 사용합니다.”
  📝Reference


7️⃣ Mastering WidgetState in Flutter 3.22

  “Flutter 3.22에서 WidgetState 마스터하기.”
  📝Reference


8️⃣ Visualize Like a Pro: Annotate Matplotlib Graphs for Stunning Data Stories

  “전문가처럼 시각화: 놀라운 데이터 스토리를 위해 Matplotilb 그래프에 주석 달기.”
  📝Reference


9️⃣ The Earning Potential of Software Programmers

  “소프트웨어 프로그래머의 수익 잠재력”
  📝Reference


1️⃣0️⃣ End Tech Debt Conversations Forever with 6 Easy Hacks to Team Culture

  “팀 문화에 대한 6가지 쉬운 해킹으로 기술 부채 대화를 영원히 끝내세요.”
  📝Reference


1️⃣1️⃣ With SimPO You Don’t Need a Reference Model to Align Your LLM

  “SimPO를 사용하면 LLM을 정렬하기 위해 참조 모델이 필요하지 않습니다.”
  📝Reference


1️⃣2️⃣ Even if you had perfect data, you should still be building defensive data pipelines

  “완벽한 데이터가 있더라도 여전히 방어적인 데이터 파이프라인을 구축해야 합니다.”
  📝Reference


1️⃣3️⃣ Designing our new REST API

  “새로운 REST API 설계”
  📝Reference


1️⃣4️⃣ Koin-Depondent Composable Previews in Android Jetpack Compose

  “Android Jetpack Compose의 Koin 종속 컴포저블 미리보기”
  📝Reference


1️⃣5️⃣ Let’s Build a RESTful API in Rust

  “Rust에서 RESTful API를 구축해 봅시다”
  📝Reference


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-13-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-13-TIL.html"><h1 class="title_post">📝 [TIL] 240613 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-13-TIL.html" class="txt_post">
                            
  원형 큐를 구현할 때 rear의 초기값을 -1로 설정하지 않는 이유.
  알고리즘
  피자 나눠 먹기(2)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-13-AboutAlgorithm.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-13-AboutAlgorithm.html"><h1 class="title_post">📦[DS,Algorithm] 알고리즘(Algorithm)</h1></a>
                        <a href="/Backend/AnD/2024-06-13-AboutAlgorithm.html" class="txt_post">
                            1️⃣ 알고리즘(Algorithm).

알고리즘(Algorithm)은 주어진 문제를 해결하기 위해 일련의 명확한 단계로 구성된 절차나 방법을 의미합니다.

쉽게 말해, 알고리즘은 문제 해결을 위한 일련의 규칙 또는 지침입니다.

1️⃣ 알고리즘(Algorithm)의 정의.

알고리즘은 다음과 같은 요소를 갖춘 절차를 말합니다.


  
    입력(Input) : 알고리즘이 처리할 하나 이상의 값이 주어집니다.
  
  
    출력(Output) : 알고리즘의 수행 결과로 하나 이상의 값이 생성됩니다.
  
  
    명확성(Definiteness) : 각 단계는 명확하게 정의되어 있어야 합니다. 모호한 부분 없이 명확한 지침이어야 합니다.
  
  
    유한성(Finiteness) : 알고리즘은 유한한 단계 내에서 종료되어야 합니다. 즉, 알고리즘은 무한히 실행되지 않고, 한정된 단계 내에서 끝나야 합니다.
  
  
    유효성(Effectiveness) : 알고리즘의 모든 단계는 실제로 수행 가능해야 하며, 사람이 직접 수행할 수 있을 정도로 기본적인 연산으로 구성되어 있어야 합니다.
  


2️⃣ 알고리즘의 특성

알고리즘은 다음과 같은 특성을 가질 수 있습니다.


  
    정확성(Correctness) : 알고리즘은 올바른 결과를 생성해야 합니다.
  
  
    시간 복잡도(Time Complexity) : 알고리즘이 문제를 해결하는 데 걸리는 시간입니다. 일반적으로 크기에 대한 함수로 표현됩니다.
  
  
    공간 복잡도(Space Complexity) : 알고리즘이 문제를 해결하는 데 사용하는 메모리 양입니다. 이 또한 입력 크기에 대한 함수로 표현됩니다.
  
  
    효율성(Efficiency) : 알고리즘이 주어진 자원을 얼마나 효율적으로 사용하는지 나타냅니다. 여기에서는 시간 복잡도와 공간 복잡도가 포함됩니다.
  
  
    확장성(Scalability) : 알고리즘이 입력 크기에 따라 얼마나 잘 동작하는지 나타냅니다. 확장성 있는 알고리즘은 큰 입력 크기에서도 효율적으로 작동합니다.
  


3️⃣ 알고리즘의 중요성.

알고리즘(Algorithm)은 컴퓨터 과학 및 프로그래밍에서 핵심적인 역할을 합니다.

효율적인 알고리즘을 사용하면 컴퓨터 프로그램이 더 빠르고 적은 자원을 사용하여 문제를 해결할 수 있습니다.

또한 알고리즘은 문제 해결의 논리적이고 체계적인 접근 방식을 제공하여 복잡한 문제를 단순화하고 해결하는 데 도움을 줍니다.


  알고리즘을 잘 이해하고 사용하는 것은 프로그래머와 컴퓨터 과학자에게 필수적인 기술입니다.
이를 통해 다양한 문제를 효율적으로 해결하고, 더 나은 소프트웨어와 시스템을 설계할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-13-ReasonOfRearIsntSetToMinusOneInCircularQueue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-13-ReasonOfRearIsntSetToMinusOneInCircularQueue.html"><h1 class="title_post">📦[DS,Algorithm] Circular Queue(원형 큐)를 배열로 구현시 rear를 -1으로 설정하지 않는 이유.</h1></a>
                        <a href="/Backend/AnD/2024-06-13-ReasonOfRearIsntSetToMinusOneInCircularQueue.html" class="txt_post">
                            1️⃣ Circular Queue(원형 큐)를 배열로 구현시 rear를 -1으로 설정하지 않는 이유.

Java에서 원형 큐를 구현할 때 ‘rear’ 의 초기값을 ‘-1’ 로 설정하지 않는 이유는 여러 가지가 있습니다.

주요 이유는 큐의 인덱싱을 단순화하고, 논리적인 흐름을 일관되게 유지하기 위함입니다.

다음은 그 이유를 자세히 설명한 것입니다.

1️⃣ 인덱스의 일관성 유지.


  ‘rear’ 를 ‘0’ 으로 초기화하면 큐의 인덱싱이 단순해집니다.
    
      ‘rear’ 와 ‘front’ 모두 0에서 시작하여, 큐의 크기를 ‘capacity’ 로 나눈 나머지를 사용하여 인덱스를 순환시킵니다.
      이는 모듈로 연산을 사용하여 인덱스를 관리하는 데 있어 편리합니다.
    
  
  ‘rear’ 를 ‘-1’ 로 설정할 경우, 요소를 추가할 때마다 매번 ‘rear’ 를 ‘0’ 으로 조정하는 특별한 처리가 필요하게 됩니다.
    
      이는 코드의 복잡성을 증가시키고 실수의 가능성을 높입니다.
    
  


2️⃣ 코드의 단순화.


  ‘rear’ 를 ‘0’ 으로 초기화하면 초기 상태와 요소 추가, 삭제시 별도의 조건 검사를 줄일 수 있습니다.
    
      예를 들어 ‘rear’ 가 ‘-1’ 인지 확인하는 추가 조건문을 피할 수 있습니다.
    
  
  ‘0’ 부터 시작하면 ‘enqueue’ 와 ‘dequeue’ 연산에서 ‘rear’ 와 ‘front’ 인덱스의 증가와 감소가 일관되게 처리됩니다.


3️⃣ 편리한 초기 상태 처리.


  ‘rear’ 를 ‘0’ 으로 설정하면 초기 상태에서 큐가 비어 있는지 확인하는 것이 더 직관적입니다.
    
      예를 들어 ‘isEmpty’ 메서드는 단순히 ‘size’ 변수를 확인하여 큐가 비어 있는지 확인할 수 있습니다. ‘rear’ 가 ‘-1’ 이면 추가적인 상태 검사가 필요할 수 있습니다.
    
  


2️⃣ 예시 코드.

다음은 ‘rear’ 의 초기값을 ‘0’ 으로 설정하는 원형 큐의 코드입니다.

public class CircularQueue {
	private int[] queue;
	private int front;
	private int rear;
	private int size;
	private int capacity;

	public CircularQueue(int capacity) {
		this.capacity = capacity;
		this.queue = new int[capacity];
		this.front = 0;
		this.rear = 0;
		this.size = 0;
	}

	public boolean isFull() {
		return size == capacity;
	}

	public boolean isEmpty() {
		return size == 0;
	}

	public void enqueue(int data) {
		if (isFull()) {
			throw new RuntimeException("Queue is full");
		}
		queue[rear] = data;
		rear = (rear + 1) % capacity;
		size++;
	}

	public int dequeue() {
		if (isEmpty()) {
			throw new RuntimeException("Queue is empty");
		}
		int data = queue[front];
		front = (front + 1) % capacity;
		size--;
		return data;
	}

	public int peek() {
		if (isEmpty()) {
			throw new RuntimeException("Queue is empty");
		}
		return queue[front];
	}

	public int getSize() {
		return size;
	}

	public void displayCircularQueue() {
		if (isEmpty()) {
			throw new RuntimeException("Queue is empty");
		}
		int i = front;
		int count = 0;
		while (count &lt; size) {
			System.out.print("["+ queue[i] + "]");
			i = (i + 1) % capacity;
			count++;
		}
		System.out.println();
	}

	public int getMiddle() {
		if (isEmpty()) {
			throw new RuntimeException("Queue is empty");
		}
		int middleIndex = (front + size / 2) % capacity;
		return queue[middleIndex];
	}
}

// Main
public class Main {

	public static void main(String[] args) {
		CircularQueue circularQueue = new CircularQueue(5);
		CircularQueue.enqueue(10);
		CircularQueue.enqueue(20);
		CircularQueue.enqueue(30);
		CircularQueue.enqueue(40);
		CircularQueue.enqueue(50);
		CircularQueue.displayCircularQueue();
		System.out.println();

		System.out.println("Middle element: " + circularQueue.getMiddle());
		circularQueue.displayCircularQueue();
		System.out.println();

		System.out.println("===DEQUEU===");
		System.out.println(circularQueue.dequeue());
		circularQueue.enqueue(60);
		circularQueue.displayCircularQueue();
		System.out.println();

		System.out.println("Middle element: " + circularQueue.getMiddle());
		circularQueue.displayCircularQueue();
	}
}

// === 출력 ===
/*
[10][20][30][40][50]

Middle element: 30
[10][20][30][40][50]

===DEQUEU===
10
[20][30][40][50][60]

Middle element: 40
[20][30][40][50][60]
*/



  위 코드에서 ‘rear’ 를 0으로 설정함으로써 큐의 인덱싱과 상태 처리가 단순해지고, 이해하기 쉬워집니다.
이는 코드의 가독성과 유지보수성을 높이는 데 도움이 됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-12-CircularQueueFindMiddleIndex.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-12-CircularQueueFindMiddleIndex.html"><h1 class="title_post">📦[DS,Algorithm] Circular Queue(원형 큐)의 중간 지점 찾기.</h1></a>
                        <a href="/Backend/AnD/2024-06-12-CircularQueueFindMiddleIndex.html" class="txt_post">
                            1️⃣ Circular Queue(원형 큐)의 중간 지점 찾기.

Java에서 배열을 사용하여 구현한 원형 큐에서 중간 지점을 찾는 방법은 큐의 시작 위치(‘front’)와 끝 위치(‘rear’)를 기준으로 계산할 수 있습니다.

중간 지점을 찾는 공식은 원형 큐의 특성을 고려하여 적절히 조정되어야 합니다.

2️⃣ 중간 지점을 찾기 위한 방법.

1️⃣ 중간 지점 계산 공식.

중간 지점을 찾는 방법은 큐의 시작점과 끝점을 이용하여 계산할 수 있습니다.

원형 큐의 크기, 시작 인덱스(front), 끝 인덱스(rear)를 사용하여 중간 인덱스를 계산할 수 있습니다.

이때 중간 지점을 계산하는 공식은 다음과 같습니다.

(front + size / 2) % capacity


여기서 ‘size’ 는 큐에 현재 저장된 요소의 수이고, ‘capacity’ 는 큐의 전체 크기입나다.

3️⃣ 예시

public class CircularQueue {
    private int[] queue;
    private int front, rear, size, capacity;

    public CircularQueue(int capacity) {
        this.capacity = capacity;
        this.queue = new int[capacity];
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    public boolean isFull() {
        return size == capacity;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public void enqueue(int data) {
        if (isFull()) {
            throw new RuntimeException("Queue is full");
        }
        queue[rear] = data;
        rear = (rear + 1) % capacity;
        size++;
    }

    public int dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
        }
        int data = queue[front];
        front = (front + 1) % capacity;
        size--;
        return data;
    }

    public int getMiddle() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
        }
        int middleIndex = (front + size / 2) % capacity;
        return queue[middleIndex];
    }

    public static void main(String[] args) {
        CircularQueue cq = new CircularQueue(5);
        cq.enqueue(10);
        cq.enqueue(20);
        cq.enqueue(30);
        cq.enqueue(40);
        cq.enqueue(50);
        
        System.out.println("Middle element: " + cq.getMiddle());  // Output: Middle element: 30
        
        cq.dequeue();
        cq.enqueue(60);
        
        System.out.println("Middle element: " + cq.getMiddle());  // Output: Middle element: 40
    }
}



이 코드에서는 ‘CircularQueue’ 클래스를 정의하고, ‘enqueue’, ‘dequeue’, ‘isFull’, ‘isEmpty’ 메서드를 포함합니다.

또한, 큐의 중간 요소를 반환하는 ‘getMiddle’ 메서드를 정의합니다.

이 메서드는 현재 큐의 크기와 시작 인덱스를 사용하여 중간 인덱스를 계산한 후 해당 인덱스의 요소를 반환합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-12-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-12-TIL.html"><h1 class="title_post">📝 [TIL] 240612 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-12-TIL.html" class="txt_post">
                            
  Deque에서의 front와 rear의 변화 정리 및 복습.
  Circular Queue(원형 큐)의 중간 지점 찾기.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-11-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-11-TIL.html"><h1 class="title_post">📝 [TIL] 240611 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-11-TIL.html" class="txt_post">
                            
  피자 나눠 먹기(1)
  과제 수행(Java)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-10-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-10-TIL.html"><h1 class="title_post">📝 [TIL] 240610 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-10-TIL.html" class="txt_post">
                            
  deque에서의 front와 rear의 변화


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-10-ChangeBetweenFrontAndRearInDeque.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-10-ChangeBetweenFrontAndRearInDeque.html"><h1 class="title_post">📦[DS,Algorithm] Deque에서의 front와 rear의 변화.</h1></a>
                        <a href="/Backend/AnD/2024-06-10-ChangeBetweenFrontAndRearInDeque.html" class="txt_post">
                            🧨 시발점.

Deque을 공부하던 중 동적으로 변하는 front와 rear가 근본적으로 어떻게 동작하는지 궁금해졌습니다.

이것을 알게되면 정확하게 Deque의 addFirst, addLast, removeFirst, removeLast 시 front와 rear가 어디에 위치하는지 알 수 있고 Deque의 원리를 이해 할 수 있을 것 같았습니다.

1️⃣ Deque의 front와 rear의 위치는 변할 수 있나요? 🤔

‘Deque‘ (Double Ended Queue)에서 ‘front‘ 와 ‘rear‘ 의 위치는 변할 수 있습니다.

‘Deque‘ 는 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조이기 때문에, ‘front‘ 와 ‘rear‘ 의 위치는 데이터가 삽입되거나 제거될 때마다 변합니다.

2️⃣ Deque에서의 front와 rear의 변화. 🤩

1️⃣ 삽입 연산 (‘addFirst‘ 와 ‘addLast‘)


  ‘addFirst’ : 요소를 덱의 앞쪽에 삽입합니다.
    
      ‘front‘ 위치가 바뀝니다.
    
  
  ‘addLast’ : 요소를 덱의 뒤쪽에 삽입합니다.
    
      ‘rear‘ 위치가 바뀝니다.
    
  


2️⃣ 삭제 연산 (‘removeFirst‘ 와 ‘removeLast‘)


  ‘removeFirst’ : 덱의 앞쪽에서 요소를 제거합니다.
    
      ‘front‘ 위치가 바뀝니다.
    
  
  ‘removeLast’ : 덱의 뒤쪽에서 요소를 제거합니다.
    
      ‘rear‘ 위치가 바뀝니다.
    
  


3️⃣ 예제 코드.

아래는 ‘Deque’ 의 ‘LinkedList’ 구현을 사용하여 ‘front’ 와 ‘rear’ 의 변화를 보여주는 예제 코드입니다.

import java.util.Deque;
import java.util.LinkedList;

public class DequeExample {
	public static void main(String[] args) {
		Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();

		// 요소를 덱의 앞과 뒤에 추가
		deque.addFirst("A"); // front: A
		deque.addLast("B"); // rear: B
		deque.addFirst("C"); // front: C, rear: B
		deque.addLast("D"); // rear: D

		System.out.println("Initial Deque: " + deque); // 출력 : [C,A,B,D]

		// 앞쪽에서 요소 제거
		System.out.println("Removed from front: " + deque.removeFirst()); // 출력: C

		// 뒤쪽에서 요소 제거
		System.out.println("Removed from rear: " + deque.removeLast()); // 출력: D

		System.out.println("Deque after removals: " + deque); // 출력: [A, B]

		// 덱의 앞쪽과 뒤쪽에서 요소 확인
		System.out.println("Front element: " + deque.getFirst()); // 출력: A
		System.out.println("Rear element: " + deque.getLast()); // 출력: B
	}
}


👉 설명.

1️⃣ 삽입 연산.


  
    ‘deque.addFirst(“A”)’ : “A”를 덱의 앞에 삽입합니다.
  
  
    ‘deque.addLast(“B”)’ : “B”를 덱의 뒤에 삽입합니다.
  
  
    ‘deque.addFirst(“C”)’ : “C”를 덱의 앞에 삽입합니다.
  
  
    ‘deque.addLast(“D”)’ : “D”를 덱의 뒤에 삽입합니다.
  



  이 연산들은 ‘front’ 와 ‘rear’ 의 위치를 업데이트합니다.


2️⃣ 삭제 연산.


  
    ‘deque.removeFirst()’ : 덱의 앞쪽에서 “C”를 제거합니다.
  
  
    ‘deque.removeLast()’ : 덱의 뒤쪽에서 “D”를 제거합니다.
  



  이 연산들은 ‘front’ 와 ‘rear’ 의 위치를 다시 업데이트합니다.


3️⃣ 요소 확인.


  
    ‘deque.getFirst()’ : 덱의 앞쪽 요소를 확인합니다.
  
  
    ‘deque.getLast()’ : 덱의 뒤쪽 요소를 확인합니다.
  



  이 예시 코드는 ‘front’ 와 ‘rear’ 가 데이터의 삽입 및 삭제 연산에 따라 어떻게 변하는지 잘 보여줍니다.
‘Deque’ 는 이처럼 양쪽 끝에서의 삽입과 삭제 연산을 지원하므로, ‘front’ 와 ‘rear’ 의 위치는 동적입니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-09-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-09-TIL.html"><h1 class="title_post">📝 [TIL] 240609 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-09-TIL.html" class="txt_post">
                            
  짝수는 싫어요
  다형성
  Circular Queue(원형 큐)란?


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-09-CircularQueue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-09-CircularQueue.html"><h1 class="title_post">📦[DS,Algorithm] Circular Queue(원형 큐)란?</h1></a>
                        <a href="/Backend/AnD/2024-06-09-CircularQueue.html" class="txt_post">
                            1️⃣ Circular Queue(원형 큐)란?

원형 큐는 큐의 일종으로, 배열을 사용하여 구현되며, 큐의 마지막 위치가 처음 위치와 연결되어 원형 구조를 가지는 큐입니다.

원형 큐는 고정된 크기의 배열을 사용하여 구현되므로, 큐의 마지막 인덱스가 배열의 끝에 도달하면 다음 인덱스가 배열의 시작 부분으로 이동합니다.

이를 통해 메모리를 효율적으로 사용할 수 있으며, 큐의 처음과 끝을 관리하는 데 도움이 됩니다.

2️⃣ 원형 큐의 원리.


  
    고정된 크기 : 원형 큐는 고정된 크기의 배열을 사용하여 구현됩니다. 따라서 배열의 크기를 초과하여 요소를 추가할 수 없습니다.
  
  
    연결된 인덱스 : 큐의 마지막 인덱스가 배열의 끝에 도달하면, 다음 인덱스는 배열의 처음 부분으로 이동합니다.
  
  두 개의 포인터 : 원형 큐는 두 개의 포인터를 사용하여 구현됩니다.
    
      ‘front’ : 큐의 첫 번째 요소를 가리킵니다.
      ‘rear’ : 큐의 마지막 요소를 가리킵니다.
    
  
  비어 있는 상태와 가득 찬 상태 : 큐가 비어 있는 상태와 가득 찬 상태를 구별해야 합니다. 이를 위해 추가적인 변수를 사용하거나 포인터의 위치를 비교하여 상태를 확인합니다.


3️⃣ 원형 큐의 주요 연산.


  
    초기화 : 큐의 크기를 설정하고, ‘front’ 와 ‘rear’ 포인터를 초기화합니다.
  
  
    isEmpty() : 큐가 비어 있는지 확인합니다.
  
  
    isFull() : 큐가 가득 찼는지 확인합니다.
  
  
    enqueue() : 큐에 요소를 추가합니다. ‘rear’ 포인터를 업데이트합니다.
  
  
    dequeue() : 큐에서 요소를 제거하고 반환합니다. ‘front’ 포인터를 업데이트합니다.
  
  
    peek() : 큐의 첫 번째 요소를 반환합니다.
  


4️⃣ 원형 큐의 예제 구현.

public class CircularQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    // 생성자
    public CircularQueue(int capacity) {
        this.capacity = capacity;
        queue = new int[capacity];
        front = 0;
        rear = -1;
        size = 0;
    }

    // 큐가 비어 있는지 확인
    public boolean isEmpty() {
        return size == 0;
    }

    // 큐가 가득 찼는지 확인
    public boolean isFull() {
        return size == capacity;
    }

    // 큐에 요소 추가
    public void enqueue(int element) {
        if (isFull()) {
            System.out.println("Queue is full");
            return;
        }
        rear = (rear + 1) % capacity;
        queue[rear] = element;
        size++;
    }

    // 큐에서 요소 제거
    public int dequeue() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return -1;
        }
        int element = queue[front];
        front = (front + 1) % capacity;
        size--;
        return element;
    }

    // 큐의 첫 번째 요소 확인
    public int peek() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return -1;
        }
        return queue[front];
    }

    // 큐의 크기 반환
    public int getSize() {
        return size;
    }

    // 큐의 모든 요소 출력
    public void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }
        int i = front;
        int count = 0;
        while (count &lt; size) {
            System.out.print(queue[i] + " ");
            i = (i + 1) % capacity;
            count++;
        }
        System.out.println();
    }

    // 메인 메서드 (테스트용)
    public static void main(String[] args) {
        CircularQueue cq = new CircularQueue(5);

        cq.enqueue(10);
        cq.enqueue(20);
        cq.enqueue(30);
        cq.enqueue(40);
        cq.enqueue(50);

        cq.display(); // 출력: 10 20 30 40 50

        System.out.println("Dequeued: " + cq.dequeue()); // 출력: Dequeued: 10
        System.out.println("Dequeued: " + cq.dequeue()); // 출력: Dequeued: 20

        cq.display(); // 출력: 30 40 50

        cq.enqueue(60);
        cq.enqueue(70);

        cq.display(); // 출력: 30 40 50 60 70

        System.out.println("Front element: " + cq.peek()); // 출력: Front element: 30
    }
}


🙋‍♂️ 설명.


  큐 초기화:
    
      ‘capacity’ : 큐의 최대 크기입니다.
      ‘queue’ : 큐를 저장할 배열입니다.
      ‘front’ : 큐의 첫 번째 요소를 가리키는 인덱스입니다.
      ‘rear’ : 큐의 마지막 요소를 가리키는 인덱스입니다.
      ‘size’ : 큐에 있는 요소의 개수입니다.
    
  
  메서드:
    
      ‘isEmpty()’ : 큐가 비어 있는지 확인합니다.
      ‘isFull()’ : 큐가 가득 찼는지 확인합니다.
      ‘enqueue(int element)’ : 큐에 요소를 추가합니다.
      ‘dequeue()’ : 큐에서 요소를 제거하고 반환합니다.
      ‘peek()’ : 큐의 첫 번째 요소를 반환합니다.
      ‘getSize()’ : 큐에 있는 요소의 개수를 반환합니다.
      ‘display()’ : 큐의 모든 요소를 출력합니다.
    
  


5️⃣ 결론.

원형 큐는 배열을 효율적으로 사용하여 큐의 크기를 고정하고, 처음과 끝이 연결된 형태로 큐를 관리하는 자료구조입니다.

이를 통해 큐의 공간을 최대한 활용하고, 큐가 비어 있는지 가득 찼는지를 쉽게 확인할 수 있습니다.

🤔 궁금했던 부분.

rear = (rear + 1) % capacity;


1️⃣ 이 코드에서 % capacity 를 하는 이유는 무엇일까?

원형 큐에서 ‘rear’ 포인터를 업데이트 할 때 % capacity 를 사용하는 이유는 큐가 마지막 인덱스에 도달한 후, 다시 처음 인덱스로 돌아가도록 하기 위해서입니다.

이를 통해 큐가 원형으로 동작할 수 있습니다.

구체적으로 말하면, 큐의 크기를 고정된 크기의 배열로 구현할 때, 배열의 끝에 도달했을 때 다시 처음으로 돌아가는 기능을 제공합니다.

2️⃣ % 연산자의 역할.

배열의 인덱스는 0부터 시작하여 배열의 크기보다 1 작은 값까지입니다.

예를 들어, 배열의 크기가 5라면 인덱스는 0부터 4까지입니다.

원형 큐에서 새로운 요소를 추가할 때마다 ‘rear’ 포인터를 증가시키는데, 이 포인터가 배열의 끝을 넘어가지 않도록 해야 합니다.

이를 위해 % capacity 연산을 사용합니다.


  rear = (rear + 1) % capacity;


이 연산은 ‘rear’ 포인터를 1씩 증가시키다가, 배열의 끝에 도달하면 다시 0으로 돌아가게 합니다.

즉, 배열의 인덱스가 배열의 크기를 넘어가면, 다시 처음 인덱스(0)로 순환되게 합니다.

👉 예제.

배열의 크기가 5인 원형 큐를 생각해봅시다.


  초기 상태: ‘rear = -1’
  요소 추가 시, ‘rear’ 포인터의 변화를 관찰해보면
    
      첫 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 0’
      두 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 1’
      세 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 2’
      네 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 3’
      다섯 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 4’
      여섯 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 0’ (다시 처음으로 돌아감)
    
  


이렇게 ‘rear’ 포인터가 배열의 끝에 도달하면 다시 배열의 시작 부분으로 순환되므로, 배열을 효율적으로 사용할 수 있게 됩니다.

💻 코드 예제.

위 개념을 이용한 원형 큐의 ‘enqueue’ 메서드 구현

public void enqueue(int element) {
    if (isFull()) {
        System.out.println("Queue is full");
        return;
    }
    rear = (rear + 1) % capacity; // rear 포인터를 증가시키고, 배열의 처음으로 순환시킴.
    queue[rear] = element;
    size++;
}


6️⃣ 정리.

원형 큐에서 ’% capacity’ 연산은 ‘rear’ 포인터와 ‘front’ 포인터가 배열의 끝에 도달했을 때, 다시 배열의 시작 부분으로 돌아가기 위해 사용됩니다.

이를 통해 배열의 고정된 크기를 효율적으로 활용하며, 원형 큐의 특성을 유지할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-09-polymorphism.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-09-polymorphism.html"><h1 class="title_post">☕️[Java] 다형성(Polymorphism)</h1></a>
                        <a href="/Backend/Java/2024-06-09-polymorphism.html" class="txt_post">
                            1️⃣ 다형성(Polymorphism).

‘다형성(Polymorphism)’ 은 ‘객체 지향 프로그래밍(OOP)’ 의 중요한 개념 중 하나로, 같은 인터페이스를 통해 서로 다른 데이터 타입의 객체를 조작할 수 있도록 합니다.

다형성은 코드의 재사용성과 유연성을 높여주며, 유지보수를 쉽게 해줍니다.

Java에서 ‘다형성’ 은 주로 ‘상속’ 과 ‘인터페이스’ 를 통해 구현됩니다.

2️⃣ 다형성의 개념.

다형성은 “하나의 인터페이스로 여러 가지 형태를 구현할 수 있는 능력” 을 의미합니다.

이는 같은 메서드가 다양한 객체에서 다르게 동작할 수 있게 합니다.

3️⃣ 다형성의 두 가지 형태.

1️⃣ 컴파일 시간 다형성(Compile-time Polymorphism)


  
    메서드 오버로딩(Method Overloading)을 통해 구현됩니다.
  
  
    컴파일 시점에 어떤 메서드가 호출될지 결정됩니다.
  
  
    같은 이름의 메서드를 여러 개 정의하지만, 매개변수의 타입이나 개수가 달라야 합니다.
  


2️⃣ 런타임 다형성 (Runtime Polymorphism)


  
    메서드 오버라이딩(Method Overriding)을 통해 구현됩니다.
  
  
    실행 시점에 어떤 메서드가 호출될지 결정됩니다.
  
  
    부모 클래스의 메서드를 자식 클래스에서 재정의하여 사용합니다.
  


4️⃣ 컴파일 시간 다형성(Method Overloading).

메서드 오버로딩은 같은 클래스 내에서 같은 이름을 가진 메서드를 여러 개 정의하는 것입니다.

단, 매개변수의 수나 타입이 달라야 합니다.

💻 예제.

public class MathOperations {
	// 정수 두 개의 합
	public int add(int a, int b) {
		return a + b;
	}

	// 실수 두 개의 합
	public double add(double a, double b) {
		return a + b;
	}

	// 새 개의 정수의 합
	public int add(int a, int b, int c) {
		return a + b + c;
	}

	public static void main(String[] args) {
		MathOperations mathOperations = new MathOperations();
		System.out.println(mathOperations.add(1, 2)); // 3
		System.out.println(mathOperations.add(1.5, 2.5)); // 4.0
		System.out.println(mathOperations.add(1, 2, 3)); // 6
	}
}


5️⃣ 런타임 다형성(Method Overriding).

메서드 오버라이딩은 자식 클래스가 부모 클래스의 메서드를 재정의하는 것을 말합니다.

이를 통해 자식 클래스의 객체가 부모 클래스의 메서드를 호출할 때, 자식 클래스의 메서드가 실행되도록 합니다.

💻 예제.

class Animal {
	void makeSound() {
		System.out.println("Animal makes a sound");
	}
}

class Dog extends Animal {
	@Override
	void makeSound() {
		System.out.println("Dog barks");
	}
}

class Cat extends Animal {
	@Override
	void makeSound() {
		System.out.println("Cat meows");
	}
}

public class Main {

	public static void main(String[] args) {
		Animal myDog = new Dog(); // Animal 타입으로 Dog 객체 생성
		Animal myCat = new Cat(); // Animal 타입으로 Cat 객체 생성

		myDog.makeSound(); // Dog barks
		myCat.makeSound(); // Cat meows
	}
}


6️⃣ 인터페이스를 통한 다형성.

인터페이스를 통해서도 다형성을 구현할 수 있습니다.

인터페이스는 메서드의 서명만을 정의하며, 이를 구현하는 클래스가 메서드의 구체적인 동작을 정의합니다.

💻 예제.

interface Shape {
	void draw();
}

class Circle implements Shape {
	@Override
	public void draw() {
		System.out.println("Drawing a Circle");
	}
}

class Square implements Shape {
	@Override
	public void draw() {
		System.out.println("Drawing a Square");
	}
}

public class Main {

	public static void main(String[] args) {
		Shape myShape1 = new Circle();
		Shape myShape2 = new Square();

		myShape1.draw(); // Drawing a Circle
		myShape2.draw(); // Drawing a Square
	}
}


7️⃣ 다형성의 장점.


  
    코드 재사용성 : 상위 클래스나 인터페이스를 사용하여 다양한 하위 클래스나 구현체를 다룰 수 있어 코드의 재사용성이 높아집니다.
  
  
    유연성 : 새로운 클래스나 기능을 추가할 때 기존 코드를 수정할 필요 없이 확장할 수 있습니다.
  
  
    유지보수성 : 코드를 이해하고 유지보수하는 것이 더 쉬워집니다. 메서드의 호출이 어디서 어떻게 이루어지는지 명확하기 때문입니다.
  


8️⃣ 예제: 다형성의 실질적 사용.

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class PolymorphismExample {

	public static void main(String[] args) {
		List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
		List&lt;String&gt; linkedList = new LinkedList&lt;&gt;();

		arrayList.add("ArrayList Item");
		linkedList.add("LinkedList Item");

		printList(arrayList); // ArrayList Item
		printList(linkedList); // LinkedList Item
	}

	public static void printList(List&lt;String&gt; list) {
		for (String item : list) {
			System.out.println(item);
		}
	}
}



  이 예제에서는 ‘List‘ 인터페이스를 사용하여 ‘ArrayList‘ 와 ‘LinkedList‘ 를 동일한 방식으로 처리합니다.
이를 통해 다양한 구현체를 다룰 수 있는 유연한 코드를 작성할 수 있습니다.


📝 결론.

다형성은 객체 지향 프로그래밍의 핵심 개념 중 하나로, 코드의 유연성과 재사용성을 크게 향상시킵니다.

이를 통해 다양한 형태의 객체를 동일한 방식으로 다룰 수 있으며, 새로운 기능을 쉽게 확장하고 유지보수할 수 있습니다.

다형성은 상속과 인터페이스를 통해 구현되며, 메서드 오버로딩과 오버라이딩을 통해 다양한 형태를 취할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-08-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-08-TIL.html"><h1 class="title_post">📝 [TIL] 240608 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-08-TIL.html" class="txt_post">
                            
  Primitive Type과 Wrapper Class
  제네릭
  나머지 구하기
  중앙값 구하기


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-08-Generic.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-08-Generic.html"><h1 class="title_post">☕️[Java] 제네릭(Generic)</h1></a>
                        <a href="/Backend/Java/2024-06-08-Generic.html" class="txt_post">
                            1️⃣ 제네릭(Generic)

Java에서의 제네릭(Generic) 은 클래스나 메서드에서 사용할 데이터 타입을 나중에 지정할 수 있도록 하는 기능입니다.

제네릭을 사용하면 코드의 재사용성을 높이고, 컴파일 시 타입 안전성을 제공하며, 명시적 타입 캐스팅을 줄일 수 있습니다.

2️⃣ 제네릭(Generic)의 주요 개념.


  타입 매개변수 :
    
      제네릭 클래스나 메서드는 타입 매개변수를 사용하여 타입을 정의합니다. 이 타입 매개변수는 클래스나 메서드가 호출될 때 구체적인 타입으로 대체됩니다.
    
  
  타입 안정성 :
    
      제네릭을 사용하면 컴파일 시 타입을 검사하므로, 런타입에 발생할 수 있는 타입 오류를 줄일 수 있습니다.
    
  
  재사용성 :
    
      제네릭 클래스나 메서드는 다양한 타입에 대해 동작하도록 설계할 수 있어, 코드의 재사용성을 높입니다.
    
  


3️⃣ 제네릭 클래스.

제네릭 클래스는 클래스 선언에 타입 매개변수를 포함하여 정의합니다.

일반적으로 타입 매개변수는 한 글자로 표현 되며, ‘T(Tyep)‘, ‘E(Element)‘, ‘K(Key)‘, ‘V(Value)‘ 등이 자주 사용됩니다.

예제.

// Box 클래스
public class Box&lt;T&gt; {
	private T item;

	public void setItem(T item) {
		this.item = item;
	}

	public T getItem() {
		return item;
	}
}

// Main 클래스
public class Main {

	public static void main(String[] args) {
		Box&lt;String&gt; stringBox = new Box&lt;&gt;();
		stringBox.setItem("Hello");
		System.out.println("String item: " + stringBox.getItem()); // String item: Hello

		Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();
		integerBox.setItem(123);
		System.out.println("Integer item: " + integerBox.getItem()); // Integer item: 123
	}
}


4️⃣ 제네릭 메서드.

제네릭 메서드는 메서드 선언 타입 매개변수를 포함하여 정의합니다.

예제.

public class GenericMethodExample {
	public static &lt;T&gt; void printArray(T[] array) {
		for (T element : array) {
			System.out.print(element + " ");
		}
		System.out.println();
	}

	public static void main(String[] args) {
		Integer[] intArray = {1, 2, 3, 4, 5};
		String[] strArray = {"A", "B", "C", "D"};

		printArray(intArray); // 1 2 3 4 5 
		printArray(strArray); // A B C D 
	}
}


5️⃣ 제네릭 타입 제한 (Bounded Type Parameters)

제네릭 타입 매개변수에 제한을 걸어 특정 타입의 하위 클래스나 인터페이스만 허용할 수 있습니다.

상한 제한 (Upper Bound)

public class BoundedTypeExample&lt;T extends Number&gt; {
	private T number;

	public BoundedTypeExample(T number) {
		this.number = number;
	}

	public void printNumber() {
		System.out.println("Number: " + number);
	}

	public static void main(String[] args) {
		BoundedTypeExample&lt;Integer&gt; intExample = new BoundedTypeExample&lt;&gt;(123);
		intExample.printNumber(); // Number: 123

		BoundedTypeExample&lt;Double&gt; doubleExample = new BoundedTypeExample&lt;&gt;(45.67);
		doubleExample.printNumber(); // Number: 45.67
	}
}



  여기서 ‘T’ 는 ‘Number’ 클래스나 그 하위 클래스만 될 수 있습니다.


하한 제한 (Lower Bound)

하한 제한은 와일드카드(’? super T‘)를 사용하여 정의됩니다.

예를 들어 ‘List&lt;? super Integer&gt;‘ 는 ‘Integer‘ 의 상위 타입인 ‘Number‘, ‘Object‘ 등이 될 수 있습니다.

import java.util.ArrayList;
import java.util.List;

public class LowerBoundWildcardExample {
	public static void addNumbers(List&lt;? super Integer&gt; list) {
		for (int i = 0; i &lt; 5; i++) {
			list.add(i);
		}
	}

	public static void main(String[] args) {
		List&lt;Number&gt; numberList = new ArrayList&lt;&gt;();
		addNumbers(numberList);
		System.out.println(numberList); // [0, 1, 2, 3, 4]
	}
}


6️⃣ 제네릭의 제한 사항.


  Primitive Type 사용 불가 : 제네릭은 참조 타입만 허용하며, 기본 타입은 사용할 수 없습니다.


// 올바르지 않음
Box&lt;int&gt; intBox = new Box&lt;&gt;(); // 컴파일 오류



  정적 컨텍스트에서의 타입 매개변수 사용 : 정적 메서드나 정적 변수에서는 타입 매개변수를 사용할 수 없습니다.


public class GenericClass&lt;T&gt; {
    private static T item; // 컴파일 오류
}



  제네릭 배열 생성 불가 : 제네릭 배열을 직접 생성할 수 없습니다.


// 올바르지 않음
T[] array = new T[10]; // 컴파일 오류



  제네릭은 Java의 강력한 기능으로, 타입 안전성을 높이고 코드의 재사용성을 극대화할 수 있게 해줍니다.
이를 적절히 활용하면 더 안정적이고 유지보수하기 쉬운 코드를 작성할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-08-PrimitiveAndWrapper.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-08-PrimitiveAndWrapper.html"><h1 class="title_post">☕️[Java] Primitive Type과 Wrapper Class.</h1></a>
                        <a href="/Backend/Java/2024-06-08-PrimitiveAndWrapper.html" class="txt_post">
                            1️⃣ 도화선 🧨

‘int와 Integer의 차이가 무엇이 있을까?’ 하는 호기심이 도화선이 되어 이 글을 쓰게 되었습니다 :)

먼저 ‘int와 Integer의 차이’를 알아보니 ‘int’ 는 ‘Primitive Type’ 이고, ‘Integer’ 는 ‘Wrapper Class’ 라는 것을 알게 되었습니다.

2️⃣ Primitive Type과 Wrapper Class.

Java에서 Primitive Type 과 Wrapper Class는 각각 기본 데이터 타입과 그 기본 타입을 객체로 감싸는 클래스입니다.

이 둘의 개념과 차이점을 이해하는 것은 Java 프로그래밍에서 매우 중요합니다.

1️⃣ Primitive Type (기본 데이터 타입).

Primitive Type은 Java에서 가장 기본적인 데이터 타입을 말합니다.

Java는 다음과 같은 8가지 기본 데이터 타입을 제공합니다.


  
    
      boolean : 논리값(true 또는 false).
    
  
  
    
      byte : 8비트 정수.
    
  
  
    
      short : 16비트 정수.
    
  
  
    
      int : 32비트 정수.
    
  
  
    
      long : 64비트 정수.
    
  
  
    
      float : 32비트 부동 소수점.
    
  
  
    
      double : 64비트 부동 소수점.
    
  
  
    
      char : 16비트 유니코드 문자.
    
  


이러한 타입들은 성능이 뛰어나고 메모리를 적게 사용하며, 객체를 생성할 필요 없이 값 그 자체를 저장하고 조작할 수 있습니다.

예시

int a = 10;
boolean isJavaFun = true;
char letter = 'A';


2️⃣ Wrapper Class (래퍼 클래스)

Wrapper Class 는 각 Primitive Type 에 대응되는 클래스입니다.

이 클래스들은 Primitive Type을 객체로 감싸기 때문에 “래퍼 클래스” 라고 불립니다.

Java는 각 기본 타입에 대한 래퍼 클래스를 제공합니다.


  
    
      boolean -&gt; ‘Boolean’
    
  
  
    
      byte -&gt; ‘Byte’
    
  
  
    
      short -&gt; ‘Short’
    
  
  
    
      int -&gt; ‘Integer’
    
  
  
    
      long -&gt; ‘Long’
    
  
  
    
      float -&gt; ‘Float’
    
  
  
    
      double -&gt; ‘Double’
    
  
  
    
      char -&gt; ‘Character’
    
  


Wrapper Class 는 다음과 같은 이유로 사용됩니다.


  Primitive Type 을 객체로 다루어야 할 때(예: 컬렉션 프레임워크에서는 객체만 저장할 수 있음)
  null 값을 처리해야 할 때
  추가 메서드 및 기능을 사용해야 할 때(예: 문자열을 정수로 변환하는 메서드 등)


예시

Integer a = 10;
Boolean isJavaFun = true;
Character letter = 'A';


3️⃣ Autoboxing 과 Unboxing

Java는 기본 타입과 래퍼 클래스 간의 자동 변환을 지원합니다.

이를 Autoboxing 과 Unboxing 이라고 합니다.


  
    Autonboxing : 기본 타입이 자동으로 해당 래퍼 클래스 객체로 변환되는 것.
  
  
    Unboxing : 래퍼 클래스 객체가 자동으로 해당 기본 타입으로 변환되는 것,
  


예시

int primitiveInt = 5;
Integer wrapperInt = primitiveInt; // Autoboxing

Integer anotherWrapperInt = 10;
int anotherPrimitiveInt = anotherWrapperInt; // Unboxing


4️⃣ Primitive Type 과 Wrapper Class의 차이점.


  
    
      메모리 사용 :
        
          Primitive Type : 메모리 효율적, 객체 오버헤드 없음.
          Wrapper Class : 객체 오버헤드가 있어 더 많은 메모리 사용.
        
      
    
  
  
    
      기본값 :
        
          Primitive Type : 기본값이 정의되어 있음 (예: int는 0, boolean은 false).
          Wrapper Class : 기본값이 ‘null’ 일 수 있음.
        
      
    
  
  
    
      성능 :
        
          Primitive Type : 빠른 연산 속도.
          Wrapper Class : 객체 생성과 가비지 컬렉션의 오버헤드로 인해 상대적으로 느립.
        
      
    
  
  
    
      기능성 :
        
          Primitive Type : 단순한 데이터 저장과 연산에 적합.
          Wrapper Class : 다양한 유틸리티 메서드 제공 (예: 문자열 반환, 비교 메서드 등).
        
      
    
  


예제 코드

다음은 Primitive Type과 Wrapper Class의 사용 예를 보여주는 코드입니다.

import java.util.ArrayList;
import java.util.List;

public class Main {

	public static void main(String[] args) {
		// Primitive Type 사용
		int primitiveInt = 100;
		boolean primitiveBoolean = true;

		// Wrapper Class 사용
		Integer wrapperInt = Integer.valueOf(100); // 명시적 변환
		Boolean wrapperBoolean = Boolean.valueOf(true);

		// Autoboxing and Unboxing
		Integer autoboxedInt = 200; // Autoboxing
		int unboxedInt = autoboxedInt; // Unboxing

		// Primitive Type은 컬렉션에 저장할 수 없음
		List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();
		intList.add(primitiveInt); // Autoboxing
		intList.add(wrapperInt);

		// 컬렉션에서 값을 가져올 때 Unboxing
		int sum = 0;
		for (int num : intList) {
			sum += num; // Unboxing
		}

		System.out.println("Sum: " + sum); // Output: Sum: 200
	}
}



  이 예제에서는 기본 타입과 래퍼 클래스를 사용하여 변수레 값을 저장하고, 컬렉션에 저장된 래퍼 클래스 객체를 사용하려 연산을 수행하는 과정을 보여줍니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-07-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-07-TIL.html"><h1 class="title_post">📝 [TIL] 240607 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-07-TIL.html" class="txt_post">
                            
  LinkedList를 이용한 Deque
  분수의 덧셈 복습


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-07-LinkedListDeque.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-07-LinkedListDeque.html"><h1 class="title_post">📦[DS,Algorithm] LinkedList를 사용한 Deque.</h1></a>
                        <a href="/Backend/AnD/2024-06-07-LinkedListDeque.html" class="txt_post">
                            1️⃣ LinkedList를 사용한 Deque.

‘LinkedList‘ 는 ‘Deque‘ 인터페이스를 구현한 클래스 중 하나로, 양쪽 끝에서 삽입과 삭제가 가능한 이중 연결 리스트 기반의 자료 구조입니다.

‘LinkedList‘ 는 ‘Deque‘ 뿐만 아니라 ‘List‘, ‘Queue‘ 인터페이스도 구현하여 다양한 형태로 사용할 수 있습니다.

2️⃣ 주요 특징.


  
    이중 끝 큐 : 양쪽 끝에서 요소를 추가하고 제거할 수 있습니다.
  
  
    이중 연결 리스트 : 각 노드는 이전 노드와 다음 노드를 가리키는 두 개의 포인터를 가집니다.
  
  
    비동기적 : ‘LinkedList‘ 는 비동기적으로 동작하므로 동기화된 환경에서 안전하지 않습니다.
  


3️⃣ 주요 메서드.

삽입 연산.


  
    ‘addFirst(E e)’ : 지정된 요소를 덱의 앞쪽에 추가합니다.
  
  
    ‘addLast(E e)’ : 지정된 요소를 덱의 뒤쪽에 추가합니다.
  
  
    ‘offerFirst(E e)’ : 지정된 요소를 덱의 앞쪽에 추가합니다.
  
  
    ‘offerLast(E e)’ : 지정된 요소를 덱의 뒤쪽에 추가합니다.
  


삭제 연산.


  
    ‘removeFirst()’ : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘removeLast()’ : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘pollFirst()’ : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘pollLast()’ : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.
  


조회 연산.


  
    ‘getFirst()’ : 덱의 앞쪽에 있는 요소를 반환합니다.
  
  
    ‘getLast()’ : 덱의 뒤쪽에 있는 요소를 반환합니다.
  
  
    ‘peekFirst()’ : 덱의 앞쪽에 있는 요소를 반환합니다.
  
  
    ‘peekLast()’ : 덱의 뒤쪽에 있는 요소를 반환합니다.
  


스택 연산.


  
    ‘push(E e)’ : 스택의 맨 위에 요소를 추가합니다.(FIFO, First In First Out)
  
  
    ‘pop()’ : 스택의 맨 위에 있는 요소를 제거하고 반환합니다.(LIFO, Last In First Out)
  


4️⃣ 시간 복잡도


  삽입과 삭제 연산 : ‘addFirst‘, ‘addLast‘, ‘removeFirst‘, ‘removeLast‘, ‘offerFirst‘, ‘offerLast‘, ‘pollFirst‘, ‘pollLast‘ 등의 연산은 O(1)입니다.
    
      이중 연결 리스트를 사용하기 때문에 양쪽 끝에서의 삽입과 삭제는 상수 시간 내에 수행됩니다.
    
  
  
    조회 연산 : ‘getFirst‘, ‘getLast‘, ‘peekFirst‘, ‘peekLast‘ 등의 연산은 O(1)입니다.
  
  임의 접근 연산( **‘get(int index)‘, ‘set(int index, E element)’ 등) :** 인덱스를 사용한 접근 연산은 리스트의 중간에 있는 요소를 찾기 위해 리스트를 순회해야 하므로 O(n) 시간이 걸립니다.


5️⃣ 코드 예시.

아래 코드는 ‘LinkedList‘ 를 ‘Deque‘ 로 사용하는 예제입니다.

import java.util.Deque;
import java.util.LinkedList;

public class LinkedListDequeExample {

	public static void main(String[] args) {
		// LinkedList로 Deque 생성
		Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();

		// 요소 삽입
		deque.addFirst(1);
		deque.addLast(2);
		deque.offerFirst(0);
		deque.offerLast(3);

		// 요소 조회
		System.out.println("First element: " + deque.getFirst());
		System.out.println("Last element: " + deque.getLast());
		System.out.println("Peek first element: " + deque.peekFirst());
		System.out.println("Peek last element: " + deque.peekLast());

		// 요소 식제
		System.out.println("Removed first element: " + deque.removeFirst());
		System.out.println("Removed last element: " + deque.removeLast());
		System.out.println("Poll first element: " + deque.pollFirst());
		System.out.println("Poll last element: " + deque.pollLast());

		// 덱의 크기와 비어 있는지 여부 확인
		System.out.println("Deque size: " + deque.size());
		System.out.println("Is deque empty? " + deque.isEmpty());

		// 스택 연산.
		deque.push(4);
		System.out.println("Pushed element: " + deque.peekFirst());
		System.out.println("Popped element: " + deque.pop());
	}
}
/*
=== 출력 ===

First element: 0
Last element: 3
Peek first element: 0
Peek last element: 3
Removed first element: 0
Removed last element: 3
Poll first element: 1
Poll last element: 2
Deque size: 0
Is deque empty? true
Pushed element: 4
Popped element: 4
*/


🙋‍♂️ 설명.


  
    
      베열 초기화 : ‘DEFAULT_CAPACITY‘ 크기의 배열을 초기화하고, ‘head‘, ‘tail‘, ‘size‘ 변수를 초기화 합니다.
    
  
  
    
      삽입 연산( **‘addFirst‘, ‘addLast‘) :** 요소를 덱의 첫 번째 또는 마지막에 추가합니다.
    
  
  
    
      삭제 연산( **‘removeFirst‘, ‘removeLast‘) :** 첫 번째 요소와 마지막 요소를 각각 제거합니다.
    
  
  
    
      조회 연산( **‘getFirst‘, ‘getLast‘, ‘peekFirst‘, ‘peekLast‘) :** 첫 번째 요소와 마지막 요소를 반환합니다.
    
  
  
    
      기타 메서드 : ‘size‘ 와 ‘isEmpty‘ 메서드는 덱의 크기와 비어 있는지 여부를 반환합니다.
    
  
  
    
      스택 연산( **‘push‘, ‘pop‘) :** 스택의 맨 위에 요소를 추가하고, 스택의 맨 위에 있는 요소를 제거하고 반환합니다.
    
  



  위 예시 코드에서는 ‘LinkedList‘ 를 ‘Deque‘ 로 사용하여 다양한 연산을 수행하는 방법을 보여줍니다.
‘LinkedList‘ 는 이중 연결 리스트를 사용하기 때문에 양쪽 끝에서의 삽입과 삭제가 빠르고 효율적입니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-06-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-06-TIL.html"><h1 class="title_post">📝 [TIL] 240606 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-06-TIL.html" class="txt_post">
                            
  ArrayDeque
  코딩테스트 입문 - 두 수의 나눗셈
  코딩테스트 입문 - 숫자 비교하기
  코딩테스트 입문 - 분수의 덧셈
  코딩테스트 입문 - 배열 두 배 만들기


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-06-ArrayDeque.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-06-ArrayDeque.html"><h1 class="title_post">📦[DS,Algorithm] ArrayDeque</h1></a>
                        <a href="/Backend/AnD/2024-06-06-ArrayDeque.html" class="txt_post">
                            1️⃣ ArrayDeque.

Java에서 ‘ArrayDeque‘ 는 ‘java.util‘ 패키지에 속하는 클래스이며, 큐(Queue)와 덱(Deque)의 기능을 모두 지원하는 배열 기반의 자료 구조입니다.

‘ArrayDeque‘ 는 ‘Deque‘ 인터페이스를 구현하며, 그기가 가변적인 배열을 사용하여 요소를 저장합니다.

2️⃣ 주요 특징.


  
    이중 끝 큐 : 양쪽 끝에서 요소를 추가하고 제거할 수 있습니다.
  
  
    크기 조정 : 필요에 따라 내부 배열의 크기를 자동으로 조정합니다.
  
  
    스택 및 큐로 사용 가능 : ‘ArrayDeque‘ 는 스택(LIFO, Last In First Out)과 큐(FIFO, First In First Out) 모두로 사용할 수 있습니다.
  
  
    비동기적 : ‘ArrayDeque‘ 는 비동기적으로 동작하므로 동기화된 환경에서 안전하지 않습니다.
  


3️⃣ 주요 메서드.

삽입 연산.


  
    ‘addFirst(E e)’ : 지정된 요소를 덱의 앞쪽에 추가합니다.
  
  
    ‘addLast(E e)’ : 지정된 요소를 덱의 뒤쪽에 추가합니다.
  
  
    ‘offerFirst(E e)’ : 지정된 요소를 덱의 앞쪽에 추가합니다.
  
  
    ‘offerLast(E e)’ : 지정된 요소를 덱의 뒤쪽에 추가합니다.
  


삭제 연산.


  
    ‘removeFirst()’ : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘removeLast()’ : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘pollFirst()’ : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘pollLast()’ : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.
  


조회 연산.


  
    ‘getFirst()’ : 덱의 앞쪽에 있는 요소를 반환합니다.
  
  
    ‘getLast()’ : 덱의 뒤쪽에 있는 요소를 반환합니다.
  
  
    ‘peekFirst()’ : 덱의 앞쪽에 있는 요소를 반환합니다.
  
  
    ‘peekLast()’ : 덱의 뒤쪽에 있는 요소를 반환합니다.
  


스택 연산.


  
    ‘push(E e)’ : 스택의 맨 위에 요소를 추가합니다.(LIFO, Last In First Out)
  
  
    ‘pop(E e)’ : 스택의 맨 위에 있는 요소를 제거하고 반환합니다.(LIFO, Last In First Out)
  


4️⃣ 시간 복잡도.


  
    삽입과 삭제 연산 : ‘addFirst‘, ‘addLast‘, ‘removeFirst‘, ‘removeLast‘, ‘offerFirst‘, ‘offerLast‘, ‘pollFirst‘, ‘pollLast‘, 등의 연산은 평균적으로 O(1)입니다.
  
  
    조회 연산 : ‘getFirst‘, ‘getLast‘, ‘peekFirst‘, ‘peekLast‘ 등의 연산은 O(1)입니다.
  
  
    크기 조정 : 베열의 크기가 가득 찼을 때 크기를 두 배로 늘리거나 줄이는 작업은 O(n) 시간이 걸리지만, 이는 드물게 발생하므로 평균적으로는 O(1)로 간주합니다. (amortized O(1)).
  


5️⃣ 예제 코드

아래의 코드는 ‘ArrayDeque‘ 를 사용한 예제 코드입니다.

import java.util.ArrayDeque;
import java.util.Deque;

public class ArrayDequeExample {

	public static void main(String[] args) {
		// ArrayDeque로 Deque 생성
		Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();

		// 요소 삽입
		System.out.println("=== 요소 삽입 ===");
		deque.addFirst(1);
		deque.addLast(2);
		deque.offerFirst(0);
		deque.offerLast(3);
		System.out.println(deque);
		System.out.println();

		// 요소 조회
		System.out.println("=== 요소 조회 ===");
		System.out.println("First element: " + deque.getFirst());
		System.out.println("Last element: " + deque.getLast());
		System.out.println("Peek first element: " + deque.peekFirst());
		System.out.println("Peek last element: " + deque.peekLast());
		System.out.println();

		// 요소 삭제
		System.out.println("=== 요소 삭제 ===");
		System.out.println("Removed first element: " + deque.removeFirst());
		System.out.println("Removed last element: " + deque.removeLast());
		System.out.println("Poll first element: " + deque.pollFirst());
		System.out.println("Poll last element: " + deque.pollLast());
		System.out.println();

		// 덱의 크기와 비어 있는지 여부 확인
		System.out.println("=== 덱의 크기와 비어 있는지 여부 확인 ===");
		System.out.println("Deque size: " + deque.size());
		System.out.println("Is deque empty? " + deque.isEmpty());
		System.out.println();
		
		// 스택 연산
		System.out.println("=== 스택 연산 ===");
		deque.push(4);
		System.out.println("Pushed element: " + deque.peekFirst());
		System.out.println("Popped element: " + deque.pop());
	}
}

/*
=== 출력 ===
=== 요소 삽입 ===
[0, 1, 2, 3]

=== 요소 조회 ===
First element: 0
Last element: 3
Peek first element: 0
Peek last element: 3

=== 요소 삭제 ===
Removed first element: 0
Removed last element: 3
Poll first element: 1
Poll last element: 2

=== 덱의 크기와 비어 있는지 여부 확인 ===
Deque size: 0
Is deque empty? true

=== 스택 연산 ===
Pushed element: 4
Popped element: 4
*/


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-05-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-05-TIL.html"><h1 class="title_post">📝 [TIL] 240605 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-05-TIL.html" class="txt_post">
                            
  Deque(덱, 데크))
  코딩테스트 입문 - 두 수의 합
  코딩테스트 입문 - 두 수의 차
  코딩테스트 입문 - 두 수의 곱
  코딩테스트 입문 - 몫 구하기


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-05-Deque.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-05-Deque.html"><h1 class="title_post">📦[DS,Algorithm] Deque(데크, 덱)</h1></a>
                        <a href="/Backend/AnD/2024-06-05-Deque.html" class="txt_post">
                            1️⃣ Deque(덱, Double Ended Queue)

Deque(덱, Double Ended Queue)는 양쪽 끝에서 삽입과 삭제를 할 수 있는 자료 구조입니다.

Java에서는 java.util 패키지에서 제공하는 Deque 인터페이스와 이를 구현한 클래스인 ArrayDeque 와 LinkedList 를 통해 사용할 수 있습니다.

Deque 는 큐(Queue)와 스택(Stack)의 기능을 모두 포함하고 있습니다.

1️⃣ 데크 기본 구조


  
    데크의 기본 구조는 양방향에서 삽입 삭제 가능한 구조
  
  
    일부 기능을 제한하여 용도에 맞게 변형 가능
  





  add나 remove 계열은 예외를 발생시킵니다.
    
      때문에 예외 처리가 가능합니다.
    
  
  offer이나 poll 계열은 null이나 false를 반환합니다.
    
      때문에 return값 (반환값)을 받아서 처리할 수 있습니다.
    
  


2️⃣ Deque의 주요 메서드.

1️⃣ 삽입 연산.


  addFirst(E e) : 지정된 요소를 덱의 앞쪽에 추가합니다.
  addLast(E e) : 지정된 요소를 덱의 뒤쪽에 추가합니다.
  offerFirst(E e) : 지정된 요소를 덱의 앞쪽에 추가합니다.
  offerLast(E e) : 지정된 요소를 덱의 뒤쪽에 추가합니다.


2️⃣ 삭제 연산.


  removeFirst() : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  removeLast() : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.
  pollFirst() : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  pollLast() : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.


3️⃣ 조회 연산.


  getFirst() : 덱의 앞쪽에 있는 요소를 반환합니다.
  getLast() : 덱의 뒤쪽에 있는 요소를 반환합니다.
  peekFirst() : 덱의 앞쪽에 있는 요소를 반환합니다.
  peekLast() : 덱의 뒤쪽에 있는 요소를 반환합니다.


4️⃣ 기타 연산.


  size() : 덱에 있는 요소의 수를 반환합니다.
  isEmpty() : 덱이 비어 있는지 여부를 확인합니다.


3️⃣ 시간 복잡도.

Deque 인터페이스의 시간 복잡도는 이를 구현한 클래스에 따라 달라집니다.

Java에서는 주로 ArrayDeque 와 LinkedList 를 사용하여 Deque 를 구현합니다.

1️⃣ ArrayDeque


  삽입과 삭제 연산 (앞과 뒤 모두): 평균적으로 O(1)
  조회 연산 (앞과 뒤 모두): O(1)
  ArrayDeque 는 배열을 기반으로 구현되기 때문에, 배열이 꽉 차면 자동으로 크기를 늘리지만, 이 과정은 amortized O(1)로 간주됩니다.


2️⃣ LinkedList


  삽입과 삭제 연산 (앞과 뒤 모두): O(1)
  조회 연산 (앞과 뒤 모두): O(1)
  LinkedList 는 이중 연결 리스트로 구현되어 있어 각 노드가 이전과 다음 노드에 대한 참조를 가지고 있습니다.


LinkedList는 각 노드가 이전 노드와 다음 노드의 참조를 가지고 있어 삽입과 삭제가 O(1)의 시간 복잡도를 가집니다.
하지만 탐색에는 O(n)의 시간이 소요됩니다.

ArrayDeque는 배열을 사용하여 내부적으로 구현되기 때문에 삽입과 삭제 시에도 평균적으로 O(1)의 시간 복잡도를 가지며,
특히 큐의 끝에서의 연산이 빠릅니다.

다만, 내부적으로 배열이 가득 차면 크기를 조정해야 하므로 최악의 경우 O(n)의 시간 복잡도가 발생할 수 있습니다.


  Deque 는 다양한 상황에서 유연하게 사용될 수 있는 유용한 자료구조입니다.
특히 양쪽 끝에서의 빠른 삽입과 삭제가 필요한 경우 유용합니다.


3️⃣ 직접 Deque 인터페이스 구현.

간단한 배열을 사용하여 Deque 를 구현해보겠습니다.

import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class SimpleArrayDeque&lt;E&gt; {
  private static final int DEFALT_CAPACITY = 10;
  private E[] elements;
  private int head;
  private int tail;
  private int size;

  public SimpleArrayDeque() {
    elements = (E[]) new Object[DEFALT_CAPACITY];
    head = 0;
    tail = 0;
    size = 0;
  }

  public void addFirst(E e) {
    if (size == elements.length) {
      resize();
    }
    head = (head - 1 + elements.length) % elements.length;
    elements[head] = e;
    size++;
  }

  public void addLast(E e) {
    if (size == elements.length) {
      resize();
    }
    elements[tail] = e;
    tail = (tail + 1) % elements.length;
    size++;
  }

  public E removeFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    E element = elements[head];
    elements[head] = null; // for garbege collection
    head = (head + 1);
    size--;
    return element;
  }

  public E removeLast() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    tail = (tail - 1 + elements.length) % elements.length;
    E element = elements[tail];
    elements[tail] = null; // for garbage collection
    size--;
    return element;
  }

  public E getFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[head];
  }

  public E getLast() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[(tail - 1 + elements.length) % elements.length];
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size == 0;
  }

  private void resize() {
    int newCapacity = elements.length * 2;
    E[] newElements = (E[]) new Object[newCapacity];
    for (int i = 0; i &lt; size; i++) {
      newElements[i] = elements[(head + i) % elements.length];
    }
    elements = newElements;
    head = 0;
    tail = size;
  }

  public ArrayList&lt;E&gt; toArrayList() {
    return IntStream.range(0, size)
                    .mapToObj(i -&gt; elements[(head + i) % elements.length])
                    .collect(Collectors.toCollection(ArrayList::new));
  }
}

// Main
import java.util.ArrayList;

public class Main {

  public static void main(String[] args) {
    SimpleArrayDeque&lt;Integer&gt; deque = new SimpleArrayDeque&lt;&gt;();
    deque.addFirst(1);
    deque.addLast(2);
    deque.addFirst(0);
    deque.addLast(3);

    ArrayList&lt;Integer&gt; dequeList = deque.toArrayList();
    System.out.println("=== dequeList === ");
    System.out.println(dequeList);


    System.out.println("First element: " + deque.getFirst());
    System.out.println("Last element: " + deque.getLast());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Removed first element: " + deque.removeFirst());
    System.out.println("Remove last element: " + deque.removeLast());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Deque size: " + deque.size());
    System.out.println("Is deque empty? " + deque.isEmpty());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);
  }
}

/*
=== 출력 ===
=== dequeList === 
[0, 1, 2, 3]
First element: 0
Last element: 3
=== dequeList === 
[0, 1, 2, 3]
Removed first element: 0
Remove last element: 3
=== dequeList === 
[1, 2]
Deque size: 2
Is deque empty? false
=== dequeList === 
[1, 2]
*/


4️⃣ 입력 제한 Deque(Input-Restricted Deque).

입력 제한 Deque(Input-Restricted Deque)은 덱의 한쪽 끝에서만 삽입이 가능하고, 양쪽 끝에서 삭제가 가능한 자료구조입니다.

import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class InputRestrictedDeque&lt;E&gt; {
  private static final int DEFAULT_CAPACITY = 10;
  private E[] elements;
  private int head;
  private int tail;
  private int size;

  @SuppressWarnings("unchecked")
  public InputRestrictedDeque() {
    elements = (E[]) new Object[DEFAULT_CAPACITY];
    head = 0;
    tail = 0;
    size = 0;
  }

  public void addLast(E e) {
    if (size == elements.length) {
      resize();
    }
    elements[tail] = e;
    tail = (tail + 1) % elements.length;
    size++;
  }

  public E removeFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    E element = elements[head];
    elements[head] = null; // for garbage collection
    head = (head + 1) % elements.length;
    size--;
    return element;
  }

  public E removeLast() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    tail = (tail - 1 + elements.length) % elements.length;
    E element = elements[tail];
    elements[tail] = null; // for gatbage collection
    size--;
    return element;
  }

  public E getFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[head];
  }

  public E getLast() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[(tail - 1 + elements.length) % elements.length];
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size == 0;
  }

  private void resize() {
    int newCapacity = elements.length * 2;
    @SuppressWarnings("unchecked")
    E[] newElements = (E[]) new Object[newCapacity];
    for (int i = 0; i &lt; size; i++) {
      newElements[i] = elements[(head + i) % elements.length];
    }
    elements = newElements;
    head = 0;
    tail = size;
  }

  public ArrayList&lt;E&gt; toArrayList() {
    return IntStream.range(0, size)
                    .mapToObj(i -&gt; elements[(head + i) % elements.length])
                    .collect(Collectors.toCollection(ArrayList::new));
  }
}

// Main
import java.util.ArrayList;

public class Main {

  public static void main(String[] args) {
    InputRestrictedDeque&lt;Integer&gt; deque = new InputRestrictedDeque&lt;&gt;();
    deque.addLast(1);
    deque.addLast(2);
    deque.addLast(3);

    ArrayList&lt;Integer&gt; dequeList = deque.toArrayList();
    System.out.println("=== dequeList ===");
    System.out.println(dequeList);

    System.out.println("First element: " + deque.getFirst());
    System.out.println("Last element: " + deque.getLast());
    System.out.println("=== dequeList ===");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Remove first element: " + deque.removeFirst());
    System.out.println("Remove last elment: " + deque.removeLast());
    System.out.println("=== dequeList ===");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Deque size: " + deque.size());
    System.out.println("Is deque empty? " + deque.isEmpty());
  }
}
/*
=== 출력 ===
=== dequeList ===
[1, 2, 3]
First element: 1
Last element: 3
=== dequeList ===
[1, 2, 3]
Remove first element: 1
Remove last elment: 3
=== dequeList ===
[2]
Deque size: 1
Is deque empty? false
*/


1️⃣ 코드 설명.


  
    배열 초기화 : DEFAULT_CAPACITY 크기의 배열을 초기화하고, head, tail, size 변수를 초기화합니다.
  
  
    삽입 연산(addLast) : 요소를 덱의 마지막 에 추가합니다. 배열이 가득 차면 크기를 두 배로 늘립니다.
  
  
    삭제 연산(removeFirst, removeLaste) : 첫 번째 요소와 마지막 요소를 각각 제거합니다.
  
  
    조회 연산(getFirst, getLast) : 첫 번째 요소와 마지막 요소를 반환합니다.
  
  
    기타 메서드 : size 와 isEmpty 메서드는 덱의 크기와 덱이 비어 있는지 여부를 반환합니다.
  
  
    배열 크기 조정 (resize) : 배열이 가득 찰 때 호출되며, 배열의 크기를 두 배로 늘리고 요소를 새 배열로 복사합니다.
  



  이 예제에서는 요소를 덱의 끝에만 삽입할 수 있는 입력 제한 덱을 구현했습니다.
필요에 따라 이 구현을 확장하거나 수정하여 요구사항에 맞게 사용할 수 있습니다.


5️⃣ 출력 제한 Deque(Output-Restricted Deque).

출력 제한 Deque(Output-Restricted Deque)은 양쪽 끝에서 삽입이 가능하지만, 한쪽 끝에서만 삭제가 가능한 자료 구조입니다.

이 구조는 양쪽 끝에서 요소를 추가할 수 있지만, 삭제는 한쪽 끝에서만 할 수 있습니다.

import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class OutputRestrictedDeque&lt;E&gt; {
  private static final int DEFAULT_CAPACITY = 10;
  private E[] elements;
  private int head;
  private int tail;
  private int size;

  @SuppressWarnings("unchecked")
  public OutputRestrictedDeque() {
    elements = (E[]) new Object[DEFAULT_CAPACITY];
    head = 0;
    tail = 0;
    size = 0;
  }

  public void addFirst(E e) {
    if (size == elements.length) {
      resize();
    }
    head = (head - 1 + elements.length) % elements.length;
    elements[head] = e;
    size++;
  }

  public void addLast(E e) {
    if (size == elements.length) {
      resize();
    }
    elements[tail] = e;
    tail = (tail + 1) % elements.length;
    size++;
  }

  public E removeFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    E element = elements[head];;
    elements[head] = null; // for garbage collection
    head = (head + 1) % elements.length;
    size--;
    return element;
  }

  public E getFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[head];
  }

  public E getLast() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[(tail - 1 + elements.length) % elements.length];
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size == 0;
  }

  private void resize() {
    int newCapacity = elements.length * 2;
    @SuppressWarnings("unchecked")
    E[] newElements = (E[]) new Object[newCapacity];
    for (int i = 0; i &lt; size; i++) {
      newElements[i] = elements[(head + 1) % elements.length];
    }
    elements = newElements;
    head = 0;
    tail = size;
  }

  public ArrayList&lt;E&gt; toArrayList() {
    return IntStream.range(0, size)
                    .mapToObj(i -&gt; elements[(head + i) % elements.length])
                    .collect(Collectors.toCollection(ArrayList::new));
  }
}

// Main
import java.util.ArrayList;

public class Main {

  public static void main(String[] args) {
    OutputRestrictedDeque&lt;Integer&gt; deque = new OutputRestrictedDeque&lt;&gt;();
    deque.addFirst(1);
    deque.addLast(2);
    deque.addFirst(0);
    deque.addLast(3);

    ArrayList&lt;Integer&gt; dequeList = deque.toArrayList();
    System.out.println("=== dequeList === ");
    System.out.println(dequeList);

    System.out.println("First element: " + deque.getFirst());
    System.out.println("Last element: " + deque.getLast());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Remove first element: " + deque.removeFirst());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Deque size: " + deque.size());
    System.out.println("Is deque empty? " + deque.isEmpty());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);
  }
}

/*
=== 출력 ===
=== dequeList ===
[0, 1, 2, 3]
First element: 0
Last element: 3
=== dequeList ===
[0, 1, 2, 3]
Remove first element: 0
=== dequeList ===
[1, 2, 3]
Deque size: 3
Is deque empty? false
=== dequeList ===
[1, 2, 3]
*/


1️⃣ 코드 설명.


  
    배열 초기화 : DEFAULT_CAPACITY 크기의 배열을 초기화하고, head, tail, size 변수를 초기화 합니다.
  
  
    삽입 연산(addFirst, addLast) : 요소를 덱의 첫 번째 또는 마지막에 추가합니다. 배열이 가득 차면 크기를 두 배로 늘립니다.
  
  
    삭제 연산(removeFirst) : 첫 번째 요소를 제거합니다. 출력 제한 덱에서는 첫 번째 요소만 제거할 수 있습니다.
  
  
    조회 연산(getFirst, getLast) : 첫 번째 요소와 마지막 요소를 반환합니다.
  
  
    기타 메서드 : size 와 isEmpty 메서드는 덱의 크기와 덱이 비어 있는지 여부를 반환합니다.
  
  
    배열 크기 조정(resize) : 배열이 가득 찰 때 호출되며, 배열의 크기를 두 배로 늘리고 요소를 새 배열로 복사합니다.
  



  이 예제에서는 요소를 덱의 양쪽 끝에서 삽입할 수 있고, 첫 번째 요소만 제거할 수 있는 출력 제한 덱을 구현했습니다.
필요에 따라 이 구현을 확장하거나 수정하여 요구사항에 맞게 사용할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-03-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-03-TIL.html"><h1 class="title_post">📝 [TIL] 240603 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-03-TIL.html" class="txt_post">
                            
  IntStream


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-03-IntStream.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-03-IntStream.html"><h1 class="title_post">☕️[Java] IntStream</h1></a>
                        <a href="/Backend/Java/2024-06-03-IntStream.html" class="txt_post">
                            1️⃣ Java Docs - IntStream.


  Module : java.base
  Package : java.util.stream


Interface IntStream

All SuperInterfaces : AutoCloseble, BaseStream&lt;Integer, IntStream&gt;


  AutoCloseble
  BaseStream
  Integer
  IntStream




public interface IntStream extends BaseStream&lt;Integer, IntStream&gt;



  순차 및 병렬 집계 연산을 지원하는 기본 int 값 요소의 시퀀스입니다. 이것은 Stream의 int 기본형 특수화입니다.
    
      IntStream 이 Stream 의 한 형태로, int 값의 시퀀스를 처리하며 순차 및 병렬 연산을 지원한다는 의미입니다.
    
  
  다음 예제는 Stream과 IntStream을 사용하여 빨간색 위젯의 무게 합계를 계산하는 집계 연산을 보여줍니다.


int sum = widgets.stream()
                 .filter(w -&gt; w.getColor() == RED)
                 .mapToInt(w -&gt; w.getWeight())
                 .sum();



  streams(스트림), stream operations(스트림 연산), stream pipelines(스트림 파이프라인), and parallelism(및 병렬 처리)에 대한 추가적인 명세는 Stream 클래스 문서와 java.util.stream 패키지 문서를 참조하십시오.


Since : 1.8

Nested Class Summary

Nested Classes

  Modifier and Type: static interface
  Interface: IntStream.Builder
  Description: IntStream용 변경 가능한 빌더입니다.


2️⃣ IntStream.

IntStream 은 Java의 스트림 API(Stream API)의 일부로, 기본형 int 에 특화된 스트림을 나타냅니다.

IntStream 은 Java 8에서 도입된 스트림 API의 일부로, 컬렉션(리스트, 배열 등)과 같은 데이터 소스를 함수형 프로그래밍 스타일로 처리할 수 있게 해줍니다.

IntStream 은 Stream&lt;Integer&gt; 와는 달리 오토박싱과 언박싱의 오버헤드가 없는 것이 특징입니다.

🙋‍♂️ IntStream의 주요 기능

1. 생성:


  IntStream 을 생성하는 방법은 여러가지가 있습니다.
    
      예를 들어, 배열, 범위, 임의의 수 등을 사용하여 생성할 수 있습니다.
    
  


2. 연산:


  스트림 연산은 두 가지로 나뉩니다.
    
      중간 연산과 최종 연산.
        
          중간 연산은 또 다른 스트림을 반환하고, 지연(lazy) 평가됩니다.
          최종 연산은 스트림을 소비하여 결과를 반환합니다.
        
      
    
  


🙋‍♂️ IntStream 생성 방법.

1. of() 메서드:


  고정된 개수의 int 값을 스트림으로 생성합니다.


IntStream stream = IntStream.of(1, 2, 3, 4, 5);


2. range() 및 rangeClosed() 메서드:


  범위를 지정하여 스트림을 생성합니다. range 는 시작 값 포함, 끝 값 미포함, rangeClosed 는 시작 값과 끝 값을 모두 포함합니다.


IntStream stream = IntStream.range(0, 5); // 0, 1, 2, 3, 4, 5
IntStream closedStream = IntStream.rangeClosed(0, 5); // 0, 1, 2, 3, 4, 5


3. generate() 메서드:


  람다 표현식을 사용하여 무한 스트림을 생성합니다.
    
      🚨 주의: 무한 스트림은 반드시 제한을 걸아야 합니다.
    
  


IntStream stream = IntStream.generate(() -&gt; 1).limit(5); // 1, 1, 1, 1, 1


4. iterate() 메서드:


  초기값과 반복 함수로 스트림을 생성합니다.


IntStream stream = IntStream.iterate(0, n -&gt; n + 2).limit(5); // 0, 2, 4, 6, 8


5. builder() 메서드:


  IntStream.Builder 를 사용하여 스트림을 생성합니다.


IntStream.Builder builder = IntStream.builder()l
builder.add(1).add(2).add(3).add(4).add(5);
IntStream stream = builder.builder();


6. 배열에서 생성:


  배열을 스트림으로 변환합니다.


int[] array = {1, 2, 3, 4, 5};
IntStream stream = Arrays.stream(array);


🙋‍♂️ IntStream의 주요 메서드.

1. 중간 연산:


  map() : 각 요소에 함수 적용.
  filter() : 조건에 맞는 요소만 통과
  distinct() : 중복 요소 제거
  sorted() : 정렬
  limit() : 스트림 크기 제한
  skip() : 처음 n개 요소 건너뛰기


2. 최종 연산:


  forEach() : 각 요소에 대해 액션 수행
  toArray() : 배열로 변환
  reduce() : 모든 요소를 누적하여 하나의 값으로
  collect() : 컬렉션으로 변환
  sum() : 합계 연산
  average() : 평균 계산
  min(), max() : 최소, 최대값 찾기
  count() : 요소 개수 반환


💻 예제 코드

예제 1: 0에서 5까지 거꾸로 출력.

import java.util.stream.IntStream;

public class Reverse {

	public static void main(String[] args) {
		IntStream.rangeClosed(0, 5)
		         .map(i -&gt; 5 - i)
		         .forEach(System.out::println);
	}
}
/*
=== 출력 ===
5
4
3
2
1
0
*/


예제 2: 배열의 합계 계산

import java.util.stream.IntStream;

public class ArraySum {

	public static void main(String[] args) {
		int[] array = {1, 2, 3, 4, 5};
		int sum = IntStream.of(array).sum();
		System.out.println("sum = " + sum); // sum = 15
	}
}


예제 3: 짝수 필터링

import java.util.stream.IntStream;

public class FilterEvenNumber {

	public static void main(String[] args) {
		IntStream.rangeClosed(1, 10)
		         .filter(n -&gt; n % 2 == 0)
		         .forEach(System.out::println);
	}
}
/*
=== 출력 ===
2
4
6
8
10
*/


📝 요약

IntStream 은 Java의 스트림 API의 일부분으로, 기본형 int에 특화된 스트림입니다.

이를 통해 컬렉션이나 배열을 함수형 프로그래밍 스타일로 처리할 수 있습니다.

IntStream 은 다양한 생성 방법과 중간 및 최종 연산을 제공하여 효율적이고 직관적인 데이터 처리를 가능하게 합니다.

📚 참고 문헌.

  Java Docs - IntStream


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-02-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-02-TIL.html"><h1 class="title_post">📝 [TIL] 240602 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-02-TIL.html" class="txt_post">
                            
  자바의 배열
  JAVA DOCS 보는 법


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-06-02-HowToReadJavaDocs.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-06-02-HowToReadJavaDocs.html"><h1 class="title_post">📝[blog post] Java Docs 보는 방법.</h1></a>
                        <a href="/Backend/Post/2024-06-02-HowToReadJavaDocs.html" class="txt_post">
                            📝 Java Docs를 읽는 능력이 필요한 이유. :)

저는 Documentation이 그 어떤 유명 테크 블로거의 글 보다 중요하고 심도있게 읽어야 한다는 개인적인 의견이 있습니다.

그 이유는 Java를 개발한 개발자분들이 직접 만든 설명서나 다름 없기 때문입니다.

우리가 레고를 생각해 봅시다.

내가 좋아하는 레고를 사서 집에서 조립할 때 무엇을 보나요? 🤔

맞습니다!

레고 패키지 안에 들어있는 “설명서”를 기반으로 레고를 조립합니다.

레고를 디자인하고 만드신 분이 직접 “이렇게 순서대로 만들면 당신이 원하는 멋진 레고 완성품을 얻을 수 있습니다!” 라는 것을 직.간접적으로 보여주는 아주 자세한 설명이 들어있죠 📝

설명서는 직접 디자인하고 설계한 사람의 철학과 그들이 왜 그렇게 만들었는지 그리고 어떻게 쓰여야하는지 정확, 명료하게 명시되어 있습니다.

또한 다른 구성품과 맞춰볼 수 있는 것도 제안하거나 보여주기도 합니다.

그래서 Documentation을 보고 제대로 활용할 줄 아는 것이 개발자에게는 중요한 능력 중 하나가 아닐까 하는 생각을 합니다 🙋‍♂️

1️⃣ Java Documentation 보기.

1. 온라인 문서.


  Java SE Documentation은 Oracle 공식 사이트에서 제공됩니다.
    
      Java 버전에 따라 다른 문서가 제공되니, 사용하는 Java 버전에 맞는 문서를 선택해야 합니다.
    
  


2. IDE 내장 문서.


  많은 통합 개발 환경(IDE)에는 JavaDoc을 쉽게 볼 수 있는 기능이 내장되어 있습니다. InteillJ IDEA, Eclipes, NetBeans 등에서 코드 작성 시 JavaDocs를 볼 수 있습니다.
    
      예를 들어, IntelliJ IDEA에서 클래스나 메소드 이름 위에 커서를 올리면 해당 클래스나 메소드의 JavaDoc이 팝업으로 표시됩니다.
    
  


3. 로컬 문서.


  Java JDK를 설치할 때, JavaDoc을 로컬에 다운로드할 수 있습니다. 이를 통해 인터넷 연결 없이도 문서를 참조할 수 있습니다.
  JDK 설치 경로 아래의 docs 폴더에 HTML 형식의 문서가 저장되어 있습니다.


2️⃣ Java Documentation 활용 방법

Java Documentation을 효과적으로 활용하는 방법을 알아봅시다.🤩

1. 클래스 및 메소드 탐색.


  API 문서에서 패키지, 클래스, 메소드, 필드 등의 세부 정보를 탐색할 수 있습니다.
    
      예를 들어, java.util 패키지에 어떤 클래스가 포함되어 있는지, ArrayList 클래스에 어떤 메소드가 있는지 등을 확인할 수 있습니다.
    
  


2. 사용 예제 찾기.


  각 클래스와 메소드에는 사용 예제가 포함되어 있을 수 있습니다. 이러한 예제는 해당 API를 올바르게 사용하는 방법을 이해하는 데 도움이 됩니다.


3. 메소드 시그니처 및 설명.


  메소드의 매개변수, 반환값, 예외 등을 설명하는 시그니처와 설명을 통해 메소드의 사용법을 정확히 알 수 있습니다.
    
      예를 들어, String 클래스의 substring 메소드의 시그니처와 설명을 보면, 매개변수로 전달해야 할 값과 반환되는 값에 대한 정보를 얻을 수 있습니다.
    
  


4. 상속 구조 및 인터페이스.


  클래스가 구현하는 인터페이스와 상속받는 클래스에 대한 정보를 확인할 수 있습니다. 이를 통해 클래스의 기능을 확장하거나 인터페이스를 구현하는 방법을 이해할 수 있습니다.


3️⃣ 예제

다음은 Java Documentation을 활용하는 몇 가지 예제입니다.

예제 1: ArrayList 클래스의 메소드 사용법 확인 🙋‍♂️


  온라인 문서에서 ArrayList 클래스를 찾습니다.
    
      Java SE Documentation에서 java.util.ArrayList 를 검색합니다.
      ArrayList 클래스의 API 문서를 열어 메소드 목록을 확인합니다.
    
  
  add(E e) 메소드 사용법 확인하기.
    
      add(E e) 메소드는 리스트의 끝에 요소를 추가하는 메소드입니다.
      메소드 설명을 읽고, 예제를 확인하여 사용법을 이해합니다.
    
  


예제 2. String 클래스의 substring 메소드 사용법 확인 🙋‍♂️


  IDE 내장 문서 활용하기.
    
      IntelliJ IDEA나 Eclipse에서 String 클래스의 substring 메소드를 사용하려고 할 때, 메소드 이름 위에 커서를 올리면 JavaDoc이 표시됩니다.
      JavaDoc을 통해 substring(int beingIndex, int endIndex) 메소드의 매개변수와 반환 값에 대한 설명을 읽습니다.
    
  


public class Main {
    public static void main(String[] args) {
        String text = "Hello, World!";
        String subText = text.substring(7, 12); // "World"
        System.out.println(subText);
    }
}


위 예제에서 substring 메소드의 매개변수가 beginIndex 와 endIndex 임을 알 수 있으며, 이는 시작 인덱스부터 종료 인덱스 전까지의 문자열을 반환합니다.

예제 3. 예외 처리 방법 확인 🙋‍♂️


  예외 클래스 문서 확인하기.
    
      java.lang.NullPointerException 클래스의 문서를 확인하여 언제 이 예외가 발생하는지, 그리고 이를 어떻게 처리할 수 있는지에 대한 정보를 얻습니다.
    
  
  예외 처리 예제


public class Main {
    public static void main(String[] args) {
        try {
            String text = null;
            System.out.println(text.length());
        } catch (NullPointerException e) {
            System.out.println("Caught a NullPointerException");
        }
    }
}


이 예제는 NullPointException 이 발생할 때 이를 처리하는 방법을 보여줍니다.

📝 요약.


  Java Documentation은 Java API를 이해하고 사용하는 데 필수적인 자료입니다.
  Java Documentation를 온라인, IDE, 또는 로컬에서 접근할 수 있습니다.
  API 문서를 통해 클래스와 메소드의 세부 정보를 확인하고, 예제를 참고하여 올바르게 사용하는 방법을 배울 수 있습니다.
  상속 구조와 인터페이스 구현 방법을 이해하여 코드의 재사용성과 확장성을 높일 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-02-ArrayOfJava.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-02-ArrayOfJava.html"><h1 class="title_post">📦[DS,Algorithm] Java의 배열.</h1></a>
                        <a href="/Backend/AnD/2024-06-02-ArrayOfJava.html" class="txt_post">
                            1️⃣ Java의 배열.

1️⃣ 배열이란 무엇인가?

배열(Array)은 동일한 타입의 여러 요소를 하나의 변수로 관리할 수 있게 해주는 자료구조입니다.

배열은 연속된 메모리 공간에 할당되며, 각 요소는 인덱스를 통해 접근할 수 있습니다.

2️⃣ 배열의 선언과 초기화.

Java에서 배열은 다음과 같이 선언하고 초기화할 수 있습니다.

int[] array = new int[5]; // 크기가 5인 정수형 배열 선언.
int[] array = {10, 20, 30, 40, 50}; // 초기화와 동시에 배열 선언


3️⃣ 배열의 요소와 접근.

배열의 각 요소는 인덱스를 통해 접근할 수 있으며, 인덱스는 0부터 시작합니다.

int firstElement = array[0]; // element = 10, 첫 번째 요소에 접근
array[1] = 25; // [10, 25, 30, 40, 50], 두 번째 요소에 값 25를 저장


4️⃣ 배열의 시간 복잡도.

배열의 시간 복잡도는 연산의 종류에 따라 다릅니다.

아래는 일반적인 배열 연산과 그 시간 복잡도를 설명한 것입니다.

1. 접근(Access)


  특정 인덱스의 요소에 접근하는 시간 복잡도는 O(1)입니다.
    
      이유 : 배열은 연속된 메모리 공간에 저장되므로 인덱스를 통해 바로 접근할 수 있기 때문입니다.
    
  


// 접근(Access)
int element = array[2]; 
// element = 30,  time complexity = O(1)
// [10, 25, 30, 40, 50]


2. 탐색(Search)


  배열에서 특정 값을 찾는 시간 복잡도는 O(n)입니다.
    
      이유: 최악의 경우 배열의 모든 요소를 검사해야 할 수도 있기 때문입니다.
    
  


boolean found = false;
int target = 30;

for (int i = 0; i &lt; array.length; i++) {
    if (array[i] == target) { // i = 2, array[i] = 30
        found = true;
        break;
    }
}
// [10, 25, 30, 40, 50]


3. 삽입(Insertion)


  배열의 끝에 요소를 추가하는 시간 복잡도는 O(1)입니다.
  배열의 특정 위치에 요소를 삽입하는 시간 복잡도는 O(n)입니다.
    
      이유: 특정 위치에 삽입하기 위해서는 해당 위치 이후의 모든 요소를 한 칸씩 뒤로 밀어야 하기 때문입니다.
    
  


// 삽입(Insertion)

// 배열 삽입시 index가 array.length가 아니고 array.length - 1인 이유는
// array.length는 배열의 크기, 즉 5를 나타내기 때문입니다.
// index는 0부터 시작하기 때문에 배열의 크기가 5인 배열의 끝 index는 4입니다.
// 때문에 array.length - 1을 해줍니다.

array[array.length - 1] = 60; // 배열 끝에 삽입 (O(1)), [10, 25, 30, 40, 60]

// 배열 중간에 삽입하는 메서드
public static void insertion(int[] array, int index, int insertValue) {
  // 배열 중간에 삽입(O(n))
  for (int i = array.length - 1; i &gt; index; i--) {
    array[i] = array[i - 1];
  }
  array[index] = insertValue;
  System.out.println(Arrays.toString(array));
}


4. 삭제(Deletion)


  배열의 끝에서 요소를 제거하는 시간 복잡도는 O(1)입니다.
  배열의 특정 위치의 요소를 제거하는 시간 복잡도는 O(n)입니다.
    
      이유: 특정 위치의 요소를 제거한 후에는 해당 위치 이후의 모든 요소를 한 칸씩 앞으로 당겨야 하기 때문입니다.
    
  


// 삭제(Deletion)
    array[array.length - 1] = 0; // 배열의 끝에서 삭제 ((O(1)), [10, 25, 30, 77, 0]
    System.out.println(Arrays.toString(array));

    // 배열 중간에서 삭제하는 메서드
    int deletionValue = deletion(array, 2);
    System.out.println(deletionValue); // 30

// 배열 중간에 삭제하는 메서드
  public static int deletion(int[] array, int index) {
    // 배열 중간에 삭제(O(n))
    int[] returnValue = new int[array.length];

    for (int i = index, j = 0; i &lt; array.length - 1 ; i++) {
      returnValue[j] = array[i];
      j++;
      array[i] = array[i + 1];

    }
    array[array.length - 1] = 0; // 마지막 요소 초기화.
    int deletionValue = returnValue[0]; // 배열을 메모리에서 지우기
    returnValue = null;
    return deletionValue;
  }


5️⃣ 배열의 장점과 단점.

장점.

  빠른 접근 속도 : 인덱스를 통해 O(1) 시간에 요소를 접근할 수 있습니다.
  메모리 효율 : 연속된 메모리 공간을 사용하므로 메모리 사용이 효율적입니다.


단점.

  고정된 크기 : 배열의 크기는 선언 시에 고정되므로, 실행 중에 크기를 변경할 수 없습니다.
  삽입 및 삭제의 비효율성 : 배열 중간에 요소를 삽입하거나 삭제할 때 O(n)의 시간이 소요됩니다.
  연속된 메모리 할당 필요 : 큰 배열을 사용할 떄는 연속된 메모리 공간이 필요하여 메모리 할당에 제한이 있을 수 있습니다.



  배열은 이러한 특성들로 인해 빠른 접근이 필요한 상황에서는 매우 유용하지만, 삽입 및 삭제가 빈번히 일어나는 경우에는 비효율적일 수 있습니다.
따라서 상황에 맞게 적절한 자료구조를 선택하는 것이 중요합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-01-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-01-TIL.html"><h1 class="title_post">📝 [TIL] 240601 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-01-TIL.html" class="txt_post">
                            
  배열의 특정 인덱스의 요소를 삭제하는 방법.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-01-RemoveSpecificIndexFromArray.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-01-RemoveSpecificIndexFromArray.html"><h1 class="title_post">📦[DS,Algorithm] 배열에서 특정 인덱스의 요소를 삭제하기.</h1></a>
                        <a href="/Backend/AnD/2024-06-01-RemoveSpecificIndexFromArray.html" class="txt_post">
                            1️⃣ 배열에서 특정 인덱스의 요소를 삭제하기.

Java에서 배열의 특정 인덱스의 요소를 삭제하는 방법은 배열의 구조 특성상 직접적으로 제공되지 않습니다.

때문에 일반적으로 요소를 삭제하기 위해 다음의 방법을 사용합니다.

2️⃣ 배열에서 요소를 삭제하는 방법 2가지.

1️⃣ 새로운 배열을 생성하여 요소를 복사하는 방법 :)

● 특정 인덱스의 요소를 건너뛰고 나머지 요소를 새로운 배열에 복사합니다.

방법 1 : 새로운 배열 생성하여 복사.
// 배열의 특정 인덱스의 요소를 삭제하는 방법 - 1
// 방법1. 새로운 배열을 생성하여 요소를 복사하는 방법
// - 특정 인덱스의 요소를 건너뛰고 나머지 요소를 새로운 배열에 복사합니다.
public class Main {

  public static void main(String[] args) {
    int[] array = {10, 20, 30, 40, 50};
    array = removeElement(array, 0);

    for (int value : array) {
      System.out.println(value + " ");
    }

  }

  // 특정 배열을 지우는 메소드
  public static int[] removeElement(int[] array, int index) {
    if (index &lt; 0 || index &gt;= array.length) {
      throw new IndexOutOfBoundsException("Index out of bounds");
    }
    
    // 새로운 배열은 특정 요소를 지우기 때문에 기존 배열의 크기에서 -1 한 크기로 생성합니다.
    int[] newArray = new int[array.length - 1];

    for (int i = 0, j = 0; i &lt; array.length; i++) {

      if (i != index) {
        newArray[j++] = array[i];
      }
    }
    return newArray;
  }
}
/* 
=== 출력 ===
20 
30 
40 
50 
*/


  “방법1의 장.단점”
    
      새 배열 생성 : 메모리 사용량이 증가하지만, 원래 배열을 유지하고 싶은 경우 유용합니다.
    
  


2️⃣ 기존 배열을 이용하여 요소를 덮어쓰는 방법 :)

● 특정 인덱스 이후의 요소들을 앞으로 한 칸씩 이동시켜 덮어씁니다.

방법 2 : 기존 배열을 이용하여 요소 덮어쓰기.
// 배열의 특정 인덱스의 요소를 삭제하는 방법 - 2
// 방법2. 기존 배열을 이용하여 요소를 덮어쓰는 방법.
// - 특정 인덱스 이후의 요소들을 앞으로 한 칸씩 이동시켜 덮어 씁니다.
public class Main {

  public static void main(String[] args) {
    int[] array = {10, 20, 30, 40, 50};
    array = removeElementInPlace(array, 0);

    for (int value : array) {
      System.out.println(value + " ");
    }
  }

  public static int[] removeElementInPlace(int[] array, int index) {
    if (index &lt; 0 || index &gt;= array.length) {
      throw new IndexOutOfBoundsException("Index out of bounds");
    }

    for (int i = index; i &lt; array.length - 1; i++) {
      array[i] = array[i + 1];
    }

    // 배열의 마지막 요소를 0 또는 다른 기본값으로 설정 (선택 사항)
    array[array.length - 1] = 0;

    return array;
  }
}
/*
=== 출력 ===
20 
30 
40 
50 
0 
*/ 


  “방법2의 장.단점”
    
      기존 배열 사용 : 메모리를 절약할 수 있지만, 배열의 마지막 요소는 기본값으로 설정해야 합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-30-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-30-TIL.html"><h1 class="title_post">📝 [TIL] 240530 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-30-TIL.html" class="txt_post">
                            
  다양한 입출력 방법
  큐(Queue)
  큐 구현(LinkedList)
  큐 구현(List)
  큐 구현(Array)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-30</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-30-Queue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-30-Queue.html"><h1 class="title_post">📦[DS,Algorithm] 큐(Queue)</h1></a>
                        <a href="/Backend/AnD/2024-05-30-Queue.html" class="txt_post">
                            1️⃣ 큐(Queue).

큐(Queue)는 선형 자료구조 중 하나로, 데이터가 들어온 순서대로 처리되는 선입선출(FIFO, First In First Out) 구조를 가집니다.

1️⃣ 큐(Queue).

큐(Queue)는 가장 먼저 삽입된 데이터가 가장 먼저 제거됩니다.

2️⃣ 큐(Queue)의 연산.




  Enqueue : 큐의 뒤(rear) 끝에 데이터를 추가하는 연산입니다.





  
    Dequeue : 큐의 앞(front) 끝에서 데이터를 제거하고 반환하는 연산입니다.
  
  
    front 또는 Peek : 큐의 앞 끝에 있는 데이터를 제거하지 않고 반환하는 연산.
  
  
    isEmpty : 큐가 비어 있는지 확인하는 연산.
  
  
    Size : 큐에 저장된 데이터의 개수를 반환하는 연산.
  


3️⃣ 큐(Queue)의 실제 응용 사례.


  프린터 작업 대기열.
  CPU 작업 스케줄링.
  BFS(Breath-First Search, 너비 우선 탐색)



  큐는 배열이나 연결 리스트를 이용하여 구현할 . 수있습니다.


4️⃣ 큐의 시간 복잡도.

큐의 각 연산은 다음과 같은 시간 복잡도를 가집니다.


  Enqueue : O(1)
    
      큐의 뒤 끝에 데이터를 추가하는 연산은 항상 일정한 시간 내에 완료됩니다.
    
  
  Dequeue : O(1)
    
      큐의 앞 끝에서 데이터를 제거하는 연산도 항상 일정한 시간 내에 완료됩니다.
    
  
  Front 또는 Peek : O(1)
    
      큐의 앞 끝에 있는 데이터를 확인하는 연산은 데이터 접근만 필요하기 때문에 일정한 시간 내에 완료됩니다.
    
  
  isEmpty : O(1)
    
      큐가 비어 있는지 확인하는 연산은 큐의 크기만 확인하면 되므로 일정한 시간 내에 완료됩니다.
    
  
  Size : O(1)
    
      큐에 현재 저장된 데이터의 개수를 반환하는 연산도 일정한 시간 내에 완료됩니다.
    
  


5️⃣ 큐의 구현


  배열을 이용한 큐는 고정된 크기를 가지며, 원형 큐(Circular Queue)로 구현하여 배열의 끝에서 시작으로 순환할 수 있도록 합니다.


배열을 이용한 큐 구현.
// ArrayQueue
public class ArrayQueue {
  private int maxSize; // 큐의 최대 크기
  private int front; // 큐의 앞 끝을 가리키는 인덱스
  private int rear; // 큐의 뒤 끝을 가리키는 인덱스
  private int[] queueArray; // 큐를 저장할 배열
  private int nItems; // 큐에 저장된 데이터의 개수

  // 생성자
  public ArrayQueue(int size) {
    maxSize = size;
    queueArray = new int[maxSize];
    front = 0;
    rear = -1;
    nItems = 0;
  }

  // 큐의 값을 Enqueue하는 메소드.
  public void enqueue(int value) {
    if (isFull()) {
      System.out.println("큐가 가득 찼습니다.");
      return;
    }

    if (rear == maxSize - 1) {
      rear = -1; // 원형 큐 처리
    }

    queueArray[++rear] = value;
    nItems++;
  }

  // 큐에서 값을 dequeue하는 메소드.
  public int dequeue() {
    if (isEmpty()) {
      System.out.println("큐가 비어있습니다.");
      return -1; // 에러를 나타내기 위해 -1 반환.
    }
    int temp = queueArray[front++];

    if (front == maxSize) {
      front = 0; // 원형 큐 처리.
    }
    nItems--;
    return temp;
  }

  // 큐의 앞 끝 값을 반환하는 메소드
  public int peekFront() {
    if (isEmpty()) {
      System.out.println("큐가 비어있습니다.");
      return -1; // 에러를 나타내기 위해  -1 반환.
    }
    return queueArray[front];
  }

  // 큐가 비어있는지 확인하는 메소드.
  public boolean isEmpty() {
    return (nItems == 0);
  }

  // 큐가 가득 찼는지 확인하는 메소드.
  public boolean isFull() {
    return (nItems == maxSize);
  }

  // 큐의 크기를 반환하는 메소드.
  public int size() {
    return nItems;
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    ArrayQueue queue = new ArrayQueue(5); // 크기가 5인 큐 생성.

    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    queue.enqueue(4);
    queue.enqueue(5);

    System.out.println("=== 출력 ===");
    System.out.println();
    System.out.println("Queue의 앞 끝 값: " + queue.peekFront());
    System.out.println("Queue의 크기: " + queue.size());

    // while 문의 조건은 queue가 비어있을 경우 false 이므로 순회하지 않습니다.
    // 그러나 queue가 비어있지 않을 경우 true가 되므로 while 블록을 들어가 queue가 비어있을 때까지(!queue.isEmpty()) 동작합니다.
    while (!queue.isEmpty()) {
      System.out.println("Dequeue : " + queue.dequeue());
    }

    System.out.println("Queue의 크기 : " + queue.size());

  }
}

/*
=== 출력 ===

Queue의 앞 끝 값: 1
Queue의 크기: 5
Dequeue : 1
Dequeue : 2
Dequeue : 3
Dequeue : 4
Dequeue : 5
Queue의 크기 : 0
*/


7️⃣ 큐(Queue) 기본 구조.

큐(Queue)는 선형 자료구조 중 하나로, 데이터를 선입선출(FIFO, First In First Out) 방식으로 처리합니다.

👉 1️⃣ 큐의 기본 구성 요소.


  
    Front : 큐의 가장 앞쪽을 가리키는 포인터 입니다. Dequeue 연산이 발생할 때 데이터를 제거하는 위치를 나타냅니다.
  
  
    Rear : 큐의 가장 뒤쪽을 카리키는 포인터 입니다. Enqueue 연산이 발생할 때 데이터를 추가하는 위치를 나타냅니다.
  
  
    Queue Array(또는 List) : 큐의 데이터를 저장하는 자료구조. 배열이나 연결 리스트를 사용할 수 있습니다.
  




👉 2️⃣ 연결 리스트를 이용한 큐의 구현 방법.


  연결 리스트를 이용한 큐는 동적으로 크기를 조절할 수 있으며, 각 노드가 데이터와 다음 노드를 가리키는 포인터를 포함합니다.


// LinkedListQueue
public class LinkedListQueue {
  private class Node {
    int data;
    Node next;

    Node(int data) {
      this.data = data;
    }
  }

  private Node front; // 큐의 앞쪽 노드.
  private Node rear; // 큐의 뒤쪽 노드.
  private int size; // 큐에 저장된 데이터의 개수.

  // 생성자
  public LinkedListQueue() {
    front = null;
    rear = null;
    size = 0;
  }

  // 큐의 값을 추가하는 메소드.
  public void enqueue(int value) {
    Node newNode = new Node(value);

    if (isEmpty()) {
      front = newNode;
    } else {
      rear.next = newNode;
    }
    rear = newNode;
    size++;
  }

  // 큐에서 값을 제거하고 반환하는 메소드.
  public int dequeue() {
    if (isEmpty()) {
      System.out.println("큐가 비어있습니다.");
      return -1; // 에러를 나타내기 위해 -1 반환.
    }

    int value = front.data;
    front = front.next;

    if (front == null) {
      rear = null;
    }

    size--;

    return value;
  }

  // 큐의 앞쪽 값을 반환하는 메소드.
  public int peekFront() {
    if (isEmpty()) {
      System.out.println("큐가 비어있습니다.");
      return -1; // 에러를 나타내기 위해  -1 반환.
    }
    return front.data;
  }

  // 큐가 비어있는지 확인하는 메소드.
  public boolean isEmpty() {
    return (front == null);
  }

  // 큐의 크기를 반환하는 메소드.
  public int size() {
    return size;
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    LinkedListQueue queue = new LinkedListQueue();

    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    queue.enqueue(4);
    queue.enqueue(5);

    System.out.println("=== 출력 ===");
    System.out.println();
    System.out.println("Queue의 앞 끝 값 : " + queue.peekFront());
    System.out.println("Queue의 크기 : " + queue.size());

    // while 문의 조건은 queue가 비어있을 경우 false 이므로 순회하지 않습니다.
    // 그러나 queue가 비어있지 않을 경우 true가 되므로 while 블록을 들어가 queue가 비어있을 때까지(!queue.isEmpty()) 동작합니다.
    while (!queue.isEmpty()) {
      System.out.println("Dequeue : " + queue.dequeue());
    }

    System.out.println("Queue의 크기 : " + queue.size());
  }
}
/*
=== 출력 ===

Queue의 앞 끝 값: 1
Queue의 크기: 5
Dequeue : 1
Dequeue : 2
Dequeue : 3
Dequeue : 4
Dequeue : 5
Queue의 크기 : 0
*/


이와 같이 큐는 연결 리스트를 이용하여 구현할 수 있습니다.


  큐를 배열 또는 연결 리스트를 이용하여 구현했을 때 각각의 장단점.

  배열 기반 큐는 간단하고 빠르지만 고정된 크기 문제를 해결해야 합니다.

  연결 리스트 기반 큐는 동적으로 크기를 조절할 수 있지만 메모리 사용량이 더 많을 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-30</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-29-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-29-TIL.html"><h1 class="title_post">📝 [TIL] 240529 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-29-TIL.html" class="txt_post">
                            
  스택 문제 풀이


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-29</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-05-30-VariousInputOutputMethods.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-05-30-VariousInputOutputMethods.html"><h1 class="title_post">💾 [CS] 다양한 입출력 방법</h1></a>
                        <a href="/2024/CS/2024-05-30-VariousInputOutputMethods.html" class="txt_post">
                            1️⃣ 다양한 입출력 방법.

가장 보편적인 입출력 방법인 프로그램 입출력과 인터럽트 기반 입출력, DMA 입출력에 대해 알아보겠습니다.

1️⃣ 다양한 입출력 방법.

입출력 작업을 수행시 CPU와 장치 컨트롤러가 정보를 주고받아야 합니다.

여기에는 크게 세 가지 방법이 있습니다.


  
    프로그램 입출력.
  
  
    인터럽트 기반 입출력.
  
  
    DMA 입출력.
  


2️⃣ 프로그램 입출력

프로그램 입출력(programmed I/O) 은 기본적으로 프로그램 속 명령어로 입출력 장치를 제어하는 방법입니다.

CPU가 프로그램 속 명령어를 실행하는 과정에서 입출력 명령어를 만나면 CPU는 입출력장치에 연결된 장치 컨트롤러와 상호작용하며 입출력 작업을 수행합니다.

메모리에 저장된 정보를 하드 디스크에 백업하는 상황을 생각해 봅시다.

CPU는 대략 아래 과정으로 입출력 작업을 합니다.

1. ‘메모리에 저장된 정보를 하드 디스크에 백업한다’는 말은 ‘하드 디스크에 새로운 정보를 쓴다’는 말과 같습니다.
우선 CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령을 보냅니다.



2. 하드 디스크 컨트롤러는 하드 디스크 상태를 확인합니다.
하드 디스크가 준비된 상태라면 하드 디스크 컨트롤러는 상태 레지스터에 준비되었다고 표시합니다.



3. (1) CPU는 상태 레지스터를 주기적으로 읽어 보며 하드 디스크의 준비 여부를 확인합니다.
(2) 하드 디스크가 준비됐음을 CPU가 알게 되면 백업할 메모리의 정보를 데이터 레지스터에 씁니다. 아직 백업 작업(쓰기 작업)이 끝나지 않았다면 (1)번부터 반복하고, 쓰기가 끝났다면 작업을 종료합니다.



이렇듯 프로그램 입출력 방식에서의 입출력 작업은 CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어집니다.

3️⃣ 메모리 맵 입출력과 고립형 입출력.

CPU 내부에 있는 레지스터들과 달리 CPU는 여러 장치 컨트롤러 속 레지스터들을 모두 알고 있기란 어렵습니다.

그렇다면 아래와 같은 명령어들은 어떻게 명령어로 표현되고, 메모리에 어떻게 저장 되어 있을까요?


  프린터 컨트롤러의 상태 레지스터를 읽어라.
  프린터 컨트롤러의 데이터 레지스터에 100을 써라.
  키보드 컨트롤러의 상태 레지스터를 읽어라.
  하드 디스크 컨트롤러의 데이어 레지스터에 ‘a’를 써라.


여기에는 크게 두 가지 방식이 있습니다.

바로 메모리 맵 입출력 과 고립형 입출력 입니다.

1️⃣ 메모리 맵 입출력.

메모리 맵 입출력(memory-mapped I/O) 은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법입니다.

가령 1,024 개의 주소를 표현할 수 있는 컴퓨터가 있을 때 1,024개 전부 메모리 주소를 표현하는 데 사용하지 않습니다.

512개는 메모리 주소를, 512개는 장치 컨트롤러의 레지스터를 표현하기 위해 사용합니다.

주소 공간 일부를 아래와 같이 약속했다고 가정해 봅시다.


  516번지: 프린터 컨트롤러의 데이터 레지스터
  517번지: 프린터 컨트롤러의 상태 레지스터
  518번지: 하드 디스크 컨트롤러의 데이터 레지스터
  519번지: 하드 디스크 컨트롤러의 상태 레지스터


그렇다면 CPU는 ‘517번지를 읽어 들여라’라는 명령어로 키보드 상태를 읽을 수 있습니다.

그리고 ‘518 번지에 a를 써라’ 라는 명령어로 하드 디스크 컨트롤러의 데이터 레지스터로 데이터를 보낼 수 있습니다.

이때 중요한 점은 메모리 맵 입출력 방식에서 CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯 하면 된다는 점입니다.

그래서 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어는 굳이 다를 필요가 없습니다.

CPU가 ‘517번지를 읽어라’라는 명령어를 실행했을 때 517번지가 메모리상의 주소를 가리킨다면 CPU는 메모리 517번지에 저장된 정보를 읽어 들일 것이고, 517번지가 프린터 컽츠롤러의 상태 레지스터를 가리킨다면 CPU는 프린터의 상태를 확인할 수 있기 때문입니다.

2️⃣ 고립형 입출력.
고립형 입출력(isolated I/O) 은 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법입니다.

가령 1,024개의 주소 공간을 가진 컴퓨터가 있다고 가정해 봅시다.

아래 그림처럼 제어 버스에 ‘메모리 읽기/쓰기’ 선 이외에 ‘입출력장치 읽기/쓰기’ 선이 따로 있다면 메모리에도 1,024 개의 주소 공간을 활용하고, 입출력장치도 1,024개의 주소 공간을 활용할 수 있습니다.

CPU가 메모리 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 메모리에 접근하고, 입출력장치 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 장치 컨트롤러에 접근하기 때문입니다.



고립형 입출력 방식에서 CPU는 입출력장치에 접근하기 위해 메모리에 접근하는 명령어와는 다른(입출력 읽기/쓰기 선을 활성화시키는) 입출력 명령어를 사용합니다.

메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어는 굳이 다를 필요가 없었던 메모리 맵 입출력과 대조적입니다.


  
    
      메모리 맵 입출력
      고립형 입출력
    
  
  
    
      메모리와 입출력장치는 같은 주소 공간 사용
      메모리와 입출력장치는 분리된 주소 공간 사용
    
    
      메모리 주소 공간이 축소됨
      메모리 주소 공간이 축소되지 않음
    
    
      메모리와 입출력장치에 같은 명령어 사용 가능
      입출력 전용 명령어 사용
    
  


2️⃣ 인터럽트 기반 입출력

인터럽트는 ‘CPU가 입출력장치에 처리할 내용을 명령하면 입출력장치가 명령어를 수행하는 동안 CPU는 다른 일을 할 수 있다’라고 했습니다.

또한 ‘입출력장치가 CPU에게 인터럽트 요청 신호를 보내면 CPU는 하던 일을 잠시 멈추고 해당 인터럽트를 처리하는 프로그램인 인터럽트 서비스 루틴을 실행한 뒤 다시 하던 일로 되돌아온다’라고 했습니다.

입출력장치에 의한 하드웨어 인터럽트는 정확히 말하자면 입출력장치가 아닌 장치 컨트롤러에 의해 발생합니다.

CPU는 장치 컨트롤러에 입출력 작업을 명령하고, 장치 컨트롤러가 입출력장치를 제어하며 입출력을 수행하는 동안 CPU는 다른 일을 할 수 있습니다.

장치 컨트롤러가 입출력 작업을 끝낸 뒤 CPU에게 인터럽트 요청 신호를 보내면 CPU는 하던 일을 잠시 백업하고 인터럽트 서비스 루틴을 실행합니다.

이렇게 인터럽트를 기반으로 하는 입출력을 인터럽트 기반 입출력(Interrupt-Drive I/O) 이라고 합니다.


  폴링

  인터럽트와 자주 비교되는 개념 중 폴링(polling) 이라는 개념이 있습니다.
‘CPU는 주기적으로 장치 컨트롤러의 상태 레지스터를 확인하며 입출력장치의 상태를 확인한다’ 라고 했습니다.
이처럼 폴링이란 입출력장치의 상태는 어떤지, 처리할 데이터가 있는지를 주기적으로 확인하는 방식입니다.

  폴링 방식은 당연하게도 인터럽트 방식보다 CPU의 부담이 더 큽니다.
인터럽트를 활용하면 CPU가 인터럽트 요청을 받을 때까지 온전히 다른 일에 집중할 수 있기 때문입니다.


이번에는 조금 더 일반적인 입출력장치가 많을 때를 생각해 봅시다.

예를 들어 키보드, 모니터, 스피커, 마우스를 사용하고 있다고 생각해봅시다.

이것은 컴퓨터 속 CPU가 동시다발적으로 발생하는 키보드, 마우스, 모니터, 스피커 인터럽트를 모두 처리해야 한다는 말이기도 합니다.

어떻게 여러 입출력장치에서 인터럽트가 동시에 발생한 경우에는 인터럽트들을 어떻게 처리해야 할까요?

간단하게 생각하면 인터럽트가 발생한 순서대로 인터럽트를 처리하는 방법이 있습니다.

가령 인터럽트 A를 처리하는 도중 발생한 또 다른 인터럽트 B의 요청을 받아들이지 않고, 인터럽트 A 서비스 루틴이 끝나면 그때 비로소 인터럽트 B 서비스 루틴을 실행하는 것이죠.

CPU가 플래그 레지스터 속 인터럽트 비트를 비활성화한 태 인터럽트를 처리하는 경우 다른 입출력장치에 의한 하드웨어 인터럽트를 받아들이지 않기 때문에 CPU는 이렇듯 순차적으로 하드웨어 인터럽트를 처리하게 됩니다.



하지만 현실적으로 모든 인터럽트를 전부 순차적으로만 해결할 수 없습니다.

인터럽트 중에서도 더 빨리 처리해야 하는 인터럽트가 있기 때문입니다.

즉, CPU는 인터럽트 간에 우선순위를 고려하여 우선순위가 높은 인터럽트 순으로 여러 인터럽트를 처리할 수 있습니다.

예를 들어 아래 그림과 같이 현재 CPU가 인터럽트 A를 처리하는 도중에 또 다른 인터럽트 B가 발생했다고 가정해 봅시다.

만약 지금 처리 중인 인터럽트 A보다 B의 우선순위가 낮다면 CPU는 A를 모두 처리한 뒤 B를 처리합니다.

하지만 인터럽트 A보다 B의 우선순위가 높다면 CPU는 인터럽트 A의 실행을 잠시 멈추고 인터럽터 B를 처리한 뒤 다시 A를 처리합니다.



플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우, 혹은 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트인 NMI(Non-Mashable Interrupt) 가 발생한 경우 CPU는 이렇게 우선순위가 높은 인터럽트부터 처리합니다.

우선순위를 반영하여 다중 인터럽트를 처리하는 방법에는 여러 가지가 있지만, 많은 컴퓨터에서는 프로그래머블 인터럽트 컨트롤러(PIC: Programmable Interrupt Controller) 라는 하드웨어를 사용합니다.

PIC 는 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선 순위를 판별한 뒤 CPU에 지금 처리해야 할 하드웨어 인터럽트는 무엇인지를 알려주는 장치입니다.



PIC에는 여러 핀이 있는데, 각 핀에는 CPU에 하드웨어 인터럽트 요청을 보낼 수 있는 약속된 하드웨어가 연결되어 있습니다.

가령 첫 번째 핀은 타이머 인터럽트를 받아들이는 핀, 두 번째 핀은 키보드 인터럽트를 받아들이는 핀… 이런 식으로 말이죠.

PIC에 연결된 장치 컨트롤러들이 동시에 하드웨어 인터럽트 요청을 보내면 PIC는 이들의 우선순위를 판단하여 CPU에 가장 먼저 처리할 인터럽트를 알려줍니다.



PIC의 다중 인터럽트 처리 과정을 조금 더 정확히 알아봅시다.

1. PIC가 장치 컨트롤러에서 인터럽트 요청신호(들) 를 받아들입니다.
2. PIC는 인터럽트 우선순위를 판단한 뒤 CPU에 처리해야 할 인터럽트 요청 신호를 보냅니다.
3. CPU는 PIC에 인터럽트 확인 신호를 보냅니다.
4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보냅니다.
5. CPU는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게 되고, 해당 장치의 인터럽트 서비스 루틴을 실행합니다.

일반적으로 더 많고 복잡한 장치들의 인터럽트를 관리하기 위해 아래와 같이 PIC를 두 개 이상 계층적으로 구성합니다.

이렇게 PIC를 여러 개 사용하면 훨씬 더 많은 하드웨어 인터럽트를 관리할 수 있습니다.



참고로 PIC가 무시할 수 없는 인터럽트인 NMI까지 우선순위를 판별하지 않습니다.

NMI는 우선 순위가 가장 높아 우선순위 판별이 불필요하기 때문입니다.

PIC가 우선순위를 조정해주는 인터럽트는 인터럽트 비트를 통해 막을 수 있는 하드웨어 인터럽트입니다.

3️⃣ DMA 입출력

앞에 설명한 프로그램 기반 입출력과 인터럽트 기반 입출력의 공통점이 있다면 입출력장치와 메모리 간의 데이터 이동은 CPU가 주도하고, 이동하는 데이터도 반드시 CPU를 거친다는 점입니다.

예를 들어 입출력장치 데이터를 메모리에 저장하는 경우 CPU는 (1) 장치 컨트롤러에서 입출력장치 데이터를 하나씩 읽어 레지스터에 적재하고, (2) 적재한 데이터를 메모리에 저장합니다.



메모리 속 데이터를 입출력장치에 내보내는 경우도 마찬가지입니다.

CPU는 (1) 메모리에서 데이터를 하나씩 읽어 레지스터에 적재하고, (2) 적재한 데이터를 하나씩 입출력장치에 내보냅니다.



입출력장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU를 거쳐야 한다면 가뜩이나 바쁜 CPU는 입출력장치를 위한 연산 때문에 시간을 뺏기게 됩니다.

하드 디스크 백업과 같이 대용량 데이터를 옮길 때는 CPU 부담이 더욱 커집니다.

그래서 입출력장치와 메모리가 CPU를 거치지 않고도 상호작용할 수 있는 입출력 방식인 DMA(Direct Memory Access) 가 등장하였습니다.

DMA는 이름 그대로 직접 메모리에 접근할 수 있는 입출력 기능입니다.

DMA 입출력을 하기 위해서는 시스템 버스에 연결된 DMA 컨트롤러 라는 하드웨어가 필요합니다.



DMA 입출력 과정.

일반적으로 DMA 입출력은 아래와 같이 이루어집니다.

(1) CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산(읽기/쓰기), 읽거나 쓸 메모리 주소 등과 같은 정보로 입출력 작업을 명령합니다.
(2) DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행합니다. 이때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 씁니다.
(3) 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알립니다.

이번에는 메모리 내의 정보를 하드 디스크에 백업하는 작업이 DMA 입출력으로 어떻게 이루어지는지도 알아봅시다.

1. CPU는 DMA 컨트롤러에 하드 디스크 주소, 수행할 연산(쓰기), 백업할 내용이 저장된 메모리 주소 등의 정보와 함께 입출력 작업을 명령합니다.



2. (1) DMA 컨트롤러는 CPU를 거치지 않고 메모리와 직접 상호작용하며 백업할 정보를 읽어오고, (2) 이를 하드 디스크의 장치 컨트롤러에 내보냅니다.



3. 백업이 끝나면 DMA 컨트롤러는 CPU에게 인터럽트를 걸어 작업이 끝났음을 알립니다.



위 입출력 과정을 보면 알 수 있듯 입출력장치와 메모리 사이에 주고받을 데이터는 CPU를 거치지 않습니다.

CPU는 DMA 컨트롤러에게 입출력 작업 명령을 내리고, 인터럽트만 받으면 되기 때문에 작업 부담을 훨씬 줄일 수 있습니다.

다시 말해 CPU는 오직 입출력의 시작과 끝에만 관여하면 됩니다.

그런데 여기서 생각해 봐야 할 문제가 있습니다.

DMA 컨트롤러는 시스템 버스로 메모리에 직접 접근이 가능하지만, 시스템 버스는 동시 사용이 불가능합니다.

시트템 버스는 공용 자원이기 때문입니다.

CPU가 시스템 버스를 사용할 떄 DMA 컨트롤러는 시스템 버스를 사용할 수 없고, DMA 컨트롤러가 시스템 버스를 사용할 때는 CPU가 시스템 버스를 사용할 수 없습니다.

그래서 DMA 컨트롤러는 CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스를 이용하거나, CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스를 집중적으로 이용합니다.




  CPU 입장에서는 마치 버스에 접근하는 주기를 도둑 맞는 기분이 들 겁니다. 그래서 이러한 DMA의 시스템 버스 이용을 사이클 스틸링(cycle stealing) 이라고 부릅니다.


입출력 버스

마지막으로 DMA 컨트롤러와 장치 컨트롤러의 연결 방식과 입출력 버스에 대해 알아봅시다.

CPU, 메모리, DMA 컨트롤러, 장치 컨트롤러가 모두 같은 버스를 공유하는 구성에서는 DMA를 위해 한 번 메모리에 접근할 때마다 시스템 버스를 두 번 사용하게 되는 부작용이 있습니다.

예로 들었던 메모리 내 정보를 하드 디스크로 백업하는 상황을 다시 생각해 봅시다.

이 경우 (1) 메모리에서 DMA 컨트롤러로 데이터를 가져오기 위해 시스템 버스를 한 번 사용하고, (2) DMA 컨트롤러의 데이터를 장치 컨트롤러로 옮기기 위해 시스템 버스를 또 한 번 사용합니다.



DMA를 위해 시스템 버스를 너무 자주 사용하면 그만큼 CPU가 시스템 버스를 이용하지 못합니다.

이 문제는 DMA 컨트롤러와 장치 컨트롤러들을 입출력 버스(input/output bus) 라는 별도의 버스에 연결하여 해결할 수 있습니다.

아래 그림과 같이 장치 컨트롤러들이 시스템 버스가 아닌 입출력 버스로 DMA 컨트롤러에 연결된다면 DMA 컨트롤러와 장치 컨트롤러가 서로 데이터를 전송할 때는 시스템 버스를 이용할 필요가 없으므로 시스템 버스의 사용 빈도를 줄일 수 있습니다.



현대 대부분 컴퓨터에는 입출력 버스가 있습니다.

다시 말해 대부분의 입출력장치(장치 컨트롤러)는 시스템 버스가 아닌 입출력 버스와 연결됩니다.

이런 점에서 볼 때 입출력 버스는 입출력장치를 컴퓨터 내부와 연결 짓는 통로라고도 볼 수 있습니다.

입출력 버스에는 PIC(Peripheral Component Interconnect) 버스, PCI Express(PCIe) 버스 등 여러 종류가 있습니다.

다음 그림은 여러 입출력 장치들을 PCIe 버스와 연결해 주는 통로인 PCIe 슬롯 입니다.

사용하는 거의 모든 입출력장치들은 이렇게 입출력 버스와 연결되는 통로를 통해 시스템 버스를 타고 CPU와 정보를 주고받습니다.



🙋‍♂️ 마무리.

키워드로 정리하는 핵심 포인트


  프로그램 입출력은 프로그램 속 명령어로 입출력 작업을 하는 방식입니다.
  메모리 맵 입출력은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 입출력 방식입니다.
  고립형 입출력은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 별도로 분리하는 입출력 방식입니다.
  인터럽트 기반 입출력은 인터럽트로써 입출력을 수행하는 방법입니다.
  DMA 입출력은 CPU를 거치지 않고 메모리와 입출력장치 간의 데이터를 주고받는 입출력 방식입니다.
  입출력 버스는 입출력장치와 컴퓨터 내부를 연결 짓는 톨로로, 입출력 작업 과정에서 시스템 버스 사용 횟수를 줄여줍니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-05-29</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-28-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-28-TIL.html"><h1 class="title_post">📝 [TIL] 240528 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-28-TIL.html" class="txt_post">
                            
  스택(Stack)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-28-Stack.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-28-Stack.html"><h1 class="title_post">📦[DS,Algorithm] 스택(Stack)</h1></a>
                        <a href="/Backend/AnD/2024-05-28-Stack.html" class="txt_post">
                            1️⃣ 스택(Stack).

스택(Stack)은 자료구조의 한 종류로, 데이터가 일렬로 쌓이는 구조를 가지고 있습니다.

1️⃣ 스택(Stack)의 특징.

“후입선출(LIFO, Last In First Out)”로, 가장 나중에 삽입된 데이터가 가장 먼저 꺼내진다는 점이 특징입니다.

2️⃣ 스택(Stack)의 기본 연산.


  
    푸시(Push) : 스택의 맨 위에 데이터를 삽입하는 연산.
  
  
    팝(Pop) : 스택의 맨 위에 있는 데이터를 제거하고 반환하는 연산.
  


3️⃣ 스택(Stack)의 부가적인 연산.


  
    피크(peek) 또는 탑(top) : 스택의 맨 위에 있는 데이터를 제거하지 않고 반환하는 연산.
  
  
    isEmpty : 스택이 비어 있는지 여부를 확인하는 연산.
  
  
    size : 스택에 있는 데이터의 개수를 반환하는 연산.
  


4️⃣ 스택(Stack)의 실제 응용 사례.


  웹 브라우저의 방문 기록(뒤로 가기 기능)
  함수 호출시의 호출 스택
  역폴란드 표기법 계산 등


5️⃣ 스택(Stack)의 구현.

스택은 배열이나 연결 리스트를 이용하여 구현할 수 있습니다.

배열을 이용한 스택 구현은 고정된 크기를 가지며, 연결 리스트를 이용한 스택 구현은 동적으로 크기를 조절할 수 있습니다.


  
    배열을 이용한 스택 : 고정된 크기의 배열을 사용하여 스택을 구현할 수 있습니다. 이 경우 스택의 크기가 초과되면 더 큰 배열로 복사하는 추가 작업이 필요할 수 있습니다.
  
  
    연결 리스트를 이용한 스택 : 동적으로 크기를 조절할 수 있는 연결 리스트를 사용하여 스택을 구현할 수 있습니다. 연결 리스트의 노드 삽입 및 삭제는 O(1)의 시간 복잡도를 가지므로, 스택 연산을 효율적으로 수행할 수 있습니다.
  


6️⃣ 시간 복잡도

스택의 각 연산은 일반적으로 다음과 같은 시간 복잡도를 가집니다.


  Push : O(1)
    
      데이터를 스택의 맨 위에 추가하는 연산은 항상 일정한 시간 내에 완료됩니다.
    
  
  Pop : O(1)
    
      데이터를 스택의 맨 위에서 제거하는 연산도 항상 일정한 시간 내에 완료됩니다.
    
  
  Peek 또는 Top : O(1)
    
      스택의 맨 위에 있는 데이터를 확인하는 연산은 데이터 접근만 필요하기 때문에 일정한 시간 내에 완료됩니다.
    
  
  isEmpty : O(1)
    
      스택이 비어 있는지 확인하는 연산은 스택의 크기만 확인하면 되프로 일정한 시간 내에 완료됩니다.
    
  
  Size : O(1)
    
      스택에 있는 데이터의 개수를 반환하는 연산은 스택의 크기 정보를 유지하고 있으면 일정한 시간 내에 완료됩니다.
    
  


7️⃣ 스택 구현.
// Stack
public class Stack {
  private int maxSize; // 스택의 최대 크기
  private int top; // 스택의 맨 위를 가리키는 인덱스
  private int[] stackArray; // 스택을 저장할 배열

  // 생성자
  public Stack(int size) {
    maxSize = size;
    stackArray = new int[maxSize];
    top = -1; // 스택이 비어있음을 나타냄
  }

  // 스택에 값을 푸시하는 메소드
  public void push(int value) {
    if (isFull()) {
      System.out.println("스택이 가득 찼습니다.");
      return;
    }
    stackArray[++top] = value;
  }

  // 스택에서 값을 팝하는 메소드
  public int pop() {
    if (isEmpty()) {
      System.out.println("스택이 비어있습니다.");
      return -1; // 에러를 나타내기 위해 -1 반환
    }
    return stackArray[top--];
  }

  // 스택의 맥 위 값을 반환하는 메소드
  public int peek() {
    if (isEmpty()) {
      System.out.println("스택이 비어있습니다.");
      return -1; // 에러를 나타내기 위해 -1 반환
    }
    return stackArray[top];
  }

  // 스택이 비어있는지 확인하는 메소드
  public boolean isEmpty() {
    return (top == -1);
  }

  // 스택이 가득 찼는지 확인하는 메소드
  public boolean isFull() {
    return (top == maxSize -1);
  }

  // 스택의 크기를 반환하는 메소드
  public int size() {
    return top + 1;
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    Stack stack = new Stack(5); // 크기가 5인 스택 생성

    stack.push(1);
    stack.push(2);
    stack.push(3);
    stack.push(4);
    stack.push(5);

    System.out.println("스택의 맨 위 값 : " + stack.peek());
    System.out.println("스택의 크기 : " + stack.size());

    while (!stack.isEmpty()) {
      System.out.println("팝 : " + stack.pop());
    }

    System.out.println("스택의 크기 : " + stack.size());
  }
}
/*
===출력===
스택의 맨 위 값 : 5
스택의 크기 : 5
팝 : 5
팝 : 4
팝 : 3
팝 : 2
팝 : 1
스택의 크기 : 0
*/


주요 메서드 설명


  push(int value) : 스택의 맨 위에 값을 추가합니다. 스택이 가득 찼을 경우, 에러 메시지를 출력합니다.
  pop() : 스택의 맨 위 값을 제거하고 반환합니다. 스택이 비어 있을 경우, 에러 메시지를 출력하고 -1을 반환합니다.
  peek() : 스택의 맨 위 값을 반환하지만, 스택에서 제거하지는 않습니다. 스택이 비어 있을 경우, 에러 메시지를 출력하고 -1을 반환합니다.
  isEmpty() : 스택이 비어 있는지 여부를 확인합니다.
  isFull() : 스택이 가득 찼는지 여부를 확인합니다.
  size() : 스택에 현재 저장된 데이터의 개수를 반환합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-27-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-27-TIL.html"><h1 class="title_post">📝 [TIL] 240527 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-27-TIL.html" class="txt_post">
                            
  노드(Node)
  장치 컨트롤러와 장치 드라이버
  트리(Tree)
  이진 트리(Binary Tree)
  완전 이진 트리(Complete Binary Tree)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-27-Tree.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-27-Tree.html"><h1 class="title_post">📦[DS,Algorithm] 트리(Tree)</h1></a>
                        <a href="/Backend/AnD/2024-05-27-Tree.html" class="txt_post">
                            1️⃣ 트리(Tree).

트리(Tree) 는 계층적 구조를 나타내는 자료구조로, 노드(Node)와 에지(Edge)로 구성됩니다.

트리는 사이클이 없는 연결 그래프(Connected Graph)이며, 계층적 데이터 표현에 매우 유용합니다.

트리는 부모-자식 관계를 가지며, 데이터의 조직화와 검색, 계층적 데이터 표현에 사용됩니다.

1️⃣ 트리의 구성 요소.


  
    노드(Node) : 트리의 기본 단위로, 데이터를 저장합니다.
  
  
    에지(Edge) : 노드와 노드를 연결하는 선으로, 부모-자식 관계를 나타냅니다.
  
  
    루트(Root) : 트리의 최상위 노드로, 부모 노드가 없습니다.
  
  
    부모(Parent) : 다른 노드를 가리키는 노드입니다.
  
  
    자식(Child) : 부모 노드에 의해 가리켜지는 노드입니다.
  
  
    잎(Leaf) : 자식 노드가 없는 노드입니다.
  
  
    내부 노드(Internal Node) : 자식 노드가 있는 노드입니다.
  
  
    레벨(Level) : 루트 노드에서 특정 노드까지의 에지 수를 나타냅니다.
  
  
    높이(Height) : 트리의 최대 레벨을 의미합니다.
  


2️⃣ 트리의 특성.


  계층적 구조 : 트리는 계층적 구조로 데이터를 조직화합니다.
  사이클 없음 : 트리는 사이클이 없는 그래프입니다.
  연결성 : 모든 노드는 하나의 연결된 구성 요소로 되어 있습니다.
  한 개의 루트 노드 : 트리는 하나의 루트 노드를 가지며, 루트 노드는 트리의 시작점입니다.


3️⃣ 트리의 종류.


  
    이진 트리(Binary Tree) : 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리입니다.
  
  
    이진 탐색 트리(Binary Search Tree, BST) : 이진 트리의 일종으로, 왼쪽 자식 노드의 값이 부모 노드의 값보다 작고, 오른쪽 자식 노드의 값이 부모 노드의 값보다 큰 특성을 가집니다.
  
  
    균형 이진 트리(Balanced Binary Tree) : AVL 트리, 레드-블랙 트리 등과 같이 트리의 높이가 균형을 이루도록 유지하는 트리입니다.
  
  
    B-트리(B-Tree) : 데이터베이스와 파일 시스템에서 사용되는 트리로, 자식 노드의 수가 정해진 다진 트리(Multiway Tree)입니다.
  
  
    힙(Heap) : 완전 이진 트리의 일종으로, 부모 노드의 값이 자식 노드의 값보다 크거나 작은 특성을 가집니다.
  
  
    트라이(Trie) : 문자열 검색을 위한 트리 자료구조로, 접두사 검색에 유용합니다.
  


4️⃣ 트리의 주요 연산.


  삽입(Insertion) : 트리에 새로운 노드를 추가합니다.
  삭제(Deletion) : 트리에서 노드를 제거합니다.
  탐색(Search) : 트리에서 특정 값을 찾습니다.
  순회(Traversal) : 트리의 모든 노드를 방문합니다. 전위(Preorder), 중위(Inorder), 후위(Postorder), 레벨 순회(Level Order) 방식이 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-27-Node.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-27-Node.html"><h1 class="title_post">📦[DS,Algorithm] 노드(Node)</h1></a>
                        <a href="/Backend/AnD/2024-05-27-Node.html" class="txt_post">
                            1️⃣ Node(노드).

Node(노드) 는 연결 리스트, 트리, 그래프 등의 자료구조에서 기본적인 단위 요소를 의미합니다.

노드는 데이터를 저장하며, 다른 노드와의 연결을 나타내는 포인터(참조)를 포함합니다.

1️⃣ Node의 구성 요소.


  
    데이터(Data) : 노드가 저장하는 실제 값입니다. 이는 숫자, 문자, 객체 등 모든 데이터 타입이 될 수 있습니다.
  
  
    포인터(참조, Pointer) : 다음 노드(또는 다른 관련된 노드)를 가리지는 참조입니다. 포인터의 수와 종류는 자료구조에 따라 다릅니다.
    
      Singly Linked List : 하나의 다음 노드를 가리키는 포인터를 가집니다.
      Doubly Linked List : 이전 노드와 다음 노드를 가리키는 두 개의 포인터를 가집니다.
      트리(Tree) : 부모 노드, 자식 노드 등 여러 방향의 포인터를 가질 수 있습니다.
      그래프(Graph) : 여러 개의 인접 노드를 가리키는 포인터를 가질 수 있습니다.
    
  


Singly Linked List의 Node
Singly Linked List에서의 노드는 다음과 같은 구조를 가집니다.

public class Node {
  int data; // 노드가 저장하는 데이터
  Node next; // 다음 노드를 가리키는 포인터

  public Node(int data) {
    this.data = data;
    this.next = null;
  }
}


Doubly Linked List의 Node
Doubly Linked List에서의 노드는 다음과 같은 구조를 가집니다.
public class DoublyNode {
  int data; // 노드가 저장하는 데이터
  DoublyNode next; // 다음 노드를 가리키는 포인터
  DoublyNode prev; // 이전 노드를 가리키는 포인터

  public DoublyNode(int data) {
    this.data = data;
    this.next = null;
    this.prev = null;
  }
}


2️⃣ Node를 사용하는 예제.

Singly Linked List

Singly Linked List는 각 노드가 다음 노드를 가리키는 구조로 연결된 리스트 입니다.

아래는 Singly Linked List를 구현한 예제입니다.

//SinglyLinkedList
public class SinglyLinkedList {
  private Node head;

  public SinglyLinkedList() {
    this.head = null;
  }

  // 리스트의 맨 앞에 노드 추가
  public void addFirst(int data) {
    Node newNode = new Node(data);
    newNode.next = head;
    head = newNode;
  }

  // 리스트의 맨 끝에 노드 추가
  public void addLast(int data) {
    Node newNode = new Node(data);
    if (head == null) {
      head = newNode;
      return;
    }
    Node current = head;
    while (current.next != null) {
      current = current.next;
    }
    current.next = newNode;
  }

  // 리스트의 특정 값 삭제
  public void delete(int data) {
    if (head == null) {
      return;
    }

    if (head.data == data) {
      head = head.next;
      return;
    }

    Node current = head;

    while (current.next != null &amp;&amp; current.next.data != data) {
      current = current.next;
    }

    if (current.next != null) {
      current.next = current.next.next;
    }
  }

  // 리스트 출력
  public void printList() {
    Node current = head;
    while (current != null) {
      System.out.print(current.data + " ");
      current = current.next;
    }
    System.out.println();
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    // Singly Linked List 생성
    SinglyLinkedList singlyLinkedList = new SinglyLinkedList();

    singlyLinkedList.addFirst(1);
    singlyLinkedList.addLast(2);
    singlyLinkedList.addLast(3);
    singlyLinkedList.printList(); // 1 2 3

    singlyLinkedList.delete(2);
    singlyLinkedList.printList(); // 1 3
  }
}


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-27-CompleteBinaryTree.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-27-CompleteBinaryTree.html"><h1 class="title_post">📦[DS,Algorithm] 완전 이진 트리(Complete Binary Tree)</h1></a>
                        <a href="/Backend/AnD/2024-05-27-CompleteBinaryTree.html" class="txt_post">
                            1️⃣ 완전 이진 트리(Complete Binary Tree).

완전 이진 트리(Complete Binary Tree)는 이진 트리의 한 종류입니다.

1️⃣ 완전 이진 트리(Complete Binary Tree)의 특성.


  모든 레벨이 완전히 채워져 있다.
    
      마지막 레벨을 제외한 모든 레벨의 노드가 최대 개수로 채워져 있습니다.
      마지막 레벨의 노드들은 왼쪽부터 오른쪽으로 채워져 있습니다.
    
  
  노드의 배치
    
      트리의 높이가 ‘h’ 라면, 마지막 레벨을 제외한 모든 레벨에는 ‘2^k’ 개의 노드가 있습니다. 여기서 ‘k’ 는 해당 레벨의 깊이 입니다.
      마지막 레벨에는 1개 이상 ‘2^h’ 개 이하의 노드가 있으며, 이 노드들은 왼쪽부터 채워집니다.
    
  


2️⃣ 완전 이친 트리의 예.
        1
      /   \
     2     3
    / \   / \
   4   5 6   7
  / \
 8   9


위의 트리는 완전 이진 트리의 예입니다.

모든 레벨이 완전히 채워져 있고, 마지막 레벨의 노드들은 왼쪽부터 오른쪽으로 채워져있습니다.

3️⃣ 완전 이진 트리의 속성.


  노드 수
    
      높이가 ‘h’ 인 완전 이진 트리는 최대 ‘2^(h+1) - 1’ 개의 노드를 가질 수 있습니다.
      마지막 레벨을 제외한 모든 노드는 ‘2^h - 1’ 개의 노드를 가집니다.
    
  
  높이
    
      노드 수가 ‘n’ 인 완전 이진 트리의 높이는 ‘O(log n)’ 입니다.
    
  
  배열 표현
    
      완전 이진 트리는 배열을 사용하여 쉽게 표현할 수 있습니다. 이는 힙 자료구조에서 많이 사용됩니다.
    
  


4️⃣ 배열을 통한 완전 이진 트리 표현

완전 이진 트리는 배열을 사용하여 효율적으로 표현할 수 있습니다.

노드의 인덱스를 기준으로 부모-자식 관계를 쉽게 파악할 수 있습니다.

노드의 인덱스 규칙

  루트 노드 : 인덱스 0
  인덱스 ‘i’의 오른쪽 자식 노드 : ‘2*i + 1’
  인덱스 ‘i’의 부모 노드 : ‘(i - 1) / 2’


5️⃣ 예제 코드
아래는 완전 이진 트리를 배열로 표현하고, 이를 출력하는 간단한 예제 코드입니다.
public class CompleteBinaryTree {

  public static void main(String[] args) {
    int[] tree = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // 트리 출력
    printTree(tree);
  }

  // 배열로 표현된 완전 이진 트리 출력
  public static void printTree(int[] tree) {
    for (int i = 0; i &lt; tree.length; i++) {
      int leftChildIndex = 2 * i + 1;
      int rightChildIndex = 2 * i + 2;

      System.out.print("Node " + tree[i] + ": ");

      if (leftChildIndex &lt; tree.length) {
        System.out.print("Left Child: " + tree[leftChildIndex] + ", ");
      } else {
        System.out.print("Left Child: null, ");
      }

      if (rightChildIndex &lt; tree.length) {
        System.out.print("Right Child: " + tree[rightChildIndex]);
      } else {
        System.out.print("Right Child: null");
      }
      System.out.println();
    }
  }
}

/* 출력
Node 1: Left Child: 2, Right Child: 3
Node 2: Left Child: 4, Right Child: 5
Node 3: Left Child: 6, Right Child: 7
Node 4: Left Child: 8, Right Child: 9
Node 5: Left Child: null, Right Child: null
Node 6: Left Child: null, Right Child: null
Node 7: Left Child: null, Right Child: null
Node 8: Left Child: null, Right Child: null
Node 9: Left Child: null, Right Child: null
*/


설명


  트리 배열 초기화 : int[] tree = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    
      완전 이진 트리를 배열로 표현합니다.
    
  
  트리 출력 : printTree(tree)
    
      배열로 표현된 완전 이진 트리를 출력하는 함수입니다.
      각 노드에 대해 왼쪽 자식과 오른쪽 자식을 출력합니다.
    
  


시간 복잡도


  삽입(Insertion) : O(log n)
  삭제(Deletion) : O(log n)
  탐색(Search) : O(n) (일반적으로 완전 이진 트리는 탐색보다 삽입/삭제가 주된 연산입니다.)



  완전 이진 트리는 데이터의 구조적 특성 때문에 힙과 같은 자료구조에서 많이 사용됩니다.
이는 효율적인 삽입 및 삭제 연산을 제공하며, 배열을 통한 표현이 간편하여 다양한 알고리즘에서 유용하게 사용됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-27-BinaryTree.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-27-BinaryTree.html"><h1 class="title_post">📦[DS,Algorithm] 이진 트리(Binary Tree)</h1></a>
                        <a href="/Backend/AnD/2024-05-27-BinaryTree.html" class="txt_post">
                            1️⃣ 이진 트리(Binary Tree).

이진 트리(Binary Tree) 는 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리 구조입니다.

이 두 자식 노드는 일반적으로 왼쪽 자식(Left Child) 과 오른쪽 자식(Right Child) 이라고 불립니다.

이진 트리는 다양한 응용 프로그램에서 중요한 자료구조입니다.

1️⃣ 이진 트리의 구성 요소.


  노드(Node) : 데이터를 저장하는 기본 단위입니다.
  루트(Root) : 트리의 최상위 노드입니다.
  자식(Child) : 특정 노드로부터 연결된 하위 노드입니다.
  부모(Parent) : 특정 노드를 가리키는 상위 노드입니다.
  잎(Leaf) : 자식 노드가 없는 노드입니다.
  서브트리(Subtree) : 특정 노드와 그 노드의 모든 자식 노드로 구성된 트리입니다.


2️⃣ 이진 트리의 종류.


  
    포화 이진 트리(Full Binary Tree) : 모든 노드가 0개 또는 2개의 자식 노드를 가지는 트리입니다.
  
  
    완전 이진 트리(Complete Binary Tree) : 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 노드는 왼쪽부터 채워져 있는 트리입니다.
  
  
    높이 균형 이진 트리(Height-balanced binary Tree) : AVL 트리와 같이 각 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하인 트리입니다.
  
  
    이진 탐색 트리(Binary Search Tree, BST) : 왼쪽 서브트리의 모든 노드가 루트 노드보다 작고, 오른쪽 서브 트리의 모든 노드가 루트 노드보다 큰 트리입니다.
  


3️⃣ 이진 트리의 주요 연산 및 시간 복잡도.


  삽입(Insertion) : 새로운 노드를 트리에 추가합니다.
    
      일반적인 경우 시간 복잡도 : O(log n)(이진 탐색 트리에서)
      최악의 경우 시간 복잡도 : O(n)(편향된 트리에서)
    
  
  삭제(Deletion) : 트리에서 특정 노드를 제거합니다.
    
      일반적인 경우 시간 복잡도 : O(log n)(이진 탐색 트리에서)
      최악의 경우 시간 복잡도: O(n)(편향된 트리에서)
    
  
  탐색(Search) : 트리에서 특정 값을 찾습니다.
    
      일반적인 경우 시간 복잡도: O(log n)(이진 탐색 트리에서)
      최악의 경우 시간 복잡도 : O(n)(편향된 트리에서)
    
  
  순회(Traversal) : 트리의 모든 노드를 방문합니다. 순회 방법에는 전위(Preorder), 중위(Inorder), 후위(Postorder) 순회가 있습니다.
    
      시간 복잡도: O(n)(모든 노드를 방문하기 때문에)
    
  


4️⃣ 이진 트리의 예제
이진 탐색 트리(BST)의 구현
// TreeNode
public class TreeNode {
  int data;
  TreeNode left;
  TreeNode right;

  public TreeNode(int data) {
    this.data = data;
    this.left = null;
    this.right = null;
  }
}

// BinarySearchTree
public class BinarySearchTree {
  private TreeNode root;

  public BinarySearchTree() {
    this.root = null;
  }

  // 삽입 연산
  public void insert(int data) {
    root = insertRec(root, data);
  }

  private TreeNode insertRec(TreeNode root, int data) {
    if (root == null) {
      root = new TreeNode(data);
      return root;
    }

    if (data &lt; root.data) {
      root.left = insertRec(root.left, data);
    } else if (data &gt; root.data) {
      root.right = insertRec(root.right, data);
    }
    return root;
  }

  // 탐색 연산
  public boolean search(int data) {
    return searchRec(root, data);
  }

  private boolean searchRec(TreeNode root, int data) {
    if (root == null) {
      return false;
    }

    if (root.data == data) {
      return true;
    }

    if (data &lt; root.data) {
      return searchRec(root.left, data);
    } else {
      return searchRec(root.right, data);
    }
  }

  // 중위 순회(Inorder Traversal)
  public void inorder() {
    inorderRec(root);
  }

  private void inorderRec(TreeNode root) {
    if (root != null) {
      inorderRec(root.left);
      System.out.print(root.data + " ");
      inorderRec(root.right);
    }
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    BinarySearchTree bst = new BinarySearchTree();

    bst.insert(50);
    bst.insert(30);
    bst.insert(20);
    bst.insert(40);
    bst.insert(70);
    bst.insert(60);
    bst.insert(80);

    System.out.println("Inorder traversal of the BST:");
    bst.inorder(); // 출력: 20 30 40 50 60 70 80

    System.out.println("\nSearch for 40: " + bst.search(40)); // 출력: true
    System.out.println("Search for 90: " + bst.search(90)); // 출력: false
  }
}


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-05-27-dviceControllerAndDeviceDriver.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-05-27-dviceControllerAndDeviceDriver.html"><h1 class="title_post">💾 [CS] 장치 컨트롤러와 장치 드라이버</h1></a>
                        <a href="/2024/CS/2024-05-27-dviceControllerAndDeviceDriver.html" class="txt_post">
                            1️⃣ 장치 컨트롤러와 장치 드라이버.

1️⃣ 장치 컨트롤러.

입출력장치는 CPU, 메모리보다 다루기가 더 까다롭습니다.

여기에는 크게 두 가지 이유가 있습니다.

첫째, 입출력장치에는 종류가 너무나도 많습니다.

키보드, 모니터, USB 메모리, CD-ROM, SSD, 마우스, 스피커, 프린터 등 매우 많습니다.

장치가 이렇게 다양하면 자연스레 장치마다 속도, 데이터 전송 형식 등도 다양합니다.

따라서 다양한 입출력장치와 정보를 주고받는 방식을 규격화하기가 어렵습니다.

이는 마치 CPU와 메모리는 한국어를 사용하는데, 프린터는 영어, 스피커는 일본어, 모니터는 중국어를 사용하는 상황과 같습니다.

둘째, 일반적으로 CPU와 메모리의 데이터 전송률은 높지만 입출력장치의 데이터 전송률은 낮습니다.

여기서 전송률(transfer rate) 이란 데이터를 얼마나 빨리 교환할 수 있는지를 나타내는 지표입니다.

CPU와 메모리처럼 전송률이 높은 장치는 1초에도 수많은 데이터를 주고받을 수 있지만, 키보드나 마우스와 같은 상대적으로 전송률이 낮은 장치는 같은 시간 동안 데이터를 조금씩만 주고받을 수 있습니다.

전송률의 차이는 CPU와 메모리, 입출력 장치간의 통신을 어렵게 합니다.

장치 컨트롤러(Derive Controller)

물론 어떤 입출력장치는 CPU나 메모리보다 전송률이 높은 경우도 있습니다.

하지만 결과적으로 CPU나 메모리와 전송률이 비슷하지 않기 때문에 같은 어려움을 겪게 됩니다.

이와 같은 이유로 입출력장치는 컴퓨터에 직접 연결되지 않고 장치 컨트롤러(Drive Controller) 라는 하드웨어를 통해 연결됩니다.

장치 컨트롤러는 입출력 제어기(I/O Controller), 입출력 모듈(I/O Module) 등으로 다양하게 불립니다.

모든 입출력장치는 각자의 장치 컨트롤러를 통해 컴퓨터 내부와 정보를 주고받고, 장치 컨트롤러는 하나 이상의 입출력장치와 연결되어 있습니다.

예를 들어 하드 디스크 또한 장치 컨트롤러가 있습니다.

2️⃣ 장치 컨트롤러의 역할.

장치 컨트롤러는 대표적으로 다음과 같은 역할을 통해 앞에서 언급한 문제들을 해결합니다.


  CPU와 입풀력장치 간의 통신 중개
  오류 검출
  데이터 버퍼링


입풀력장치 종류가 많이 정보 규격롸가 어려웠던 문제는 장치 컨트롤러가 일종의 번역가 역할을 함으로써 해결할 수 있습니다.

그 과정에서 장치 컨트롤러는 자신과 연결된 입출력장치에 문제는 없는지 오류를 검출하기도 합니다.

장치 컨트롤러의 세 번째 기능인 데이터 버퍼링은 무엇일까요?

버퍼링(buffering) 이란 전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 버퍼(buffer) 라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법입니다.

쉽게 말해 버퍼링은 ‘버퍼에 데이터를 조금씩 모았다가 한꺼번에 내보내거나, 데이터를 한 번에 많이 받아 조금씩 내보내는 방법’이라고 보면 됩니다.

즉, 장치 컨트롤러는 일반적으로 전송률이 높은 CPU와 일반적으로 전송률이 낮은 입출력장치와의 전송률 차이를 데이터 버퍼일으로 완화합니다.

3️⃣ 장치 컨트롤러의 내부 구조.

이번에는 장치 컨트롤러의 간략화된 내부 구조를 살펴봅시다.

장치 컨트롤러 내부는 아래와 같습니다.

실제로는 이보다 복잡하지만, 기억해야 하는 것은 데이터 레지스터(data register) 와 상태 레지스터(status register), 제어 레지스터(control register) 세 가지 입니다.



데이터 레지스터는 CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터입니다.

앞서 장치 컨트롤러는 데이터 버퍼링으로 전송률 차이를 완화한다고 했습니다.

데이터 레지스터가 그 버퍼 역할을 합니다.

최근 주고받은 데이터가 많은 입출력장치에서는 레지스터 대신 RAM을 사용하기도 합니다.

상태 레지스터에는 입출력장치가 입출력 작업을 할 준비가 되었는지, 입출력 작업이 완료되었는지, 입출력장치에 오류는 없는지 등의 상태 정보가 저장됩니다.

제어 레지스터는 입출력장치가 수행할 내용에 대한 제어 정보와 명령을 저장합니다.

이 레지스터들에 담긴 값들은 버스를 타고 CPU나 다른 입출력장치로 전달되기도 하고, 장치 컨트롤러에 연결된 입출력장치로 전달됩니다.

2️⃣ 장치 드라이버

새로운 장치를 컴퓨터에 연결하려면 장치 드라이버를 설치해야 합니다.

1️⃣ 장치 드라이버

장치 드라이버(device driver) 란 장치 컨트롤러의 동작을 감지하고 제어함으로써 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램입니다.

프로그램이기에 당연히 실행 과정에서 메모리에 저장됩니다.

장치 컨트롤러가 입출력장치를 연결하기 위한 하드웨어적인 통로라면, 장치 드라이버는 입출력장치를 연결하기 위한 소프트웨어적인 통로입니다.



컴퓨터가 연결된 장치의 드라이버를 인식하고 실행할 수 있다면 그 장치는 어떤 회사에서 만들어진 제품이든, 생김새가 어떻든 상관없이 컴퓨터 내부와 정보를 주고받을 수 있습니다.

반대로 장치 드라이버를 인식하거나 실행할 수 없는 상태라면 그 장치는 컴퓨터 내부와 정보를 주고받을 수 없습니다.


  장치 드라이버를 인식하고 실행하는 주체

  장치 드라이버를 인식하고 실행하는 주체는 정확히 말하자면 윈도우, macOS와 같은 운영체제입니다.
즉, 운영체제가 장치드라이버를 인식하고 실행할 수 있다면 그 장치는 컴퓨터 내부와 정보를 주고받을 수 있습니다.

  장치 드라이버는 운영체제가 기본으로 제공하는 것도 있지만, 장치 제작자가 따로 제공하기도 합니다.
물론 장치 제작자가 장치 드라이버를 따로 제공하는 경우 입출력장치는 해당 드라이버를 직접 설치해야만 사용이 가능합니다.


3️⃣ 키워드로 정리하는 핵심 포인트

  입출력장치는 장치 컨트롤러 를 통해 컴퓨터 내부와 정보를 주고받습니다.
  장치 드라이버는 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-25-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-25-TIL.html"><h1 class="title_post">📝 [TIL] 240525 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-25-TIL.html" class="txt_post">
                            
  해시 테이블(Hash Table)
  해시 맵 정리


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-25-HashTable.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-25-HashTable.html"><h1 class="title_post">📦[DS,Algorithm] 해시 테이블(Hash Table)</h1></a>
                        <a href="/Backend/AnD/2024-05-25-HashTable.html" class="txt_post">
                            1️⃣ 해시 테이블(Hash Table).

해시 테이블(Hash Table)은 데이터를 키-값 쌍(key-value pairs)으로 저장하는 자료구조입니다.

해시 테이블은 해시 함수를 사용하여 키를 해시 값으로 변환하고, 이 해시 값을 인덱스로 사용하여 배열에서 값을 저장하거나 검색합니다.

이를 통해 데이터에 빠르게 접근할 수 있습니다.

1️⃣ 해시 테이블의 구성 요소.


  
    키(key) : 각 데이터를 식별하기 위한 고유한 식별자입니다.
  
  
    값(Value) : 키와 연관된 데이터입니다.
  
  
    해시 함수(Hash Function) : 키를 입력으로 받아 해시 값을 출력하는 함수입니다. 이 해시 값은 보통 정수이며, 배열의 인덱스로 사용됩니다.
  
  
    버킷(Bucket) : 해시 값에 의해 인덱싱되는 배열의 각 위치입니다. 각 버킷은 하나의 키-값 쌍 또는 충돌 처리를 위한 데이터 구조(예: 연결 리스트)를 저장할 수 있습니다.
  


2️⃣ 해시 함수의 역할.

해시 함수는 키를 고정된 크기의 해시 값으로 매핑합니다.

이상적인 해시 함수는 키를 균등하게 분포시키고, 충돌을 최소화합니다.

3️⃣ 충동(Collision)과 충돌 해결 방법.

두 개 이상의 키가 동일한 해시 값을 가질 때 충돌이 발생합니다.

해시 테이블은 이러한 충돌을 처리하기 위한 여러가지 방법을 제공합니다.


  
    체이닝(Chaining) : 각 버킷에 연결 리스트를 사용하여 동일한 해시 값을 갖는 모든 요소를 저장합니다. 충돌이 발생하면 해당 버킷의 리스트에 요소를 추가합니다.
  
  
    개방 주소법(Open Addressing) : 충돌이 발생하면 다른 빈 버킷을 찾아 데이터를 저장합니다. 이를 위해 다양한 탐사 방법(예: 선형 탐사, 제곱 탐사, 이중 해싱)을 사용합니다.
  


4️⃣ 해시 테이블의 시간 복잡도.


  검색(Search) : O(1)(평균), O(n)(최악)
  삽입(Insertion) : O(1)(평균), O(n)(최악)
  삭제(Deletion) : O(1)(평균), O(n)(최악)


최악의 경우 시간 복잡도는 해시 충돌로 인해 모든 요소가 하나의 버킷에 저장될 때 발생합니다.

그러나, 좋은 해시 함수와 충돌 해결 방법을 사용하면 평균적으로 O(1)의 성능을 유지할 수 있습니다.

5️⃣ 해시 테이블의 장점과 단점.

장점

  빠른 검색, 삽입, 삭제 성능(평균적으로 O(1))
  키를 사용하여 데이터에 빠르게 접근 가능


단점

  해시 함수의 성능에 의존
  충돌 처이 필요
  메모리 사용량이 증가할 수 있슴(특히 체이닝을 사용하는 경우)


💻 해시 테이블의 구현 예제.

아래는 Java에서 간단한 해시 테이블을 구현한 예제입니다.


// HashTable
import java.util.LinkedList;

class HashTable {
  private class HashNode {
    String key;
    String value;
    HashNode next;

    public HashNode(String key, String value) {
      this.key = key;
      this.value = value;
    }
  }

  private LinkedList&lt;HashNode&gt;[] buckets;
  private int numBuckets;
  private int size;

  public HashTable() {
    numBuckets = 10; // 버킷의 초기 크기
    buckets = new LinkedList[numBuckets];
    size = 0;

    for (int i = 0; i &lt; numBuckets; i++) {
      buckets[i] = new LinkedList&lt;&gt;();
    }
  }

  private int getBucketIndex(String key) {
    int hashCode = key.hashCode();
    int index = hashCode % numBuckets;
    return index &lt; 0 ? index * -1 : index;
  }

  public void put(String key, String value) {
    int bucketIndex = getBucketIndex(key);
    LinkedList&lt;HashNode&gt; bucket = buckets[bucketIndex];

    for (HashNode node : bucket) {
      if (node.key.equals(key)) {
        node.value = value;
        return;
      }
    }

    bucket.add(new HashNode(key, value));
    size++;
  }

  public String get(String key) {
    int bucketIndex = getBucketIndex(key);
    LinkedList&lt;HashNode&gt; bucket = buckets[bucketIndex];

    for (HashNode node : bucket) {
      if (node.key.equals(key)) {
        return node.value;
      }
    }
    return null;
  }

  public String remove(String key) {
    int bucketIndex = getBucketIndex(key);
    LinkedList&lt;HashNode&gt; bucket = buckets[bucketIndex];

    HashNode prev = null;
    for (HashNode node : bucket) {
      if (node.key.equals(key)) {
        if (prev != null) {
          prev.next = node.next;
        } else {
          bucket.remove(node);
        }
        size--;
        return node.value;
      }
      prev = node;
    }
    return null;
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size == 0;
  }
}

// Main
public class Main {
  public static void main(String[] args) {
    HashTable hashTable = new HashTable();
    hashTable.put("one", "1");
    hashTable.put("two", "2");
    hashTable.put("three", "3");

    System.out.println("Value for key 'one': " + hashTable.get("one"));
    System.out.println("Value for key 'two': " + hashTable.get("two"));
    System.out.println("Removing key 'one': " + hashTable.remove("one"));
    System.out.println("Contains key 'one': " + (hashTable.get("one") != null));
  }
}

/*
출력
Value for key 'one': 1
Value for key 'two': 2
Removing key 'one': 1
Contains key 'one': false
*/


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-24-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-24-TIL.html"><h1 class="title_post">📝 [TIL] 240524 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-24-TIL.html" class="txt_post">
                            
  배열 문제 풀이
  배열 정리
  해시(Hash)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-24-Hash.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-24-Hash.html"><h1 class="title_post">📦[DS,Algorithm] 해시(Hash)</h1></a>
                        <a href="/Backend/AnD/2024-05-24-Hash.html" class="txt_post">
                            1️⃣ 해시(Hash).

해시(Hash)란 컴퓨터 과학에서 주어진 입력 데이터를 고정된 크기의 고유한 값(일반적으로 숫자)으로 변환하는 과정 또는 그 결과 값을 말합니다.

해시는 주로 데이터 검색, 데이터 무결성 검증, 암호화 등에 사용됩니다.

1️⃣ 해시의 개념.


  해시 함수(Hash Function)
    
      임의의 길이를 가진 데이터를 고정된 길이의 해시 값으로 변환하는 함수입니다.
      해시 함수는 동일한 입력에 대해 항상 동일한 해시 값을 생성해야 하며, 서로 다른 입력에 대해서는 가능한 한 다른 해시 값을 생성해야 합니다.
    
  
  해시 값(Hash Value)
    
      해시 함수를 통해 생성된 고정된 크기의 출력 값입니다.
        
          이를 해시 코드(Hash Code) 또는 다이제스트(Digest)라고도 합니다.
        
      
    
  


2️⃣ 해시 함수의 특징.


  
    결정성(Deterministic) : 동일한 입력에 대해 항상 동일한 해시 값을 반환합니다.
  
  
    효율성(Efficiency) : 해시 함수는 입력 데이터를 빠르게 처리하여 해시 값을 생성해야 합니다.
  
  
    충돌 저항성(Collision Resistance) : 서로 다른 두 입력이 동일한 해시 값을 갖지 않도록 해야 합니다. 현실적으로 완벽한 충돌 저항성은 불가능하므로, 가능한 충돌을 최소화하는 것이 중요합니다.
  
  
    역상 저항성(Pre-image Resistance) : 해시 값을 통해 원해의 입력 데이터를 유추하는 것이 어렵거나 불가능해야 합니다.
  
  
    두 번째 역상 저항성(Second Pre-image Resitance) : 특정 입력과 동일한 해시 값을 갖는 또 다른 입력을 찾는 또 다른 입력을 찾는 것이 어려워야 합니다.
  


3️⃣ 해시 함수의 용도.


  
    데이터 검색 : 해시 테이블(Hash Table)과 같은 자료구조에서 빠른 데이터 검색을 위해 사용됩니다.
  
  
    데이터 무결성 검증 : 데이터가 변경되지 않았음을 확인하기 위해 해시 값을 사용합니다. 예를 들어, 파일의 해시 값을 비교하여 파일이 손상되지 않았음을 확인할 수 있습니다.
  
  
    암호화 및 보안 : 패스워드 저장, 디지털 서명, 메시지 인증 코드(MAC) 등에서 데이터의 무결성과 기밀성을 보장하기 위해서 사용됩니다.
  


4️⃣ 해시 함수의 예

  
    SHA-256(Secure Hash Algorithm 256-bit) : 256비트의 해시 값을 생성하는 암호화 해시 함수입니다.
  
  
    MD5(Message Digest Algorithm 5) : 128비트의 해시 값을 생성하는 해시 함수로, 현재는 충돌 저항성의 취약성 때문에 보안 용도로는 권장되지 않습니다.
  
  
    CRC32(Cyclic Redundancy Check 32-bit) : 데이터 전송 오류 검출을 위해 사용되는 32비트 해시 함수입니다.
  


🙋‍♂️ 주요 포인트 요약

  
    해시(Hash) 는 데이터를 고정된 크기의 고유한 값으로 변환하는 과정입니다.
  
  
    해시 함수는 빠르고 효율적으로 해시 값을 생성하며, 충돌을 최소화하고 역상을 예측할 수 없도록 설계되어야 합니다.
  
  
    해시 함수는 데이터 검색, 무결성 검증, 암호화 등 다양한 용도로 사용됩니다.
  


💻 해시 함수의 예제 코드

아래는 Java에서 SHA-256 해시 함수를 사용하여 문자열의 해시 값을 생성하는 예제입니다.
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Main {

  public static void main(String[] args) {
    String input = "Hello World!";

    try {
      // SHA-256 해시 함수 인스턴스 생성
      MessageDigest digest = MessageDigest.getInstance("SHA-256");

      // 입력 문자열의 해시 값 계산
      byte[] hash = digest.digest(input.getBytes());

      // 해시 값을 16진수 문자열로 변환하여 출력
      System.out.println("Hash value: " + bytesToHex(hash));
    } catch (NoSuchAlgorithmException e) {
      e.printStackTrace();
    }
  }

  // 바이트 배열을 16진수 문자열로 변환하는 함수
  private static String bytesToHex(byte[] bytes) {
    StringBuilder hexString = new StringBuilder();

    for (byte b : bytes) {
      String hex = Integer.toHexString(0xff &amp; b);

      if (hex.length() == 1) hexString.append('0');
      hexString.append(hex);
    }
    return hexString.toString();
  }
}


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-23-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-23-TIL.html"><h1 class="title_post">📝 [TIL] 240523 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-23-TIL.html" class="txt_post">
                            
  큐(Queue)
  원형 큐(Circular Queue)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-23-circularQueue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-23-circularQueue.html"><h1 class="title_post">📦[DS,Algorithm] 원형 큐(Circular Queue)</h1></a>
                        <a href="/Backend/AnD/2024-05-23-circularQueue.html" class="txt_post">
                            1️⃣ 원형 큐(Circular Queue).

원형 큐(Circular Queue)란, “고정된 크기의 배열” 을 사용하여 구현된 큐로서, 배열의 끝에 도달하면 다시 배열의 시작 부분으로 돌아가는 구조를 가진 큐입니다.

이를 통해 큐가 꽉 차 있는지, 비어 있는지를 효율적으로 관리할 수 있으며, 공간을 효율적으로 사용할 수 있습니다.

1️⃣ 원형 큐의 특징.

  
    
      선입선출(FIFO, First In First Out) : 일반적인 큐와 마찬가지로 먼저 들어간 데이터가 먼저 나오는 구조입니다.
    
  
  
    
      순환 구조 : 배열의 끝에 도달하면 다시 처음으로 돌아갑니다. 이를 통해 고정된 크기의 배열을 이용하여 메모리를 효율적으로 사용합니다.
    
  
  3 고정 크기 : 큐의 최대 크기는 배열의 크기로 제한 됩니다.


2️⃣ 원형 큐의 주요 연산.

  
    
      Enqueue : 큐의 뒤쪽(rear)에 새로운 요소를 추가합니다.
    
  
  
    
      Dequeue : 큐의 앞쪽(front)에서 요소를 제거하고 반환합니다.
    
  
  
    
      Peek : 큐의 앞쪽(front) 요소를 제거하지 않고 반환합니다.
    
  
  
    
      IsEmpty : 큐가 비어 있는지 여부를 확인합니다.
    
  
  
    
      IsFull : 큐가 가득 찼는지 여부를 확인합니다.
    
  


3️⃣ 원형 큐의 장점.

  메모리 효율성 : 고정된 크기의 배열을 사용하여 메모리를 효율적으로 사용합니다.
  연속된 메모리 사용 : 배열을 사용하여 메모리를 연속적으로 사용하므로 캐시 효율성이 높습니다.


4️⃣ 원형 큐의 단점.

  고정 크기 제한 : 크기가 고정되어 있으므로, 큐가 가득 찬 경우 더 이상 요소를 추가할 수 없습니다. 이 문제를 해결하려면 동적으로 크기를 조절할 수 있는 방법을 추가로 구현해야 합니다.


5️⃣ 원형 큐의 구현 예제

// CircularQueue
public class CircularQueue {
  private int[] queue;
  private int front;
  private int rear;
  private int size;
  private int capacity;

  // 원형 큐 초기화
  public CircularQueue(int capacity) {
    this.capacity = capacity;
    queue = new int[capacity];
    front = 0;
    rear = -1;
    size = 0;
  }

  // 큐에 요소 추가
  public void enqueue(int element) {
    if (isFull()) {
      System.out.println("Queue is full");
      return;
    }

    rear = (rear + 1) % capacity;
    queue[rear] = element;
    size++;
  }

  // 큐에서 요소 제거 및 반환
  public int dequeue() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }
    int element = queue[front];
    front = (front + 1) % capacity;
    size--;
    return element;
  }

  // 큐의 앞쪽 요소 반환
  public int peek() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }
    return queue[front];
  }

  // 큐가 비어 있는지 확인
  public boolean isEmpty() {
    return size == 0;
  }

  // 큐가 가득 찼는지 확인
  public boolean isFull() {
    return size == capacity;
  }

  // 큐의 크기 반환
  public int getSize() {
    return size;
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    CircularQueue circularQueue = new CircularQueue(5);

    circularQueue.enqueue(1);
    circularQueue.enqueue(2);
    circularQueue.enqueue(3);
    circularQueue.enqueue(4);
    circularQueue.enqueue(5);

    System.out.println("Dequeue: " + circularQueue.dequeue());
    System.out.println("Dequeue: " + circularQueue.dequeue());

    circularQueue.enqueue(6);
    circularQueue.enqueue(7);

    System.out.println("Peek: " + circularQueue.peek());

    while (!circularQueue.isEmpty()) {
      System.out.println("Dequeue: " + circularQueue.dequeue());
    }
  }
}

// 출력
/*
Dequeue: 1
Dequeue: 2
Peek: 3
Dequeue: 3
Dequeue: 4
Dequeue: 5
Dequeue: 6
Dequeue: 7
 */


코드 설명.


  
    
      CircularQueue 클래스:
        
          ‘queue’ : 큐를 저장하는 배열.
          ‘front’ : 큐의 앞쪽 인덱스.
          ‘rear’ : 큐의 뒤쪽 인덱스.
          ‘size’ : 현재 큐에 저장된 요소의 개수.
          ‘capacity’ : 큐의 최대 크기.
        
      
    
  
  
    
      메서드:
        
          ‘enqueue(int element)’ : 큐가 가득 차지 않았으면 요소를 큐에 추가합니다.
          ‘dequeue()’ : 큐가 비어 있지 않으면 큐의 앞쪽 요소를 제거하고 반환합니다.
          ‘peek()’ : 큐의 앞쪽 요소를 제거하지 않고 반환합니다.
          ‘isEmpty()’ : 큐가 비어 있는지 확인합니다.
          ‘isFull()’ : 큐가 가득 찼는지 확인합니다.
          ‘getSize()’ : 큐의 현재 크기를 반환합니다.
        
      
    
  
  
    
      main 메서드:
        
          원형 큐를 생성하고 여러 연산을 수행하여 큐의 동작을 테스트합니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-23-Queue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-23-Queue.html"><h1 class="title_post">📦[DS,Algorithm] 큐(Queue)</h1></a>
                        <a href="/Backend/AnD/2024-05-23-Queue.html" class="txt_post">
                            1️⃣ 큐(Queue)

큐(Queue)는 컴퓨터 과학에서 흔히 사용되는 자료구조 중 하나로, 선입선출(FIFO, First In First Out) 방식으로 동작합니다.

즉, 큐에 먼저 들어간 데이터가 먼저 나오는 구조입니다.

큐의 주요연산.

  
    
      Enqueue : 큐의 뒤쪽(rear)에 새로운 요소를 추가합니다.
    
  
  
    
      Dequeue : 큐의 앞쪽(front)에서 요소를 제거하고 반환합니다.
    
  
  
    
      Peek 또는 Front : 큐의 앞쪽(front) 요소를 제거하지 않고 반환합니다.
    
  
  
    
      IsEmpty : 큐가 비어 있는지 여부를 확인합니다.
    
  


큐가 유용하게 사용되는 상황.

  프린터 대기열 : 인쇄 작업을 순서대로 처리합니다.
  프로세스 스케줄링 : 운영 체제에서 프로세스들이 CPU 시간을 얻기 위해 대기하는 순서를 유지합니다.
  너비 우선 탐색(BFS) : 그래프 탐색 알고리즘에서 각 노드를 방문할 순서를 유지합니다.


큐의 구현.
큐는 배열이나 연결 리스트를 사용하여 구현할 수 있습니다.

배열을 사용한 큐 구현 예제
public class QueueArray {
  private int[] elements;
  private int front;
  private int rear;
  private int size;
  private int capacity;

  public QueueArray(int capacity) {
    this.capacity = capacity;
    elements = new int[capacity];
    front = 0;
    rear = -1;
    size = 0;
  }

  // 큐에 요소 추가
  public void enqueue(int element) {
    if (size == capacity) {
      System.out.println("Queue is full");
      return;
    }

    rear = (rear + 1) % capacity;
    elements[rear] = element;
    size++;
  }

  // 큐에서 요소 제거 및 반환
  public int dequeue() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }

    int element = elements[front];
    front = (front + 1) % capacity;
    size--;
    return element;
  }

  // 큐의 앞쪽 요소 반환
  public int peek() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }
    return  elements[front];
  }

  // 큐가 비어 있는지 확인
  public boolean isEmpty() {
    return size == 0;
  }

  // 큐의 크기 반환
  public int getSize() {
    return size;
  }
}

// Main 클래스
public class Main {

  public static void main(String[] args) {
    QueueArray queue = new QueueArray(5);

    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);

    System.out.println("Front element: " + queue.peek());
    System.out.println("Dequeue element: " + queue.dequeue());
    System.out.println("Front element after dequeue: " + queue.peek());

    queue.enqueue(4);
    queue.enqueue(5);
    queue.enqueue(6);

    while (!queue.isEmpty()) {
      System.out.println("Dequeued element: " + queue.dequeue());
    }
  }
}

// 출력
/*
Front element: 1
Dequeue element: 1
Front element after dequeue: 2
Dequeued element: 2
Dequeued element: 3
Dequeued element: 4
Dequeued element: 5
Dequeued element: 6
 * /


연결 리스트를 사용한 큐 구현 예제
// Node
public class Node {
  int data;
  Node next;

  public Node(int data) {
    this.data = data;
    this.next = null;
  }
}

// QueueLinkedList
public class QueueLinkedList {
  private Node front;
  private Node rear;
  private int size;

  public QueueLinkedList() {
    front = null;
    rear = null;
    size = 0;
  }

  // 큐에 요소 추가
  public void enqueue(int data) {
    Node newNode = new Node(data);

    if (rear != null) {
      rear.next = newNode;
    }
    rear = newNode;

    if (front == null) {
      front = newNode;
    }
    size++;
  }

  // 큐에서 요소 제거 및 반환
  public int dequeue() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }

    int data = front.data;
    front = front.next;

    if (front == null) {
      rear = null;
    }
    size--;
    return data;
  }

  // 큐의 앞쪽 요소 반환
  public int peek() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }
    return front.data;
  }

  // 큐가 비어 있는지 확인
  public boolean isEmpty() {
    return front == null;
  }

  // 큐의 크기 반환
  public int getSize() {
    return size;
  }
}

// Main 클래스
public class Main {

  public static void main(String[] args) {
    QueueLinkedList queue = new QueueLinkedList();

    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);

    System.out.println("Front element: " + queue.peek());
    System.out.println("Dequeue element: " + queue.dequeue());
    System.out.println("Front element after dequeue: " + queue.peek());

    queue.enqueue(4);
    queue.enqueue(5);

    while (!queue.isEmpty()) {
      System.out.println("Dequeued element: " + queue.dequeue());
    }
  }
}

// 출력
/*
Front element: 1
Dequeue element: 1
Front element after dequeue: 2
Dequeued element: 2
Dequeued element: 3
Dequeued element: 4
Dequeued element: 5
 * /


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-05-22-VariousAuxiliaryMemoryDevices.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-05-22-VariousAuxiliaryMemoryDevices.html"><h1 class="title_post">💾 [CS] 다양한 보조기억장치</h1></a>
                        <a href="/2024/CS/2024-05-22-VariousAuxiliaryMemoryDevices.html" class="txt_post">
                            다양한 보조기억장치

보조기억장치에는 다양한 종류가 있습니다.

그중 가장 태중적인 보조기억장치는 하드 디스크와 플래시 메모리입니다.

우리가 흔히 사용하는 USB 메모리, SD 카드, SSD 같은 저장 장치를 말합니다.

하드 디스크(HDD: Hard Disk Drive)

하드 디스크(HDD: Hard Disk Drive) 는 자기적인 방식으로 데이터를 저장하는 보조기억장치입니다.

이 때문에 하드 디스크를 자기 디스크(magnetic disk) 의 일종으로 지칭하기도 합니다.

대용향 저장 장치가 필요한 작업이나 서버실에 자주 출입하는 작업을 한다면 하드 디스크를 자주 접하게 될 겁니다.

하드 디스크의 생김새.

다음 그림이 바로 하드 디스크입니다.

우리가 아는 CD나 옛날 음향 장치는 LP가 떠오를 겁니다.

실제로도 하드 디스크는 CD나 LP와 비슷하게 동작합니다.

동그란 원판에 데이터를 저장하고, 그것을 회전시켜 뾰족한 리더기로 데이터를 읽는 점에서 비슷합니다.



하드 디스크에서 실질적으로 데이터가 저장되는 곳은 아래 그림 속 동그란 원판입니다.

이를 플래터(platter) 라고 합니다.

하드 디스크는 자기적인 방식으로 데이터를 저장합니다.

플래터는 자기 물질로 덮여 있어 수많은 N극과 S극을 저장합니다.

N극과 S극은 0과 1의 역할을 수행합니다.

그 플래터를 회전시키는 구성 요소를 스핀들(spindle) 이라고 합니다.

스핀들이 플래터를 돌리는 속도는 분당 회전수를 나타내는 RPM(Revolution Per Minute) 이라는 단위로 표현됩니다.

가령 RPM이 15,000인 하드 디스크는 1분에 15,000바퀴를 회전하는 하드 디스크입니다.



플래터를 대상으로 데이터를 읽고 쓰는 구성 요소는 헤드(head) 입니다.

헤드는 플래터 위에서 미세하게 떠 있는 채로 데이터를 읽고 쓰는, 마치 바늘같이 생긴 부품입니다.

그리고 헤드는 원하는 위치로 헤드를 이동시키는 디스크 암(disk arm) 에 부착되어 있습니다.

CD나 LP에 비해 하드 디스크는 훨씬 더 많은 양의 데이터를 저장해야 하므로 일반적인 여러 겹의 플래터로 이루어져 있고 플래터 양면을 모두 사용할 수 있습니다.

양면 플래터를 사용하면 위아래로 플러터당 두 개의 헤드가 사용됩니다.

이 때 일반적으로 모든 헤드는 디스크 암에 부착되어 다같이 이동합니다.



데이터가 저장되는 방법.

그럼 이제 플래터에 데이터가 어떻게 저장되는지 알아봅시다.

플래터는 트랙(track) 과 섹터(sector) 라는 단위로 데이터를 저장합니다.

아래 그림터럼 플래터를 여러 동심원으로 나누었을 때 그중 하나의 원을 트랙이라고 부릅니다.

그리고 트랙은 마치 피자처럼 여러 조각으로 나우어지는데, 이 한 조각을 섹터라고 부릅니다.

섹터는 하드 디스크의 가장 작은 전송 단위입니다.

하나의 섹터는 일반적으로 512바이트 정도의 크기를 가지고 있지만, 정확한 크기는 하드 디스크에 따라 차이가 있습니다.

일부 하드 디스크의 섹터 크기는 4,096바이트에 이르기도 합니다.



여러 겹의 플래터가 사용 될 수 있습니다.

이때 여러 겹의 플래터 상에서 같은 트랙이 위치한 곳을 모아 연결한 논리적 단위를 실린더(cyilnder) 라고 부릅니다.

쉽게 말해 한 플래터를 동심원으로 나눈 공간은 트랙, 같은 트랙끼리 연결한 원통 모양의 공간은 실린더입니다.



연속된 정보는 보통 한 실린더에 기록됩니다.

예를 들어 두 개의 플래터를 사용하는 하드 디스크에서 네 개 섹터에 걸쳐 데이터를 저장할 때는 첫 번째 플래터 윗면, 뒷면과 두 번째 플래터 윗면, 뒷면에 데이터를 저장합니다.

연속된 정보를 하나의 실린더에 기록하는 이유는 디스크 암을 움직이지 않고도 바로 데이터에 접근할 수 있기 때문입니다.



데이터에 접근하는 과정

데이터가 하드 디스크의 섹터, 트랙, 실린더에 저장된다는 것을 알았다면 저장된 데이터에 접근하는 과정을 생각해 봅시다.

하드 디스크가 저장된 데이터에 접근하는 시간은 크게 탐색 시간, 회전 지연, 전송 시간 으로 나뉩니다.


  탐색 시간(seek time) : 접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간을 의미합니다.





  회전 지연(rotational latency) : 헤드가 있는 곳으로 플래터를 회전시키는 시간을 의미합니다.





  전송 시간(transfer time) : 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간을 의미합니다.




위 시간들은 별것 아닌 것 같아도 성능에 큰 영향을 끼치는 시간입니다.

일례로 구글의 AI를 주도하고 있는 제프 딘은 과거 ‘프로그래머가 꼭 알아야 할 컴퓨터 시간들’을 공개한 바 있는데, 일부를 발췌하면 다음과 같습니다.



물론 2011년에 자료가 공개된 이후 오늘날 하드 디스크 성능은 많이 향상되었지만, 하드 디스크에서 다량의 데이터를 탐색하고 읽어 들이는 시간은 생각보다 어마어마하다는 사실을 쉽게 짐작할 수 있습니다.

탐색 시간과 회전 지연을 단축시키기 위해서는 플래터를 빨리 돌려 RPM을 높이는 것도 중요하지만, 참조 지역성, 즉 접근하려는 데이터가 플래터 혹은 헤드를 조금만 옮겨도 접근할 수 있는 곳에 위치해 있는 것도 중요합니다.



플래시 메모리

하드 디스크는 최근에 많이 사용하는 보조기억장치이지만, 플래시 메모리(flush memory) 기반의 보조기억장치 또한 많이 사용합니다.

우리가 흔히 사용하는 USB 메모리, SD 카드, SSD가 모두 플래시 메모리 가반의 보조기억장치입니다.

플래시 메모리 내부.

다음 그림에서 붉은 박스로 표기한 부분이 플래시 메모리입니다.



플래시 메모리는 전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반의 저장 장치입니다.

사실 플래시 메모리는 보조기억장치 범주에만 속한다기보다는 다양한 곳에서 널리 사용하는 저장 장치로 보는 것이 옳습니다.

주기억장치 중 하나인 ROM에도 사용되고, 우리가 일상적으로 접하는 거의 모든 전자 제품안에 플래시 메모리가 내장되어 있다고 봐도 무방합니다.


  두 종류의 플래시 메모리

  플래시 메모리에는 크래 NAND 플래시 메모리 와 NOR 플래시 메모리 가 있습니다.
NAND 플래시와 NOR 플래시는 각각 NAND 연산을 수행하는 회로(NAND 게이트)와 NOR 연산을 수행하는 회로(NOR 게이트)를 기반으로 만들어진 메모리를 뜻합니다. 
이 둘 중 대용량 저장 장치로 많이 사용되는 플래시 메모리는 NAND 플래시 메모리 입니다.


플래시 메모리에는 셀(cell) 이라는 단위가 있습니다.

셀이란 플래시 메모리에서 데이터를 저장하는 가장 작은 단위입니다.

이 셀이 모이고 모여 MB, GB, TB 용량을 갖는 저장 장치가 되는 것입니다.

이 때 하나의 셀에 몇 비트를 저장할 수 있느냐에 따라 플래시 메모리 종류가 나뉩니다.

한 셀에 1비트를 저장할 수 있는 플래시 메모리를 SLC(Single Level Cell) 타입,

한 셀에 2비트를 저장할 수 있는 플래시 메모리를 MLC(Multiple Level Cell) 타입,

한 셀에 4비트를 저장할 수 있는 플래시 메모리를 TLC(Triple-Level Cell) 타입이라고 합니다.

큰 차이가 아닌 것처럼 보여도 이는 플래시 메모리의 수명, 속도, 가격에 큰 영향을 끼칩니다.

참고로 한 셀에 4비트를 저장할 수 있는 QLC 타입도 있습니다.


  플래시 메모리도 수명이 있나요?

  플래시 메모리에는 수명이 있습니다.
플래시 메모리 뿐만 아니라 하드 디스크 또한 수명이 있습니다.
우리가 사용하는 USB 메모리, SSD, SD 카드는 수명이 다하면 더 이상 저장 장치로써 사용이 불가능합니다.
종이에 연필로 쓰고 지우개로 지우고를 반복하다 보면 결국 종이가 찢어지는 것처럼 한 셀에 일정 횟수 이상 데이터를 쓰고 지우면
그 셀은 더 이상 데이터를 저장할 수 없기 때문입니다.


SLC, MLC, TCL 타입의 특징과 차이점.

사람 한 명을 비트, 셀을 집에 비유하면 SLC 타입은 한 집에 한 명, MLC 타입은 한 집에 두 명, TLC 타입은 세 명이 사는 구조로 비유할 수 있습니다.

SLC 타입

SLC 타입은 아래 그림과 같이 한 셀로 두 개의 정보를 표현할 수 있습니다.

홀로 거주하는 집에 제약 없이 출입이 가능하듯 SLC 타입은 MLC나 TLC 타입에 비해 비트의 빠른 입출력이 가능합니다.



수명도 MLC나 TLC 타입보다 길어서 수만에서 수십만 번 가까이 데이터를 쓰고 지우고를 반복할 수 있습니다.

하지만 SLC 타입은 용량 대비 가격이 높습니다.

이는 마치 혼자서 살면 감당해야 할 주거 비용이 커지는 것과 같습니다.

그렇기에 보통 기업에서 데이터를 읽고 쓰기가 매우 많이 반복되며 고성능의 빠른 저장 장치가 필요한 경우에 SLC 타입을 사용합니다.

MLC 타입

MLC 타입은 다음 그림과 같이 한 셀로 네 개의 정보를 표현할 수 있습니다.

SLC 타입보다 일반적으로 속도와 수명은 떨어지지만, 한 셀에 두 비트씩 저장할 수 있다는 점에서 MLC 타입은 SLC 타입도다 대용량화하기 유리합니다.

집의 개수가 같다면 한 집에 한 명씩 사는 것보다 한 집에 두 명씩 사는 것이 훨씬 더 많은 사람을 수용할 수 있는 것과 같은 이치입니다.



두 명이 한 집에서 주거 비용을 나눠 내면 혼자 감당해야 하는 주거 비용보다 저렴해지듯 MLC 타입은 SLC 타입보다 용량 대비 가격이 저렴합니다.

시중에서 사용되는 많은 플래시 메모리 저장 장치들이 MLC 타입(혹은 후술할 TLC 타입)으로 만들어집니다.

TLC 타입

한 셀당 3비트씩 저장할 수 있는 TLC 타입은 한 셀로 여덟 개의 정보를 표현할 수 있습니다.

그렇기에 대용화 하기 유리합니다.

일반적으로 SLC나 MLC 타입보다 수명과 속도가 떨어지지만 용량 대비 가격도 저렴합니다.



정리.

정리하면, 같은 용량의 플래시 메모리 저장 장치라고 할지라도 셀의 타입에 따라 수명, 가격, 성능이 다릅니다.

썻다 지우기를 자주 반복해야 하는 경우 혹은 높은 성능을 원하는 경우에는 고가의 SLC 타입을 선택하는 것이 좋고, 저가의 대용량 저장 장치를 원한다면 TLC 타입, 그 중간을 원한다면 MLC 타입의 저장 장치를 선택하는 것이 좋습니다.





플래시 메모리의 셀보다 더 큰 단위.

이제 플래시 메모리의 가장 작은 단위인 셀보다 더 큰 단위를 알아봅시다.

셀들이 모여 만들어진 단위를 페이지(page), 그리고 페이지가 모여 만들어진 단위를 블록(block) 이라고 합니다.

블록이 모여 플레인(plane), 플레인이 모여 다이(die) 가 됩니다.



플레시 메모리에서 읽기와 쓰기는 페이지 단위로 이루어 집니다.

하지만 삭제는 페이지보다 큰 블록 단위로 이루어집니다.

읽기/쓰기 단위와 삭제 단위가 다르다는 것이 플래시 메모리의 가장 큰 특징 중 하나입니다.

페이지의 상태.

페이지는 세 개의 상태를 가질 수 있습니다.

이는 각각 Free, Valid, Invalid 상태입니다.


  Free 상태 : 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태.
  Valid 상태 : 이미 유효한 데이터를 저장하고 있는 상태.
  Invalid 상태 : 쓰레기값이라 부르는 유효하지 않은 데이터를 저장하고 있는 상태.


플래시 메모리는 하드 디스크와는 달리 덮어쓰기가 불가능하여 Vaild 상태인 페이지에는 새 데이터를 저장할 수 없습니다.

플래시 메모리의 간단한 동작 예시.

플래시 메모리의 간단한 동작을 예시로 알아봅시다.

X라는 블록이 네 개의 페이지로 이루어져 있다고 가정해 보겠습니다.

그리고 그중 두 개의 페이지에는 왼쪽 아래와 같이 A와 B라는 데이터가 저장 되어 있다고 합시다.

여기서 블록 X에 새로운 데이터 C를 저장한다면 아래 그림과 같이 저장됩니다.

플래시 메모리의 읽기 쓰기 단위는 페이지이기 때문입니다.



여기서 새롭게 저장된 C와 기존에 저장되어 있던 B는 그대로 둔 채 기존의 A만을 A’로 수정하고 싶다면 플래시 메모리에서 덮어쓰기는 불가능하기 때문에 기존에 저장된 A는 Invalid 상태가 되어 더 이상 값이 유효하지 않은 쓰레기값이 되고, 새로운 A’ 데이터가 저장됩니다.

결과적으로 블록 X의 Valid 페이지는 B, C, A’가 됩니다.



그런데 여기서 문제가 있습니다.

A와 같이 쓰레기 값을 저장하고 있는 공간은 사용하지 않을 공간인데도 불구하고 용량을 차지하고 있습니다.

이는 엄연히 용량 낭비입니다.

그렇다고 A만 지울 수도 없습니다.

앞서 언급했듯이 플래시 메모리에서 삭제는 블록 단위로 수행되기 때문입니다.

그래서 최근 SSD를 비롯한 플래시 메모리는 이런 쓰레기 값을 정리하기 위해 가비지 컬렉션(Garbege Collection) 기능을 제공합니다.

가비지 컬렉션은 1. 유효한 페이지들만을 새로운 블록으로 복사한 뒤, 2. 기존의 블록을 삭제하는 기능입니다.

즉, 블록 X의 모든 유효한 페이지를 새로운 블록 T로 옮기고 블록 X를 삭제하는 것입니다.





키워드로 정리하는 핵심 포인트


  하드 디스크 의 구성요소에는 플래터, 스핀들, 헤드, 디스크 암이 있습니다.
  플래터는 트랙과 섹터로 나뉘고, 여러 플래터의 동일한 트랙이 모여 실린더를 이룹니다.
  하드 디스크의 데이터 접근 시간은 크게 탐색 시간, 회전 지연, 전송 시간으로 나뉩니다.
  플래시 메모리는 한 셀에 몇 비트를 저장할 수 있느냐에 따라 SLC, MLC, TLC로 나뉩니다.
  플래시 메모리의 읽기과 쓰기는 페이지 단위로, 삭제는 블록 단위로 이루어 집니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-05-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-22-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-22-TIL.html"><h1 class="title_post">📝 [TIL] 240522 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-22-TIL.html" class="txt_post">
                            
  다양한 보조기억장치


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-21-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-21-TIL.html"><h1 class="title_post">📝 [TIL] 240521 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-21-TIL.html" class="txt_post">
                            
  자료구조 소개
  RAID의 정의와 종류
  선형 자료구조 - 배열


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-21-linearDS-Array.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-21-linearDS-Array.html"><h1 class="title_post">📦[DS,Algorithm] 선형 자료구조 - 배열</h1></a>
                        <a href="/Backend/AnD/2024-05-21-linearDS-Array.html" class="txt_post">
                            1️⃣ 선형 자료구조 - 배열.

자료구조 관점에서 배열을 이해하고 여러 방법으로 구현 가능

1️⃣ 배열(Array).

자료구조 관점에서 배열(Array)은 동일한 타입의 데이터를 연속된 메모리 공간에 저장하는 선형 자료구조입니다.

배열은 조정된 크기를 가지며, 인덱스를 사용하여 각 요소에 빠르게 접근할 수 있는 특징이 있습니다.

배열은 가장 기본적이고 널리 사용되는 자료구조 중 하나입니다.

특징.

  고정된 크기(Fixed Size)
    
      배열은 선언 시 크기가 결정되며, 배열의 크기는 변경할 수 없습니다. 이 크기는 배열을 사용하는 동안 고정되어 있습니다.
      예: ‘int[] numbers = new int[10];‘(크기가 10인 정수형 배열)
    
  
  연속된 메모리 공간(Contiguous Memory Allocation)
    
      배열의 요소들은 메모리상에 연속적으로 배치됩니다. 이는 인덱스를 통한 빠른 접근을 가능하게 합니다.
      첫 번째 요소의 메모리 주소를 기준으로 인덱스를 사용하여 다른 요소의 주소를 계산할 수 있습니다.
    
  
  인덱스를 통한 접근(Indexing)
    
      배열의 각 요소는 인덱스를 통해 접근할 수 있습니다. 인덱스는 0부터 시작하여 배열의 크기 -1까지의 값을 가집니다.
      예: ‘numbers[0]’,’numbers[1]‘,…,’numbers[9]‘
    
  
  동일한 데이터 타입(Homogeneous Data Type)
    
      배열은 동일한 데이터 타입의 요소들로 구성됩니다. 즉, 배열 내 모든 요소는 같은 데이터 타입이어야 합니다.
      예: 정수형 배열, 문자열 배열 등.
    
  


장점.

  빠른 접근 속도(Fast Access) :
    
      인덱스를 사용하여 O(1) 시간 복잡도로 배열의 임의의 요소에 접근할 수 있습니다. 이는 배열의 주요 장점 중 하나입니다.
    
  
  간단한 구현(Simple Implementation) :
    
      배열은 데이터 구조가 간단하여 구현이 용이합니다. 기본적인 자료구조로, 다른 복잡한 자료구조의 기초가 됩니다.
    
  


단점.


  고정된 크기(Fixed Size) :
    
      배열의 크기는 선언 시 결정되며, 크기를 변경할 수 없습니다. 이는 크기를 사전에 정확히 예측하기 어려운 경우 비효율적일 수 있습니다.
    
  
  삽입 및 삭제의 비효율성(Inefficient Insertions and Deletions) :
    
      배열의 중간에 요소를 삽입하거나 삭제할 경우, 요소들을 이동시켜야 하기 때문에 O(n) 시간이 소요됩니다. 이는 큰 배열의 경우 성능 저하를 초래할 수 있습니다.
    
  
  메모리 낭비(Memory Waste) :
    
      배열의 크기를 너무 크게 설정하면 사용되지 않는 메모리가 낭비될 수 있고, 너무 작게 설정하면 충분한 데이터를 저장할 수 없습니다.
    
  


배열의 사용 예시.


  정수형 배열 선언 및 초기화
    int[] numbers = new int[5];
numbers[0] = 10;
numbers[1] = 20;
numbers[2] = 30;
numbers[3] = 40;
numbers[4] = 50;
    
  
  배열의 요소 접근
    int firstElement = numbers[0]; // 10
int lastElement = numbers[4]; // 50
    
  
  배열의 순회
    for (int i = 0; i &lt; numbers.length; i++) {
  System.out.println(numbers[i]);
}
    
  


마무리.

배열은 다양한 상황에서 기본적인 데이터 저장과 접근 방법을 제공하며, 특정 요구사항에 맞춰 다른 자료구조와 함께 사용되기도 합니다.

배열의 빠른 접근 속도와 간단한 구조 덕분에, 많은 알고리즘과 프로그램에서 핵심적인 역할을 합니다.



2️⃣ 배열 직접 구현.
// CustomArray 클래스
public class CustomArray {
  private int[] data;
  private int size;

  // 특정 용량으로 배열을 초기화하는 생성자
  public CustomArray(int capacity) {
    data = new int[capacity];
    size = 0;
  }

  // 배열의 크기를 가져오는 메서드
  public int size() {
    return size;
  }

  // 배열이 비어 있는지 확인하는 메서드
  public boolean isEmpty() {
    return size == 0;
  }

  // 특정 인덱스의 요소를 가져오는 메서드
  public int get(int index) {
    if (index &lt; 0 || index &gt;= size) {
      throw new IndexOutOfBoundsException("Index out of bounds");
    }
    return data[index];
  }

  // 특정 인덱스에 요소를 설정하는 메서드
  public void set(int index, int value) {
    if (index &lt; 0 || index &gt;= size) {
      throw new IndexOutOfBoundsException("Index out of bounds");
    }
    data[index] = value;
  }

  // 배열에 요소를 추가하는 메서드
  public void add(int value) {
    if (size == data.length) {
      throw new IllegalStateException("Array is full");
    }
    data[size] = value;
    size++;
  }

  // 특정 인덱스의 요소를 삭제하는 메서드
  public void remove(int index) {
    if (index &lt; 0 || index &gt;= size) {
      throw new IndexOutOfBoundsException("Index out of bounds");
    }

    for (int i = index; i &lt; size - 1; i++) {
      data[i] = data[i + 1];
    }
    size--;
  }

  // 모든 요소를 출력하는 메서드
  public void print() {
    for (int i = 0; i &lt; size; i++) {
      System.out.print(data[i] + " ");
    }
    System.out.println();
  }
}


설명.

  필드:
    
      ‘data’ : 실제 데이터를 저장하는 배열.
      ‘size’ : 현재 배열에 저장된 요소의 개수.
    
  
  생성자:
    
      ‘CustomArray(int capacity)’ : 초기 용량을 설정하여 배열을 초기화 합니다.
    
  
  메서드:
    
      ‘size()’ : 현재 배열에 저장된 요소의 개수를 반환합니다.
      ‘isEmpty()’ : 배열이 비어있는지 확인합니다.
      ‘get(int index)’ : 특정 인덱스의 요소를 반환합니다.
      ‘set(int index, int value)’ : 특정 인덱스의 요소를 설정합니다.
      ‘add(int value)’ : 배열의 마지막에 요소를 추가합니다.
      ‘remove(int index)’ : 특정 인덱스의 요소를 제거하고, 이후의 요소들을 앞으로 이동시킵니다.
      ‘print()’ : 배열의 모든 요소를 출력합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-21-IntroDataStructureAndAlgorithm.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-21-IntroDataStructureAndAlgorithm.html"><h1 class="title_post">📦[DS,Algorithm] 자료구조 소개</h1></a>
                        <a href="/Backend/AnD/2024-05-21-IntroDataStructureAndAlgorithm.html" class="txt_post">
                            1️⃣ 자료구조(Data Structure)

자료구조(Data Structure)는 데이터를 효율적으로 저장하고 관리하며, 이를 통해 데이터를 효율적으로 접근하고 수정할 수 있도록 하는 체계적인 방법입니다.

자료구조는 알고리즘의 성능을 최적화하고 프로그램의 효율성을 향상시키는 데 중요한 역할을 합니다.

기본 개념.

자료구조는 데이터를 저장하는 방식과 데이터를 조작하는 방법을 정의합니다.

이는 데이터를 어떻게 배열하고, 접근하고, 수정하고, 삭제할지를 규정하는 규칙과 방법의 집합입니다.

주요 목적.


  효율적인 데이터 저장 및 접근.
    
      데이터를 효율적으로 저장하여 빠르게 접근하고 검색할 수 있도록 합니다.
    
  
  데이터 수정 및 삭제 용이.
    
      데이터를 쉽게 수정하고 삭제할 수 있도록 합니다.
    
  
  알고리즘 최적화.
    
      알고리즘의 성능을 최적화하고 실행 시간을 단축시킵니다.
    
  


주요 종류.


  배열(Array)
    
      고정된 크기의 연속된 메모리 공간에 데이터를 저장합니다.
      인덱스를 사용하여 데이터에 빠르게 접근할 수 있습니다.
    
  
  연결 리스트(Linked List)
    
      각 요소가 데이터와 다음 요소를 가리키는 포인터를 포함합니다.
      동적 크기 조절이 가능하며 삽입과 삭제가 용이합니다.
    
  
  스택(Stack)
    
      후입선출(LIFO, Last In First Out) 방식으로 동작합니다.
      데이터를 삽입하는 push와 삭제하는 pop 연산을 가집니다.
    
  
  큐(Queue)
    
      선입선출(FIFO, First In First Out) 방식으로 동작합니다.
      데이터를 삽입하는 enqueue와 삭제하는 dequeue 연산을 가집니다.
    
  
  트리(Tree)
    
      계층적 구조를 가지며, 노드와 에지로 구성됩니다.
      이진 트리, 이진 탐색 트리, AVL 트리 등 다양한 형태가 있습니다.
    
  
  그래프(Graph)
    
      노드(정점)와 에지(간선)로 구성된 자료구조로, 다양한 관계를 표현할 수 있습니다.
      방향 그래프, 무방향 그래프 등이 있습니다.
    
  
  해시 테이블(Hash Table)
    
      키-값 쌍을 저장하며, 해시 함수를 사용하여 데이터에 빠르게 접근할 수 있습니다.
      충돌 해결 방법으로 체이닝과 개방 주소법이 있습니다.
    
  


응용 사례.
자료구조는 데이터베이스, 운영체제, 네트워크, 인공지능, 게임 개발 등 다양한 분야에서 중요한 역할을 합니다.
적절한 자료구조의 선택은 프로그램의 성능과 효율성을 크게 향상시킬 수 있습니다.



2️⃣ 자료구조의 분류

1️⃣ 선형 자료구조(Linear Data Structure)

선형 자료구조(Linear Data Structure)는 데이터 요소들이 순차적으로 배열된 구조를 의미합니다.

이 자료구조에서는 데이터 요소들이 직선 형태로 연결되어 있으며, 각 요소는 한 다음 요소나 이전 요소와 연결되어 있습니다.

선형 자료구조의 주요 특징인 데이터 요소들이 한 줄로 배열되어 있다는 점 입니다.

주요 선형 자료구조르는 배열, 연결 리스트, 스택, 큐 등이 있습니다.

주요 선형 자료구조.


  배열(Array)
    
      정의 : 동일한 타입의 데이터 요소들이 연속된 메모리 공간에 저장되는 자료구조입니다.
      특징 : 고정된 크기를 가지며 인덱스를 통해 데이터에 빠르게 접근할 수 있습니다.
      예시 : 정수형 배열, 문자열 배열 등.
    
  
  연결 리스트(Linked List)
    
      정의 : 각 데이터 요소가 노드로 구성되고, 각 노드는 데이터와 다음 노드를 가리키는 포인터를 포함하는 자료구조입니다.
      특징 : 동적 크기 조절이 가능하며 삽입과 삭제가 용이하지만, 인덱스를 통한 접근은 배열보다 느립니다.
      종류 : 단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트 등.
    
  
  스택(Stack)
    
      정의 : 후입선출(LIFO, Last In First Out) 방식으로 동작하는 자료구조입니다.
      특징 : 데이터 삽입(push)과 삭제(pop)이 한쪽 끝에서만 이루어집니다.
      사용 사례 : 함수 호출 스택, 역순 문자열 처리 등.
    
  
  큐(Queue)
    
      정의 : 선입선출(FIFO, First In First Out) 방식으로 동작하는 자료구조입니다.
      특징 : 데이터의 삽입(enqueue)은 한쪽 끝(후단)에서, 삭제(dequeue)는 반대쪽 끝(전단)에서 이루어집니다.
      종류 : 원형 큐, 우선순위 큐, 덱(Deque) 등.
      사용 사례 : 운영 체제의 작업 스케줄링, 프린터 대기열 등.
    
  


선형 자료구조의 특징 및 장단점.

  특징.
    
      순차적 접근이 가능하며, 데이터를 차례대로 처리할 때 유리합니다.
      메모리에서 연속적으로 배치되므로 인덱스를 통해 직접 접근할 수 있습니다.(배열의 경우)
    
  
  장점.
    
      간단하고 구현이 용이합니다.
      데이터의 삽입과 삭제가 특정 조건 하에 효율적일 수 있습니다(예: 스택, 큐)
    
  
  단점
    
      데이터 크기에 따라 메모리 낭비가 발생할 수 있습니다(배열의 경우).
      특정 요소 접근이나 삽입/삭제 시 성능이 저하될 수 있습니다(연결 리스트의 경우)
    
  


마무리.

선형 자료구조는 데이터가 순차적으로 연결되어 있어 순차적 처리에 적합하며, 프로그램의 다양한 부분에서 사용되는 기초적인 자료구조입니다.



2️⃣ 비선형 자료구조(Non-linear Data Structure)

비선형 자료구조(Non-linear Data Structure)는 데이터 요소들이 계층적 또는 그물 형태로 배열된 구조를 의미합니다.

이 자료구조에서는 데이터 요소들이 순차적으로 배열되지 않고, 하나의 요소가 여러 요소들과 연결될 수 있습니다.

주요 비선형 자료구조로는 트리(Tree)와 그래프(Graph)가 있습니다.

주요 비선형 자료구조.


  트리(Tree)
    
      정의 : 노드와 그 노드들을 연결하는 간선으로 구성된 계층적 자료구조입니다. 트리는 루트 노드에서 시작하여 자식 노드로 분기하며, 사이클이 없습니다.
      특징 : 트리는 계층적 관계를 나타내며, 각 노드는 0개 이상의 자식 노드를 가질 수 있습니다.
      종류 :
        
          이진 트리(Binary Tree) : 각 노드가 최대 두 개의 자식 노드를 가지는 트리입니다.
          이진 탐색 트리(Binary Search Tree) : 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큰 값을 가지는 이진 트리입니다.
          균형 이진 트리(Balanced Binary Tree) : AVL 트리, 레드-블랙 트리 등과 같이 높이가 균형을 이루도록 유지되는 트리입니다.
          힙(Heap) : 완전 이진 트리의 일종으로, 최대 힙과 최소 힙이 있습니다.
          트라이(Trie) : 문자열을 저장하고 빠르게 검색하기 위해 사용되는 트리입니다.
        
      
    
  
  그래프(Graph)
    
      정의 : 정점(Vertex)들과 이 정점들을 연결하는 간선(Edge)들로 구성된 자료구조입니다.
      특징 : 그래프는 방향 그래프(Directed Graph)와 무방향 그래프(Undirceted Graph)로 나눌 수 있으며, 사이클이 존재할 수 있습니다.
      종류 :
        
          방향 그래프(Directed Graph) : 간선에 방향성이 있는 그래프입니다.
          무방향 그래프(Undirected Graph) : 간선에 방향성이 없는 그래프입니다.
          가중치 그래프(Weighted Graph) : 간선에 가중치가 부여된 그래프입니다.
          비가중치 그래프(Unweighted Graph) : 간선에 가중치가 없는 그래프입니다.
        
      
    
  


비선형 자료구조의 특징 및 장단점.

  특징 :
    
      계층적 또는 네트워크 구조를 나태내는 데 적합합니다.
      복잡한 관계를 표현할 수 있으며, 데이터 요소 간의 다대다 관계를 처리할 수 있습니다.
    
  
  장점 :
    
      데이터의 계층적 구조를 쉽게 표현할 수 있습니다(트리).
      복잡한 연결 관계를 효과적으로 모델링할 수 있습니다(그래프).
      특정 유형의 탐색, 정렬, 데이터 압축, 네트워크 라우팅 등에 유용합니다.
    
  
  단점 :
    
      구현과 관리가 선형 자료구조보다 복잡할 수 있습니다.
      특정 작업(예: 트리의 균형 유지, 그래프 탐색 등)에서 추가적인 알고리즘이 필요합니다.
    
  


마무리.

비선형 자료구조는 데이터가 단순히 순차적으로 배열되지 않고, 복잡한 관계를 나타내는 경우에 사용됩니다.

예를 들어, 파일 시스템의 디렉터리 구조, 데이터베이스 인덱스, 소셜 네트워크의 사용자 관계 등이 비선형 자료구조를 활용하는 사례입니다.



2️⃣ 자료구조의 구현.

1️⃣ 추상 자료형(Abstract Data Type, ADT)

자바 프로그래밍에서의 추상 자료형(Abstract Data Type, ADT)은 데이터의 논리적 구조와 이를 조작하는 연산들을 명확하게 정의한 개념입니다.

ADT는 구현 세부 사항을 숨기고, 데이터와 연산의 인터페이스를 통해 사용자에게 추상적인 수준에서 데이터 조작을 제공합니다.

즉, ADT는 데이터가 어떻게 저장되고 구현되는지에 대한 정보는 감추고, 데이터와 상호작용하는 방법만을 정의합니다.

주요 개념


  추상화(Abstraction)
    
      ADT는 데이터를 추상화하여 데이터의 실제 구현과 독립적으로 사용될 수 있도록 합니다.
      사용자는 데이터의 저장 방식이나 연산의 구현 방법을 알 필요 없이, ADT가 제공하는 인터페이스를 통해 데이터를 조작할 수 있습니다.
    
  
  인터페이스(Interface)
    
      ADT는 데이터 타입과 이를 다루는 연산들을 인터페이스를 통해 정의합니다.
      자바에서는 인터페이스(Interface) 키워드를 사용하여 ADT의 연산을 정의할 수 있습니다.
    
  
  캡슐화(Encapsulation)
    
      ADT는 데이터와 연산을 하나의 단위로 묶어 캡슐화합니다.
      데이터를 직접 접근하지 않고, 정의된 연산을 통해서만 접근할 수 있도록 하여 데이터 무결성을 보장합니다.
    
  


자바에서의 ADT 예시

다음은 자바에서 스택(Stack) ADT를 정의하고 구현하는 예시입니다.

스택 인터페이스 정의
public interface Stack&lt;T&gt; {
    void push(T item); // 스택에 아이템을 추가
    T pop(); // 스택에서 아이템을 제거하고 반환
    T peek(); // 스택의 맨 위 아이템을 반환(제거하지 않음)
    boolean isEmpty(); // 스택이 비어 있는지 확인
    int size(); // 스택의 크기 반환
}


스택 구현
import java.util.ArrayList;
import java.util.List;

public class ArrayListStack&lt;T&gt; implements Stack&lt;T&gt; {
    private List&lt;T&gt; list = new ArrayList&lt;&gt;();
    
    @Override
    public void push(T item) {
        list.add(item);
    }
    
    @Override
    public T pop() {
        if (isEmpty()) {
            throw new RuntimException("Stack is empty");
        }
        return list.remove(list.size() - 1);
    }
    
    @Override
    public T peek() {
        if (isEmpty()) {
            throw new RuntimeException("Stack is empty");
        }
        return list.get(list.size() - 1);
    }
    
    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }
    
    @Override
    public int size() {
        return list.size();
    }
}


설명

  
    ‘Stack&lt;T&gt;‘ 인터페이스는 스택 ADT의 연산을 정의합니다. 이 인터페이스는 ‘push’, ‘pop’, ‘peek’, ‘isEmpty’, ‘size’ 메서드를 포함합니다.
  
  ‘ArrayListStack&lt;T&gt;‘ 클래스는 ‘Stack&lt;T&gt;‘ 인터페이스를 구현합니다. 이 클래스는 ‘ArrayList’ 를 내부 데이터 구조로 사용하여 스택 연산을 구현합니다.
  ‘push’ 메서드는 스택에 아이템을 추가합니다.
  ‘pop’ 메서드는 스택에서 맨 위의 아이템을 제거하고 반환합니다.
  ‘peek’ 메서드는 스택의 맨 위 아이템을 제거하지 않고 반환합니다.
  ‘isEmpty’ 메서드는 스택이 비어 있는지 확인합니다.
  ‘size’ 메서드는 스택의 크기를 반환합니다.


이 예시에서 ‘Stack&lt;T&gt;‘ 인터페이스는 스택 ADT를 정의하고, ‘ArrayListStack&lt;T&gt;‘ 클래스는 이 ADT를 구현한 것입니다.

사용자는 ‘ArrayListStack’ 의 내부 구현을 알 필요 없이 ‘Stack’ 인터페이스를 통해 스택 연산을 사용할 수 있습니다.

이는 ADT의 주요 장점 중 하나인 구현의 독립성을 잘 보여줍니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-05-21-RAID.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-05-21-RAID.html"><h1 class="title_post">💾 [CS] RAID의 정의와 종류</h1></a>
                        <a href="/2024/CS/2024-05-21-RAID.html" class="txt_post">
                            RAID의 정의와 종류.

1TB 하드 디스크 네 개로 RAID를 구성하면 4TB 하드 디스크 한 개의 성능과 안전성을 능가할 수 있습니다.

RAID의 정의.

‘보조기억장치에도 수명이 있습니다.’ 그래서 ‘하드 디스크와 같은 보조기억장치에 어떻게든 저장만 하면 됩니다’ 와 같은 단순한 답변은 다소 부족한 해법입니다.

이럴 때 사용할 수 있는 방법 중 하나가 RAID입니다.

RAID(Redundant Array of Independent Disks) 는 주로 하드 디스크와 SSD를 사용하는 기술로, 데이트의 안정선 혹은 높은 성능을 위해 여러 개의 물리적 보조기억장치를 마치 하나의 논리적 보조기억장치처럼 사용하는 기술을 의미합니다.

RAID의 종류

RAID 구성 방법을 RAID 레벨 이라고 표현합니다.

RAID 레벨에는 대표적으로 RAID 0, RAID 1, RAID 2, RAID 3, RAID 4, RAID 5, RAID 6 이 있고 그로부터 파생된 RAID 10, RAID 50 등이 있습니다.

RAID 0

RAID 0 은 여러 개의 보조기억장치에 데이터를 잔순히 나누어 저장하는 구성 방식입니다.

가령 1TB 하드 디스크 네 개로 RAID 0을 구성했다고 가정해 봅시다.



이제 어떠한 데이터를 저장할 때 각 하드 디스크는 아래와 같이 번갈아 가며 데이터를 저장합니다,
즉, 저장되는 데이터가 하드 디스크 개수만큼 나위어 자장되는 것입니다.



이때 마치 줄무늬처럼 분산되어 저장된 데이터를 스트라입(Stripe) 이라 하고, 분산하여 저장하는 것을 스트라이핑(Striping) 이라고 합니다.

위와 같이 데이터가 분산되어 저장되면, 다시 말해 스트라이핑되면 저장된 데이터를 읽고 쓰는 속도가 빨라집니다.

하나의 대용량 저장 장치를 이용했더라면 여러 번에 걸쳐 일고 썻을 데이터를 동시에 읽고 쓸 수 있기 때문입니다.

그렇기에 4TB 저장 장치 한 개를 읽고 쓰는 속도보다 RAID 0로 구성된 1TB 저장 장치 네 개의 속도가 이론상 네 배가량 빠릅니다.



RAID 0의 단점

RAID 0에는 단점이 있습니다.

저장된 정보가 안전하지 않습니다.

RAID 0으로 구성된 하드 디스크 중 하나에 문제가 생긴다면 다른 모든 하드 디스크의 정보를 읽는 데 문제가 생길 수 있습니다.

그래서 등장한 것이 RAID 1 입니다.



RAID 1

RAID 1 은 복사본을 만드는 방식입니다.

마치 거울처럼 완전한 복사본을 만드는 구성이기에 미러링(mirroring) 이라고도 부릅니다.

아래 그림은 네 개의 하드 디스크를 RAID 1으로 구성한 모습입니다.

RAID 0처럼 데이터 스트라이핑이 사용되긴 했지만, 오른쪽의 두 하드 디스크는 마치 거울처럼 왼쪽의 두 하드 디스크와 동일한 내용을 저장하고 있습니다.

이처럼 RAID 1에 어떠한 데이터를 쓸 때는 원본과 복사본 두 군데에 씁니다.

그렇기에 쓰기 속도는 RAID 0보다 느립니다.



RAID 1 방식은 복구가 매우 간단하다는 장점이 있습니다.

똑같은 디스크가 두 개 있는 셈이니, 하나에 문제가 발생해도 잃어버린 정보를 금방 되찾을 수 있기 때문입니다.

RAID 1의 단점

RAID 1은 하드 디스크 개수가 한정되었을 때 사용 가능한 용량이 적어지는 단점이 있습니다.

위 그림만 보아도 RAID 0 구성은 4TB의 정보를 저장할 수 있는 반면, RAID 1에서는 2TB의 정보만 저장할 수 있습니다.

즉, RAID 1에서는 복사본이 만들어지는 용량만큼 사용자가 사용하지 못합니다.

결국 많은 양의 하드 디스크가 필요하게 되고, 비용이 증가한다는 단점으로 이어집니다.

RAID 4
RAID 4는 RAID 1처럼 완전한 복사본을 만드는 대신 오류를 검출하고 복구하기 위한 정보를 저장한 장치를 두는 구성 방식입니다.

이때 ‘오류를 검출하고 복구하기 위한 정보’를 패리티 비트(parity bit) 라고 합니다.

RAID 4에서는 패리티를 저장한 장치를 이용해 다른 장치들의 오류를 검출하고, 오류가 있다면 복구합니다.

이로써 RAID 4는 RAID 1보다 적은 하드 디스크로도 데이터를 안전하게 보관할 수 있습니다.




  오류를 검출하는 패리트 비트

  원래 패리트 비트는 오류 검출만 가능할 뿐 오류 복구는 불가능합니다.
하지만 RAID에서는 패리트 값으로 오류 수정도 가능합니다.
다만 구체적인 방법인 패리티 계산법은 다루지 않을 예정입니다.
여기서 다음 두 가지만 기억하면 됩니다.

  
    RAID 4에서는 패리티 정보를 저장한 장치로서 나머지 장치들의 오루를 검출.복구한다.
    패리티 비트는 본래 오류 검출용 정보지만, RAID에서는 오류 복구도 가능하다.
  


RAID 5
RAID 4에서는 어떤 새로운 데이터가 저장될 때마다 패리티를 저장하는 디스크에도 데이터를 쓰게 되므로 패리티를 저장하는 장치에 병목 현상이 발생한다는 문제가 있습니다.



RAID 5는 아래 그림처럼 패리티 정보를 분산하여 저장하는 방식으로 RAID 4의 문제인 병목 현상을 해소합니다.



RAID 6
RAID 6 의 구성은 기본적으로 RAID 5와 같으나, 다음 그림과 같이 서로 다른 두 개의 패리티를 두는 방식입니다.

이는 오류를 검출하고 복구할 수 있는 수단이 두 개가 생긴 셈입니다.

따라서 RAID 6은 RAID 4나 RAID 5보다 안전한 구성이라 볼 수 있습니다.

다만 새로운 정보를 저장할 때마다 함께 저장할 패리티가 두 개이므로, 쓰기 속도는 RAID 5보다 느립니다.

따라서 RAID 6은 데이터 저장 속도를 조금 희생하더라도 데이터를 더욱 안전하게 보관하고 싶을 때 사용하는 방식입니다.





정리

이 외에도 RAID 0과 RAID 1을 혼합한 RAID 10 방식도 있고, RAID 0과 RAID 5를 혼합한 RAID 5방식도 있습니다.


  note: 이렇게 여러 RAID 레벨을 혼합한 방식을 Nested RAID 라고 합니다.


각 RAID 레벨마다 장단점이 있으므로 어떤 상황에서 무엇을 최우선으로 원하는지에 따라 최적의 RAID 레벨은 달라질 수 있습니다.

그렇기에 각 RAID 레벨의 대략적인 구성과 특징을 아는것이 중요합니다.



키워드로 정리하는 핵심 포인트

  RAID란 데이터의 안전성 혹은 높은 성능을 위해 여러 하드 디스크나 SSD를 마치 하나의 장치저럼 사용하는 기술입니다.
  RAID 0은 데이터를 단순히 병렬로 분산하여 저장하고, RAID 1은 완전한 복사본을 만듭니다.
  RAID 4는 패리티를 저장한 장치를 따로 두는 방식이고, RAID 5는 패리티를 분산하여 저장하는 방식입니다.
  RAID 6은 서로 다른 두 개의 패리티를 두는 방식입니다.




                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-05-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-18-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-18-TIL.html"><h1 class="title_post">📝 [TIL] 240518 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-18-TIL.html" class="txt_post">
                            
  수학적 귀납법
  명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-05-18-Math.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-05-18-Math.html"><h1 class="title_post">[Math] 수학적 귀납법</h1></a>
                        <a href="/Backend/Math/2024-05-18-Math.html" class="txt_post">
                            📝 수학적 귀납법이란?
수학적 귀납법은 자연수에 대한 명제의 참 여부를 증명하는 데 사용되는 강력한 수학적 증명 기법입니다.
이를 통해 무한히 많은 경우에 대해 명제가 참임을 보일 수 있습니다.

수학적 귀납법은 주로 ‘기본 단계’ 와 ‘귀납 단계’ 로 이루어집니다.

1️⃣ 기본 단계(Base Case)
명제가 첫 번째 자연수 n = 1(또는 특정 시작점 n = k)에 대해 참임을 증명합니다.

2️⃣ 귀납 단계(Inductive Step)
명제가 임의의 자연수 n = k에 대해 참이라고 가정했을 때, n = k + 1에도 참임을 증명합니다.

이를 좀 더 형식적으로 설명하면 다음과 같습니다.


  기본 단계:
    P(1)이 참임을 증명합니다.
    
  
  귀납 단계:
    P(k)가 참이라고 가정합니다.(귀납 가정)
P(k+1)이 참임을 증명합니다.
    
  


기본 단계와 귀납 단계가 모두 성립하면, 수학적 귀납법에 의해 모든 자연수 n에 대해 명제 P(n)이 참임을 증명할 수 있습니다.

3️⃣ 예제
자연수 n에 대해 다음 명제를 증명해봅시다:
1+2+3+...+n= n(n+1)/2



  기본 단계:
n = 1일때,
    1 = 1(1+1)/2 = 2/2 = 1
    
  


따라서 P(1)은 참입니다.


  귀납 단계:
P(k)가 참이라고 가정합니다 즉,
    1+2+3+...+k = k(k+1)/2
    
    이 가정하에 P(k+1)이 참임을 증명합니다.
  


1+2+3+...+k+(k+1) = k(k+1)/2+(k+1)


우변을 정리하면,
k(k+1)/2 + (k+1) = (k(k+1)+2(k+1))/2 = ((k+1)(k+2))/2


이는 P(k+1) 입니다.

기본 단계와 귀납단계가 모두 성립했으므로, 수학적 귀납법에 의해 모든 자연수 n에 대해 1+2+3+...+n = n(n+1)/2임을 증명할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-05-18-Math-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-05-18-Math-1.html"><h1 class="title_post">[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.</h1></a>
                        <a href="/Backend/Math/2024-05-18-Math-1.html" class="txt_post">
                            1️⃣ 기하학 - 설득술로서 발전해 온 수학

1️⃣ 명제와 증명.
“필요조건” 과 “충분조건” 에 대한 이해는 모든 논리의 기초가 되는 가장 중요한 사항이라 해도 과언이 아닙니다.

수학은 논리와 떼려야 뗄 수 없는 관계라는 것은 모두가 아는 사실이지만 ‘필요’ 와 ‘충분’ 은 수학의 논리 중에서도 가장 중요한 역할을 하는 기본적인 사고방식입니다.

‘이것 없이는 어떠한 수학적 논리도 전개할 수 없다’라고 단언할 수 있을 정도입니다.

또한, ‘부정’을 이용해서 증명하는 방법인 “대우” 와 “귀류법” 의 이해도 매우 중요합니다.

대우는 얼핏 보기에도 복잡해 보이는 명제를 단순화하고, 귀류법은 정면 돌파로는 증명할 수 없는(하기 어려운) 명제를 증명할 때 큰 힘을 발휘합니다.

명제란 무엇인지 먼저 확인해 봅시다.

명제: 참과 거짓을 객관적으로 판정할 수 있는 문장이나 식


예를 들어 ‘백두산은 한국에서 가장 높은 산이다’는 명제지만 ‘백두산은 멋있다’는 명제가 아닙니다.

백두산의 높이가 한국에서 가장 높은지는 객관적으로 판정할 수 있지만, 백두산이 멋지다고 느끼는 데는 개인차가 있으며(심지어 대부분이 ‘멋지다’고 생각할지라도) 참과 거짓을 객관적으로 판단할 수 없기 때문입니다.

💡 논리적 사고의 기초: 필요조건과 충분 조건.
우선 필요조건과 충분조건의 정의를 살펴보겠습니다.


  필요조건과 충분조건의 정의

  명제 ‘P이면 Q이다’ 가 참일 때,

  P를(Q이기 위한) “충분조건”

  Q를(P이기 위한) “필요조건”

  이라고 합니다.


‘P이면 Q이다’ 에서 P를 ‘재즈’라 하고 Q를 ‘음악’이라 하면 ‘재즈는 음악이다’가 됩니다.
이는 당연히 참이므로(올바르므로) 정의에 따라

  재즈: 충분조건
  음악: 필요조건


이 됩니다.

확실히 재즈가 되기 위해서는 (적어도) 음악일 필요가 있습니다.

또한, 음악이 되기 위해서 재즈면 (넉넉하게) 충분하다고 할 수 있습니다.

재즈는 음악의 한 장르이므로 이 둘의 관계를 그림으로 표현하면 다음과 같은 모습이 됩니다.



이처럼 한쪽이 다른 한쪽을 완전히 포함하는 경우를 다음과 같이 집합으로 이해해 보는 것도 매우 중요합니다.


  영역이 더 작은 쪽(재즈): 충분조건
영역이 더 큰 쪽(음악): 필요조건


특히 두 개의 명제 ‘P이면 Q다’ 와 ‘Q이면 P다’가 모두 참일 경우에는 ‘P와 Q가 서로의 필요충분조건이다’라고 합니다. 또는 ‘P와 Q는 서로 동치다’ 라고도 합니다.


  NOTE : 실수란

  수학에서는 일반적으로 부등식의 범위를 수직선에 나타낼 때,

  등호 없는 부등호(&lt;)는 ○와 대각선

  등호 있는 부등호(≤)는 ●와 (직선에) 수직으로 뻗은 선

  으로 표기합니다.

  예를 들어 1 ≤ x &lt; 4는 다음과 같이 표기합니다.

  


우리는 보통 무언가를 고를 때, 자연스레 “필요저건에 따라 후보를 줄여 나갑니다. 그리고 충분조건을 만족하는 후보를 탐색합니다.”

예를 들어 점심 메뉴를 고를 때, ‘8,000원 안팍의 메뉴’처럼 예산이 필요조건이 사람이 적지 않을 것입니다.

거기에 ‘30분 안에 먹을 수 있는 메뉴’ 혹은 ‘깔끔한 맛’ 등의 필요조건을 더 해, 그 모든 필요조건을 만족하는 메뉴로 후보를 줄여 나갑니다.

그리고 남은 메뉴(후보)가 오늘 점심으로 괜찮은지(충분한지) 고민합니다.

그 결과(예를 들어) ‘그럼 오늘 점심은 경양식 돈까스로 하자’고 결정하는 사고방식은 매우 당연하다고 생각할 것입니다.

이처럼 필요조건과 충분조건을 구분하는 능력은 문제를 해결할 때 대단한 위력을 발휘합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-18-Troubleshooting-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-18-Troubleshooting-1.html"><h1 class="title_post">☕️[Java] 문자열 비교 - 트러블슈팅</h1></a>
                        <a href="/Backend/Java/2024-05-18-Troubleshooting-1.html" class="txt_post">
                            1️⃣ 문자열 비교.
  private static String exceptionHandleForPersonOfNationalMerit(Scanner scanner) throws InvalidCheckException {
    System.out.print("국가유공자 여부를 입력해 주세요.(y/n) :");
    String personOfNationalMerit = scanner.next();

    // 들어온 값이 y 또는 n이 아닌 경우 예외를 던집니다.
    if (personOfNationalMerit != "y" &amp;&amp; personOfNationalMerit != "n") {
      throw new InvalidCheckException("유효하지 않은 입력입니다. y 또는 n을 입력해주세요.");
    }
    return personOfNationalMerit;
  }


🤔 문제 상황.
1. 문자열 비교가 안되는 상황.

  ’==’ 연산자를 사용해서 “y” 또는 “n” 외의 다른 문자열이 들어올 경우 커스텀한 에러 를 발생시키려 했지만 정상적인 값인 “y” 와 n 을 넣어도 에러가 발생 하는 문제가 생겼습니다.


💻 트러블슈팅.
1. equals() 메소드의 사용.

자바에서는 문자열 비교를 할 때 ’==’ 연산자를 사용하는 것이 아니라 ‘equals()’ 메소드를 사용해야 합니다.

  ’==’ 연산자는 객체의 레퍼런스를 비교하기 때문에, 두 문자열이 같은 객체를 참조하는지 여부를 확인합니다.
  ‘equals()’ 메소드는 문자열의 내용을 비교합니다.


따라서, “y” 와 “n” 을 비교할 때 ’==’ 대신 ‘equals()’ 를 사용해야 합니다.

  private static String exceptionHandleForPersonOfNationalMerit(Scanner scanner) throws InvalidCheckException {
    System.out.print("국가유공자 여부를 입력해 주세요.(y/n) :");
    String personOfNationalMerit = scanner.next();

    // 들어온 값이 y 또는 n이 아닌 경우 예외를 던집니다.
    if (!personOfNationalMerit.equals("y") &amp;&amp; !personOfNationalMerit.equals("n")) {
      throw new InvalidCheckException("유효하지 않은 입력입니다. y 또는 n을 입력해주세요.");
    }
    return personOfNationalMerit;
  }


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html"><h1 class="title_post">📝[blog post] 나는 어떤 백엔드 개발자가 되고 싶은걸까?</h1></a>
                        <a href="/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html" class="txt_post">
                            🤔 나는 어떤 백엔드 개발자가 되고 싶은걸까?

🙋‍♂️ 백엔드 개발자의 역할과 책임

어떤 백엔드 개발자가 되고 싶은지 말하기 전에 백엔드 개발자는 어떤 역할과 책임이 있는지 알아보아야 할 것 같아요.

1️⃣ 웹 서버 개발.

  웹 서버 및 API 개발.
  HTTP 요청 및 응답 처리.
  RESTful 서비스 설계 및 구현.


2️⃣ 데이터베이스 관리.

  데이터베이스 설계 및 최적화.
  SQL 및 NoSQL 데이터베이스 작업.
  데이터 모델링 및 스키마 설계.


3️⃣ 서버 사이드 로직.

  비즈니스 로직 구현.
  사용자 인증 및 권한 관리.
  데이터 유효성 검사.


4️⃣ API 개발 및 통합.

  외부 API와의 통합 작업.
  내부 API 설계 및 개발.
  API 문서화 및 유지보수.


5️⃣ 성능 최적화.

  서버 성능 모니터링 및 튜닝.
  캐싱 전략 설계 및 구현.
  로드 밸런싱 및 스케일링.


6️⃣ 보안 관리.

  데이터 보안 및 암호화.
  OWASP 및 기타 보안 지침 준수.
  침입 탐지 및 대응.


7️⃣ 클라우드 컴퓨팅.

  AWS, Azure, GCP 등 클라우드 플랫폼 사용.
  클라우드 기반 서비스 배포 및 관리.
  컨테이나화 및 오케이스트레이션(Docker, Kubernetes)


8️⃣ DevOps와 CI/CD.

  지속적 통합 및 배포(CI/CD) 파이프라인 구축.
  서버 및 서비스의 자동화 및 오케스트레이션.
  인프라스트럭처 코드화(Infrastructure as Code).


9️⃣ 로그 및 모니터링.

  애플리케이션 및 서버 로그 관리.
  모니터링 도구 설정(예: Prometheus, Grafana).
  로그 분석 및 문제 해결.


백엔드 개발자는 일반적으로 이 모든 역할을 하나의 프로젝트 내에서 수행하지 않아요.
회사나 팀의 구조에 따라 특정 역할에 집중하게 된답니다.
예를 들어, 일부 개발자는 데이터베이스 관리에 중점을 두고, 다른 개발자는 클라우드 인프라 관리에 집중할 수 있습니다.

🙋‍♂️ 내가 되고 싶은 백엔드 개발자.

  
    
      맡은 역할과 책임에 최선을 다하는 개발자
        
          저는 맡은 바에 항상 최선을 다해 임무를 완수합니다.
          내가 맡은 바에는 책임이라는 것이 따르기 때문에 항상 최선을 다해야 한다고 생각합니다.
        
      
    
  
  
    
      소통을 잘하는 백엔드 개발자.
        
          커뮤니케이션이 정말 중요하다고 생각합니다.
          하나의 프로그램을 만들기 위해서는 많은 사람들이 함께 만들어가는 것 이기 때문에 함께 협력하고 소통을 잘해야 합니다.
        
      
    
  
  
    
      유연한 사고를 가진 백엔드 개발자.
        
          나 자신의 의견 또는 생각 역시도 틀릴 수 있다는 것을 항상 인지하고 여러 모든 의견을 유연하게 받아들일 수 있는 백엔드 개발자가 되고 싶습니다.
        
      
    
  
  
    
      말이 아닌 코드로 증명하는 개발자.
        
          말로만 대단한 듯이 말하는 개발자가 아닌 진짜 코드로 증명해내는 그런 백엔드 개발자가 되고 싶습니다.
        
      
    
  
  
    
      겸손과 꾸준한 성장을 하는 백엔드 개발자.
        
          겸손의 미덕을 알고 있습니다. 언제나 배움의 자세를 가지고 항상 배우려 노력하며 꾸준히 성장하는 백엔드 개발자가 되고 싶습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-17-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-17-TIL.html"><h1 class="title_post">📝 [TIL] 240517 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-17-TIL.html" class="txt_post">
                            
  연습 문제 풀이(2)
  예외 처리 - 트러블슈팅
  문자열 처리 - 트러블슈팅


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-17-PracticeSummary-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-17-PracticeSummary-2.html"><h1 class="title_post">📝[blog post] 연습 문제 풀이 정리(2)</h1></a>
                        <a href="/Backend/Post/2024-05-17-PracticeSummary-2.html" class="txt_post">
                            1️⃣ 수열과 재귀.

연습 문제를 풀다보니 수열과 재귀에 대해 많은 수학적 사고력이 필요하겠다는 생각이 들었습니다.


  수열 : 수학에서 수의 나열을 의미합니다.
    
      즉, 어떤 규착에 따라 나열된 수들의 집합을 말합니다.
      수열은 각 수를 나타내는 일련의 할(terms)으로 구성되며, 각 항은 특정 위치(index)를 가집니다.
      수열의 예로는 다음과 같은 것들이 있습니다.
        
          등차수열: 각 항이 일정한 값만큼 증가하거나 감소하는 수열(예: 2, 5, 8, 11…)(각 항이 3씩 증가)
          등비수열: 각 항이 일정한 비율로 증가하거나 감소하는 수열(예: 3, 9, 27, 81…)(각 항이 이전 항의 3배)
          피보나치 수열: 첫 두 항이 0과 1이고, 그 이후의 각 항이 바로 앞 두항의 합인 수열(예: 0, 1, 1, 2, 3, 5, 8….)
            
              수열은 다양한 수학적 문제를 해결하는 데 사용되며, 특히 함수, 극한, 미적분 등의 주제와 밀접한 관련이 있습니다.
            
          
        
      
    
  
  재귀 : 프로그래밍과 수학에서 사용되는 개념으로, 어떤 함수나 알고리즘이 자기 자신을 호출하는 방식울 말합니다.
    
      재귀를 통해 복잡한 문제를 더 작은 하위 문제로 나누어 해결할 수 있습니다.
      재귀 함수는 기본적으로 두 가지 부분으로 구성됩니다.
        
          1. 기저 조건(Base Case) : 재귀 호출이 더 이상 필요하지 않은 경우를 정의합니다. 기저 조건이 충족되면 함수는 더 이상 자기 자신을 호출하지 않고 종료됩니다.
          2. 재귀 호출(Recursive Call) : 함수가 자기 자신을 호출하여 문제를 더 작은 부분으로 나누어 해결하려고 시도합니다.
            
              재귀는 문제를 단순하고 직관적으로 표현할 수 있는 강력한 도구이지만, 재귀 호출이 과도하면 스택 오버플로(stack overflow)가 발생할 수 있으므로 주의가 필요합니다.
                
                  따라서 재귀를 사용할 때는 기저 조건을 잘 정의하고, 필요할 경우 반복(iteration)으로 문제를 해결하는 방법도 고려해야 합니다.
                
              
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html"><h1 class="title_post">☕️[Java] 예외 처리 - 트러블슈팅</h1></a>
                        <a href="/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html" class="txt_post">
                            1️⃣ 예외 처리.

실제 코드를 작성하면서 예외 처리에 대한 문제를 맞닥뜨려 어떻게 해야 할지 고민하다 다음과 같이 풀어보았습니다.

  private static int enterTheAge(Scanner scanner) {
    while (true) {
      try {
        System.out.print("나이를 입력해 주세요.(숫자): ");
        int age = scanner.nextInt();
        return age;
      } catch (InputMismatchException e) {
        System.out.println("숫자를 입력해 주세요.");
        scanner.next();
      }
    }
  }


🤔 문제 상황.
1. 나이는 숫자만 입력되어야 한다.

  숫자가 아닌 것들이 들어왔을 경우 예외 처리를 해줘서 다시 유저가 나이를 입력할 수 있게끔 하도록 만드는 과정에서 문제 상황이 발견되었습니다.


💻 트러블슈팅.
1. while 반복문의 사용.

  while (true) 를 사용하여 무한 루프를 돌려 내부에서 숫자가 아니면 다시금 유저가 “유효하지 않은 입력입니다” 라는 예외 처리 출력문을 받고 “나이를 입력해 주세요” 라는 원래의 출력문을 받을 수 있도록 했습니다.


2. try-catch 문의 사용.

  try-catch 문을 사용하여 Scanner 클래스 메소드를 사용할 때 발생하는 예외중, 사용자가 기대하는 타입의 입력을 제공하지 않았을 때 던져지는 InputMismatchException 를 catch 문에 넣어주어 이 예외가 발생시 잡아서 실행하는 블럭 내부에 예외 처리 코드를 아래와 같이 삽입 하였습니다.
    try {
  System.out.print("나이를 입력해 주세요.(숫자): ");
  int age = scanner.nextInt();
  return age;
} catch (InputMismatchException e) {
  System.out.println("숫자를 입력해 주세요.");
  scanner.next();
}
    
  
  ‘scanner.next()’ 를 호출하여 잘못된 입력을 버리고, 다음 입력을 기다리도록 합니다.
  사용자가 유효한 숫자를 입력하면 ‘age’ 를 반환하고 메소드를 종료합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-16-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-16-TIL.html"><h1 class="title_post">📝 [TIL] 240516 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-16-TIL.html" class="txt_post">
                            
  연습 문제 정리(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-16-PracticeSummary-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-16-PracticeSummary-1.html"><h1 class="title_post">📝[blog post] 연습 문제 풀이 정리(1)</h1></a>
                        <a href="/Backend/Post/2024-05-16-PracticeSummary-1.html" class="txt_post">
                            1️⃣ 이중 for 문.
이중 for 문은 for 문을 중첩해서 사용하는 것을 말합니다.

한 for 문 안에 또 다른 for 문 안에 또 다른 for 문이 들어있는 구조로, 주로 2차원 배열이나 리스트, 행렬을 처리할 때 사용됩니다.

1.1 기본 구조.
for (초기화1; 조건1; 증감1) {
    for (초기화2; 조건2; 증감2) {
        // 코드 블록
    }
}


1.2 예시
예를 들어, 2차원 리스트의 모든 요소를 출력하는 경우를 생각해 봅시다.
public class Main {
    public static void main(Stringp[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        for (int[] row : matrix) {
            for (int element : row) {
                System.out.println(element);
            }
        }
    }
}



  위 코드에서 ‘matrix’ 는 2차원 리스트입니다.
    
      첫 번째 for 문은 ‘matrix’ 의 각 행(row)을 순회하고, 두 번째 for 문은 각행의 요소(element)를 순회합니다.
    
  


출력 결과는 다음과 같습니다.
1
2
3
4
5
6
7
8
9


2️⃣ 규칙성을 찾는 것이 중요!
어떤 문제를 마주치면 규칙성을 찾는 것이 중요한 것 같습니다.
연습 문제 2-1 중 ‘정수형 숫자를 로마 숫자 표기로 변환하는 프로그램’ 을 작성하는 문제에서 그것을 깨달았습니다.

먼저 어떤 규칙성이 있는지 찾아낸 후 그 규칙성에 따라 문제를 풀고, 문제를 컴퓨터적 사고력을 이용하여 코딩을 하니 문제가 풀리는 것을 알게 되었습니다.

3️⃣ 인덱스를 자유자재로 가지고 놀 줄 알아야 합니다!
연습 문제를 풀면서 느낀 점 중 하나가 “인덱스를 자유자재로 가지고 놀 줄 알아야 한다” 는 부분이었습니다.

“인덱스를 자유자재로 가지고 논다” 라는 말은 문자열이 주어지면 인덱스를 활용하여 문자를 삽입, 삭제, 추출, 변환 등을 자유롭게 할 줄 알아야 한다는 의미입니다.

연습 문제 중 문자열에 대한 문제는 이 부분이 가장 중요시되는 것 같았습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-14-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-14-TIL.html"><h1 class="title_post">📝 [TIL] 240514 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-14-TIL.html" class="txt_post">
                            
  스트림


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-14-Stream.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-14-Stream.html"><h1 class="title_post">☕️[Java] 스트림</h1></a>
                        <a href="/Backend/Java/2024-05-14-Stream.html" class="txt_post">
                            1️⃣ 스트림.

1. 스트림(Stream)
자바에서 스트림(Stream) API는 자바 8에서 도입되어 컬렉션의 요소를 선언적으로 처리할 수 있는 방법을 제공합니다.
스트림 API를 이용하면 데이터 요소의 시퀀스를 효율적으로 처리할 수 있으며, 데이터를 병렬로 처리하는 것도 간단할게 할 수 있습니다.
스트림을 이용하면 복잡한 데이터 처리 작업을 간결하고 명확한 코드로 작성할 수 있습니다.

1.2 스트림의 주요 특정.

  
    1. 선언적 처리 : 스트림을 사용하면 무엇을 할 것인지(what)에 집중하여 작업을 설명할 수 있고, 어떻게 처리할 것인지(how)는 스트림 API가 알아서 최적화하여 처리합니다.
  
  
    2. 파이프라이닝 : 스트림 연산은 파이프라인을 형성할 수 있으며, 여러 단계의 처리 과정을 연결하여 복잡한 데이터 처리를 효과적으로 할 수 있습니다.
  
  
    3. 내부 반복 : 스트림은 “내부 반복”을 사용합니다. 즉, 데이터를 어떻게 반복할지 스트림이 처리하므로, 개발자는 각 요소에 어떤 처리를 할지만 정의하면 됩니다.
  
  
    4. 불변성 : 스트림은 데이터를 수정하지 않습니다. 대신, 각 단계에서 결과를 내는 새로운 스트림을 생성합니다. 이는 함수형 프로그래밍의 특성을 반영합니다.
  


1.3 스트림의 작업 흐름.
스트림 API의 작업 흐름은 크게 세 부분으로 나눌 수 있습니다.


  1. 스트림 생성 : 컬렉션, 배열, I/O 자원 등의 데이터 소스로부터 스트림을 생성합니다.
    List&lt;String&gt; myList = Arrays.asList("a1", "a2", "b1", "b2", "c2", "c1");
Stream&lt;String&gt; myStrean = myList.stream();
    
  
  2. 중간 연산(Intermediate operations) : 스트림을 변환하는 연산으로, 필터링, 매핑, 정렬 등이 있으며, 이 연산들은 연결 가능하고, 또한 게으르게(lazily) 실행됩니다.
    myStream.filter(s -&gt; s.startsWith("c"))
      .map(String::toUpperCase)
      .sorted();
    
  
  3. 종단 연산(Terminal operations) : 스트림의 요소들을 소모하여 결과를 생성하는 연산입니다. 예를 들어, forEach, reduce, collect 등이 있으며, 이 연산을 수행한 후 스트림은 더 이상 사용할 수 없습니다.
    myStream.forEach(System.out::println);
    
  


1.4 스트림과 병렬 처리.
스트림 API는 병렬 처리를 간단하게 지원합니다.
‘paralleStream()’ 을 호출하면 자동으로 여러 쓰레드에서 스트림 연산이 병렬로 수행됩니다.
이는 데이터가 큰 경우에 유용하며, 멀티코어 프로세서의 이점을 쉽게 활용할 수 있게 해줍니다.

1.5 📝 정리.
스트림은 자바에서 데이터 컬렉션을 함수형 스타일로 쉽게 처리할 수 있게 하는 강력한 도구입니다.
이는 코드의 간결성과 가독성을 높이는 데 큰 도움을 줍니다.



2. 중개 연산(Intermediate operations)
자바 스트림 API에서 중개 연산(Intermediate operations)은 스트림의 요소들을 처리하고 변형하는 연산들로서, 다른 스트림을 반환합니다.

중개 연산은 게으른(lazy) 특성을 가지며, 종단 연산(Terminal operation)이 호출되기 전까지는 실제로 실행되지 않습니다.

이런 특성은 연산의 체인을 구성할 때 성능 최적화에 도움을 줍니다.

2.1 중개 연산의 주요 특성.

  
    게으른 실행(Lazy Execution) : 중개 연산은 호출되었을 때 즉시 실행되지 않습니다. 대신, 종단 연산이 호출될 때 까지 실행이 지연됩니다.
  
  
    스트림 변환 : 각 중개 연산은 변형된 형태의 새로운 스트림을 변환합니다. 이는 연산을 연쇄적으로 연결할 수 있도록 합니다.
  


2.2 주요 중개 연산의 종류.

  1. 필터링(Filtering)
    
      ‘filter(Predicate&lt;T&gt; predicate)’ : 주어진 조건(프리디케이트)에 맞는 요소만을 포함하는 스트림을 반환합니다.
        List&lt;String&gt; names = Arrays.asList("Jo", "Lee", "Park", "Kang");
  names.stream()
   .filter(name -&gt; name.startsWith("K"))
   .forEach(System.out::println); // 출력: "Kang"
        
      
    
  
  2. 매핑(Mapping)
    
      ‘map(Function&lt;T, R&gt; mapper)’ : 스트림의 각 요소에 주어진 함수를 적용하고, 함수 결과로 주성된 새 스트림을 반환합니다.
      ‘flatMap(Function&lt;T, Stream&lt;R&gt;&gt; mapper)’ : 각 요소에 함수를 적용한 결과로 생성된 여러 스트림을 하나의 스트림으로 평탄화합니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);
numbers.stream()
 .map(number -&gt; number * number)
 .forEach(System.out::println); //출력: 1, 4, 9, 16
        
      
    
  
  3. 정렬(Sorting)
    
      ‘sorted() :’ 자연 순서대로 스트림을 정렬합니다.
      ‘sorted(Comparator&lt;T&gt; comparator) :’ 주어진 비교자를 사용하여 스트림을 정렬합니다.
        List&lt;String&gt; fruits = Arrays.asList("banana", "apple", "orange", "kiwi");
fruits.stream()
.sorted()
.forEach(System.out::println); // 출력: apple, banana, kiwi, orange
        
      
    
  
  4. 제한(Limiting) 및 건너뛰기(Skipping)
    
      ‘limit(long maxSize)’ : 스트림의 요소를 주어진 크기로 제한합니다.
      ‘skip(long n)’ : 스트림의 처음 n개 요소를 건너뜁니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
numbers.stream()
 .skip(2)
 .limit(3)
 .forEach(System.out::println); // 출력 3, 4, 5
        
      
    
  
  5. 중복 제거(Distinct)
    
      ‘distinct()’ : 스트림에서 중복된 요소를 제거합니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 2, 3, 4, 4, 5);
numbers.stream()
 .distinct()
 .forEach(System.out::println); // 출력: 1, 2, 3, 4, 5
        
      
    
  


2.3 📝 정리.
중개 연산을 통해 데이터 스트림을 세밀하게 제어하고 원하는 형태로 데이터를 변형 할 수 있습니다.
이러한 연산들은 다양한 데이터 처리 작업에서 매우 유용하게 사용됩니다.



3. 최종 연산(Terminal operations)
자바 스트림 API에서 최종 연산(Terminal operations)은 스트림 파이프라인의 실행을 트리거하고 스트림의 요소를 소비하여 결과를 생성하거나 부작용(side effect)을 일으키는 연산입니다.

최종 연산이 호출되기 전까지 중간 연산들은 게으른(lazy) 방식으로 처리되며 실행되지 않습니다.
최종 연산 후에는 스트림이 소비되어 더 이상 사용할 수 없게 됩니다.

3.1 최종 연산의 주요 유형.

  1. 수집(Collection)
    
      ‘collect(Collector&lt;T, A, R&gt; collector)’ : 스트림의 요소를 변환, 결합하고 컬렉션으로 또는 다른 형태로 결과를 수집합니다.
        
          예를 들어, ‘toList()’, ‘toSet()’, ‘toMap()’ 등이 있습니다.
            List&lt;String&gt; names = Array.asList("Alice", "Bob", "Charlie", "David");
List&lt;String&gt; list = names.stream()
               .filter(name -&gt; name.startsWith("A"))
               .collect(Collectors.toList());
System.out.println(list); // 출력 ["Alice"]
            
          
        
      
    
  
  2. 집계(Aggregation)
    
      ‘count()’ : 스트림의 요소 개수를 반환합니다.
      ‘max(Comparator&lt;T&gt; comparator)’ : 스트림에서 최대값을 찾습니다.
      ‘min(Comparator&lt;T&gt; comparator)’ : 스트림에서 최소값을 찾습니다.
      ‘reduce(BinaryOperator&lt;T&gt; accumulator)’ : 스트림의 요소를 결합하여 하나의 결과를 생성합니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);
int sum = numbers.stream()
           .reduce(0, (a, b) -&gt; a + b);
System.out.println(sum); // 출력: 10
        
      
    
  
  3. 반복(Iteration)
    
      ‘forEach(Consumer&lt;T&gt; action)’ : 각 요소에 대해 주어진 작업을 수행합니다. 스트림의 순서대로 실행됩니다.
        List&lt;String&gt; names = Arrays.asList("Alist", "Bob", "Charlie", "David");
names.stream()
   .forEach(System.out::println); // Alice, Bob, Charlie, David
        
      
    
  
  4. 조건 검사(Checking)
    
      ‘allMatch(Predicate&lt;T&gt; predicate) :’ 모든 요소가 주어진 조건을 만족하는지 검사합니다.
      ‘anyMatch(Predicate&lt;T&gt;predicate) :’ 어떤 요소라도 주어진 조건을 만족하는지 검사합니다.
      ‘noneMatch(Predicate&lt;T&gt;predicate) :’ 모든 요소가 주어진 조건을 만족하지 않는지 검사합니다.
        boolean allEven = numbers.stream()
                   .allMatch(n -&gt; n % 2 == 0);
System.out.println(allEven); // 출력: false
        
      
    
  
  5. 요소 검색(Finding)
    
      ‘findFirst()’ : 스트림의 첫 번째 요소를 Optional로 반환합니다.
      ‘findAny()’ : 스트림에서 임의의 요소를 Optional로 반환합니다. 병렬 스트림에서 유용합니다.
        Optional&lt;String&gt; first = names.stream()
                        .findFirst();
first.ifPresent(System.out::println); // 출력 Alice
        
      
    
  


3.2 📝 정리.
이러한 최종 연산들은 스트림 처리를 완료하고 필요한 결과를 도출하기 위해 사용됩니다.
스트림 API를 통해 데이터 처리를 선언적이고 간결하게 할 수 있으며, 복잡한 로직을 효과적으로 관리할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-13-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-13-TIL.html"><h1 class="title_post">📝 [TIL] 240513 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-13-TIL.html" class="txt_post">
                            
  컬렉션 프레임워크
  HashMap에 key 값은 항상 int 여야 할까요?
  람다식
  람다식은 하나만!


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-lambdaIsOnlyOne.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-lambdaIsOnlyOne.html"><h1 class="title_post">☕️[Java] 람다식은 하나만!</h1></a>
                        <a href="/Backend/Java/2024-05-13-lambdaIsOnlyOne.html" class="txt_post">
                            람다식은 하나만!😆
자바에서는 “하나의 추상 메소드를 갖는 인터페에스에 대해서만 람다식을 직접 사용할 수 있습니다.”
이를 함수형 인터페이스라고 부르며, 람다식은 이런 함수형 인터페이스의 구현을 간단히 할 수 있는 방법을 제공합니다.

하지만 아래의 코드와 같이 인터페이스 내에 두 개의 추상 메서드 (‘plus’, ‘minus’)가 있기 때문에, 이 인터페이스를 람다식으로 직접 구현하는 것은 불가능합니다.

interface Carculator {
    public abstract int plus(int x, int y);
    public abstract int minus(int x, int y);
}


람다식을 사용하려면 함수형 인터페이스가 필요하므로, 두 메소드 각각을 위한 두 개의 별도의 인터페이스를 정의하거나 기존 인터페이스 중 하나를 수정해야 합니다.

아래의 코드는 이를 위해 각 메소드를 분리하여 두 개의 함수형 인터페이스를 만든 예시입니다.
interface Calculator {
  public abstract int operation(int x, int y);
}
public class Main {

  public static void main(String[] args) {
    Calculator plus = (x, y) -&gt; { return x + y; };
    System.out.println(plus.operation(10,2)); // 12
    Calculator minus = (x, y) -&gt; { return x - y; };
    System.out.println(minus.operation(10,2)); // 8
  }
}


위 코드는 각 연산을 람다식으로 간단히 구현하고 있습니다.
만약 원래의 ‘Carculator’ 인터페이스를 유지고하고 싶다면 이를 직접적으로 람다식으로 구현할 수는 없으며, 대신 익명 클래스나 정규 클래스를 사용해야 합니다.

아래의 코드는 익명 클래스를 사용하는 방법을 보여줍니다.
Calculator calclator = new Calculator() {
    @Override
    public int plus(int x, int y) {
        return x + y;
    }
    
    @Override
    public int minus(int x, int y) {
        return x - y;
    }
}


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html"><h1 class="title_post">☕️[Java] HashMap에 key 값은 항상 int 여야 할까요?</h1></a>
                        <a href="/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html" class="txt_post">
                            🤔 HashMap에 key 값은 항상 int 여야 할까요?

강의와 예제 코드를 열심히 보고 따라서 타이핑하고 있던 중 “문뜩!” 떠올랐습니다. 🤩

‘HashMap에 key 값은 항상 int 여야 할까요?🤔’

그래서 구글링과 챗 지피티 그리고 Java의 정석 도서를 살펴본 후 이 글을 쓰게 되었습니다 :)



🙅‍♂️ 대답은 “아니오!” 입니다.

자바 프로그래밍에서 ‘HashMap’ 의 키 값은 ‘int’ 형일 필요는 없다고 합니다.

‘HashMap’ 은 키로서 어떠한 객체도 사용할 수 있으며, 기는 자바의 ‘제네릭’ 을 통해 다양한 유형의 객체를 키로 사용할 수 있게 해준다고 합니다.
(오! “제네릭” 은 아직 안배웠지만 🥲 Swift에서 봐서 비슷한 느낌 같은데?!)

키 객체는 ‘Object’ 클래스의 ‘hashCode()’ 메소드와 ‘equals()’ 메소드를 적절히 구현해야 합니다.
(‘Object’ 클래스는 무엇이고,  ‘hashCode()’ 메소드와 ‘equals()’ 메소드는 무엇인가?!! 🤪)

이는 ‘HashMap’ 이 키의 해시 코드를 사용하여 데이터를 저장하고 검색하기 때문입니다.
(도통 무슨 소리인지 몰라서 아래 “제네릭”. “Object 클래스”, “hashCode()”, “equals()”를 정리했어요 ㅎㅎ)

‘HashMap’ 을 사용할 때, 키로 사용되는 객체의 ‘hashCode()’ 메소드가 효율적이고 일관성 있는 값을 반환해야 합니다.
또한, ‘equalse()’ 메소드는 객체의 동등성을 정확하게 판단할 수 있어야 합니다.
이 두 메소드의 구현이 적절히 이루어져야 ‘HashMap’ 이 키의 중복 없이 정확하게 데이터를 관리할 수 있습니다.

예시 - String 객체를 키로 사용하는 ‘HashMap’
import java.util.HashMap;

public class Example {
    public static void main(String[] args) {
        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        map.put("one", 1);
        map.put("two", 2);
        map.put("three", 3);
        
        System.out.println(map.get("two")); // 출력: 2
    }
}



  위 예시에서 보듯, ‘String’ 외에도 사용자가 정의한 어떠한 객체든 ‘hashCode()’ 와 ‘equals()’ 가 적절히 구현되어 있다면 키로 사용할 수 있습니다.
    
      따라서 ‘int’ 만을 키로 사용해야 하는 것은 아닙니다.
    
  




1️⃣ 제네릭(Generic).
자바에서 ‘제네릭(Generic)’ 은 클래스, 인터페이스, 메소드를 정의할 때 타입(Type)을 하나의 매개변수처럼 취급하여, 다양한 데이터 타입을 사용할 수 있도록 하는 프로그래밍 기법입니다.

제네릭을 사용하면 컴파일 시점에 타입 안정성을 제공하고, 타입 캐스팅을 줄여 코드를 더 간결하고 읽기 쉽게 만들 수 있습니다.

제네릭 기본 문법.
제네릭은 타입 매개변수를 사용하여 구현됩니다.

타입 매개변수는 보통 한 글자로 표현되며, 일반적으로 다음과 같은 문자를 사용합니다.


  ‘E’ : Element(컬렉션에서 사용되는 요소)
  ‘K’ : Key(키)
  ‘V’ : Value(값)
  ‘T’ : Type(일반적인 타입)
  ‘S’, ‘U’, ‘V’ 등 - 두 번째, 세 번째, 네 번째 타입을 나타내기 위해 사용


예시: 제네릭을 사용한 클래스와 메소드
// 제네릭 클래스 예시
public class Box&lt;T&gt; {
    private T t; // T는 이 클래스가 다루는 객체의 타입을 매개변수화합니다.
    
    public void set(T t) {
        this.t = t;
    }
    
    public T get() {
        return t;
    }
}

// 제네릭 메소드 예시
public static &lt;T&gt; void printArray(T[] inputArray) {
    for (T element : inputArray) {
        System.out.print(element + " ");
    }
    System.out.println();
}


  위 예시에서 ‘Box’ 클래스는 타입 매개변수 ‘T’ 를 사용하여 다양한 타입을 저장하고 반환할 수 있는 범용 컨테이너로 사용됩니다.
  ‘printArray’ 메소드는 어떤 배열 타입도 받아들일 수 있으며, 그 요소들을 출력합니다.




2️⃣ Object 클래스.
자바 프로그래밍에서 ‘Object’ 클래스는 자바의 클래스 계층 구조에서 가장 상위에 위치하는 클래스입니다.

모든 자바 클래스는 직접적이거나 간접적으로 ‘Object’ 클래스를 상속받습니다.

이는 ‘Object’ 클래스가 자바에서 모든 클래스의 근본(base)이라는 의미 입니다.

‘Object’ 클래스는 자바의 ‘java.lang’ 패키지에 포함되어 있으며, 모든 객체에 공통적으로 필요한 메서드를 제공합니다.

Object 클래스의 의의.
‘Object’ 클래스의 메서드들은 자바의 모든 클래스에 기본적인 기능을 제공합니다.

이로 인해, 개발자는 어떤 클래스를 만들 때도 이러한 기본적인 메서드들을 새로 작성하지 않고도, 필요에 따라 이를 상속받아 확장하거나 재정의할 수 있습니다.

‘Object’ 클래스는 자바의 모든 클래스와 객체에 공통적인 근복적인 메커니즘을 제공하는 중추적인 역할을 합니다.



3️⃣ Object 클래스의 hashCode() 메소드.
자바의 ‘Object’ 클래스에서 ‘hashCode()’ 메소드는 객체의 메모리 주소를 기반으로 계산된 정수 값을 반환하는 메소드입니다.

이 메소드는 객체의 해시 코드를 제공하며, 해시 기반 컬렉션(예: ‘HashMap’, ‘HashSet’, ‘Hashtable’ 등)에서 객체를 효율적으로 관리하기 위해 사용됩니다.

hashCode() 메소드의 주요 용도

  1. 해시 테이블 사용 : ‘hashCode()’ 는 특히 해시 테이블을 사용하는 자료 구조에서 중요합니다.
    
      객체의 해시 코드를 사용하여, 해당 객체가 저장되거나 검색될 해시 버킷을 결정합니다.
        
          이로 인해 데이터의 삽입, 검색, 삭제 작업이 빠르게 수행될 수 있습니다.
        
      
    
  
  2. 객체의 동등성의 빠른 검증 : ‘hashCode()’ 메소드는 ‘equals()’ 메소드와 함께 사용되어 객체의 동등성을 검사합니다.
    
      두 객체가 같다면 반드시 같은 해시 코드를 반환해야 합니다.
        
          따라서, 해시 코드가 다른 두 객체는 결코 같을 수 없으므로, ‘equals()’ 호출 전에 해시 코드를 먼저 확인함으로써 불필요한 비교를 줄일 수 있습니다.
        
      
    
  




4️⃣ Object 클래스의 equals() 메소드.
자바 프로그래밍에서 ‘Object’ 클래스의 ‘equals()’ 메소드는 두 객체가 동등한지 비교하는데 사용됩니다.

이 메소드는 ‘Object’ 클래스에서 모든 클래스로 상속되며, 특히 객체의 동등성을 판단할 때 중요한 역할을 합니다.

기본적으로, ‘Object’ 클래스의 ‘equals()’ 메소드는 두 객체의 참조가 같은지 확인합니다.

즉, 두 객체가 메모리상에서 같은 위치를 가리키는지 검사합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-CollectionFramework.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-CollectionFramework.html"><h1 class="title_post">☕️[Java] 컬렉션 프레임워크</h1></a>
                        <a href="/Backend/Java/2024-05-13-CollectionFramework.html" class="txt_post">
                            1️⃣ 컬렉션 프레임워크

1. 컬렉션 프레임워크(Collection Framework)
자바 컬렉션 프레임워크는 자료 구조를 효율적으로 관리하고 조작할 수 있는 방법을 제공하는 통합 아키텍처입니다.
이 프레임워크는 다양한 인터페이스와 구현을 포함하며, 다양한 종류의 컬렉션들을 제어하고, 데이터 집합을 효율적으로 관리하기 위한 알고리즘을 제공합니다.

1.2 컬렉션 프레임워크의 구요 구성 요소.

  1. 인터페이스(Interface) : 컬렉션 프레임워크의 핵심 인터페이스로는 ‘Collection’, ‘List’, ‘Queue’ 등이 있으며 각각 다른 형태의 데이터 집합을 추상화합니다.
    
      예를 들어, ‘List’ 는 순서가 있는 데이터 집합을, ‘Set’ 은 중복을 허용하지 않는 데이터 집합을 나타냅니다.
    
  
  2. 구현(Implementation) : 이러한 인터페이스를 실제로 구현한 클래스들로, ‘ArrayList’, ‘LinkedList’, ‘HashSet’, ‘TreeSet’, ‘PriorityQueue’ 등이 포함됩니다.
    
      각 클래스는 컬렉션 인터페이스를 구현하며, 데이터의 특성에 따라 선택하여 사용할 수 있습니다.
    
  
  3. 알고리즘(Algorithm) : 컬렉션 데이터를 처리하는 데 필요한 다양한 알고리즘이 제공됩니다.
    
      이 알고리즘은 정렬, 검색, 순환 및 변환 등을 포함하며, 이들은 대부분 ‘Collections’ 클래스에 정적 메소드로 제공됩니다.
    
  


1.3 📝 정리.
컬렉션 프레임워크를 사용하면 데이터를 보다 효율적으로 처리할 수 있고, 기능의 재사용성 및 유지 보수성이 향상됩니다.
또한, 자바 개발자로서 다양한 데이터 컬렉션을 쉽게 처리하고, 표준화된 방법으로 데이터를 조작할 수 있는 능력을 갖추게 됩니다.



2. List 인터페이스.
자바 프로그래밍에서 ‘List’ 인터페이스는 ‘java.util’ 패키지의 일부로, 순서가 있는 컬렉션을 나타냅니다.
이 인터페이스를 사용하면 사용자가 목록의 특정 위치에 접근, 삽입, 삭제를 할 수 있는 동시에, 목록의 요소들이 입력된 순서대로 저장 및 관리됩니다.
‘List’ 는 중복된 요소의 저장을 허용하기 때문에, 같은 값을 가진 요소를 여러 개 포함할 수 있습니다.

2.1 List 인터페이스의 주요 메서드.

  add(E e) : 리스트의 끝에 요소를 추가합니다.
  add(int index, E element) : 리스트의 특정 위치에 요소를 삽입합니다.
  remove(Object o) : 리스트에서 지정된 요소를 삭제합니다.
  remove(int index) : 리스트에서 지정된 위치의 요소를 삭제합니다.
  get(int index) : 지정된 위치에 있는 요소를 반환합니다.
  set(int index, E element) : 리스트의 특정 위치에 요소를 설정(교체)합니다.
  indexOf(Object o) : 객체를 찾고, 리스트 내의 첫 번째 등장 위치를 반환합니다.
  size() : 리스트에 있는 요소의 수를 반환합니다.
  clear() : 리스트에서 모든 요소를 제거합니다.


2.3 가장 널리 사용되는 구현체.
‘List’ 인터페이스는 다양한 구현체를 가지고 있으며, 가장 널리 사용되는 구현체는 ‘ArrayList’, ‘LinkedList’ 그리고 ‘Vector’ 입니다.

각 구현체는 내부적인 데이터 관리 방식이 다르므로, 사용 상황에 따라 적합한 구현체를 선택할 수 있습니다.


  ‘ArrayList’ : 내부적으로 배열을 사용하여 요소들을 관리합니다. 인덱스를 통한 빠른 접근이 가능하지만, 크기 조정이 필요할 때 비용이 많이 들 수 있습니다.
  ‘LinkedList :’ 내부적으로 양방향 연결 리스트를 사용합니다. 데이터의 삽입과 삭제가 빈번하게 일어나는 경우 유용합니다.
  Vector : ‘ArrayList’ 와 비슷하지만, 모든 메소드가 동기화되어 있어 멀티스레드 환경에서 사용하기에 안전합니다.


2.4 📝 정리.
이러한 특성들로 인해 ‘List’ 인터페이스는 자바에서 데이터를 순차적으로 처리할 필요가 있는 다양한 애플리케이션에서 중요하게 사용됩니다.



3. Set 인터페이스.
자바 프로그래밍에서 ‘Set’ 인터페이스는 ‘java.util’ 패키지의 일부이며, 중복을 허용하지 않는 요소의 컬렉션을 나타냅니다.

‘Set’ 은 ‘Collection’ 인터페이스를 확장하는 인터페이스로서, 집합의 개념을 구현합니다.
이는 각 요소가 컬렉션 내에서 유일하게 존재해야 함을 의미합니다.

인덱스로 요소를 관리하는 ‘List’ 인터페이스와 달리, ‘Set’ 은 요소의 순서를 유지하지 않습니다.

3.1 Set의 주요 특징.

  중복 불허 : 같은 요소의 중복을 허용하지 않으며, 이미 ‘Set’ 에 존재하는 요소를 추가하려고 시도하면 그 요소는 컬렉션에 추가되지 않습니다.
  순서 보장 없음 : 대부분의 ‘Set’ 구현체는 요소의 저장 순서를 유지하지 않습니다. 그러나 ‘LinkedHashSet’ 과 같은 특정 구현체는 요소의 삽입 순서를 유지할 수 있습니다.
  값에 의한 접근 : ‘Set’ 은 인덱스를 사용하지 않고 값에 의해 요소에 접근합니다.


3.2 주요 메서드.
‘Set’ 인터페이스는 ‘Collection’ 인터페이스에서 상속받은 다양한 메소드를 포함합니다.
주요 메서드는 다음과 같습니다.


  add(E e): 요소 e를 Set에 추가합니다. 이미 존재하는 요소를 추가하려는 경우, 요소는 추가되지 않고 false를 반환합니다.
  remove(Object o): 지정된 객체 o를 Set에서 제거합니다.
  contains(Object o): Set이 지정된 객체 o를 포함하고 있는지 여부를 반환합니다.
  size(): Set의 요소 개수를 반환합니다.
  isEmpty(): Set이 비어 있는지 여부를 반환합니다.
  clear(): Set의 모든 요소를 제거합니다


3.3 주요 구현체.
‘Set’ 인터페이스는 여러 가지 방법으로 구현될 수 있으며, 각 구현체는 다른 특성을 가집니다.


  HashSet : 가장 널리 사용되는 ‘Set’ 구현체로, 해시 테이블을 사용하여 요소를 저장합니다. 요소의 삽입, 삭제, 검색 작업은 평균적으로 상수 시간(O(1))이 걸립니다.
  LinkedHashSet : ‘HashSet’ 의 확장으로, 요소의 삽입 순서를 유지합니다.
  TreeSet : 레드-블랙 트리 구조를 사용하여 요소를 저장합니다. 요소는 자연적 순서 또는 비교자에 의해 정렬됩니다.
    
      이로 인해 삽입, 삭제, 검색 작업에 로그 시간(O(log n))이 걸립니다.
    
  


3.4 📝 정리.
‘Set’ 인터페이스는 주로 중복을 허용하지 않는 데이터 컬렉션을 다루는 데 사용되며, 특히 요소의 유일성을 보장하는데 유용합니다.



4. Map 인터페이스.
자바에서 ‘Map’ 인터페이스는 ‘java.util’ 패키지에 속하며, 키(key)와 값(value) 쌍으로 이루어진 데이터를 저장하는 자료구조를 정의합니다.

‘Map’ 은 키의 중복을 허용하지 않으면서 각 키는 하나의 값에 매핑됩니다.

값은 중복될 수 있지만, 각 키는 유일해야 합니다.

이러한 특성 때문에 ‘Map’ 은 키를 통해 빠르게 데이터를 검색할 수 있는 효율적인 수단을 제공합니다.

4.1 Map의 주요 특징.

  키 기반 데이터 접근 : 키를 사용하여 데이터에 접근하므로, 키에 대한 빠른 검색, 삽입, 삭제가 가능합니다.
  키의 유일성 : 같은 키를 다시 ‘Map’ 에 추가하려고 하면 기존 키에 연결된 값이 새 값으로 대체됩니다.
  값의 중복 허용 : 같은 값을 가진 여러 키가 ‘Map’ 에 존재할 수 있습니다.


4.2 주요 메서드
‘Map’ 인터페이스는 데이터를 관리하기 위해 다음과 같은 주요 메소드를 제공합니다.


  put(K key, V value): 키와 값을 Map에 추가합니다. 이미 키가 존재하면, 해당 키의 값이 새로운 값으로 업데이트 됩니다.
  get(Object key): 지정된 키에 연결된 값을 반환합니다. 키가 존재하지 않는 경우, null을 반환합니다.
  remove(Object key): 지정된 키와 그 키에 매핑된 값을 Map에서 제거합니다.
  containsKey(Object key): Map에 특정 키가 있는지 검사합니다.
  containsValue(Object value): Map에 특정 값이 하나 이상 있는지 검사합니다.
  keySet(): Map의 모든 키를 Set 형태로 반환합니다.
  values(): Map의 모든 값을 컬렉션 형태로 반환합니다.
  entrySet(): Map의 모든 “키-값” 쌍을 Set 형태의 Map.Entry 객체로 반환합니다.
  size(): Map에 저장된 “키-값” 쌍의 개수를 반환합니다.
  clear(): Map의 모든 요소를 제거합니다.


4.3 주요 구현체
‘Map’ 인터페이스의 주요 구현체로는 다음과 같은 클래스들이 있습니다.

  HashMap : 가장 일반적으로 사용되는 ‘Map’ 구현체로, 해시 테이블을 사용합니다.
    
      요소의 순서를 보장하지 않으며, 키와 값에 ‘null’ 을 허용합니다.
    
  
  LinkedHashMap : ‘HashMap’ 을 상속받아 구현된 클래스로, 요소의 삽입 순서를 유지합니다.
    
      이는 순회 시 삽인된 순서대로 요소를 얻을 수 있게 해줍니다.
    
  
  TreeMap : 레드-블랙 트리를 기반으로 하는 ‘Map’ 구현체로, 모든 키가 자연적 순서대로 정렬됩니다.
    
      정렬된 순서로의 접근이 필요할 때 유용합니다.
    
  
  Hashtable : ‘HashMap’ 과 유사하지만, 모든 메소드가 동기화되어 있어 멀티스레드 환경에서 사용하기에 안전합니다.
    
      그러나 성능이 ‘HashMap’ 보다 느리고, 키와 값에 ‘null’ 을 허용하지 않습니다.
    
  


4.4 📝 정리.
‘Map’ 인터페이스는 다양한 애플리케이션에서 설정, 프로파일, 사용자 세션 등의 데이터를 키와 값의 형태로 관리할 때 유용하게 사용됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-lambda.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-lambda.html"><h1 class="title_post">☕️[Java] 람다식</h1></a>
                        <a href="/Backend/Java/2024-05-13-lambda.html" class="txt_post">
                            1️⃣ 람다식.

1. 람다 표현식(Lambda Expression)
자바 프로그래밍에서 람다식 또는 람다 표현식(Lambda Expression)은 간결한 방식으로 익명 함수(anonymous function)를 제공하는 기능입니다.

자바 8부터 도입된 이 기능은 함수형 프로그래밍의 일부 개념을 자바에 도입하여, 코드를 더 간결하고 명료하게 만들어 주며 특히 컬렉션의 요소를 처리할 때 유용하게 사용됩니다.

1.2 람다식의 특징.

  익명성 : 람다는 이름이 없기 때문에 익명으로 처리됩니다.
  함수 : 람다는 메서드와 유사하지만, 독립적으로 존재할 수 있는 함수입니다.
  전달성 : 람다 표현식은 메서드 인자로 전달되거나 변수에 저장될 수 있습니다.
  간결성 : 코드의 간결성을 높여, 불필요한 반복을 줄여줍니다.


1.3 람다 표현식의 기본 구조.
람타 표현식은 주로 매개 변수를 받아들여 결과를 반환하는 식의 형태로 작성됩니다.

일반적인 형태는 다음과 같습니다.
(parameters) -&gt; expression
또는
(parameters) -&gt; { statements; }


  매개 변수 : 괄호 안에 정의되며, 매개 변수의 타입을 명시할 수도 있고 생략할 수도 있습니다.
    
      매개 변수가 하나뿐인 경우, 괄호도 생략할 수 있습니다.
    
  
  
    화살표(-&gt;) : 매개 변수와 몸체를 구분짓는 역할을 합니다.
  
  몸체 : 람다의 실행 로직을 담고 있으며, 식(expression) 또는 문장(statements)이 올 수 있습니다.
    
      식은 단일 실행 결과를 반환하며, 중괄호는 생략할 수 있습니다.
      문장은 중괄호 안에 작성되며, 여러 줄의 코드를 포함할 수 있습니다.
    
  


1.4 예시

  Thread 실행하기
    new Thread(() -&gt; System.out.println("Hello from a thread")).start();
    
  
  리스트의 각 요소 출력하기
    List&lt;String&gt; list = Arrays.asList("Apple", "Banana", "Cherry");
list.forEach(item -&gt; System.out.println(item));
    
  
  Comparator를 통한 정렬
    List&lt;String&gt; cities = Arrays.asList("Seoul", "New York", "London");
Collections.sort(cities, (s1, s2) -&gt; s1.compareTo(s2));
    
  


1.5 📝 정리.
람다 표현식은 이벤트 리스너, 스레드의 실행 코드 등 여러 곳에서 기존에 익명 클래스를 사용하던 부분을 대체하여 코드를 더 간결하게 만들 수 있습니다.

또한, 스트림 API와 함께 사용될 때 강력한 데이터 처리 기능을 제공하여 복잡한 컬렉션 처리를 단순화시킬 수 있습니다.



2. 람다식의 장점.
자바에서 람다식(Lambda Expression)을 사용하는 것은 여러 가지 장점을 제공합니다.

이러한 장점들은 프로그래밍 스타일, 코드의 간결성, 효율성 및 기능성 측면에서 특히 두드러집니다.

2.1 람다식의 주요 장점들.

  1. 코드의 간결성 : 람다식을 사용하면 복잡한 익명 클래스를 사용할 필요가 없어지므로 코드를 훨씬 간결하게 작성할 수 있습니다.
    
      예를 들어, 스레드를 실행하거나 이벤트 리스너를 설정할 때 몇 줄의 코드로 작성할 수 있습니다.
    
  
  2. 가독성 향상 : 람다식은 기존의 익명 클래스보다 훨씬 읽기 쉽고 이해하기 쉬운 코드를 작성할 수 있게 합니다.
    
      이는 유지보수 시간을 줄이고 코드의 질을 향상시키는 데 도움이 됩니다.
    
  
  3. 함수형 프로그래밍 지원 : 람다식은 자바에 함수형 프로그래밍 스타일을 도입하였습니다.
    
      이는 데이터 처리와 조작을 보다 선언적으로 표현할 수 있게 해, 복잡한 데이터 처리 로직을 간결하고 효율적으로 작성할 수 있도록 합니다.
    
  
  4. 코드의 재사용성 증가 : 람다식을 사용하면 특정 동작을 수행하는 코드 블록을 쉽게 재사용할 수 있습니다.
    
      람다식은 변수처럼 취급될 수 있어, 메소드에 인자로 전달하거나 변수에 할당하여 다른 위치에서 사용할 수 있습니다.
    
  
  5. 병렬 실행 용이 : 자바 8 이후로 스트림 API와 결합된 람다식은 컬렉션 처리를 병렬로 쉽게 수행할 수 있게 해줍니다.
    
      이는 ‘parallelStream()’ 과 같은 메소드를 사용하여 멀티코어 프로세서의 이점을 쉽게 활용할 수 있게 합니다.
    
  
  6. 지연 실행(Lazy Evaluation) : 람다식은 지연 실행을 가능하게 합니다.
    
      예를 들어, 조건이 충족될 때까지 코드 실행을 지연시키거나, 필요할 때만 데이터를 처리하도록 할 수 있습니다.
        
          이는 성능 최적화에 도움을 줄 수 있습니다.
        
      
    
  
  7. 함수 인터페이스와의 호환성 : 람다식은 단일 추상 메소드를 가진 인터페이스(함수 인터페이스)와 호환됩니다.
    
      이는 많은 내장 함수 인터페이스(‘Runnable’, ‘Callable’, ‘Comparator’ 등)와 사용자 정의 함수 인터페이스에 람다식을 적용할 수 있음을 의미합니다.
    
  


2.2 📝 정리.
이러한 장점들로 인해 람다식은 자바 프로그래머들 사이에서 매우 인기 있는 기능이 되었으며, 모던 자바 코드에서는 필수적인 요소로 자리 잡고 있습니다.



3. 람다식의 단점.
자바에서 람다식을 사용하면 여러 가지 장점이 있지만, 몇 가지 단점 또는 주의할 점도 있습니다.

3.1 람다식의 사용과 관련된 단점.

  1. 디버깅의 어려움 : 람다식은 익명 함수이기 때문에 디버깅이 더 복잡할 수 있습니다.
    
      스택 트레이스에서 람다식이 어디에 위치하는지 명확하게 표시되지 않아 오류를 추적하기 어려울 수 있습니다.
    
  
  2. 코드의 남용 : 람다식을 과도하게 사용하면 코드가 오히려 더 복잡해지고 이해하기 어려워질 수 있습니다.
    
      특히 람다 내부에 긴 로직이나 조건문을 넣을 경우 가독성이 떨어질 수 있습니다.
    
  
  3. 람다 캡처링 오버헤드 : 람다식은 주변 환경의 변수를 캡처(Capture)할 수 있습니다.
    
      이 때, 람다가 외부 변수를 캡처 할 경우 추가적인 비용이 발생할 수 있으며, 이는 성능에 영향을 줄 수 있습니다.
    
  
  4. 직렬화의 문제 : 람다식은 기본적으로 직렬화가 보장되지 않습니다.
    
      따라서 람다식을 사용하는 객체를 직렬화하려고 할 때 문제가 발생할 수 있습니다.
        
          이는 분산 시스템에서 특히 중요한 이슈가 될 수 있습니다.
        
      
    
  
  5. 학습 곡선 : 자바 8 이전의 버전에 익숙한 개발자들에게 람다식과 스트림 API는 새로운 패러다임을 익혀야 하는 도전과제를 제시합니다.
    
      이는 초기 학습 곡선을 가파르게 만들 수 있습니다.
    
  
  6. 타입 추론의 복잡성 : 람다식에서는 자바 컴파일러가 타입을 추론해야 하는데, 때때로 이 추론이 개발자의 의도와 다른게 이루어질 수 있습니다.
    
      이는 코드의 명확성을 떨어뜨릴 수 있습니다.
    
  
  7. 함수형 인터페이스의 제약 : 람다식은 단 하나의 추상 메소드를 가진 함수형 인터페이스와 함꼐 사용됩니다.
    
      때로는 이런 제약이 프로그램 설계를 더 복잡하게 만들 수 있습니다.
    
  


3.2 📝 정리.
람다식의 단점들은 주로 개발과 관련된 트레이드오프와 관련이 있으며, 이러한 단점을 이해하고 적절히 관리한다면 람다식을 효과적으로 사용할 수 있습니다.



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-12-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-12-TIL.html"><h1 class="title_post">📝 [TIL] 240512 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-12-TIL.html" class="txt_post">
                            
  입출력(2)
  예외 처리


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-12-Input-Ouput-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-12-Input-Ouput-2.html"><h1 class="title_post">☕️[Java] 입출력(2)</h1></a>
                        <a href="/Backend/Java/2024-05-12-Input-Ouput-2.html" class="txt_post">
                            1️⃣ 입출력(2)

1. 파일 출력.
자바 프로그래밍에서 파일 출력은 프로그램이 데이터를 쓰는 과정을 말합니다.
이 과정을 통해 프로그램은 실행 결과를 저장하거나, 사용자가 입력한 정보를 파일에 기록하고, 다른 프로그램이나 나중에 프로그램 자체가 다시 사용할 수 있는 형태로 데이터를 출력할 수 있습니다.

2. 파일 출력을 수행하기 위한 기본 방법들.

  1. FileOutputStream 사용
    
      ‘FileOutputStream’ 클래스는 바이트 단위의 출력을 파일에 직접 쓸 때 사용됩니다.
      이 클래스를 사용하면 이미지, 비디오 파일, 이진 데이터 등을 파일로 저장할 수 있습니다.
```java
import java.io.FileOutputStream;
import java.io.IOException;
    
  


public class FileOutputExample {
    public static void main(String[] args) {
        String data = “Hello, this is a test.”;
        try (FileOutputStream out = new FileOutputStream(“output.txt”)) {
            out.write(data.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

- **2. PrintWriter 사용**
    - **'PrintWriter'** 는 문자 데이터를 출력할 때 사용됩니다.
    - 이 클래스는 파일에 텍스트를 쓸 때 편리하며, 자동 플러싱 기능, 줄 단위 출력 등의 메소드를 제공합니다.
```java
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class PrintWriteExample {
    public static void main(String[] args) {
        try (PrintWriter writer = new PrintWriter(new FileWriter("output.txt", true))) {
            writer.println("Hello, this is a test.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



  3. FileWriter 사용
    
      ‘FileWriter’ 는 자바에서 파일에 텍스트 데이터를 쓰기 위한 간편한 방법 중 하나입니다.
      이 클래스는 내부적으로 문자 데이터를 파일에 쓸 수 있도록 ‘OutputStreamWriter’ 를 사용하여 바이트 스트림을 문자 스트림으로 변환합니다.
      ‘FileWriter’ 는 텍스트 파일을 쉽게 작성할 수 있도록 해주며, 생성자를 통해 다양한 방식으로 파일을 열 수 있습니다.
```java
import java.io.FileWriter;
import java.io.IOException;
    
  


public class FileWriterExample {
    pulbic static void main(String[] args) {
        try (FileWriter writer = new FileWriter(“output.txt”, true)) {
            writer.write(“Hello, this is a test.”);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

- **4. BufferedWriter 사용**
    - **'BufferedWrite'** 는 버퍼링을 통해 효율적으로 파일에 문자 데이터를 쓸 수 있도록 합니다.
    - **'FileWriter'** 와 함께 사용되어, 더 큰 데이터를 처리할 때 성능을 개선합니다.
```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedWriterExample {
    public static void main(String[] args) {
        String content = "Hello, this is a test.";
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {
            writer.write(content);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



2. 파일 입력.

자바 프로그래밍에서 파일 입력은 프로그램이 파일로부터 데이터를 읽어들이는 과정을 말합니다.

이 데이터는 텍스트나 바이너리 형태일 수 있으며, 파일에서 데이터를 읽어 프로그램 내에서 사용할 수 있도록 만드는 것이 목적입니다.

파일 입력을 위해 자바는 다양한 입출력 클래스를 제공합니다.

2.1 주로 사용되는 파일 입력 방법.


  1. FileInputStream 사용
    
      ‘FileInputStream’ 은 바이트 단위로 파일에서 데이터를 읽는 데 사용됩니다.
      이 클래스는 이미지, 비디오 파일, 실행 파일등의 이진 데이터 처리에 주로 사용됩니다.
```java
import java.io.FileInputStream;
import java.io.IOException;
    
  


public class FileInputStreamExample {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream(“input.dat”)) {
            int content;
            while ((content = fis.read()) != -1) {
                // content 변수에 한 바이트씩 읽어들인 데이터를 저장
                System.out.print((char) content);
            }
        } catch (IOExecption e) {
            e.printStackTrace();
        }
    }
}

- **2. BufferedRead** 와 **FileReader 사용**
    - **'BufferedReader'** 와 **'FileReader'** 는 텍스트 데이터를 효과적으로 읽기 위해 함께 사용됩니다.
    - **'FileReader'** 는 파일에서 문자 데이터를 읽어들이며, **'BufferedReader'** 는 버퍼링을 통해 읽기 성능을 향상 시킵니다.
```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedReaderExample {
    public static void main(String[] args) {
        try (BufferedReader br new BufferedReader(new FileReader("input.txt"))) {
            String line;
            while ((line = br.readline()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



  3. Scanner 사용
    
      ‘Scanner’ 클래스는 텍스트 파일을 읽을 때 유용하며, 특히 토큰화(tokenizing)된 데이터를 처리할 때 편리합니다.
      ‘Scanner’ 는 정규식을 사용하여 입력을 구분자로 분리하고, 다양한 타입으로 데이터를 읽어들일 수 있습니다.
```java
import java.io.File;
import java.util.Scanner;
    
  


public class ScannerExample {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(new File(“input.txt”))) {
            while (scanner.hasNextLine()) {
                System.out.println(scanner.nextLine());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

2.2 📝 정리.
이렇게 다양한 방법을 통해 파일로부터 데이터를 읽을 수 있으며, 각 방법은 사용하는 데이터 타입과 처리할 데이터의 양에 따라 선택할 수 있습니다.
파일에서 데이터를 읽는 것은 데이터를 처리하거나, 설정 정보를 불러오거나, 사용자 데이터를 읽는 등 다양한 목적으로 활용됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-12-ExceptionHandling.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-12-ExceptionHandling.html"><h1 class="title_post">☕️[Java] 예외 처리</h1></a>
                        <a href="/Backend/Java/2024-05-12-ExceptionHandling.html" class="txt_post">
                            1️⃣ 예외 처리

예외 처리가 무엇인지 이해하고, 예외 처리 방법에 대해 직접 구현

1. 예외(Exception)
자바 프로그래밍에서 “예외(Exception)” 란 프로그램 실행 중에 발생하는 비정상적인 조건 또는 오류를 의미합니다.
이는 프로그램의 정상적인 흐름을 방해하며, 적절히 처리하지 않으면 프로그램이 비정상적으로 종료될 수 있습니다.
자바에서는 이러한 예외를 효과적으로 처리하기 위해 강력한 예외 처리 메커니즘을 제공합니다.

1.2 예외의 유형.
자바에서 예외는 크게 두 가지 유형으로 나눌 수 있습니다.


  1. Checked Execptions
    
      컴파일 시간에 체크되는 예외로, 컴파일러가 해당 예외를 처리하도록 요구합니다.
      이 예외들은 주로 외부 시스템과의 상호 작요(파일 입출력, 네트워크 통신 등)에서 발생하며, 프로그래머가 이를 적절히 처리하도록 강제합니다.
    
  
  2. Unchecked Exceptions
    
      런타임에 발생하는 예외로, 주로 프로그래머의 실수로 인해 발생합니다.(예: 배령의 범위를 벗어나는 접근, null 참조 등.)
      이러한 예외는 컴파일러가 체크하지 않으므로, 개발자가 예측하고 적절히 처리할 필요가 있습니다.
    
  




2. 예외 처리(Exception Handling)
자바 프로그래밍에서 예외 처리는 프로그램 실행 중에 발생할 수 있는 예외적인 상황, 즉 오류나 문제를 안전하게 관리하고 대처하는 방법을 말합니다.
예외 처리를 통해 프로그램의 비정상적인 종료를 막고, 오류 발생 시 적절한 대응을 할 수 있도록 합니다.
이는 프로그램의 안정성과 신뢰성을 높이는 데 중요한 역할을 합니다.

2.1 예외 처리의 주요 구성 요소.


  1. try 블록
    
      예외가 발생할 가능성이 있는 코드를 이 블록 안에 넣습니다.
      만약 블록 안의 코드 실행 중에 예외가 발생하면, 즉시 해당 블록의 실행을 중단하고 ‘catch’ 블록으로 제어를 넘깁니다.
    
  
  2. catch 블록
    
      ‘try’ 블록에서 발생한 특정 유형의 예외를 처리합니다.
      프로그램이 예외를 안전하게 처리할 수 있도록 적절한 로직을 구현할 수 있습니다.
      하나의 ‘try’ 블록에 여러 ‘catch’ 블록을 사용하여 다양한 종류의 예외를 각각 다르게 처리할 수 있습니다.
    
  
  3. finally 블록
    
      이 블록은 예외의 발생 여부롸 관계없이 실행되는 코드를 포함합니다.
      주로 사용되는 목적은 자원 해제와 같은 정리 작업을 수행하기 위함입니다.
      예를 들어 파일이나 네트워크 자원을 닫거나 해제할 때 사용됩니다.
    
  
  4. throws 키워드
    
      메소드 선언 시 사용되며, 해당 메소드가 예외를 직접 처리하지 않고 호출한 메소드로 예외를 전파하겠다는 것을 나타냅니다.
      이를 통해 예외 처리의 책임을 메소드 호출자에게 넘길 수 있습니다.
    
  


2.2 예외 처리 예제.
public class ExceptionHandlingExample {
    public static void main(String[] args) {
        try {
            int result = divide(10, 0);
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            System.err.println("Arithmetic Exception: Division by zero is not allowed.");
        } finally {
            System.out.println("This block is always executed.");
        }
    }
    
    public static int divide(int numerator, in denominator) {
        return numerator / denominator; // This ca throw ArithmeticException if denominator is zero.
    }
}



  이 예제에서 ‘divide’ 메소드는 분모가 0일 때 ArithmeticException 을 발생시킬 수 있습니다.
    
      ‘try’ 블록 안에서 이 메소드를 호출하고, 예외가 발생하면 ‘catch’ 블록에서 이를 잡아서 적절한 오류 메시지를 출력합니다.
      또한, ‘finally’ 블록은 예외 발생 여부와 상관없이 실행되어 어떤 상황에서도 실행될 필요가 있는 코드를 포함할 수 있습니다.
    
  




3. throw 키워드.
자바 프로그래밍에서 ‘throw’ 키워드는 개발자가 의도적으로 예외를 발생시키기 위해 사용합니다.
이를 통해 특정 상황에서 프로그램의 흐름을 제어하거나, 특정 조건에서 오류를 발생시켜 예외 처리 메커니즘을 테스트하거나 강제할 수 있습니다.
‘throw’ 는 예외 객체를 생성하고 이를 던집니다(throw)
즉, 프로그램의 정상적인 실행 흐름을 중단하고 예외 처리 루틴으로 제어를 이동시킵니다.

3.1 ‘throw’ 사용법.
‘throw’ 를 사용할 때는 예외 객체를 생성해야 합니다.
이 객체는 ‘Throwable’ 클래스 또는 그 하위 클래스의 인스턴스여야 합니다.
자바에서는 대부분 ‘Exception’ 클래스 또는 그 서브클래스를 사용하여 예외를 생성하고 던집니다.

예제.
public class Main {
    public static void main(String[] args) {
        try {
            checkAge(17);
        } catch (Exception e) {
            System.out.println("Exception caught: " + e.getMessage());
        }
    }
    
    static void checkAge(int age) throws Execption {
        if (age &lt; 18) {
            throw new Exception("Access denied - You must be at least 18 years old.");
        }
        System.out.println("Access granted - You are old enough!");
    }
}


  이 예제에서 ‘checkAge’ 메소드는 나이를 확인하고, 18세 미만인 경우 예외를 던집니다.
    
      이 예외는 ‘throw new Exception(…)’ 을 통해 생성되고 던져집니다.
      메인 메소드에서는 이 메소드를 ‘try’ 블록 안에서 호출하고, ‘catch’ 블록을 통해 예외를 잡아서 처리합니다.
        
          결과적으로, 사용자가 18세 미만이면 “Access denided” 메시지를 포함하는 예외가 출력됩니다.
        
      
    
  


3.2 ‘throw’와 ‘throws’의 차이

  ‘throw’ : 예외를 실제로 발생시키는 행위입니다. 이는 메소드 내부에서 특정 조건에서 예외를 발생시킬 때 사용됩니다.
  ‘throws’ : 메소드 선언에 사용되며, 해당 메소드가 실행되는 동안 발생할 수 있는 예외를 명시적으로 선언합니다. 이는 호출자에게 해당 메소드를 사용할 때 적절한 예외 처리가 필요하다는 것을 알립니다.




4. throws 키워드.
자바 프로그래밍에서 ‘throws’ 키워드는 메소드 선언에 사용되며, 해당 메소드가 실행 도중 발생할 수 있는 특정 유형의 예외를 명시적으로 선언하는 데 사용됩니다.
‘throws’ 는 메소드가 예외를 직접 처리하지 않고, 대신 이를 호출한 메소드로 예외를 “던져”(전파하는) 사실을 알립니다.
이를 통해 예외 처리 책임을 메소드 호출자에게 넘기는 것입니다.

4.1 ‘throws’ 사용의 목적.

  명시성
    
      메소드가 발생시킬 수 있는 예외를 명시함으로써, 이 메소드를 사용하는 다른 개발자들에게 해당 메소드를 사용할 때 어떤 예외들을 처리해야 하는지 명확하게 알릴 수 있습니다.
    
  
  강제 예외 처리
    
      ‘throws’ 로 선언된 예외는 대부분 “checked exception” 이며, 이는 메소드를 호출하는 코드가 반드시 이 예외들을 처리하도록 강제합니다(try-catch 블록을 사용하거나, 또 다시 ‘throws’ 로 예외를 전파하도록 함).
    
  


4.2 ‘throws’ 사용법 예제.
아래 예제에서는 ‘throws’ 를 사용하여 ‘IOException’ 을 처리하는 방법을 보여줍니다.
이 예외는 파일 입출력 작업에서 자주 발생합니다.

import java.io.*;

public class Main {
    public static void main(String[] args) {
        try {
            readFile("example.txt");
        } catch (IOExecption e) {
            System.out.println("An error occurred: " + e.getMessage());
        }
    }
    
    public static void readFile(String filename) throws IOException {
        File file = new File(filename);
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(file);
            int content;
            while ((content = fis.read()) != -1) {
                // Process the content
                System.out.print((char) content);
            }
        } finally {
            if (fis != null) {
                fis.close();
            }
        }
    }
}



  이 예제에서 ‘readFile’ 메소드는 파일을 읽을 때 발생할 수 있는 IOException 을 처리하지 않고, 대신 ‘throws’ 키워드를 사용하여 이 예외를 메소드를 호출한 ‘main’ 메소드로 전달합니다.
    
      ‘main’ 메소드는 이 예외를 ‘catch’ 블록을 통해 처리합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-11-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-11-TIL.html"><h1 class="title_post">📝 [TIL] 240511 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-11-TIL.html" class="txt_post">
                            
  인터페이스
  내부 클래스
  입출력(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html"><h1 class="title_post">📝[blog post] 프론트엔드와 백엔드는 무엇이 다를까?(+내가 백엔드 개발자가 되고 싶은 이유)</h1></a>
                        <a href="/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html" class="txt_post">
                            1️⃣ 프론트엔드와 백엔드?
처음 이 글의 여정을 함께하기에 앞서 프론트엔트가 무엇인가 백엔드가 무엇인지 알아야 할 것 같아요!

제가 아무것도 모르는 당시 저 두 단어 “프론트엔드”, “백엔드”를 듣고 느낀 것은

“프론트엔드”는 뭔가 프론트 데스크 같이 앞에서 누군가가 나를 반겨주는 느낌이였고, “백엔드”는 뒤쪽에서 나를 받쳐주는 든든한 느낌이랄까? 😆

그저 느낌으로는 알쏭달쏭하니 정확한 의미를 알아보는 여행을 떠나봅시다! 🙋‍♂️

2️⃣ 프론트엔드.
프론트엔드는 웹사이트에서 우리가 볼 수 있는 모든 것들을 만드는 일을 말해요 😆



예를 들어, 컴퓨터나 핸드폰으로 책을 보거나 게임을 할 때, 그 화면에 보이는 모든 것들이 바로 프론트엔드에서 만들어진 거예요.(존경합니다 프론트엔드 개발자님들🙇‍♂️)

이렇게 생각해 볼까요?



웹사이트를 마치 컬러링북처럼 생각한다면, 프론트엔드 개발자는 그림을 그리고 색칠하는 사람이에요 🧑‍🎨

프론트엔드 개발자들은 화면에 나타날 모양이나 색상을 정하고, 어디를 누르면 어떤일이 일어날지도 결정합니다.

예를 들어, ‘스타드’ 버튼을 누르면 게임이 시작되거나, 사진을 클릭하면 커지는 것처럼 말이에요.

즉, 프론트엔드는 우리가 웹사이트에서 보고 만지는 모든 것을 아름답고 재미있게 만들어 주는 중요한 일을 한답니다!

3️⃣ 백엔드.


백엔드는 웹사이트에서 우리가 눈에 보이지 않는 부분을 다루는 일을 해요.(그렇다고 뭐.. 해커 이런건 아닙니다.. 완전히 달라요…)



이것은 마치 마술사가 무대 뒤에서 마술을 준비하는 것과 비슷해요! 🪄

우리가 볼 수는 없지만, 마술이 멋기제 보이도록 도와주죠.

예를 들어, 우리가 컴퓨터로 쇼핑을 할 때, 옷이나 장난감을 고르고 주문 버튼을 눌러요. 이떄 백엔드는 주문한 것이 무엇인지 기억하고, 그 물건을 어디로 보내야 할지 알려줘요.

또한, 우리가 어떤 게임을 하거나 질문을 할 때도, 백엔드는 그 대답을 찾아서 화면에 보여주죠.

백엔드는 컴퓨터와 데이터베이스라는 큰 저장소를 사용해서, 우리가 웹사이트에서 필요한 모든 정보를 처리하고 저장하는 곳이에요.

우리가 보지 못하지만, 웹사이트가 잘 작동하도록 도와주는 매우 중요한 부분이랍니다!

4️⃣ 내가 백엔드 개발자가 되고 싶은 이유.

저는 어렸을 때 레고를 참 좋아했어요 :)



그 중에서도 테크닉 레고를 가장 좋아했었어요 :)

그 이유는 완성된 것을 보는 것도 좋았지만 조립해 나가면서 그 안에 중심이 되는 코어, 즉 움직임의 중앙부를 제가 직접 조립하고 움직임이 어디서부터 시작되는지를 직접 이해하는 것이 너무 재미있었거든요.

자동차 레고를 만들다보면 직접 엔진를 만들게 됩니다.

그러면 진짜 엔진이 어떻게 움직이고 이 엔진이 어떻게 동작하느냐에 따라 자동차의 다른 부품들이 맞물려 하나씩 동작하는지 상상되는게 너무 행복했었어요.

이런것들이 어렸을 때부터 너무 좋았답니다.

그리고나서 조금 커서는 루어 낚시를 좋아하게 되었어요.



이 루어 낚시는 “배스” 라는 어종을 대상으로 하는 낚시인데, 이 어종에 대한 여러가지 공부를 해야 했었어요.

먼저, 이 어종이 온도에 민감해 온도에 따라 공격 패턴이 달라요 그래서 그 패턴에 대한 데이터를 수집해야 했었어요.

두 번째, 이 어종은 수중 구조물에 굉장히 예민해요. 자신이 좋아하는 수중 구조물이 따로 있어서 그 수중 구조물을 따로 탐색하고 이해하는 법을 배워야 했었어요.

세 번째, 날씨에 영향을 많이 받는 어종이에요. 햇빛과 그늘 그리고 비가 오는 날과 안오는 날에 따라 먹이 사냥 패턴이 달라져요. 그에 따른 루어 선택과 패턴을 다르게 골라야 합니다.

네 번째, 피딩 타임이라는 이 어종의 먹이 사냥 시간이 있습니다. 이 시간에 따라 어종의 먹이 사냥 패턴이 매우 다양해요.

마지막, 계절에 따라 이 어종이 물 속이 바닥, 중층 또는 상층에 머무는지 이런 데이터가 달라요.

이렇게 이 어종을 낚기 위해서는 수 많은 변수와 데이터들을 조합하여 적절한 위치에 적합한 루어를 선택하여 공격 패턴에 맞는 액션을 주어야 배스가 물어 줍니다.

그럴때 “아 나의 데이터가 맞았구나!” 하는 희열감과 아드레날린 그리고 도파민이 폭발해버리죠.

이런 특성이 저는 백엔드에서도 비슷하게 적용되는 것 같아요.

레고는 백엔드에서의 중심 동작을 알아가는 과정과 직접 동작하는 로직을 만드는 부분에서의 즐거움을 찾아가는 과정에서 재미를 느끼고,

낚시는 백엔드에서 데이터를 찾고 뽑아내어 가공하고 내어주는 부분에서 희열을 느끼는 것 같습니다.

그래서 저의 적성과 맞는 것 같아요.

저는 이러한 부분에서 백엔드 개발자가 제가 즐길 수 있는 부분이 서로 맞기 때문에 백엔드 개발자가 되고 싶습니다 😆

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-11-InnerClass.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-11-InnerClass.html"><h1 class="title_post">☕️[Java] 내부 클래스</h1></a>
                        <a href="/Backend/Java/2024-05-11-InnerClass.html" class="txt_post">
                            1️⃣ 내부 클래스.
내부 클래스의 개념과 종류 이해
익명 클래스 직접 구현

1. 내부 클래스(Inner Class).
자바 프로그래밍에서 내부 클래스(Inner Class)는 다른 클래스의 내부에 정의된 클래스를 말합니다.

내부 클래스는 주로 외부 클래스와 밀접한 관련이 있으며, 외부 클래스의 멤버들에 대한 접근을 용이하게 하기 위해 사용됩니다.

1.1 내부 클래스의 특징.
자바의 내부 클래스에는 몇 가지 특징이 있습니다.
이 특징들은 내부 클래스가 어떻게 사용되고, 그들이 주는 이점과 한계를 이해하는 데 도움이 됩니다.


  1. 접근성과 밀접성 : 내부 클래스는 외부 클래스의 모든 필드와 메소드(프라이빗 포함)에 접근할 수 있습니다. 이는 내부 클래스가 외부 클래스와 밀접한 작업을 수행할 때 매우 유용합니다.
    
      이러한 접근은 내부 클래스가 외부 클래스의 구현 세부사항에 깊이 연결될 수 있게 합니다.
    
  
  2. 캠슐화 증가 : 내부 클래스를 사용하면 관련 있는 부분만을 그룹화하여 외부에 불필요한 정보를 노출하지 않고도 복잡한 코드를 더 잘 구조화할 수 있습니다.
    
      이는 코드의 유지보수성과 가독성을 높이는 데 도움이 됩니다.
    
  
  
    3. 코드의 응집성 : 내부 클래스는 특정 외부 클래스와 매우 강하게 연결되어 있기 때문에, 그 기능이 외부 클래스와 밀접하게 관련된 기능을 수행할 때 코드의 응집력을 높일 수 있습니다.
  
  4. 더 나은 논리적 그룹핑 : 특정 기능을 내부 클래스에 구현함으로써, 관련 기능과 데이터를 함께 논리적으로 그룹화할 수 있습니다.
    
      이는 전체 코드베이스를 통해 일관성을 유지하고, 기능별로 코드를 정리하는 데 도움이 됩니다.
    
  
  
    5. 명시적인 컨텍스트 연결 : 내부 클래스는 명시적으로 그들의 외부 클래스의 인스턴스와 연결됩니다. 이는 그들이 외부 클래스의 상태와 행동에 따라 다르게 작동할 수 있음을 의미합니다.
  
  
    6. 다중 상속의 일종의 구현 : 자바는 다중 상속을 지원하지 않지만, 내부 클래스를 통해 비슷한 효과를 낼 수 있습니다. 외부 클래스가 하나 이상의 내부 클래스를 가질 수 있고, 각 내부 클래스는 다른 클래스를 상속받을 수 있으므로 다양한 기능을 조합할 수 있습니다.
  
  7. 메모리 및 성능 고려사항 : 내부 클래스는 외부 클래스의 인스턴스와 연결되어 있기 때문에, 외부 클래스의 인스턴스가 메모리에 남아 있는 동안에는 가비지 컬렉션에서 제거되지 않습니다. 이는 메모리 관리 측면에서 고려해야 할 사항입니다.


1.2 내부 클래스의 네 가지 유형.

  
    1. 비정적 중첩 클래스(Non-static Nested Class) 또는 내부 클래스(Inner Class) : 이 클래스는 외부 클래스의 인스턴스 멤버처럼 동작하며, 외부 클래스의 인스턴스에 대한 참조를 가지고 있습니다. 외부 클래스의 인스턴스 멤버와 메소드에 접근할 수 있습니다.
  
  
    2. 정적 중첩 클래스(Static Nested Class) : 이 클래스는 외부 클래스의 정적 멤버처럼 동작하며, 외부 클래스의 인스턴스 멤버에는 접근할 수 없지만, 정적 멤버에는 접근할 수 있습니다.
  
  
    3. 지역 클래스(Local Class) : 특정 메소드 또는 초기화 블록 내부에 정의된 클래스로, 선언된 영역 내에서만 사용할 수 있습니다. 지역 클래스는 해당 메소드 내에서만 사용되므로, 외부로 노출되지 않습니다.
  
  
    4. 익명 클래스(Anonymous Class) : 이름이 없는 클래스로, 일반적으로 단 한 번만 사용되며 주로 리스너(listener) 또는 작은 델리게이션 클래스로 사용됩니다. 클래스 선언과 인스턴스 생성이 동시에 이루어집니다.
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-11-Interface.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-11-Interface.html"><h1 class="title_post">☕️[Java] 인터페이스</h1></a>
                        <a href="/Backend/Java/2024-05-11-Interface.html" class="txt_post">
                            1️⃣ 인터페이스.

1. 인터페이스(Interface).
자바에서 인터페이스(Interface)는 메서드의 시그니처만을 정의하는 참조 타입입니다.

인터페이스는 클래스가 구현(implement) 해야 하는 동작의 설계를 제공하며, 구현하는 모든 클래스에 대해 특정 메소드들이 반드시 존재하도록 강제합니다.

이는 다형성을 지원하는 강력한 방법으로, 서로 다른 클래스들이 동일한 인터페이스를 구현함으로써 동일한 방식으로 처리될 수 있게 해 줍니다.

1.2 인터페이스의 주요 특징.

  1. 메소드 선언만 포함 : 인터페이스는 메소드의 구현을 포함하지 않습니다.(자바 8 이전까지는).
    
      메소드의 몸체는 인터페이스를 구현하는 클래스에서 제공됩니다.
    
  
  2. 상수만 포함 가능 : 인터페이스는 상수만을 멤버로 가질수 있습니다.
    
      모든 필드는 ‘public’, ‘static’, ‘final’ 로 선언됩니다.
    
  
  
    3. 다중 구현 지원 : 한 클래스는 여러 인터페이스를 구현할 수 있으며, 이를 통해 다중 상속의 이점을 얻을 수 있습니다.
  
  4. 디폴트 메소드와 정적 메소드 : 자바 8 이후부터는 인터페이스에 디폴트 메소드(구현을 포함하는 메소드)와 정적 메소드를 정의할 수 있게 되었습니다.
    
      이를 통해 더 유연한 설계가 가능해졌습니다.
    
  


1.3 인터페이스 정의 예시.
public interface Vehicle {
    void start();
    void stop();
}



  위 예제에서 ‘Vehicle’ 인터페이스는 ‘start’ 와 ‘stop’ 이라는 두 메소드를 정의합니다.
    
      이 인터페이스를 구현하는 모든 클래스는 이 두 메소드의 구체적인 구현을 제공해야 합니다.
    
  


1.4 인터페이스 구현 예.
public class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car starts.");
    }
    
    @Override
    public void stop() {
        System.out.println("Car stops.");
    }
}



  ‘Car’ 클래스는 ‘Vehicle’ 인터페이스를 구현합니다.
    
      이 클래스는 start 와 ‘stop’ 메소드를 구체적으로 구현해야 합니다.
    
  


1.5 결론.
인터페이스는 클래스와 다른 클래스 사이의 계약을 정의하고, 특정 작업을 수행하는 메소드의 시그니처를 강제합니다.
이는 코드의 상호 운용성을 높이고, 다형성을 통한 유연한 프로그래밍 설계를 가능하게 합니다.
인터페이스를 사용함으로써 다양한 구현체를 동일한 방식으로 처리할 수 있어, 코드의 유지보수성과 확장성이 향상됩니다.



2. 상수(constant).
자바 프로그래밍에서 상수(constant)는 값이 선언 후 변경될 수 없는 변수를 의미합니다.

상수는 일반적으로 프로그램 전체에서 변하지 않는 값에 사용되며, 이는 코드의 읽기 쉬움과 유지 관리를 돕습니다.

자바에서 상수를 선언하기 위해 ‘final’ 키워드를 변수 선언과 함께 사용합니다.

2.1 상수의 특징.

  1. 불변성 : 상수는 한 번 초기화되면 그 값이 변경될 수 없습니다.
  2. 명확성 : 코드 내에서 직접적인 값보다는 의미 있는 이름을 가진 상수를 사용함으로써 코드의 가독성과 유지보수성이 향상됩니다.
  3. 공용 사용 : 자주 사용되는 값이나 의미가 명확한 수치를 상수로 선언하여 코드 전바에 걸쳐 재사용할 수 있습니다.


2.2 상수 선언 예시.
상수를 선언하는 방법은 간단합니다.
‘final’ 키워드를 사용하여 변수를 선언하고, 초기화합니다.
일반적으로 상수의 이름은 대문자로 표기하며, 단어 간에는 언더스코어(‘_‘)를 사용합니다.
이는 상수임을 쉽게 식별할 수 있도록 도와줍니다.

public class Constants {
    public static final int MAX_WIDTH = 800;
    public static final int MAX_HEIGHT = 600;
    public static final String COMPANY_NAME = "MyCompany";
}


  위 예에서 ‘MAX_WIDTH’, ‘MAX_HEIGHT’, ‘COMPANY_NAME’ 은 모두 상수이며, 이들의 값은 선언된 후 변경될 수 없습니다.


2.3 상수 사용의 이점.

  오류 감소 : 값이 한 번 설정되면 변경되지 않기 때문에, 예상치 못한 곳에서 값이 변경되어 발생할 수 있는 버그를 줄일 수 있습니다.
  코드 재사용성 : 한 곳에서 값을 변경하면, 해당 상수를 사용하는 모든 위치에서 변경된 값이 적용됩니다. 이는 일관성 유지와 함께 코드 관리를 간소화합니다.
  컴파일 시간 최적화 : 상수 값은 컴파일 시간에 결정되므로, 런타임에 추가적인 계산 비용이 들지 않습니다.


2.4 결론.
상수는 프로그램 내에서 변하지 않는 값을 나타내며, 코드의 안정성과 유지보수성을 높이는 데 중요한 역할을 합니다.
자바에서는 ‘final’ 키워드를 사용하여 이러한 상수를 쉽게 생성할 수 있습니다.



3. 클래스의 상속과 인터페이스의 구현을 동시에 사용.
자바에서는 클래스의 상속과 인터페이스의 구현을 동시에 사용하여 “다중 상속“과 유사한 효과를 얻을 수 있습니다.

이는 자바의 설계에서 클래스는 단일 상속만을 허용하지만, 인터페이스는 다중으로 구현할 수 있게 함으로써 이루어집니다.

3.1 단일 상속과 다중 인터페이스 구현.

  단일 상속 : 자바에서 클래스는 단 하나의 상위 클래스만 상속받을 수 있습니다.
    
      이는 C++ 같은 언어에서 볼 수 있는 다중 상속의 복잡성과 관련된 문제(예: 다이아몬드 문제)를 피하기 위함입니다.
    
  
  다중 인터페이스 구현 : 한 클래스는 여러 인터페이스를 구현할 수 있습니다.
    
      이는 인터페이스가 구체적인 구현을 포함하지 않기 때문에(자바 8 이전까지, 자바 8 이후에는 디폴트 메소드를 통해 일부 구현을 포함할 수 있음), 클래스가 여러 인터페이스를 구현함으로써 다중 상속의 효과를 나타낼 수 있습니다.
    
  


3.2 예시.

  다음 예시에서 ‘Car’ 클래스는 ‘Vehicle’ 클래스를 상속받고, ‘Electric’ 및 ‘Autonomous’ 두 인터페이스를 구현하고 있습니다.
    
      이를 통해 ‘Car’ 클래스는 ‘Vehicle’ 클래스의 속성과 메소드를 상속받으며, 동시에 두 인터페이스의 메소드를 구현해야 합니다.
    
  


class Vehicle {
    void drive() {
        System.out.println("This vehicle is driving.");
    }
}

interface Electric {
    void charge();
}

interface Autonomous {
    void navigate();
}

class Car extends Vehicle implements Electric, Autonomous {
    @Override
    public void charge() {
        System.out.println("The car is charging.");
    }
    
    @Override
    public void navigate() {
        System.out.println("The car is navigating autonomously.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        myCar.drive();
        myCar.charge();
        myCar.navigate();
    }
}


3.4 결론.
자바에서는 한 클래스가 단일 상속을 통해 한 클래스의 기능을 상속받고, 동시에 여러 인터페이스를 구현함으로써 다중 상속의 효과를 얻을 수 있습니다.
이는 자바의 타입 시스템이 제공하는 유연성을 활용하는 좋은 예시로, 소프트웨어 설계에서 필요한 다양한 기능을 조합할 수 있게 해 줍니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-11-Input-Output-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-11-Input-Output-1.html"><h1 class="title_post">☕️[Java] 입출력(1)</h1></a>
                        <a href="/Backend/Java/2024-05-11-Input-Output-1.html" class="txt_post">
                            1️⃣ 입출력(1)

콘솔 입출력 방법에 대해 직접 구현

1. 콘솔 입력
자바에서 콘솔 입력을 받는 방법은 여러 가지가 있습니다.

주로 사용되는 몇 가지 방법들을 소개하겠습니다.


  1. Scanner 클래스 사용
    
      ‘Scanner’ 클래스는 자바의 ‘java.util’ 패키지에 포함되어 있으며, 다양한 타입의 입력을 콘솔에서 받기 위해 널리 사용됩니다.
      ‘System.in’ 을 ‘Scanner’ 객체에 연결하여 사용자로부터 입력을 받을 수 있습니다.
```java
import java.util.Scanner;
    
  


public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println(“Enter your name: “);
        String name = scanner.nextLine();
        System.out.println(“Hello, “ + name);
        scanner.close();
    }
}

- **2. BufferedReader** 와 **InputStreamReader 사용**
    - 이 방법은 **'java.io'** 패키지를 사용합니다.
    - **'InputStreamReader'** 는 바이트 스트림을 문자 스트림으로 변환하는데 사용되고, **'BufferedReader'** 는 텍스트 읽기를 효율적으로 할 수 있게 해 줍니다.
        - 이 방법은 예외 처리를 필요로하며, 라인 단위로 입력을 받습니다.
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
            System.out.println("Enter your name: ");
            String name = reader.readLine();
            System.out.println("Hello, " + name);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



  3. Console 클래스 사용
    
      ‘Console’ 클래스는 자바 6 이상에서 사용할 수 있으며, 콘솔에서 비밀번호와 같은 민감한 데이터를 읽을 때 유용합니다.
      ‘System.console()’ 메소드를 통해 ‘Console’ 객체를 얻을 수 있으나, 이 방법은 IDE에서는 작동하지 않을 수 있습니다.(콘솔 환경에서만 사용 가능.)
```java
import java.io.Console;
    
  


public class Main {
    public static void main(String[] args) {
        Console console = System.console();
        if (console != null) {
            String name = console.readLine(“Enter your name: “);
            char[] password = console.readPassword(“Enter your password: “);
            console.printf(“Hello, %s\n”, name);
        } else {
            System.out.println(“No console available”);
        }
    }
}
```

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-10-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-10-TIL.html"><h1 class="title_post">📝 [TIL] 240510 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-10-TIL.html" class="txt_post">
                            
  다형성
  추상클래스


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-10-abstractClass.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-10-abstractClass.html"><h1 class="title_post">☕️[Java] 추상클래스</h1></a>
                        <a href="/Backend/Java/2024-05-10-abstractClass.html" class="txt_post">
                            1️⃣ 추상클래스.
추상 클래스가 무엇인지 설명할 수 있음
abstract를 이용하여 추상 클래스 구현

1. 추상 메소드(Abstract Method)
자바 프로그래밍에서 추상 메소드(abstract method)는 선언만 있고 구현은 없는 메소드입니다.
이러한 메소드는 추상 클래스(abstract class)나 인터페이스(interface) 내부에서 선언될 수 있으며, 구체적인 행동은 하위 클래스에서 구현됩니다.

추상 메소드를 사용하는 주된 목적은 하위 클래스가 특정 메소드를 반드시 구현하도록 강제하는 것입니다.
이는 코드의 일관성을 유지하고, 다형성을 통한 유연한 프로그래밍 설계를 가능하게 합니다.

1.2 추상 메소드의 특징.

  선언만 있고 구현이 없음 : 메소드 본체가 없으며, 메소드 선언은 세미콜론(’;’) 으로 끝납니다.
  하위 클래스에서의 구현 필수 : 추상 메소드를 포함하는 클래스를 상속받는 모든 하위 클래스는 해당 메소드를 구현해야만 인스턴스 생성이 가능합니다.
  ‘abstract’ 키워드 사용 : 메소드 앞에 ‘abstract’ 키워드를 명시하여 추상 메소드임을 표시합니다.


1.3 추상 메소드 예시
다음은 추상 클래스와 추상 메소드의 간단한 예시입니다.
abstract class Animal {
    // 추상 메소드
    abstract void makeSound();
    
    void breathe() {
        System.out.println("Btrathing...");
    }
}

class Dog extends Animal {
    // 추상 메소드 구현
    void makeSound() {
        System.out.println("Bark!");
    }
}

class Cat extends Animal {
    // 추상 메소드 구현
    void makeSound() {
        System.out.println("Meow!");
    }
}



  위 예에서 ‘Animal’ 클래스는 ‘makeSound’ 라는 추상 메소드를 포함하고 있습니다.
  ‘Dog’ 와 ‘Cat’ 클래스는 ‘Animal’ 클래스를 상속받고 ‘makeSound’ 메소드를 각각 다르게 구현하고 있습니다.
    
      이는 다형성의 좋은 예로, ‘Animal’ 타입의 참조를 사용하여 각각의 하위 클래스 객체를 다룰 때 동일한 메소드(‘makeSound’)를 호출하더라도 서로 다른 행동(개는 짖고, 고양이는 울음)을 보여줍니다.
    
  


1.4 결론.
추상 메소드는 프로그램의 확장성과 유지보수성을 향상시키는 객체 지향 설계의 핵심 요소입니다.
다양한 상황에 맞춰 동일한 인터페이스에 여러 구현을 제공할 수 있어 유연한 코드 작성이 가능합니다.



2. 추상 클래스(abstract class)
자바에서 추상 클래스(abstract class)는 완전하지 않은 클래스로, 추상 클래스 자체로는 인스턴스를 생성할 수 없습니다.
추상 클래스의 주요 목적은 다른 클래스들의 기본이 되는 클래스를 제공하여 코드의 재사용성을 높이고, 일관된 설계를 유도하는 것입니다.
추상 클래스는 하나 이상의 추상 메소드를 포함할 수 있으며, 또한 구현된 메소드도 포함할 수 있습니다.

2.1 추상 클래스의 특징.

  1. 인스턴스 생성 불가 : 추상 클래스는 직접적으로 인스턴스를 생성할 수 없습니다. 반드시 상속을 통해 그 기능을 확장하고 구체적인 클래스에서 인스턴스를 생성해야 합니다.
  2. 추상 메소드 포함 가능 : 추상 클래스는 하나 이상의 메소드를 포함할 수 있습니다. 추상 메소드는 선언만 있고 구현은 없으며, 이를 상속받은 구체적인 클래스에서 구현해야 합니다.
  3. 구현된 메소드 포함 가능 : 추상 클래스는 구현된 메소드도 포함할 수 있어, 자식 클래스들이 이 메소드를 재사용하거나 오버라이드 할 수 있습니다.
  4. 생성자 및 필드 포함 가능 : 추상 클래스는 자신의 생성자와 필드(변수)를 가질 수 있으며, 이는 상속받은 클래스에서 사용할 수 있습니다.


2.2 추상 클래스의 사용 예시.
abstract class Animal {
    abstract void makeSound();
    
    void eat() {
        System.out.println("This animal is eating.");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark!");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow!");
    }
}



  이 예에서 ‘Animal’ 은 추상 클래스로, ‘makeSound()’ 메소드를 추상 메소드로 포함하고 있습니다.
    
      ‘Dog’ 와 ‘Cat’ 은 ‘Animal’ 클래스를 상속받아 ‘makeSound()’ 메소드를 각각 구현합니다.
      추상 클래스 ‘Animal’ 의 ‘eat()’ 메소드는 모든 동물이 공통적으로 사용할 수 있는 구현된 메소드입니다.
    
  


2.3 결론.
추상 클래스는 공통적인 특징을 가진 클래스들 사이의 일반적인 행동을 정의하고, 이를 상속받는 구체적인 클래스들이 이를 구현하도록 하는 데에 주로 사용됩니다.

이를 통해 코드의 재사용성과 유지보수성을 향상시키며, 객체 지향 설계의 일관성과 안정성을 보장할 수 있습니다.



3. 익명 클래스(anonymous class).
자바에서 익명 클래스(anonymous class)는 이름이 없는 클래스입니다.

이들은 주로 일회성 사용 목적으로 설계되며, 인터페이스나 추상 클래스를 간편하게 구현하거나, 기존 클래스를 임시로 확장하기 위해 사용됩니다.

익명 클래스는 일반적으로 이벤트 리스너나 작은 콜백 객체 같이 간단한 기능을 수행하는 데에 활용됩니다.

3.1 익명 클래스의 특징.

  1. 이름이 없음 : 익명 클래스는 이름을 가지지 않습니다. 인스턴스 생성 시점에 정의됩니다.
  2. 즉석에서 정의 및 사용 : 익명 클래스는 즉석에서 정의되어 바로 인스턴스가 생성됩니다. 보통 이들은 한 번만 사용되고 재사용되지 않습니다.
  3. 상속 및 구현 : 익명 클래스는 상쉬 클래스를 상속하거나 인터페이스를 구현할 수 있습니다. 그러나 다중 상속은 지원하지 않습니다.
  4. 오직 하나의 인스턴스만 생성 가능 : 익명 클래스로부터 직접적으로 두 개 이상의 객체를 생성할 수는 없습니다. 다시 사용하려면 클래스 정의를 반복해야 합니다.
  5. 지역 클래스 비슷 : 지역 변수처럼 동작하여 주변 스코프의 변수를 참조할 수 있습니다. 자바 8 이전에는 final 변수만 참조 가능했으나, 자바 8부터는 effectively final(명시적으로 final로 선언되지 않았어도 값이 변경되지 않는 변수) 변수도 참조할 수 있습니다.


3.2 익명 클래스의 사용 예.
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        System.out.println("버튼이 클릭되었습니다!");
    }
});


  위 예제에서 ‘ActionListener’ 인터페이스는 익명 클래스를 통해 구현되었습니다.
    
      ‘button.addActionListener’ 메소드에 직접 전달되면서 버튼 클릭 시 “버튼이 클릭되었습니다!”를 출력하는 ‘actionPerformed’ 메소드를 포함하고 있습니다.
    
  


3.3 결론.
익명 클래스는 특정 인터페이스나 상위 클래스의 메소드를 구현하거나 오버라이드할 때 사용됩니다.
짧고 간단한 기능을 구현하는 데 유용하며, 코드의 간결성을 유지할 수 있게 도와줍니다.
하지만 복잡한 로직이나 반복적으로 사용될 기능에 대해서는 일반 클래스나 지역 클래스를 사용하는 것이 더 적합할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-10-polymorphism.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-10-polymorphism.html"><h1 class="title_post">☕️[Java] 다형성</h1></a>
                        <a href="/Backend/Java/2024-05-10-polymorphism.html" class="txt_post">
                            1️⃣ 다형성.

1. 다형성(Polymorphism)
자바에서 말하는 다형성(Polymorphism)은 객체가 여러 형태를 취할 수 있는 능력을 말합니다.

이는 같은 이름의 메소드 호출이 객체의 타입에 따라 다은 동작을 수행할 수 있게 해 주어 코드의 유연성과 재사용성을 증가시킵니다.

자바에서는 주로 두 가지 형태의 다형성을 지원하는데, 이는 컴파일 시간 다형성과 런타임 다형성입니다.

1.2. 컴파일 시간 다형성(정적 다형성).
컴파일 시간 다형성은 주로 메소드 오버로딩을 통해 구현됩니다.
메소드 오버로딩은 동일한 메소드 이름을 가지면서 매개변수 타입, 순서, 개수가 다른 여러 메소드를 같은 클래스 내에 선언하는 것을 의미합니다.
이러한 메소드들은 컴파일 시에 그 타입에 따라 구별되어 처리됩니다.

1.3 컴파일 시간 다형성 예시.
public class Display {
    public void print(int num) {
        System.out.println("Printing integer: " + num);
    }
    
    public void print(String str) {
        System.out.println("Printing string: " + str);
    }
}


1.4 런타임 다형성(동적 다형성).
런타임 다형성은 메소드 오버라이딩을 통해 구현됩니다.
이 경우 서브클래스에서 상속받은 부모 클래스의 메소드를 재정의하여 동일한 메소드 호출이 서로 다른 클래스 객체에 대해 다른 동작을 할 수 있도록 합니다.
이는 실행 중에 결정되므로 동적 다형성이라고 합니다.

1.5 런타임 다형성 예시.
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    void sound() {
        System.out.println("Cat meows");
    }
}

public class TestPolymorphism {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        myAnimal.sound(); // 출력: Dog barks
        
        myAnimal = new Cat();
        myAnimal.sound(); // 출력: Cat meows
    }
}


  여기서 ‘Animal’ 클래스의 ‘sound()’ 메소드는 ‘Dog’ 와 Cat 클래스에서 오버라이딩되었습니다.
    
      ‘myAnimal’ 참조 변수는 ‘Animal’ 타입이지만, 참조하는 객체의 실제 타입에 따라 적절한 ‘sound()’ 메소드가 호출됩니다.
    
  


1.6 다형성의 장점.

  유연성 : 다형성을 사용하면 프로그램을 더 유연하게 설계할 수 있습니다.
    
      예를 들어, 다양한 지식 클래스의 객체들을 부모 클래스 타입의 컬렉션에 저장하고, 각 객체에 대해 공통된 인터페이스를 통해 작업을 수행할 수 있습니다.
    
  
  코드 재사용과 유지 보수의 향상 : 공통 인터페이스를 사용함으로써 코드를 재사용하고, 새로운 클래스 타입을 추가하거나 기존 클래스를 수정할 때 유지 보수가 용이해집니다.


📝 정리.
이렇게 다형성은 객체 지향 프로그래밍의 중요한 특성 중 하나로, 프로그램의 다양한 부분에서 유용하게 활용됩니다.



2. instanceof
자바 프로그래밍에서 ‘instanceof’ 연산자는 특정 객체가 지정한 타입의 인스턴스인지를 검사하는 데 사용됩니다.
이 연산자는 객체의 타입을 확인할 때 유용하게 쓰이며, 주로 객체의 실제 타입을 판별하여 안전하게 형 변환을 하기 전이나 특정 타입에 따른 조건 분기를 실행할 때 사용됩니다.

2.1 instanceof 연산자의 사용법.
‘instanceof’ 는 구 개의 피 연산자를 비교합니다.

  왼쪽 피연산자는 객체를 나타내며, 오른쪽 피연산자는 타입(클래스나 인터페이스)을 나타냅니다.
  연산의 결과는 불리언 값입니다.
    
      만약 왼쪽 피연산자가 오른쪽 피연산자가 지정하는 타입의 인스턴스면 ‘true’ 를, 그렇지 않으면 ‘false’ 를 반환합니다.
    
  


기본 구조
if (object instanceof ClassName) {
    // 조건이 참일 때 실행될 코드
}


예시
class Animal {}
class Dog extends Animal {}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Dog dog = new Dog();
        Animal animalDog = new Dog();
        
        System.out.println(animal instanceof Animal); // true
        System.out.println(dog instanceof Animal); // true
        System.out.println(animalDog instanceof Animal); // true
        System.out.println(animal instanceof Dog); // false
    }
}



  이 예시에서 ‘dog instanceof Animal’ 은 ‘true’ 를 반환합니다.
    
      왜냐하면 ‘Dog’ 클래스가 ‘Animal’ 클래스의 서브클래스이기 때문입니다.
      하지만 ‘animal instanceof Dog’ 은 ‘false’ 를 반환하는데, 이는 ‘Animal’ 인스턴스가 ‘Dog’ 타입이 아니기 때문입니다.
    
  


2.2 instanceof의 주의점

  1. null 검사 : ‘instanceof’ 는 객체 참조가 ‘null’ 일 때 항상 ‘false’ 를 반환합니다.
    
      따라서 ‘null’ 값에 대한 추가적인 검사 없이도 안전하게 사용할 수 있습니다.
    
  
  2. 다운캐스팅 검증 : 객체를 하위 클래스 타입으로 다운캐스팅하기 전에 ‘instanceof’ 를 사용하여 해당 객체가 실제로 해당 하위 클래스의 인스턴스인지를 확인하는 것이 안전합니다.
    
      이를 통해 ‘ClassCastException’ 을 예발할 수 있습니다.
    
  
  3. 인터페이스 검사 : ‘instanceof’ 는 클래스 뿐만 아니라 인터페이스 타입에 대해서도 사용할 수 있습니다. 객체가 특정 인터페이스를 구현하는지 여부를 검사할 수 있습니다.


📝 정리.
‘instanceof’ 는 다형성을 사용하는 객체 지향 프로그램에서 객체의 타입을 안전하게 확인하고, 타입에 맞는 적절한 동작을 수행하도록 도와주는 중요한 도구입니다.



3. 업캐스팅(Upcasting).
자바 프로그래밍에서 업캐스팅(Upcasting)은 서브클래스의 객체를 슈퍼클래스 타입의 참조로 변환하는 과정을 말합니다.
이는 일반적으로 자동으로 수행되며, 명시적으로 타입을 지정할 필요가 없습니다.
업캐스팅은 객체 지향 프로그래밍의 다형성을 활용하는 데 핵심적인 역할을 합니다.

3.1 업캐스팅의 특징과 이점.

  1. 자동 형 변환 : 자바에서는 서브클래스의 객체를 슈퍼클래스 타입의 탐조 변수에 할당할 때 자동으로 업캐스팅이 발생합니다.
  2. 안전성 : 업캐스팅은 항상 안전하며, 데이터 손실이나 오류 없이 수행됩니다. 이는 서브클래스가 슈퍼클래스의 모든 특성을 상속받기 때문입니다.
  3. 다형적 행동 : 업캐스팅을 통해 서브클래스의 객체들을 슈퍼클래스 타입으로 다룰 수 있어, 다양한 타입의 객체들을 일관된 방식으로 처리할 수 있습니다. 이를 통해 코드의 유연성과 재사용성이 향상됩니다.


3.2 예시.
아래는 업캐스팅을 사용한 자바 코드 예시입니다.
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        Animal myAnimal = myDog; // Dog 객체를 Animal 타입으로 업캐스팅
        
        myAnimal.eat(); // 호출 가능
        // myAnimal.bark(); // 컴파일 에러, Animal 타입은 bark 메소드를 알지 못함
    }
}



  이 예시에서 ‘Dog’ 객체가 ‘Animal’ 타입으로 업캐스팅 되었습니다.
    
      ‘myAnimal’ 변수는 ‘Animal’ 클래스의 메소드만 호출할 수 있으며, ‘Dog’ 클래스의 ‘bark()’ 메소드는 호출할 수 없습니다.
    
  


3.3 업캐스팅 후의 제한사항.
업캐스팅을 한 후에는 원래 서브클래스의 특정 메소드나 속성에 접근할 수 없게 됩니다.
즉, 업캐스팅된 객체는 슈퍼클래스의 필드와 메소드만 사용할 수 있으며, 추가된 서브클래스의 특성은 사용할 수 없습니다.
이는 다형성의 한 예로서, 슈퍼 클래스 타입을 통해 다양한 서브클래스의 객체들을 통합적으로 다룰 수 있도록 해주며, 프로그램을 더 유연하고 확장 가능하게 만듭니다.



4. 다운캐스팅(Downcasting).
자바 프로그래밍에서 다운캐스팅(Downcasting)은 슈퍼클래스 타입의 객체 참조를 서브클래스 타입의 참조로 변환하는 과정을 말합니다.
다운캐스팅은 업캐스팅의 반대 과정으로, 업캐스팅된 객체를 다시 원래의 서브클래스 타입으로 변환할 때 사용됩니다.
다운캐스팅은 명시적으로 수행되어야 하며, 자바에서는 이 과정이 자동으로 이루어지지 않습니다.

4.1 다운캐스팅의 필요성.
업캐스팅을 통해 객체가 슈퍼클래스 타입으로 변환되면, 해당 객체는 슈퍼클래스의 메소드와 필드만 접근 가능합니다.
서브클래스에만 있는 메소드나 필드에 접근하려면 다운캐스팅을 사용하여 해당 객체를 다시 서브클래스 타입으로 변환해야 합니다.

4.2 다운캐스팅의 사용법과 주의사항.
다운캐스팅은 타입 캐스팅 연산자를 사용하여 수행되며, 반드시 ‘instanceof’ 연산자로 타입 체크를 먼저 수행하는 것이 안전합니다.
이는 변환하려는 객체가 실제로 해당 서브클래스의 인스턴스인지 확인하여 ‘ClassCastExecption’ 을 방지하기 위함입니다.

4.3 예시.
다운캐스팅을 사용하는 자바 코드 예시입니다.
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // 업캐스팅
        myAnimal.eat();
        
        // 다운캐스팅 전에 instanceof로 체크
        if (myAnimal instanceof Dog) {
            Dog myDog = (Dog) myAnimal; // 다운캐스팅
            myDog.bark(); // 이제 서브클래스의 메소드 호출 가능
        }
    }
}



  이 예시에서 ‘Animal’ 타입의 ‘myAnimal’ 객체는 ‘Dog’ 클래스의 인스턴스입니다.
    
      ‘myAnimal’ 을 ‘Dog’ 타입으로 다운캐스팅하여 ‘Dog’ 클래스의 ‘bark()’ 메소드에 접근할 수 있습니다.
      다운캐스팅을 수행하기 전에 ‘instanceof’ 를 사용해 ‘myAnimal’ 이 실제로 ‘Dog’ 의 인스턴스인지 확인함으로써 안정을 확보합니다.
    
  


4.4 주의사항.

  다운캐스팅은 객체의 실제 타입이 캐스팅하려는 클래스 타입과 일치할 때만 안전하게 수행됩니다.
  잘못된 다운캐스팅은 런타임에 ‘ClassCastException’ 을 발생시킬 수 있습니다.


📝 정리.
다운캐스팅은 특정 상황에서 필수적이며, 객체의 모든 기능을 활용하기 위해 사용되지만, 항상 타입 검사를 수행하고 신중하게 사용해야 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-09-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-09-TIL.html"><h1 class="title_post">📝 [TIL] 240509 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-09-TIL.html" class="txt_post">
                            
  상속


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-09-Inheritance.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-09-Inheritance.html"><h1 class="title_post">☕️[Java] 상속</h1></a>
                        <a href="/Backend/Java/2024-05-09-Inheritance.html" class="txt_post">
                            1️⃣ 상속.



1. 상속(Inheritance)
자바 프로그래밍에서의 상속(Inheritance)은 한 클래스가 다른 클래스의 속성과 메소드를 물려받는 기능을 말합니다.

상속을 사용하면 기존 코드를 재사용하고 확장하는 것이 용이해져, 소프트웨어의 설계와 유지 보수가 효율적으로 이루어질 수 있습니다.

1.2 상속의 주요 개념.

  1. 슈퍼클래스(부모 클래스) : 기능이 상속되는 클래스입니다.
    
      예를 들어, ‘Vehicle’ 클래스가 있을 때 클래스의 속성(예: 속도)과 메소드(예: start, stop)를 다른 클래스가 상속받을 수 있습니다.
    
  
  2. 서브클래스(자식 클래스) : 슈퍼클래스의 속성과 메소드를 상속받는 클래스입니다.
    
      서브클래스는 메소드를 그대로 사용할 수도 있고, 필요에 따라 재정의(오버라이드)할 수도 있습니다.
        
          예를 들어, ‘Car’ 클래스가 ‘Vehicle’ 클래스를 상속받는 경우, ‘Car’ 는 ‘Vehicle’ 의 모든 속성과 메소드를 사용할 수 있으며 추가적인 기능(예: 4륜 구동 기능)을 더할 수 있습니다.
        
      
    
  
  3. 메소드 오버라이딩(Method Overriding) : 서브클래스가 슈퍼클래스에서 상속받은 메소드를 재정의하여 사용하는 것 입니다.
    
      서브클래스는 상속받은 메소드를 자신의 필요에 맞게 변경할 수 있습니다.
    
  
  4. 생성자 상속 : 자바에서 생성자는 상속되지 않습니다. 서브클래스의 생성자가 호출될 때, 슈퍼클래스의 생성자도 자동으로 호출되어야 하는데, 이는 ‘super()’ 키워드를 통해 명시적으로 호출해야 합니다.


📝 정리.
상속을 사용하면 코드의 중복을 줄이고, 각 클래스의 기능을 명확하게 구분지어 설계할 수 있어 프로그램 전체의 구조가 개선됩니다.





class 자식 클래스명 extends 부모 클래스명 { // 다중 상속 불가능
    필드;
    메소드;
    ...
}


2. 상속과 접근제어자와의 관계.
자바에서 상속과 접근 제어자(Access modifiers)는 클래스와 클래스 멤버(필드, 메소드)의 접근성을 결정하는 데 중요한 역할을 합니다.
접근 제어자는 클래스의 데이터를 보호하고, 코드의 유지 보수를 용이하게 하며, 외부로부터의 불필요한 접근을 막는 기능을 합니다.

상속에서 접근 제어자는 어떤 멤버가 서브클래스에게 상속될 수 있는지, 그리고 상속받은 멤버를 서브클래스가 어떻게 활용할 수 있는지 결정짓는 요소입니다.

2.1 주요 네 가지 접근 제어자.

  1. private : 멤버가 선언된 클래스 내에서만 접근 가능합니다.
    
      ‘private’ 접근 제어자가 지정된 멤버는 상속되지 않습니다.
    
  
  2. default(package-private) : 접근 제어자를 명시하지 않으면, 기본적으로 ‘default’ 접근이 적용됩니다.
    
      이러한 멤버들은 같은 패키지 내의 다른 클래스에서 접근할 수 있지만, 다른 패키지의 서브클래스에서는 접근할 수 없습니다.
    
  
  3. protected : ‘protected’ 멤버는 같은 패키지 내의 모든 클래스와 다른 패키지의 서브클래스에서 접근할 수 있습니다.
    
      이 접근 제어자는 상속을 사용할 때 특히 유용하며, 서브클래스가 슈퍼클래스의 멤버를 활용하거나 수정할 수 있게 합니다.
    
  
  4, public : ‘public’ 멤버는 모든 클래스에서 접근할 수 있습니다.
    
      상속과 관련하여, ‘public’ 멤버는 서브클래스에 의해 자유롭게 상속되고 사용될 수 있습니다.
    
  


📝 정리.

  상속과 접근 제어자의 관계에서 중요한 점은, 서브클래스가 상속받은 멤버에 접근할 수 있는 권한은 슈퍼클래스에서 해당 멤버에 지정된 접근 제어자에 의해 결정된다는 것 입니다.
    
      예를 들어, 슈퍼클래스에서 ‘protected’ 로 선언된 메소드는 서브클래스에서 접근 가능하고 필요에 따라 오버라이딩할 수 있지만, ‘private’ 으로 선언된 메소드는 서브클래스에서 직접접으로 접근하거나 사용할 수 없습니다.
        
          이러한 제한은 객체 지향 프로그래밍에서 캡슐화와 정보 은닉을 강화하는 데 도움을 줍니다.
        
      
    
  




3. super와 super().

자바에서 ‘super’ 키워드와 ‘super()’ 생성자 호출은 상속을 사용할 때 매우 중요한 역할을 합니다.
이들은 서브클래스가 슈퍼클래스와 상호작용할 수 있게 해 줍니다.

3.1 super와 super() 키워드의 사용 방식.

3.1.1 super 키워드.

  ‘super’ 키워드는 슈퍼 클래스의 필드나 메소드에 접근할 때 사용됩니다.
    
      서브클래스에서 메소드를 어버라이드 했을 때, 슈퍼클래스의 버전을 호출하고 싶은 경우에 유용하게 사용할 수 있습니다.
      이는 슈퍼클래스의 구현을 활용하면서 추가적인 기능을 서브클래스에 구현할 때 필요합니다.
        
          예를 들어, 슈퍼클래스 ‘Vehicle’ 의 메소드 ‘start()’ 를 서브클래스 ‘Car’ 에서 오버라이드한 후, ‘Car’ 의 ‘start()’ 메소드에서 ‘super.start()’ 를 호출하면, ‘Vehicle’ 클래스의 ‘start()’ 메소드가 실행됩니다.
        
      
    
  


3.1.2 super() 생성자 호출.

  ‘super()’ 는 서브클래스의 생성자에서 슈퍼클래스의 생성자를 호출할 때 사용됩니다.
    
      자바에서는 모든 클래스가 생성자를 가지며, 서브클래스의 생성자가 호출될 때 슈퍼클래스의 생성자도 자동으로 호출됩니다.
      명시적으로 슈퍼클래스의 생성자를 호출하고자 할 때 ‘super()’ 를 사용합니다.
    
  
  이 호출은 서브클래스의 생성자의 첫 번째 명령어로 위치해야 합니다.
    
      슈퍼클래스의 생성자를 호출함으로써, 슈퍼 클래스의 인스턴스 변수들이 적절히 초기화될 수 있습니다.
    
  
  예를 들어, 슈퍼클래스 ‘Vehicle’ 에 ‘Vehicle(int speed)’ 라는 생성자가 있고, 서브클래스 ‘Car’ 에서 이를 상속 받을 때, ‘Car’ 의 생성자에서 ‘super(100)’ 을 호출하면 ‘Vehicle’ 의 생성자가 호출죄어 ‘speed’ 변수가 ‘100’ 으로 초기화됩니다.


📝 정리.
이 두 사용법은 객체지향 프로그래밍에서 클래스의 계층을 통해 기능을 확장하고 관리하는 데 필수적입니다.
‘super’ 의 사용은 상속 관계에 있는 클래스 간의 코드를 재사용하고, 유지 관리를 쉽게 하며, 다형성을 구현하는 데 중요한 역할을 합니다.



4. 오버라이딩(Overriding)
자바 프로그래밍에서 오버라이딩(Overriding)은 서브클래스가 상속받은 슈퍼클래스의 메소드를 자신의 요구에 맞게 재정의하는 과정을 말합니다.

오버라이딩은 객체 지향 프로그래밍의 핵심 개념 중 하나로, 다형성을 가능하게 하며, 상속 받은 메소드를 서브클래스에서 새로운 방식으로 구현할 수 있도록 해줍니다.

4.1 오버라이딩 규칙.
오버라이딩을 할 때는 몇 가지 규칙을 따라야 합니다.


  1. 메소드 이름과 시그니처 일치 : 오버라이딩할 메소드는 슈퍼클래스의 메소드와 동일한 이름, 매개변수 목록, 반환 타입을 가져야 합니다.
  2. 접근 제어 : 오버라이딩하는 메소드는 슈퍼클래스의 메소드보다 더 제한적인 접근 제어를 가질 수 없습니다.
    
      예를 들어, 슈퍼클래스의 메소드가 ‘public’ 이라면 서브클래스의 오버라이딩 메소드도 적어도 ‘public’ 이어야 합니다.
    
  
  3. 반환 타입 : 오버라이딩하는 메소드의 반환 타입은 슈퍼클래스의 메소드 반환 타입과 같거나 그 하위 타입이어야 합니다.(이것은 공변 반환 타입이라고 함.)


4.2 오버라이딩의 예.
슈퍼클래스 ‘Animal’ 에 다음과 같은 메소드가 있다고 가정해 봅시다.
public class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
}


이제 ‘Dog’ 클래스가 ‘Animal’ 클래스를 상속받고 ‘makeSound()’ 메소드를 오버라이드하여 다음과 같이 구현할 수 있습니다.
public class Dog extends Animal {
    @Override // 이 어노테이션은 선택적이지만, 오버라이딩임을 명시적으로 나타냅니다.
    public void makeSound() {
        System.out.println("Dog barks");
    }
}



  이 예에서 ‘Dog’ 클래스의 ‘makeSound()’ 메소드는 ‘Animal’ 의 makeSound() 메소드를 오버라이드하여 “Dog barks”를 출력하도록 재정의합니다.


4.3 오버라이딩의 중요성.
오버라이딩은 다음과 같은 이점을 제공합니다.

  유연성 : 같은 메소드 호출이지만, 다양한 서브클래스에서 서로 다른 동작을 구현할 수 있습니다.
  재사용성 : 기존의 코드를 변경하지 않고도, 상속받은 메소드를 새로운 요구에 맞게 확장할 수 있습니다.
  유지보수 : 코드의 중복을 줄이고, 유지보수를 간편하게 할 수 있습니다.


📝 정리.
오버라이딩은 프로그램의 다형성을 구현하는 데 필수적인 기능으로, 상속받은 메소드를 사용하는 대신 서브클래스에 맞게 특화된 기능을 구현할 수 있도록 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-08-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-08-TIL.html"><h1 class="title_post">📝 [TIL] 240508 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-08-TIL.html" class="txt_post">
                            
  클래스와 객체(2)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-08-ClassesAndObjects-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-08-ClassesAndObjects-2.html"><h1 class="title_post">☕️[Java] 클래스와 객체(2)</h1></a>
                        <a href="/Backend/Java/2024-05-08-ClassesAndObjects-2.html" class="txt_post">
                            1️⃣ 클래스와 객체(2)

1. 오버로딩(Overloading).
자바 프로그래밍에서 오버로딩(Overloading)은 같은 클래스 내에서 메소드 이름이 같지만 매개변수의 타입이나 개수가 다른 여러 메소드를 정의하는 것을 의미합니다.

오버로딩을 사용하면 같은 기능을 하는 메소드라도 다양한 입력에 대응하여 유연하게 메소드를 호출할 수 있습니다.

오버로딩은 메소드만 가능하며, 생성자에도 적용될 수 있습니다.

1.2. 오버로딩의 규칙.

  1. 메소드 이름이 같아야 합니다 : 오버로딩된 메소드들은 같은 이름을 공유합니다.
  2. 매개변수 목록이 달라야 합니다 : 매개변수의 개수나 타입, 혹은 그 순서가 달라야 합니다. 매개변수의 차이를 통해 자바 컴파일러는 호출할 적절한 메소드를 결정합니다.
  3. 반환 타입은 오버로딩을 구분하는 데 사용되지 않습니다 : 오버로딩된 메소드는 반환 타입이 다르더라도, 이는 오버로딩을 구분하는 데 사용되지 않습니다.
    
      즉, 반환 타입만 다른 메소드는 오버로딩이 아닙니다.
    
  
  4. 접근 제어자와 예외는 오버로딩을 구분하는 데 사용되지 않습니다 : 이 역시 메소드를 구별하는 데 사용되지 않습니다.


1.3. 오버로딩의 예.
public class Print {
    // 오버로딩 예제: 같은 메소드 이름, 다른 매개변수 타입
    public void display(int a) {
        System.out.println("Integer: " + a);
    }
    
    public void display(String a) {
        System.out.println("String: " + a);
    }
    
    // 오버로딩 예제: 같은 메소드 이름, 다른 매개변수 개수
    public void display(int a, int b) {
        System.out.println("Two integers: " + a + ", " + b);
    }
    
    // 오버로딩 예제: 같은 메소드 이름, 매개변수의 순서가 다름
    public void display(String a, int b) {
        System.out.println("String and integer: " + a + ", " + b);
    }
}

public class Test {
    public static void main(String[] args) {
        Print prt = new Print();
        prt.display(1); // 출력: Integer: 1
        prt.display("Hello"); // 출력: String: Hello
        prt.display(1, 2); // 출력: Two integers: 1, 2
        prt.display("Age", 30); // 출력: String and integer: Age, 30
    }
}



  이 예제에서 ‘Print’ 클래스는 ‘display’ 라는 메소드를 여러 번 오버로딩했습니다.
    
      매개변수의 타입, 개수, 순서에 따라 다른 메소드가 호출됩니다.
        
          이를 통해 다양한 타입과 개수의 입력을 유연하게 처리할 수 있습니다.
        
      
    
  


📝 정리.
오버로딩을 통해 프로그램의 가독성을 향상시키고, 유사한 기능을 하는 메소드들을 하나의 이름으로 그룹화함으로써 프로그램을 더욱 직관적으로 만들 수 있습니다.

이러한 방식은 프로그래밍의 복잡성을 줄이고, 코드의 유지보수를 용이하게 합니다.



2. 접근제어자(Access Modifiers).
자바 프로그래밍에서 접근 재어자(Access Modifiers)는 클래스, 메서드, 변수 등과 같은 멤버들에 대한 접근 권한을 제어하는 키워드입니다.

이러한 접근 제어자를 사용함으로써 클래스의 캡슐화를 강화할 수 있으며, 객체의 데이터와 메서드를 외부에서 직접접으로 접근하거나 수정하는 것을 제한할 수 있습니다.

접근 제어자는 클래스의 멤버(변수, 메서드, 생성자 등)와 클래스 자체에 적용될 수 있습니다.

2.1 자바에서 사용하는 주요 접근 제어자


  1. public : 어떤 클래스에서든 접근할 수 있도록 허용합니다.
    
      public으로 선언됩 멤버는 어디서든 접근이 가능합니다.
    
  




  2. protected : 같은 패키지 내의 클래스 또는 다른 패키지의 서브 클래스에서 접근할 수 있습니다.




  3. default(package-private) : 접근 제어자를 명시하지 않은 경우, 같은 패키지 냐의 클래스들만 접근할 수 있습니다. 이를 종종 package-private라고도 합니다.




  private : 해당 멤보를 선언한 클래스 내에서만 접근할 수 있습니다. 외부 클래스에서는 접근할 수 없어, 클래스 내부 구현을 숨기는 데 유용합니다.


2.2 접근 제어자의 사용 예제.

public class AccessExample {
    public int publicVar = 10; // 어디서든 접근 가능
    protected int protectedVar = 20; // 같은 패키지 또는 상속 받은 클래스에서 접근 가능
    int defaultVar = 30; // 같은 패키지 내에서만 접근 가능
    private int privateVar = 40; // 이 클래스 내에서만 접근 가능
    
    public void show() {
        System.out.println("publicVar: " + publicVar);
        System.out.println("protectedVar: " + pretectedVar);
        System.out.println("defaultVar: " + defaultVar);
        System.out.println("privateVar: " + privateVar);
    }
}

public class Test {
    public static void main(String[] args) {
        AccessExample example = new AccessExample();
        System.out.println(example.publicVar); // 접근 가능
        System.out.println(example.protectedVar); // 다른 패키지에 있지 않은 이상 접근 가능
        System.out.println(example.defaultVar); // 같은 패키지에 있을 경우 접근 가능
        // System.out.println(example.privateVar); // 컴파일 에러 발생, 접근 불가능
        example.show(); // 모든 변수 출력 가능
            
    }
}


  위 예제에서는 다양한 접근 제어자가 적용된 변수들을 선언하고, 이에 대한 접근 가능성을 보여줍니다.
  ‘publicVar’ 은 어디서든 접근할 수 있지만, ‘privateVar’ 는 오직 선언된 클래스 내부에서만 접근할 수 있습니다.
  ‘protectedVar’ 과 ‘defaultVar’ 는 좀 더 제한적인 접근을 허용합니다.


📝 정리.
이렇게 접근 제어자를 통해 자바에서는 데이터 보호 및 캡슐화, 객체의 정확한 사용을 보장하여 프로그램의 안정성과 유지보수성을 향상시킬 수 있습니다.



3. static 키워드.
자바 프로그래밍에서 ‘static’ 키워드는 클래스의 멤버(필드, 메서드, 블록 또는 내부 클래스)를 클래스 레벨에 소속 시키는 역할을 합니다.

이는 특정 인스턴스에 속하기보다는 클래스 자체에 속한다는 의미입니다.

‘static’ 멤버는 클래스의 모든 인스턴스에 의해 공유되며, 클래스가 메모리에 로드될 때 생성되고, 클래스가 언로드될 때 소멸됩니다.

3.1 static의 특징.

  1. 클래스 레벨에서 공유 : ‘static’ 필드는 클래스의 모든 인스턴스 간에 공유됩니다.
    
      이는 특정 데이터를 모든 객체가 공유해야 할 필요가 있을 때 유용합니다.
    
  
  2. 인스턴스 생성 없이 접근 기는 : ‘static’ 메서드나 필드는 객체의 인스턴스를 생성하지 않고도 클래스 이름을 통해 직접 접근할 수 있습니다.
  3. 정적 초기화 블록 : ‘static’ 키워드를 사용한 블록(정적 블록)은 클래스가 처음 메모리에 로그 될 때 단 한 번 실행됩니다.
    
      이는 ‘static’ 필드의 초기화에 사용할 수 있습니다.
    
  


3.2 static 필드와 메서드 사용 예.
public class Calculator {
    // 정적 필드
    public static int calculatorCount = 0;
    
    // 정적 블록
    static {
        System.out.println("Calculator 클래스 로딩!");
    }
    
    // 생성자
    public Calculator() {
        calculatorCount++; // 생성될 때마다 계산기의 수를 증가
    }
    
    // 정적 메서드
    public static int add(int a, int b) {
        return a + b;
    }
}

public class Test {
    public static void main(String[] args) {
        Calculator c1 = new Calculator();
        Calculator c2 = new Calculator();
        
        System.out.println("Created Calculators: " + Calculator.calculatorCount); // 2 출력
        System.out.println("Sum: " + Calculator.add(5,3)); // 8 출력
    }
}



  이 예제에서는 ‘Calculator’ 클래스의 인스턴스 생성 횟수를 추적하는 ‘static’ 필드 ‘calculatorCount’ 와 정적 메서드 ‘add’ 를 사용합니다.
    
      ‘calculatorCount’ 는 ‘Calculator’ 의 모든 인스턴스에 의해 공유되며, ‘add’ 메서드는 인스턴스를 생성하지 않고도 호출할 수 있습니다.
    
  


3.3 static 사용 시 주의점

  ‘static’ 메서드 내에서는 인스턴스 변수나 메서드를 직접 사용할 수 없습니다.
  ‘static’ 은 남용하면 객체지향의 원칙을 해칠 수 있습니다.
    
      예를 들어, 객체 간의 상태 공유가 과도하게 이루어져 객체 간의 결합도가 높아질 수 있습니다.
    
  
  ‘static’ 변수는 프로그램의 실행이 끝날 때까지 메모리에 남아 있으므로 메모리 사용에 주의해야 합니다.


3.4 static 메소드와 static 변수와의 관계성.
자바 프로그래밍에서 ‘static’ 메소드와 ‘static’ 변수는 두 가지 공통점을 가지고 있습니다.

둘 다 클래스 레벨에서 정의되며, 클래스의 모든 인스턴스 간에 공유됩니다.

이런 공통점 때문에, ‘static’ 메소드는 ‘static’ 변수에 직접 접근할 수 있지만, 일반 인스턴스 변수에는 접근할 수 없습니다.

3.5 static 변수.
‘static’ 변수는 클래스 변수라고도 하며, 특정 클래스의 모든 인스턴스에 의해 공유됩니다.
이 변수는 클래스가 메모리에 로드될 때 생성되고, 클래스가 언로드될 때까지 메모리에 존재합니다.
‘static’ 변수는 특히 클래스의 인스턴스들이 공통적으로 사용해야 하는 데이터를 저장하는데 유용합니다.
예를 들어, 모든 계산기 객체가 공유해야 하는 ‘calculatorCount’ 와 같은 경우에 사용됩니다.

3.6 static 메소드
‘static’ 메소드 역시 클래스 레벨에 정의되며, 이 메소드는 인스턴스 생성 없이 클래스 이름을 통해 직접 호출할 수 있습니다.

‘static’ 메소드는 인스턴스 필드나 메소드에 접근할 수 없습니다.

그 이유는 ‘static’ 메소드가 호출될 때 해당 클래스의 인스턴스가 존재하지 않을 수 있기 때문입니다.
따라서 ‘static’ 메소드는 오로지 ‘static’ 변수나 다른 ‘static’ 메소드에만 접근할 수 있습니다.

3.7 두 요소의 상호작용.
‘static’ 메소드에는 ‘static’ 변수에 자유롭게 접근하고 수정할 수 있습니다.
이는 ‘static’ 변수가 클래스에 속하고 메소드도 클래스 레벨에서 실행되기 때문입니다.
예를 들어, 어떤 클래스의 모든 인스턴스가 사용할 설정 값을 ‘static’ 변수에 저장하고, 이 값을 설정하거나 조회하는 ‘static’ 메소드를 제공할 수 있습니다.

3.8 예제
public class Counter {
    public static int count = 0; // 'static' 변수
    
    public static void increment() { // 'static' 메소드
        count++; // 'static' 변수에 접근하여 값을 증가
    }
    
    public static void displayCount() {
        System.out.println("Count: " + count); // 'static' 변수의 현재 값을 출력
    }
}

public class Test {
    public static void main(String[] args) {
        Counter.increment();
        Counter.increment();
        Countet.displayCount(); // 출력: Count: 2
    }
}



  
    이 예제에서 ‘Counter’ 클래스는 ‘static’ 변수 ‘count’ 를 가지고 있으며, increment 메소드를 통해 이 변수의 값을 증가시키고, ‘displayCount’ 메소드를 통해 값을 출력합니다.
  
  
    모든 ‘Counter’ 객체가 ‘count’ 값을 공유하며, ‘static’ 메소드를 통해 이 값을 조작할 수 있습니다.
  


📝 정리.
‘static’ 은 전역 변수나 전역 메서드와 유사한 효과를 제공하지만, 자바의 객체지향적 특성과 일관성을 유지하기 위해 적절히 사용되어야 합니다.

‘static’ 메소드와 ‘static’ 변수는 클래스 레벨에서 관리되어 클래스의 모든 인스턴스에 의해 공유되는 특성을 가지고 있습니다.

이를 통해 클래스 전체에 영향을 미치는 작업을 수행할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-07-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-07-TIL.html"><h1 class="title_post">📝 [TIL] 240507 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-07-TIL.html" class="txt_post">
                            
  다차원 배열
  클래스와 객체(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-07-MultidimensionalArray.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-07-MultidimensionalArray.html"><h1 class="title_post">☕️[Java] 다차원 배열</h1></a>
                        <a href="/Backend/Java/2024-05-07-MultidimensionalArray.html" class="txt_post">
                            1️⃣ 다차원 배열.
자바 프로그래밍에서 다차원 배열이란, 배열의 배열을 의미합니다.
이는 데이터를 행렬이나 그리드 형태로 구성할 수 있게 해주며, 주로 2차원 이상의 데이터 구조를 필요로 할 때 사용됩니다.
가장 흔한 형태는 2차원 배열이지만, 3차원 이상의 배열도 만들 수 있습니다.

1. 2차원 배열.
2차원 배열은 행렬과 비슷하게 생각할 수 있으며, 각 행과 열에 데이터를 저장합니다.

  예를 들어, 숫자로 이루어진 표를 저장하거나 정보를 격자 형태로 관리할 때 유용합니다.


1.2 2차원 배열의 초기화
자바에서 이차원 배열을 초기화하는 방법은 크게 세 가지로 나눌 수 있습니다.
배열을 선언할 때 크기만 지정해 두거나, 선언과 동시에 특정 값을 사용하여 초기화하거나, 나중에 각 요소에 값을 할당할 수 있습니다.

아래는 각 방법에 대한 설명과 예제입니다.

1.1.1 크기만 지정하여 배열 선언하기.
이 방법은 배열의 행과 열의 크기를 지정해 초기화하지만, 배열의 각 요소는 자동으로 기본 값으로 설정됩니다.(예: int의 경우 0).

inu[][] array = new int[3][4]; // 3행 4열의 배열 생성


  이렇게 선언된 배열은 모든 요소가 0으로 초기화됩니다.


1.1.2 선언과 동시에 초기값을 제공하여 배열 초기화하기.
배열을 선언하면서 동시에 초기값을 제공할 수 있습니다.
이 방법은 배열의 내용을 명확히 알고 있을 때 유용합니다.
int[][] array = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
}; // 각 행에 대한 값들을 중괄호로 묶어서 초기화


  이 예제에서 배열은 3행 4열의 구조로, 각 행의 값이 명시적으로 초기화되어 있습니다.


1.1.3 반복문을 사용하여 배열 초기화하기.
반복문을 사용하면 배열의 각 요소를 동적으로 초기화할 수 있습니다.
이 방법은 런타임에 따라 배열 값을 설정해야 할 때 유용합니다.
int[][] array = new int[3][4];
for (int i = 0; i &lt; array.length; i++) {
    for (int j = 0; j &lt; array[i].length; j++) {
        array[i][j] = (i + 1) * (j + 1); // 각 요소를 행 인덱스와 열 인덱스의 곱으로 초기화
    }
}



  이 방법은 배열의 각 위치에 i와 j 인덱스에 의존하는 계산 결과를 저장합니다.


📝 정리.
이 세 가지 방법은 상황에 따라 각기 다른 이점을 제공하므로, 요구 사항에 맞게 선택하여 사용할 수 있습니다.

2. 3차원 배열.
3차원 배열은 데이터를 3차원 공간으로 구성하여 저장합니다.
이는 비디오 게임의 공간 데이터, 과학 실험 데이터 등 복잡한 정보를 구조화하는 데 사용될 수 있습니다.

2.1. 3차원 배열의 초기화.
자바에서 3차원 배열을 초기화하는 방법은 2차원 배열과 유사합니다.
크게 세 가지 방법으로 나눌 수 있습니다.


  크기만 지정하여 선언하기.
  선언과 동시에 구체적인 값으로 초기화하기
  반복문을 사용하여 동적으로 초기화하기


아해는 각 방법에 대한 설명과 예시입니다.

2.1.1. 크기만 지정하여 배열 선언하기.
이 방법은 삼차원 배열의 각 차원의 크기를 지정합니다.
각 요소는 자동으로 기본값으로 설정됩니다.(예: ‘int’ 의 경우 0).

int[][][] array = new int[3][4][5] // 3개의 4x5 행렬을 갖는 삼차원 배열



  이 배열은 3개의 2차원 배열을 가지며, 각 2차원 배열은 4행 5열 구조입니다.


2.1.2. 선언과 동시에 초기값을 제공하여 배열 초기화하기.
삼차원 배열을 선언하면서 바로 값을 지정할 수 있습니다.
이 방법은 각 요소의 초기값을 명확히 알고 있을 때 매우 유용합니다.
int [][][] array = {
    {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15},
        {16, 17, 18, 19, 20}  
    },
    {
        {21, 22, 23, 24, 25},
        {26, 27, 28, 29, 30},
        {31, 32, 33, 34, 35},
        {36, 37, 38, 39, 40}
    },
    {
        {41, 42, 43, 44, 45},
        {46, 47, 48, 49, 50},
        {51, 52, 53, 54, 55},
        {56, 57, 58, 59, 60}
    }
}; // 각 행렬 및 행에 대한 값들을 중괄호로 묶어서 초기화


2.1.3. 반복문을 사용하여 배열 초기화하기
반복문을 사용해 삼차원 배열의 각 요소를 동적으로 초기화할 수 있습니다.
이 방법은 프로그램 실행 중에 배열 값을 설정해야 할 때 매우 유용합니다.
int[][][] array = new int[3][4][5];

for (int i = 0; i &lt; array.length; i++) {
    for (int j = 0; j &lt; array[i].length; j++) {
        for (int k = 0; k &lt; array[i][j].length; k++) {
            array[i][j][k] = (i + 1) * (j + 1) * (k + 1) // 각 요소를 i, j, k 인덱스의 곱으로 초기화
        }
    }
}



  이 예제에서는 각 위치에 해당하는 인덱스의 곱을 저장하여 배열을 초기화하고 있습니다.
    
      이러한 초기화 방법은 특히 배열의 구조가 복잡할 때 배열을 효과적으로 관리할 수 있게 도와줍니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-07-ClassesAndObjects-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-07-ClassesAndObjects-1.html"><h1 class="title_post">☕️[Java] 클래스와 객체(1)</h1></a>
                        <a href="/Backend/Java/2024-05-07-ClassesAndObjects-1.html" class="txt_post">
                            1️⃣ 클래스와 객체(1)

1. 클래스(Class)
자바 프로그래밍 언어에서 클래스는 객체를 생성하기 위한 설계도 혹은 템플릿입니다.
클래스는 객체의 상태를 정의하는 필드(변수)와 객체의 행동을 정의하는 메서드(함수)로 구성됩니다.

클래스를 사용하는 주된 목적은 데이터와 그 데이터를 조작하는 방법들은 하나의 장소에 묶어 관리하기 위함입니다.
이를 통해 데이터 추상화, 캡슐화, 상속, 다형성 등의 객체지향 프로그래밍의 주요 개념들을 구현할 수 있습니다.

1.2 클래스의 구성 요소.

  1. 필드(Field) : 객체의 데이터 또는 상태를 저장하는 변수입니다.
  2. 메서드(Method) : 객체가 수행할 수 있는 행동을 정의한 코드 블록입니다.
    
      메서드는 필드의 값을 처리하거나 다른 메서드를 호출할 수 있습니다.
    
  
  3. 생성자(Constructor) : 클래스로부터 객체를 생성할 때 초기화를 담당하는 특별한 종류의 메서드입니다.
    
      생성자는 클래스 이름과 같은 이름을 가집니다.
    
  


1.3 클래스 예제
자바에서의 간단한 클래스 예제를 살펴보겠습니다.
public class Car {
    // 필드(변수)
    private String color;
    private String model;
    
    // 생성자
    public Car(String color, String model) {
        this.color = color;
        this.model = model;
    }
    
    // 메서드
    public void drive() {
        System.out.println(model + " 색상의 " + color + " 자동차가 주행 중입니다.");
    
    }
}

// 객체 생성 및 사용
public class Test {
    public static void main(String[] args) {
        Car myCar = new Car("레드", "테슬라");
        myCar.drive();
    }
}



  위의 예제에서 ‘Car’ 클래스는 ‘color’와 ‘model’이라는 두 개의 필드를 가지며, 이는 각각 자동차의 색상과 모델을 나타냅니다.
  ‘Car’ 클래스의 객체를 생성할 때는 ‘new’ 키워드와 함께 생성자를 호출하여 초기 상태를 설정합니다.
  ‘drive’ 메서드는 자동차가 주행하고 있음을 시뮬레이션하는 기능을 합니다.


📝 정리.
클래스를 사용함으로써 코드의 재사용성, 관리성 및 확장성이 향상되며, 대규모 소프트웨어 개발에서 필수적인 요소가 됩니다.



2. 객체(Object)와 인스턴스(Instance).
자바 프로그래밍에서 “객체(Object)”와 “인스턴스(Instance)”는 매우 중요한 개념입니다.
이 두 용어는 종종 서로 바꿔 쓰이지만, 각각의 의미에는 약간의 차이가 있습니다.

2.1 객체(Object).
객체는 소프트웨어 세계의 구성 요소로, 실제 세계의 객체를 모방한 것입니다.
객체는 데이터(속성)와 그 데이터를 조작할 수 있는 함수(메서드)를 캡슐화합니다.
객체는 클래스에 정의된 속성과 기능을 실제로 사용할 수 있도록 메모리상에 할당된 구조입니다.
객체의 개념은 클래스의 특성을 실제로 구현하는 것입니다.

2.2 인스턴스(Instance).
인스턴스는 클래스 타입에 따라 생성된 객체를 의미합니다.
예를 들어, ‘Car’ 클래스의 구체적인 객체(예: 빨간색 테슬라 자동차, 파란색 현대 자동차 등)는 모두 ‘Car’ 클래스의 인스턴스입니다.
즉, 인스턴스는 특정 클래스의 구현체입니다.
인스턴스라는 용어는 주로 객체가 메모리에 할당되어 실제로 생성되었음을 강조할 때 사용됩니다.

2.3 객체와 인스턴스의 관계.
간단히 말해, 모든 인스턴스는 객체입니다, 하지만 사용된 맥락에 따라 ‘인스턴스’라는 용어는 그 객체가 특정 클래스의 구현체임을 명시적으로 나타낼 때 사용됩니다.
예를 들어, 우리가 ‘new Car(“blue”, “Hyundai”)’ 를 통해 생성한 객체는 ‘Car’ 클래스의 인스턴스입니다.

2.4 예제 코드.
public class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void speak() {
        System.out.println(name + " makes a noise.");
    }
}

public class Test {
    public static void main(String[] args) {
        // 여기서 'dog'는 Animal 클래스의 객체이자 인스턴스입니다.
        Animal dog = new Animal("Dog");
        dog.speak();
    }
}



  위 예제에서 ‘Animal’ 클래스가 있고, ‘main’ 메서드에서 ‘Animal’ 클래스의 새 객체를 생성합니다.
    
      여기서 ‘dog’ 는 ‘Animal’ 클래스의 인스턴스이며 객체입니다.
        
          ‘dog’ 는 ‘Animal’ 클래스에 정의된 메서드와 필드를 사용할 수 있습니다.
        
      
    
  


📝 정리.
요약하면, 객체는 속성과 메서드를 갖는 소프트웨어의 기본 구성 단위이고, 인스턴스는 그 객체가 특정 클래스의 실제 구현체임을 의미합니다.
이 두 용어는 프로그래밍에서 클래스 기반의 객체를 생성하고 다룰 때 핵심적인 역할을 합니다.

클래스와 객체의 관계를 이해
기본 사용 방법과 생성자 및 this의



3. 메소드(Method).
자바 프로그래밍에서 메소드(Method)는 클래스에 속한 함수로서, 특정 작업을 수행하는 코드 블록입니다.
메소드는 객체의 행동을 정의하며, 클래스 내에서 정의된 데이터나 상태(필드)를 조작하는 데 사용됩니다.

메소드를 통해 객체지향 프로그래밍의 중요한 특징인 캡슐화와 추상화를 구현할 수 있습니다.

3.1 메소드의 주요 특징.

  1. 재사용성 : 메소드는 코드의 재사용성을 증가시킵니다. 한 번 정의된 메소드는 여러 위치에서 호출되어 사용될 수 있습니다.
  2. 모듈성 : 메소드를 사용함으로써 큰 프로그램을 작은 단위로 나누어 관리할 수 있습니다. 이는 코드의 가독성과 유지보수성을 향상시킵니다.
  3. 정보 은닉 : 메소드를 통해 구현 세부사항을 숨기고 사용자에게 필요한 기능만을 제공할 수 있습니다.


3.2 메소드의 구성 요소.

  1. 메소드 이름 : 메소드를 식별하는 데 사용되며, 메소드가 수행하는 작업을 설명하는 명확한 이름을 가집니다.
  2. 매개변수 목록(Parameter List) : 메소드에 전달되는 인자의 타입, 순서, 그리고 개수를 정의합니다. 매개변수는 선택적일 수 있습니다.
  3. 반환 타입 : 메소드가 작업을 수행한 후 반환하는 데이터의 타입입니다. 반환할 데이터가 없으면 ‘void’ 로 지정됩니다.
  4. 메소드 바디 : 실제로 메소드가 수행할 작업을 구현하는 코드 블록입니다.


3.3 예제.
자바에서 간단한 메소드 예제를 보여드리겠습니다.
public class Calculator {
    // 메소드 정의: 두 정수의 합을 반환
    public int add(int num1, int num2) {
        return num1 + num2;
    }
    
    // 메소드 정의: 두 정수의 차를 반환
    public int subtract(int num1, int num2) {
        return num1 - num2;
    }
}

public class Test {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        int result1 = calc.add(5, 3); // 8 반환
        int result2 = calc.subtract(5, 3); // 2 반환
        System.out.println("Addition Result: " + result1);
        System.out.println("Subtraction Result: " + result2);
    }
}



  이 예제에서 ‘Calculator’ 클래스는 두 개의 메소드 ‘add’ 와 ‘subtract’ 를 가지고 있습니다.
    
      각각의 메소드는 두 개의 정수를 받아 그 결과를 반환합니다.
        
          이렇게 메소드를 사용하면 코드를 효율적으로 관리할 수 있으며, 필요에 따라 재사용할 수 있습니다.
        
      
    
  


📝 정리.
메소드는 자바 프로그래밍에서 기능을 모듈화하고 코드의 재사용을 가능하게 하는 핵심 요소입니다.



4. 접근 제어자(Access Modifiers)
자바 프로그래밍에서 접근 제어자(Access Modifiers)는 클래스, 메서드, 변수 등과 같은 멤버들에 대한 접근 권한을 제어하는 키워드입니다.

이러한 접근 제어자를 사용함으로써 클래스의 캡슐화를 강화할 수 있으며, 객체의 데이터와 메서드를 외부에서 직접적으로 접근하거나 수정하는 것을 제한할 수 있습니다.

접근 제어자는 클래스의 멤버(변수, 메서드, 생성자 등)와 클래스 자체에 적용될 수 있습니다.

4.1 자바에서 사용하는 주요 접근 제어자.

  1. public : 어떤 클래스에서든 접근할 수 있도록 허용합니다.
    
      public으로 선언된 멤버는 어디서든 접근이 가능합니다.
    
  
  
    2. protected : 같은 패키지 내의 클래스 또는 다른 패키지의 서브 클래스에서 접근할 수 있습니다.
  
  3. default(package-private) : 접근 제어자를 명시하지 않은 경우, 같은 패키지 내의 클래스들만 접근할 수 있습니다.
    
      이를 종종 package-private라고도 합니다.
    
  
  4. private : 해당 멤버를 선언한 클래스 내에서만 접근할 수 있습니다.
    
      외부 클래스에서는 접근할 수 없어, 클래스 내부 구현을 숨기는 데 유용합니다.
    
  


4.2 접근 제어자의 사용 예제.
public class AccessExample {
    public int publicVar = 10; // 어디서든 접근 가능
    protexted int protectedVar = 20; // 같은 패키지 또는 상속받은 클래스에서 접근 가능
    int defaultVar = 30; // 같은 패키지 내에서만 접근 가능
    private int privateVar = 40; // 이 클래스 내에서만 접근 가능
    
    public void show() {
        System.out.println("publicVar: " + publicVar);
        System.out.println("protectedVar: " + protectedVar);
        System.out.println("defaultVar: " + defaultVar);
        System.out.println("privateVar: " + privateVar);
    }
}

public class Test {
    public static void main(String[] args) {
        AccessExample example = new AccessExample();
        System.out.println(example.publicVar); // 접근 가능
        System.out.println(example.protectedVar); // 다른 패키지에 있지 않은 이상 접근 가능
        System.out.println(example.defaultVar); // 같은 패키지에 있을 경우 접근 가능
        // System.out.println(example.privateVar); // 컴파일 에러 발생, 접근 불가능
        example.show(); // 모든 변수 출력 가능
    }
}



  위 예제에서는 다양한 접근 제어자가 적용된 변수들을 선언하고, 이에 대한 접근 가능성을 보여줍니다.
    
      ‘publicVar’ 은 어디서든 접근할 수 있지만, ‘privateVar’ 는 오직 선언된 클래스 내부에서만 접근할 수 있습니다.
      ‘protectedVar’ 과 ‘defaultVar’ 는 좀 더 제한적인 접근을 허용합니다.
    
  


📝 정리.
이렇게 접근 제어자를 통해 자바에서는 데이터 보호 및 캡슐화, 객체의 정확한 사용을 보장하여 프로그램의 안정성과 유지보수성을 향상시킬 수 있습니다.



5. static 키워드.
자바 프로그래밍에서 ‘static’ 키워드는 특정 필드나 메소드, 또는 중첩 클래스를 클래스의 인스턴스가 아닌 클래스 자체에 소속되게 합니다.

이를 사용함으로써 해당 멤버는 클래스의 모든 인스턴스에 걸쳐 공유되며, 인스턴스 생성 없이 클래스 이름을 통해 직접 접근할 수 있습니다.

5.1 static의 주요 사용 사례.

  1. 정적 필드(Static Fields) : 모든 인스턴스에 의해 공유되는 클래스 변수입니다.
    
      예를 들어, 회사의 모든 직원이 같은 회사 이름을 공유할 때 사용할 수 있습니다.
    
  
  2. 정적 메소드(Static Methods) : 인스턴스 변수에 접근할 필요 없이, 클래스 이름을 통해 직접 호출할 수 있는 메소드입니다.
    
      유틸리티 함수나 핼퍼 함수를 작성할 때 자주 사용됩니다.
    
  
  
    3. 정적 초기화 블록(Static Initialization Blocks) : 클래스가 처음 로딩될 때 한 번 실행되며, 정적 변수를 초기화하는 데 사용됩니다.
  
  4. 정적 중첩 클래스(Static Nested Classes) : 다른 클래스 내부에 위치하면서도 독립적으로 사용될 수 있는 클래스입니다.


5.2 static 키워드의 장점과 단점.
장점.

  메모리 효율성 : static 멤버는 클래스 로드 시 메모리에 한 번만 할당되고 모든 인스턴스가 공유하기 때문에 메모리 사용을 최소화할 수 있습니다.
  편리성 : 객체 생성 없이 바로 접근할 수 있어, 유틸리티 함수 같은 공통 기능 구현에 유용합니다.


단점.

  과도한 사용은 객체지향 원칙에 어긋남 : 객체 간의 결합도가 높아지고, 객체의 상태 관리가 어려워질 수 있습니다.
  테스트가 어려워질 수 있슴 : static 메소드는 오버라이드가 불가능하며, 상태를 공유하기 때문에 병렬 테스트 환경에서 문제를 일으킬 수 있습니다.


5.3 예제.
public class Company {
    // 정적 필드
    public static String companyName = "Global Tech";
    
    // 정적 메소드
    public static void printCompanyName() {
        System.out.println("Company Name: " + companyName);
    }
}

public class Test {
    public static void main(String[] args) {
        // 객체 생성 없이 정적 메소드 호출
        Company.printCompanyName();
    }
}



  이 예제에서 ‘Company’ 클래스에는 정적 필드 ‘companyName’ 과 정적 메소드 ‘printCompanyName()’ 이 있습니다.
    
      ‘main’ 메소드에서는 ‘Company’ 클래스의 객체를 생성하지 않고도 ‘printCompanyName()’ 메소드를 호출하려 회사 이름을 출력합니다.
    
  


📝 정리.
정적 멤버는 클래스와 관련된, 변하지 않는 값이나, 모든 인스턴스가 공유해야 하는 정보를 관리할 때 유용하게 사용됩니다.



6. 생성자(Constructor)
자바 프로그래밍에서 생성자(Constructor)는 클래스로부터 객체가 생성될 때 호출되는 특별한 유형의 메서드입니다.
생성자의 주요 목적은 새로 생성된 객체를 초기화하는 것으로, 객체의 기본 상태를 설정하는 데 사용됩니다.

생성자는 메서드처럼 보일 수 있지만, 리턴 타입이 없고 클래스 이름과 동일한 이름을 가집니다.

6.1 생성자 특징.

  1. 클래스 이름과 동일 : 생성자의 이름은 항상 선언된 클래스의 이름과 동일해야 합니다.
  2. 리턴 타입 없음 : 생성자는 값을 반환하지 않으며, 리턴 타입도 선언하지 않습니다.
  3. 자동 호출 : 객체가 생성될 때 자동으로 호출됩니다.
    
      이는 객체의 필드를 초기화하거나, 객체 생성 시 실행해야 할 다른 시작 루틴을 실행하는 데 사용할 수 있습니다.
    
  
  4. 오버로딩 가능 : 하나의 클래스에 여러 생성자를 정의할 수 있습니다.
    
      이를 생성자 오버로딩이라고 하며, 파라미터의 수나 타입에 따라 다른 생성자를 호출할 수 있습니다.
    
  


6.2 생성자의 유형.

  1. 기본 생성자(Default Constructor) : 개발자가 명시적으로 생성자를 정의하지 않으면, 자바 컴파일러는 매개변수가 없는 기본 생성자를 제공합니다.
    
      이 기본 생성자는 객체의 필드를 기본값으로 초기화합니다.
    
  
  2. 매개변수가 있는 생성자(Parameterized Constructor) : 하나 이상의 매개변수를 받아 객체의 초기 상태를 세팅 할 수 있도록 해줍니다.


6.3 예제.
public class Person {
    private String name;
    private int age;
    
    // 기본 생성자
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }
    
    // 매개변수가 있는 생성자
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void displayInfo() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}

public class Test {
    public static void main(String[] args) {
        // 기본 생성자를 사용하여 객체 생성
        Person person1 = new Person();
        person1.displayInfo(); // 출력: Name: Unknown, Age: 0
        
        // 매개변수가 있는 생성자를 사용하여 객체 생성
        Person person2 = new Person("Jhon", 25);
        person2.displayInfo(); // 출력: Name: Jhon, Age: 25
    }
}


  이 예제에서 ‘Person’ 클래스는 두 가지 유형의 생성자를 가집니다.
    
      하나는 매개변수가 없어 기본값으로 객체를 초기화하고, 다른 하나는 이름과 나이를 받아 객체를 초기화합니다.
    
  


📝 정리.
생성자를 사용함으로써 클래스의 인스턴스가 유효한 상태로 시작될 수 있도록 보장하며, 필요한 초기 설정을 자동으로 수행할 수 있습니다.
이는 객체 지향 프로그래밍에서 객체의 무결성을 유지하는 중요한 방법입니다.



7. this 키워드와 this() 생성자 호출.
자바에서 ‘this’ 키워드와 ‘this()’ 생성자 호출은 객체 자신을 참조하고 객체의 생성자를 호출하는 데 사용되는 중요한 요소입니다.

이들은 객체 내부에서 사용되며, 클래스의 멤버(필드, 메서드, 생성자)와 관련된 동작을 명확히 하는 데 유용합니다.

7.1 this 키워드.
‘this’ 키워드는 현재 객체, 즉 메서드나 생성자를 호출하는 인스턴스를 참조하는 데 사용됩니다.

주로 다음과 같은 상황에서 사용됩니다.


  
    1. 필드와 매개변수 이름이 같을 때 구분 : 메서드나 생성자의 매개변수와 클래스의 필드 이름이 같을 때, 필드와 매개변수를 구분하기 위해 사용됩니다.
  
  
    2. 메서드 체이닝 : 객체의 메서드를 연속적으로 호출할 때 ‘this’ 를 반환함으로써 메서드 체이닝을 구현할 수 있습니다.
  
  
    3. 현재 객체를 다른 메서드에 전달 : 현재 객체의 참조를 다른 메서드에 전달할 때 사용됩니다.
  


7.2 this() 생성자 호출.
‘this()’ 는 같은 클래스의 다른 생성자를 호출하는 데 사용됩니다.
주로 생성자 오버로딩이 있을 때, 중복 코드를 최소화하고, 하나의 생성자에서 다른 생성자를 호출하여 필드 초기화 등의 공통 작업을 중앙집중적으로 관리할 수 있게 해줍니다.


  
    1. 생성자 오버로딩 처리 : 클래스에 여러 생성자가 있을 때,  ‘this()’ 를 사용하여 한 생성자에서 다른 생성자를 호출함으로써 공통 코드를 재사용할 수 있습니다.
  
  
    2. 코드 간결성 유지 : 필수적인 초기화 작업을 주 생성자에만 명시하고, 나머지 생성자는 이 주 생성자를 호출하게 함으로써 코드의 간결성을 유지합니다.
  


7.3 예제.
public class Rectangle {
    private int width;
    private int height;
    
    // 주 생성자
    public Rectangle(int width, int height) {
        this.width = width; // 'this'로 필드와 매개변수 구분
        this.height = height;
    }
    
    // 부 생성자
    public Rectangle() {
        this(10, 10) // 'this()' 로 다른 생성자 호출
    }
    
    public void displaySize() {
        System.out.println("Width: " + this.width + ", Height: " + this.height);
    }
}

public class Test {
    public static void main(String[] args) {
        Rectangle rect1 = new Rectangle(30, 40);
        rect1.displaySize(); // 출력: Width: 30, Height: 40
        
        Rectangle rect2 = new Rectangle();
        rect2.displaySize(); // 출력: Width: 10, Height: 10
    }
}



  이 예제에서 ‘Rectangle’ 클래스는 두 개의 생성자를 가지고 있습니다.
    
      기본 생성자는 ‘this()’ 를 사용하여 주 생성자를 호출하고, 주 생성자에서는 ‘this’ 키워드를 사용하여 클래스 필드와 생성자 매개변수를 구분합니다.
        
          이렇게 ‘this’ 와 ‘this()’ 를 사용함으로써 코드의 중복을 줄이고, 초기화 로직을 하나의 생성자에 집중할 수 있습니다.
        
      
    
  


📝 정리.
이처럼 ‘this’ 와 ‘this()’ 는 자바에서 클래스의 인스턴스 자신을 참조하거나 클래스 내 다른 생성자를 호출하는 데 매우 유용한 도구입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-06-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-06-TIL.html"><h1 class="title_post">📝 [TIL] 240506 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-06-TIL.html" class="txt_post">
                            
  반복문


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-06-loopStatement.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-06-loopStatement.html"><h1 class="title_post">☕️[Java] 반복문</h1></a>
                        <a href="/Backend/Java/2024-05-06-loopStatement.html" class="txt_post">
                            1️⃣ 반복문

1. for 반복문.
자바 프로그래밍에서 ‘for’ 반복문은 특정 조건을 만족하는 동안 코드 블록을 반복해서 실행하도록 설계된 제어 구조입니다.
‘for’ 문은 초기화, 조건 검사, 반복 후 실행할 작업(일반적으로 증감)을 한 줄에 명시하여 코드의 가독성과 관리를 용이하게 합니다.
이는 반복 실행이 필요한 많은 상황에서 유용하게 사용됩니다.

1.2 for 반복문의 기본 구조.
‘for’ 문의 기본 구조는 다음과 같습니다.

for (초기화; 조건; 증감) {
    // 반복해서 실행할 코드
}


  초기화 : 반복문이 시작할 때 한 번 실행되는 부분으로, 반복문의 제어 변수를 초기 설정합니다.
  조건 : 이 조건이 참(‘true’) 인 동안 반복문 내의 코드가 실행 됩니다. 조건이 거짓(‘false’)이 되면 반복문은 종료됩니다.
  증감 : 각 반복의 끝에서 실행되며, 주로 제어 변수의 값을 증가시키거나 감소시키는데 사용됩니다.


1.3 for 반복문의 예시
기본 예시

for (int i = 0; i &lt; 5; i++) {
    System.out.println("i의 값은: " + i);
}



  이 예제에서는 ‘i’ 를 0부터 시작하여 ‘i’ 가 5미만일 동안 반복하여, 매 반복마다 ‘i’ 를 1씩 증가시킵니다.
    
      따라서 “i의 값은: 0” 부터 “i의 값은: 4” 까지 총 다섯 번의 출력을 하게 됩니다.
    
  


확장된 예시: 다중 제어 변수
for (int i = 0, j = 10; i &lt; j; i++, j--) {
    System.out.println("i = " + i + ". j = " + j);
}



  이 예제에서는 두 개의 제어 변수 ‘i’ 와 ‘j’ 를 사용합니다.
    
      ‘i’ 는 증가하고 ‘j’ 는 감소하며, ‘i’ 가 ‘j’ 와 같거나 ‘j’ 보다 크게 되면 반복이 종료됩니다.
        
          이런 패턴은 복잡한 반복 조건이 필요한 경우 유용하게 사용됩니다.
        
      
    
  


1.4 사용 사례
‘for’ 반복문은 배열이나 컬렉션과 같은 데이터 구조를 순회할 때 매우 유용합니다.
예를 들어, 배열의 모든 요소를 처리하거나 조작할 때 자주 사용됩니다.
int[] numbers = {1,2,3,4,5};
for (int i = 0; i &lt; numbers.length; i++) {
    System.out.println("배열 요소: " + numbers[i]);
}



  여기서 ‘numbers.length’ 는 배열의 길이를 반환하며, ‘i’ 는 0에서 시작하여 배열의 크기 미만이 될 때까지 증가하면서 배열의 각 요소에 접근합니다.


📝 정리
‘for’ 반복문은 코드를 간결하게 하면서 반복적인 작업을 효과적으로 처리할 수 있도록 도와줍니다.



2. while 반복문.
자바 프로그래밍에서 ‘while’ 반복문은 특정 조건이 참(‘true’)인 동간 주어진 코드 블록을 반복적으로 실행하는 구조 입니다.
‘while’ 문은 주로 반복 횟수가 불확실할 때 또는 반복 횟수를 사전에 정확히 알 수 없을 때 사용됩니다.

2.1 while 반복문의 기본 구조.
‘while’ 문의 기본 구조는 다음과 같습니다.

while (조건) {
    // 조건이 참인 동안 반복 실행될 코드
}


  여기서 ‘조건’ 은 각 반복 이전에 평가되며, 이 조건이 참(‘true’)일 때 반복 블록 내의 코드가 실행됩니다. 조건이 거짓(‘false’)이 되면 반복문은 종료됩니다.


2.2 while 반복문 예시.
간단한 예
int i = 0;
while (i &lt; 5) {
    System.out.println("i의 값은: " + i);
    i++; // i 값을 증가시켜 조건이 eventually 거짓이 되도록 함
}



  이 예제에서는 ‘i’ 가 0부터 시작하여 5미만인 동안 반복문을 실행합니다.
    
      반복문 내에서 ‘i’ 를 1씩 증가시켜 eventually 조건이 거짓이 되도록 합니다.
        
          결과적으로 ‘i’ 의 값은 0부터 4까지 콘솔에 출력됩니다.
        
      
    
  


사용자 입력 받기
‘while’ 문은 사용자 입력을 받고, 그 입력에 따라 반복을 계속할지 여부를 결정할 때 유용하게 사용될 수 있습니다.
예를 들어, 사용자가 특정 문자를 입력할 때까지 입력을 계속 받는 프로그램은 다음과 같이 작성할 수 있습니다.
Scanner scanner = new Scanner(System.in);
String input = "";
while (!input.equals("종료")) {
    System.out.println("문자열을 입력하세요. 종료하려면 '종료'를 입력하세요: ");
    input = scanner.nextLine();
}
scanner.close();


2.3 주의사항.
‘while’ 반복문을 사용할 때는 반복문 내에서 조건이 eventually(결국) 거짓이 될 수 있도록 조치를 취해야 합니다.
그렇지 않으면, 조건이 항상 참으로 평가될 경우 무한 후프에 빠질 수 있습니다.
따라서 조건 변수를 적절히 조작하거나 적절한 로직을 구현하여 반복문이 적절한 시점에 종료될 수 있도록 해야 합니다.

📝 정리.
‘while’ 문은 그 구조가 간단하고 유연하여, 특정 조건 하에 반복 실행을 해야 할 때 매우 유용한 프로그래밍 도구입니다.



3. do-while 반복문.
자바 프로그래밍에서 ‘do-while’ 반복문은 조건을 검사하기 전에 최소 한 번은 코드 블록을 실행하는 반복문입니다.
이 구조는 ‘while’ 반복문과 비슷하지만, 조건의 참/거짓 여부에 관계없이 최소한 처음에는 반복문 내의 코드를 실행한다는 점이 다릅니다.
‘do-while’ 문은 주로 사용자 입력을 처리하거나, 조건이 반복문의 실행 후에 결정되어야 할 때 유용합니다.

3.1 do-while 반복문의 기본 구조.
‘do-while’ 문의 기본 구조는 다음과 같습니다.
do {
    // 최소 한 번은 실행될 코드
} while (조건);



  여기서 ‘조건’ 은 반복문의 끝에서 평가됩니다.
    
      조건이 참(‘true’)이면, 코드 블록이 반복적으로 실행됩니다. 조건이 거짓(‘false’)이면, 반복이 종료됩니다.
    
  


3.2 do-while 반복문의 예시.
기본 예
int i = 0;
do {
    System.out.println("i의 값은: " + i);
    i++;
} while (i &lt; 5);



  이 예제에서는 ‘i’ 가 0부터 시작하여 ‘i &lt; 5’ 인 동안 반복합니다.
    
      ‘do-while’ 문은 ‘i’ 의 초기 값에 상관없이 최소 한 번은 “i의 값은: 0”을 출력하고 시작합니다. 그 후 ‘i’ 가 5미만인 동안 계속해서 반복됩니다.
    
  


사용자 입력 받기
사용자로부터 입력을 받고, 특정 조겅(“종료” 문자열 입력)을 만족할 때까지 계속 입력을 받는 프로그램을 구현할 때 ‘do-while’ 문이 유용하게 사용됩니다.

Scanner scanner = new Scanner(System.in);
String input;
do {
    System.out.println("문자열을 입력하세요. 종료하려면 '종료'를 입력하세요:");
    input = scanner.nextLine();
} while (!input.equals("종료"));
scanner.close();


  이 코드는 사용자가 “종료”를 입력할 때까지 계속해서 입력을 받습니다.
    
      입력을 받는 동작은 최소 한 번은 실행되며, 이는 ‘do-while’ 문이 최조 실행을 보장하기 때문입니다.
    
  


3.3 주의사항.
‘do-while’ 반복문을 사용할 때, 조건을 적절히 설정하여 반복문이 적절한 시점에 종료되도록 해야 합니다. 그렇지 않으면 무한 루프에 빠질 수 있습니다.
또한, 조건 검사가 반복문의 끝에서 이루어지므로, 조건이 매우 빨리 거짓이 되어도 코드 블록이 한 번은 실행됨을 기억해야 합니다.

📝 정리.
‘do-while’ 문은 조건이 반복 블록 실행 후에만 알 수 있거나, 반복 블록을 적어도 한 번은 실행해야 하는 경우 특히 유용한 도구입니다.



4. continue.
자바 프로그래밍에서 ‘continue’ 문은 반복문 내에서 사용되며, 그것이 실행될 때 현재 반복의 나머지 부분을 건너뛰고 즉시 다음 반복으로 넘어가도록 합니다.
이를 통해 특정 조건에서 반복문의 다음 순환을 즉시 시작할 수 있게 해줍니다.
‘continue’ 는 주로 반복문 내에서 특정 조건에 대한 예외 처리나 불필요한 처리를 건너뛰기 위해 사용됩니다.

4.1 continue 기본 사용법
‘continue’ 문은 주로 ‘for’, ‘while’, 또는 ‘do-while’ 반복문 내에서 사용됩니다.
간단하게는 ‘continue’ 를 실행하면 반복문의 현재 순회에서 남은 코드를 실행하기 않고, 다음 반복으로 진행합니다.

4.2 continue 예시
‘for’ 반복문에서의 사용
for (int i = 0; i &lt; 10; i++) {
    if (i % 2 == 0) {
        continue; // 짝수인 경우, 출력을 건너뛰고 다음 반복으로 넘어감
    }
    System.out.println(i); // 홀수만 출력
}



  이 코드는 0부터 9까지의 숫자 중에서 홀수만 출력합니다.
    
      ‘i’ 가 짝수일 경우, ‘continue’ 문이 실행되어 ‘System.out.println(i);’ 줄을 건너뛰고 다음 반복으로 넘어갑니다.
    
  


‘while’ 반복문에서의 사용
int i = 0;
while (i &lt; 10) {
    i++;
    if (i % 2 == 0) {
        continue; // 짝수인 경우, 아래의 출력을 건너뛰고 다음 반복으로 넘어감
    }
    System.out.println(i); // 홀수만 출력
}



  이 예제에서도 ‘continue’ 는 짝수를 확인하는 조건에서 참일 경우 나머지 코드를 건너뛰고 다음 반복을 계속 진행하도록 합니다.


4.3 continue 특징 및 주의사항.

  ‘continue’ 문은 현재 수행 중인 반복의 나머지 부분을 건너뛰고, 반복문의 조건 검사로 직접 이동하여 다음 반복을 시작합니다.
  ‘continue’ 문을 사용할 때는 반복문이 무한 루프에 빠지지 않도록 주의해야 합니다.
    
      예를 들어, ‘continue’ 문이 반복문의 변수 값을 변경하는 코드를 건너뛰면 그 변수의 값이 업데이트되지 않아 무한 루프가 발생할 수 있습니다.
    
  
  ‘continue’ 는 루프의 흐름을 제어하고, 코드의 읽기 어려움을 증가시킬 수 있으므로, 사용할 때는 명확한 이유가 있어야 합니다.


📝 정리.
‘continue’ 문은 코드를 보다 효율적으로 만들고, 필요 없는 조건을 빠르게 건너뛸 수 있게 도와줍니다.
그러나 코드의 가독성과 유지 관리에 영향을 줄 수 있으므로 신중하게 사용해야 합니다.



5. break문.
자바 프로그래밍에서 ‘break’ 문은 반복문(‘for’, ‘while’, ‘do-while’) 또는 ‘switch’ 문에서 현재 블록의 실행을 즉시 종료하고, 해당 블록의 바깥으로 제어를 이동시키는 역할을 합니다.

이는 반복문 또는 ‘switch’ 문 내에서 특정 조건을 만족할 때 추가적인 처리 없이 루프나 선택 구조를 벗어나기 위해 사용됩니다.

5.1 break 기본 사용법.

  반복문에서의 사용 : ‘break’ 를 사용하여 무한 루프를 종료하거나 특정 조건이 만족될 때 반복문을 조기에 종료할 수 있습니다.
  ‘switch’ 문에서의 사용 : 각 ‘case’ 블록 뒤에 ‘break’ 를 사용하여 ‘switch’ 문을 종료하고, 다음 ‘case’ 로 넘어가지 않도록 합니다.


5.2 break 예시
반복문에서의 ‘break’
for (int i = 0; i &lt; 10; i++) {
    if (i == 5) {
        break; // i가 5가 되면 for 루프를 종료
    }
    System.out.println(i);
}


  이 코드에서는 ‘i’ 가 5에 도달하면 ‘break’ 문이 실행되어 ‘for’ 루프가 즉시 종료됩니다.
    
      결과적으로, 0부터 4까지의 숫자만 출력됩니다.
    
  


‘while’ 반복문에서의 ‘break’
int i = 0;
while (true) { // 무한 루프
    if (i == 5) {
        break; // i가 5가 되면 while 루프를 종료
    }
    System.out.println(i);
    i++;
}


  이 예제에서도 ‘i’ 가 5일 때 ‘break’ 문을 사용하여 무한 루프를 종료합니다.


‘switch’ 문에서의 ‘break’
int number = 2;
switch (number) {
    case 1:
        System.out.println("Number is 1");
        break;
    case 2:
        System.out.println("Number is 2");
        break;
    case 3:
        System.out.println("Number is 3");
        break;
    default:
        System.out.println("Number is not 1, 2, or 3");
}



  ‘switch’ 문에서 ‘number’ 가 2일 때 해당하는 ‘case’ 블록이 실행되고, ‘break’ 문으로 인해 ‘switch’ 문을 벗어나게 됩니다.


5.3 break문 특징 및 주의사항

  ‘break’ 문은 코드 실행을 즉시 중단시키므로, 효과적인 프로그램 흐름 제어를 가능하게 합니다.
  반복문이나 ‘switch’ 문 내에서만 ‘break’ 문을 사용할 수 있습니다.
  ‘break’ 문을 사용할 때는 코드의 흐름을 명확히 이해하고 있어야 하며, 무분별한 사용은 코드의 가독성과 유지보수를 어렵게 만들 수 있습니다.


📝 정리.
‘break’ 는 코드의 복잡성을 줄이고 특정 조건에서 즉시 반복문을 종료할 수 있는 강력한 도구입니다.
그러나 그 사용은 코드의 구조를 명확하게 유지하는 방식으로 신중하게 이루어져야 합니다.



6. for-each문.
자바 프로그래밍에서 ‘for-each’ 문, 또는 강화된 ‘for’ 문(enhanced for loop)은 배열이나 컬렉션 프레임워크에 저장된 각 요소를 순회하기 위해 사용되는 구문입니다.

기존의 ‘for’ 문보다 간결하며, 코드를 읽고 작성하기가 더 쉬워 배열이나 컬렉션의 모든 요소에 접근할 때 일반적으로 권장되는 방식입니다.

6.1 for-each문 기본 구조.
‘for-each’ 문의 기본 구조는 다음과 같습니다.
for (타입 변수명 : 배열 또는 컬렉션) {
    // 변수명을 사용한 코드
}



  여기서 ‘타입’ 은 배열 또는 컬렉션에 저장된 요소의 타입을 말하고, ‘변수명’ 은 반복되는 각 요소를 참조하는 데 사용되는 변수 이름입니다.
  ‘배열 또는 컬렉션’ 은 순회할 배열이나 컬렉션 객체를 지정합니다.


6.2 for-each문 예시
배열 사용 예
int[] numbers = {1,2,3,4,5};
for(int number: numbers) {
    System.out.println(number);
}


  이 코드에서 ‘for-each’ 문은 ‘numbers’ 배열의 모든 요소를 순회합니다.
    
      각 반복에서 ‘number’ 변수에 배열의 요소가 할당되며, 그 값을 출력합니다.
    
  


컬렉션 사용 예
List&lt;String&gt; names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name);
}


  이 예에서는 ‘names’ 리스트의 모든 요소를 순회합니다.
    
      각 요소는 ‘name’ 변수에 할당되고, ‘System.out.println’ 을 통해 출력됩니다.
    
  


6.3 for-each문의 장점.

  가독성 향상: ‘for-each’ 문은 간결하고 이해하기 쉬워, 코드의 가독성을 크게 향상시킵니다.
  오류 감소: 전통적인 ‘for’ 문에서 발생할 수 있는 인덱스 관련 실수나 경계 조건 오류를 방지할 수 있습니다.
  향상된 추상화: 컬렉션의 내부 구조나 크기를 몰라도 각 요소에 접근할 수 있습니다.


6.4 for-each문의 제한사항.

  컬렉션 수정 불가: ‘for-each’ 문을 사용하는 동안 컬렉션을 수정할 수 없습니다.
    
      예를 들어, 순회 중인 컬렉션에서 요소를 추가하거나 제거할 수 없습니다.
    
  
  인덱스 접근 불가: ‘for-each’ 문은 각 요소에 대한 인덱스를 제공하지 않습니다.
    
      특정 인덱스의 요소에 접근하거나 인덱스를 활용한 복잡한 로직이 필요한 경우에는 전통적인 ‘for’ 문을 사용해야 합니다.
    
  


📝 정리.
‘for-each’ 문은 자바에서 컬렉션과 배열을 효율적으로 처리할 수 있는 강력하고 사용하기 쉬운 도구입니다.
이를 통해 코드를 더욱 간결하고 안전하게 만들 수 있습니다.



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-05-06-addressSpaceInMemory.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-05-06-addressSpaceInMemory.html"><h1 class="title_post">💾 [CS] 메모리의 주소 공간</h1></a>
                        <a href="/2024/CS/2024-05-06-addressSpaceInMemory.html" class="txt_post">
                            메모리의 주소 공간.

주소에는 물리 주소와 논리 주소가 있다. 이번 절에서는 이 두 주소의 개념과 차이, 그리고 두 주소 간의 변환 방법을 학습한다.

1. 주소의 종류.
지금까지 ‘메모리에 저장된 정보의 위치는 주소로 나타낼 수 있다’ 정도로만 설명했지만, 사실 주소에는 두 종류가 있습니다.


  1. 물리주소 : 메모리 하드웨어가 사용하는 주소.
  2. 논리주소 : CPU와 실행 중인 프로그램이 사용하는 주소.


2. 물리 주소와 논리 주소.
CPU와 실행 중인 프로그램은 현재 메모리 몇 번지에 무엇이 저장되어 있는지 다 알고 있지 않습니다.

  그 이유는 메모리에 저장된 정보는 시시각각 변하기 때문입니다.


메모리에는 새롭게 실행되는 프로그램이 시시때때로 적재되고, 실행이 끝난 프로그램은 삭제됩니다.
게다가, 같은 프로그램을 실행하더라도 실행할 때마다 적재되는 주소가 달라질 수 있습니다.

  예를 들어, 1500번지에 적재되었던 프로그램을 다시 실행하면 3000번지, 또 다시 실행하면 2700번지에 적재될 수 있습니다.


그렇다면 CPU와 실행 중인 프로그램이 이해하는 주소는 무엇일까요?

주소에는 메모리가 사용하는 물리 주소가 있고, CPU와 실행 중인 프로그램이 사용하는 논리 주소가 있습니다.


  물리 주소(Physical address) : 정보가 실제로 저장된 하드웨어상의 주소를 의미.
  논리 주소(logical address) : CPU와 실행 중인 프로그램이 사용하는 주소, 실행 중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소를 의미함.


예를 들어 현재 메모리에 메모장, 게임, 인터넷 브라우저 프로그램이 적재되어 있다고 가정해 보겠습니다.
메모장, 게임, 인터넷 브라우저 프로그램은 현재 다른 프로그램들이 메모리 몇 번지에 저장되어 있는지,
다시 말해 다른 프로그램들의 물리 주소가 무엇인지 굳이 알 필요가 없습니다.

새로운 프로그램이 언제든 적재될 수 있고, 실행되지 않은 프로그램은 언제든 메모리에서 사라질 수 있기 때문입니다.

그래서 메모장, 게임, 인터넷 브라우저는 모두 물리 주소가 아닌 0번지부터 시작하는 자신만을 위한 주소인 논리 주소를 가지고 있습니다.

예를 들어, ‘10번지’라는 주소는 메모장에도, 게임에도, 인터넷 브라우저에도 논리 주소로써 존재할 수 있습니다.
프로그램마다 같은 논리 주소가 얼마든지 있을 수 있다는 뜻입니다.
그리고 CPU는 이 논리 주소를 받아들이고, 해석하고, 연산합니다.



정리하면, 메모리가 사용하는 주소는 하드웨어상의 실제 주소인 물리 주소이고, CPU와 실행 중인 프로그램이 사용하는 주소는 각각의 프로그램에 부여된 논리 주소입니다.

그런데 CPU가 이해하는 주소가 논리 주소라고는 해도 CPU가 메모리와 상호작용하려면 논리 주소와 물리 주소 간의 변환이 이루어져야 합니다.

논리 주소와 물리 주소 간에 어떠한 변환도 이루어지지 않는다면 CPU와 메모리는 서로 이해할 수 없는 주소 체계를 가지고 각자 다른 이야기만 할 뿐 결코 상호작용할 수 없을 테니까요.

그렇다면 논리 주소는 어떻게 물리 주소로 변환될까요?

논리 주소와 물리 주소 간의 변환은 CPU와 주소 버스 사이에 위치한 메모리 관리 장치(MMU: Memory Management Unit) 라는 하드웨어에 의해 수행됩니다.



MMU는 CPU가 발생시킨 논리 주소에 베이스 레지스터 값을 더하여 논리 주소를 물리 주소로 변환합니다.
예를 들어 현재 베이스 레지스터에 15000이 저장되어 있고 CPU가 발생시킨 논리 주소가 100번지라면 이 논리 주소는 아래 그림처럼 물리 주소 15100번지(100+15000)로 변환됩니다.
물리 주소 15000번지부터 적재된 프로그램 A의 논리 주소 100번지에는 이렇게 접근이 가능한 것 입니다.



베이스 레지스터는 프로그램의 가장 작은 물리 주소, 즉 프로그램의 첫 물리 주소를 저장하는 셈이고,
논리 주소는 프로그램의 시작점으로부터 떨어진 거리인 셈입니다.

3. 메모리 보호 기법.
메모장 프로그램의 물리 주소가 1000번지부터 1999번지, 인터넷 브라우저 프로그램의 물리 주소가 2000번지부터 2999번지, 게임 프로그램의 물리 주소가 3000번지부터 3999번지라고 가정해 보겠습니다.

만약 메모장 프로그램 명령어 중 ‘(논리 주소) 1500번지에 숫자 100을 저장하라’와 같은 명령어가 있다면 숫자 100은 어떤 물리 주소에 저장될까요? 이 명령어는 실행되어도 안전할까요?

혹은 인터넷 브라우저 프로그램 명령어 중 ‘(논리 주소) 1100번지의 데이터를 삭제하라’와 같은 명령어가 있다면 어떤 물리 주소의 데이터가 삭제될까요? 이 명령어는 실행되어도 안전할까요?

위와 같은 명령어들은 실행되어서는 안 됩니다.
프로그램의 논리 주소 영역을 벗어났기 때문입니다.
위 명령어들이 실행된다면 메모장 프로그램 명령어는 애꿏은 인터넷 브라우저 프로그램에 숫자 10을 저장하고, 인터넷 브라우저 프로그램 명령어는 자신과는 전혀 관련 없는 게임 프로그램 정보를 삭제합니다.

이렇게 다른 프로그램의 영역을 침범할 수 있는 명령어는 위험하기 때문에 논리 주소 범위를 벗어나는 명령어 실행을 방지하고 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호할 방법이 핑요합니다.

이는 한계 레지스터(limit register) 라는 레지스터가 담당합니다.

베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장한다면, 한계 레지스터는 논리 주소의 최대 크기를 저장합니다.

즉, 프로그램의 물리 주소 범위는 베이스 레지스터 값 이상, 베이스 레지스터 값 + 한계 레지스터 값 미만이 됩니다.



CPU가 접근하려는 논리 주소는 한계 레지스터가 저장한 값보다 커서는 안 됩니다.
한계 레지스터보다 높은 주소 값에 접근하는 것은 곧 프로그램의 범위에 벗어난 메모리 공간에 접근하는 것과 같디 때문입니다.

베이스 레지스터에 100, 한계 레지스터에 150이 저장되어 있다고 해 봅시다.
이는 물리 주소 시작점이 100번지, 프로그램의 크기(논리 주소의 최대 크기)는 150임을 의미합니다.
따라서 이 프로그램은 150번지를 넘어서는 논리 주소를 가질 수 없습니다.

이번에는 베이스 레지스터에 1500, 한계 레지스터에 1000이 저장되어 있다고 해 봅시다.
이는 물리주소 시작점이 1500번지, 프로그램 크기는 1000임을 의미합니다.
따라서 이 프로그램은 1000번지를 넘어서는 논리 주소를 가질 수 없습니다.

CPU는 메모리에 접근하기 전에 접근하고자 하는 논리 주소가 한계 레지스터보다 작은지를 항상 검사합니다.
만약 CPU가 한계 레지스터보다 높은 논리 주소에 접근하려고 하면 인터럽트(트랩)를 발생시켜 실행을 중단합니다.

이러한 방식으로 실행 중인 프로그램의 독립적인 실행 공간을 확보하고 하나의 프로그램이 다른 프로그램을 침범하지 못하게 보호할 수 있습니다.

5. 키워드로 정리하는 핵심 키워드

  물리 주소는 메모리 하드웨어상의 주소이고, 논리 주소는 CPU와 실행 중인 프로그램이 사용하는 주소입니다.
  MMU는 논리 주소를 물리 주소로 변환합니다.
  베이스 레지스터는 프로그램의 첫 물리 주소를 저장합니다.
  한계 레지스터는 실행 중인 프로그램의 논리 주소의 최대 크기를 저장합니다.




컴퓨터 시스템에서 “물리 주소(Physical Address)”와 “논리 주소(Logical Address)”는 메모리 관리의 중요한 개념입니다.
각각은 다음과 같은 의미를 가지며, 시스템의 효율적인 메모리 관리를 위해 사용됩니다.

1.1 논리 주소(Logical Address)

  정의 : 논리 주소는 프로그램이 사용하는 주소입니다.
    
      이 주소는 프로그램이 실행되면서 생성되는 주소로, 사용자 또는 프로그램이 접근할 수 있는 주소입니다.
      이 주소는 가상 메모리 주소라고도 하며, 실제 메모리의 물리적 위치와는 독립적입니다.
    
  
  목적 : 논리 주소의 주요 목적은 각 프로세스가 독립된 주소 공간을 갖게 하여, 프로세스간의 메모리 충돌을 방지하고 보안을 강화하는 데 있습니다.
    
      또한, 프로그래밍을 단순화시키고 메모리 관리를 더 유연하게 만듭니다.
    
  


1.2 물리 주소(Physical Address)

  정의 : 물리 주소는 메모리 장치 내의 실제 위치를 가리키는 주소입니다.
    
      이 주소는 시스템의 메모리 관리 유닛(Memory Management Unit, MMU)에 의해 사용되며, 실제 RAM에서 데이터를 찾는 데 사용됩니다.
    
  
  목적 : 물리 주소는 시스템의 메모리를 효율적으로 할당하고 관리하는 데 필요합니다.
    
      이를 통해 시스템은 실제 메모리 공간을 최적화하고, 필요한 데이터와 프로그램을 정확한 위치에서 처리할 수 있습니다.
    
  


1.3 주소 변환(Address Translation)
논리 주소에서 물리 주소로의 변환은 주로 메모리 관리 유닛(MMU)에 의해 수행됩니다.
이 과정은 다음과 같은 방법으로 이루어 집니다.


  1. 페이지 테이블 : 운영체제는 페이지 테이블을 사용하여 논리 주소를 물리 주소로 매핑합니다.
    
      페이지 테이블을 논리 주소를 페이지로 나누고, 각 페이지가 실제 메모리의 어느 부분에 해당하는지를 나타내는 테이블입니다.
    
  
  
    2. 변환 조회 버퍼(TLB) : 변환 조회 버퍼는 자주 사용되는 주소 매핑을 캐시하는 작은 메모리로, 주소 변환 과정을 빠르게 만듭니다.
  
  3. 주소 변환 과정
    
      프로세스가 논리 주소를 생성합니다.
      MMU는 논리 주소의 페이지 번호를 확인하고, 해당 페이지 번호가 페이지 테이블에 있는지 확인합니다.
      페이지 테이블에서 해당 페이지의 물리 주소를 찾아 매핑합니다.
      물리 주소를 사용하여 실제 메모리에서 데이터를 엑세스합니다.
    
  


📝 정리
이러한 주소 변환 메커니즘은 메모리 보호, 프로세스 격리, 메모리 사용의 효율성 증가 등을 가능하게 하며, 복잡한 현대의 멀티태스킹 환경에서 중요한 역할을 합니다.

Q1. 물리 주소(Physical Address)’와 ‘논리 주소(Logical Address)’에 대해 설명해 주시겠습니까? 이 두 주소의 개념과 차이점을 구체적으로 말씀해 주시고, 어떻게 논리 주소가 물리 주소로 변환되는지 그 과정에 대해서도 설명해 주세요.


  
    논리 주소는 프로그램이 사용하는 주소로, 프로그램 코드에 의해 참조되는 주소입니다. 이는 운영체제에 의해 관리되며, 프로그램이 메모리에 로드되는 위치와 무관하게 일관성을 유지합니다. 즉, 프로그램이 메모리의 어느 위치에 로드되든지 간에 같은 논리 주소를 사용할 수 있습니다. 논리 주소는 가상 메모리 주소라고도 하며, 이를 통해 개발자는 실제 메모리 구조를 신경 쓰지 않고 프로그래밍할 수 있습니다.
  
  
    물리 주소는 메모리 장치 내의 실제 물리적 위치를 가리킵니다. 즉, 물리 주소는 RAM 내의 실제 데이터나 명령어가 저장된 위치를 나타내며, 메모리 관리 유닛(MMU)에 의해 논리 주소로부터 변환됩니다.
  
  
    논리 주소에서 물리 주소로의 변환은 주로 메모리 관리 유닛(MMU)을 통해 이루어집니다. 이 과정은 다음과 같습니다:
    
      
        
          프로세스가 생성하는 논리 주소는 페이지 번호와 오프셋으로 구성됩니다.
        
      
      
        
          페이지 번호는 페이지 테이블을 참조하여 해당 페이지가 메모리의 어느 물리적 위치에 있는지 결정합니다. 이 페이지 테이블은 운영 체제에 의해 관리되며, 각 페이지의 물리 주소를 저장합니다.
        
      
      
        
          물리 주소는 결정된 페이지 시작 주소에 오프셋을 추가하여 최종적으로 결정됩니다.
        
      
      
        
          변환 조회 버퍼(TLB)는 이러한 변환 과정을 가속화하기 위해 자주 사용되는 주소 변환을 캐시합니다.
            
              이러한 변환 과정을 통해 시스템은 효율적으로 메모리를 관리하며, 프로세스 간 메모리 격리와 보안을 유지할 수 있습니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-05-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-05-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-05-TIL.html"><h1 class="title_post">📝 [TIL] 240505 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-05-TIL.html" class="txt_post">
                            
  여러가지 연산자(1)
  여러가지 연산자(2)
  조건문


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-05-conditionalStatement.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-05-conditionalStatement.html"><h1 class="title_post">☕️[Java] 조건문</h1></a>
                        <a href="/Backend/Java/2024-05-05-conditionalStatement.html" class="txt_post">
                            1️⃣ 조건문

1. if문.
자바 프로그래밍에서 ‘if’ 문은 조건부 실행을 제어하는 기본적인 제어 구문입니다.
이를 통해 프로그램은 주어진 조건이 참(‘true’)인지 거짓(‘false’)인지에 따라 다른 행동을 취할 수 있습니다.

1.1 if문 기본 구조.
‘if’ 문의 기본 구조는 다음과 같습니다.
if (조건) {
    // 조건이 참일 때 실행될 코드
}


  여기서 ‘조건’ 은 boolean 타입의 표현식으로, 평가 결과가 ‘true’ 또는 ‘false’ 가 됩니다.
    
      조건이 ‘true’ 일 때만 중괄호 ’{}’ 내부의 코드가 실행됩니다.
    
  


1.2 예시
예를 들어, 사용자의 나이가 성인 기준을 만족하는지를 확인하는 코드는 다음과 같습니다.
int age = 20;
if (age &gt;= 18) {
    System.out.println("성인입니다.");
}


  이 코드에서 ‘age &gt;= 18’ 이라는 조건이 참이면 “성인입니다.” 라는 메시지를 출력합니다.


1.3 ‘else’와 ‘else if’ 확장
‘if’ 문은 종종 ‘else’ 와 ‘else if’ 와 함께 사용되어 보다 복잡한 조건 로직을 구현할 수 있습니다.
if (조건1) {
    // 조건1이 참일 때 실행될 코드
} else if (조건2) {
    // 조건1이 거짓이고 조건2가 참일 때 실행될 코드
} else {
    // 위의 모든 조건이 거짓일 때 실행될 코드
}


예를 들어, 점수에 따라 학점을 출력하는 코드는 다음과 같습니다.

int score = 85;
if (score &gt;= 90) {
    System.out.println("학점 A");
} else if (score &gt;= 80) {
    System.out.println("학점 B");
} else if (score &gt;= 70) {
    System.out.println("학점 C");
} else {
    System.out.println("학점 D");
}



  이 예제에서 ‘score’ 변수의 값에 따른 다른 학점을 출력합니다.
    
      ‘if’, ‘else if’, ‘else’ 구문은 점수 범위에 따라 조건적으로 실행되며, 가장 먼저 만족하는 조건의 블록만 실행됩니다.
    
  


📝 정리.
‘if’ 문은 프로그래밍에서 결정을 내리는 데 필수적인 구조이며, 다양한 조건에 따라 코드의 실행 흐름을 제어하는 데 사용됩니다.



2. switch문.
자바 프로그래밍에서 ‘switch’ 문은 다수의 조건 중 하나를 선택해 실행할 때 사용하는 조건문입니다.
이는 ‘if-else’ 조건문의 대안으로, 변수의 값에 따라 여러 실행 경로 중 하나를 선택할 수 있도록 해줍니다.
‘switch’ 문은 특히 특정 변수가 취할 수 있는 명확한 값들을 기반으로 다양한 케이스를 처리할 때 유용하게 사용됩니다.

2.1 switch문의 기본 구조.
‘switch’ 문의 기본 구조는 다음과 같습니다.
switch (표현식) {
    case 값1:
        // 표현식 결과가 값1과 일치할 때 실행할 코드
        break;
    case 값2:
        // 표현식 결과가 값2와 일치할 때 실행할 코드
        break;
    // 추가적인 case들을 더 정의할 수 있습니다.
    default:
        // 어떤 case도 일치하지 않을 때 실행할 코드
}


2.2 switch 문의 주요 특징.

  1. 표현식 은 주로 정수, 문자형 또는 열거형(enum) 데이터를 사용합니다. 자바 7 이상에서는 문자열(String)도 지원합니다.
  2. case 라벨은 ‘switch’ 문 내에서 표현식의 결과와 일치하는 값을 가지며, 해당 값에 대한 실행 코드를 포함합니다.
  3. break 문은 ‘switch’ 문을 종료하고 다음 코드로 넘어가도록 합니다. ‘break’ 가 없으면 다음 ‘case’ 로 계속 진행되어 “fall-through” 현상이 발생합니다.
  4. default 섹션은 선택적으로 사용되며, 어떤 ‘case’ 도 일치하지 않을 때 실행됩니다.


2.3 switch 문 예시.
학생의 점수에 따라 학점을 부여하는 간단한 예를 들어보겠습니다.
int score = 92;
String grade;

switch (score / 10) {
    case 10:
    case 9:
        grade = "A";
        break;
    case 8:
        grade = "B";
        break;
    case 7:
        grade = "C";
        break;
    case 6:
        grade = "D";
        break;
    default:
        greade = F;
}

System.out.println("학점: " + grade);



  이 코드에서 ‘score / 10’ 의 결과값에 따라 다른 ‘case’ 블록이 실행됩니다.
  ‘92/10’ 은 ‘9’ 이므로, ‘grade’ 는 “A” 가 됩니다.
  각 ‘case’ 는 ‘break’ 문으로 종료되므로, 해당 ‘case’ 실행 후, ‘switch’ 문을 벗어납니다.


📝 정리.
‘switch’ 문은 코드의 가독성을 높이고, 많은 조건 분기를 간결하게 처리할 수 있는 방법을 제공합니다.
이는 특히 각 조건이 명확할 때 더욱 유용하며, 코드의 구조를 명확하게 표현할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-05-VariousOperators-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-05-VariousOperators-1.html"><h1 class="title_post">☕️[Java] 여러가지 연산자(1)</h1></a>
                        <a href="/Backend/Java/2024-05-05-VariousOperators-1.html" class="txt_post">
                            1️⃣ 각각의 연산자에 대한 이해

1. 항과 연산자.

1.1 단항 연산자(Unary Operator).
자바 프로그래밍에서 단항 연산자(Unary Operator)는 오직 한 개의 피연산자(operand)를 가지고 연산을 수행하는 연산자를 말합니다.

이들은 변수나 값에 직접 적용되며, 표현식의 결과를 반환합니다.

단항 연산자는 특히 간단한 수학 연산, 값의 부정, 또는 값의 증감 등에서 유용하게 사용됩니다.

1.2 자바에서 사용되는 주요 단항 연산자.

  1. 부정 연산자('!')
    
      불리언 값을 반전시킵니다.
        
          예를 들어, '!true' 는 'false' 가 됩니다.
        
      
    
  
  2. 단항 플러스 및 마이너스 연산자('+', '-')
    
      '+' 는 일반적으로 숫자의 부호를 그대로 두지만, 명시적으로 사용할 수 있습니다.
      '-' 는 숫자의 부호를 반전시킵니다.
        
          예를 들어, '-5' 는 양수 '5' 를 음수로 변환합니다.
        
      
    
  
  3. 증가 및 감소 연산자('++', '--')
    
      '++' 연산자는 변수의 값을 1만큼 증가시킵니다.
      '--' 연산자는 변수의 값을 1만틈 감소시킵니다.
      이 연산자들은 전위(prefix) 형태(예: '++x')와 후위(postfix) 형태(예: 'x++')로 사용될 수 있습니다.
        
          전위 형태는 변수를 증가시키고 표현식의 값을 반환하기 전에 증가된 값을 사용하고, 후위 형태는 표현식의 값을 반환한 후 변수를 증가시킵니다.
        
      
    
  
  4. 비트 반전 연산자('~')
    
      정수형 변수는 모든 비트를 반전시킵니다.
        
          예를 들어, '~00000000' 은 '11111111' 이 됩니다.
            
              이는 정수에 대해 비트 단위 NOT 연산을 수행합니다.
            
          
        
      
    
  


1.3 예제 사용.

public class UnaryDemo {
    public static void main(String[] args) {
        boolean a = false;
        System.out.println(!a); // true

        int num = 5;
        System.out.println(-num); // -5
        System.out.println(++num); // 6
        System.out.println(num++); // 6, 그리고 num이 7이 됨
        System.out.println(--num); // 6
        System.out.println(num--); // 6, 그리고 num이 5가 됨

        int b = 0b00000000; // 이진수로 0
        System.out.println(~b); // 모든 비트가 1로 반전
    }
}



  이 예제에서는 다양한 단항 연산자들의 사용 방법과 그 효과를 보여줍니다.
    
      단항 연산자들은 자바 프로그래밍에서 변수를 조작하거나 특정 연산을 더 간결하게 수행하는데 매우 유용합니다.
    
  




2.1 이항 연산자(Binary Operator)
자바 프로그래밍에서 이항 연산자(Binary Operator)는 두 개의 피연산자(operand)를 취해 연산을 수행하고 결과를 반환하는 연산자를 말합니다.

이항 연산자는 수학적 계산, 논리 비교, 값의 할당 등 다양한 작업에 사용됩니다.

2.2 자바에서 사용되는 주요 이항 연산자의 종류.

  1. 산술 연산자.
    
      ’+’ (덧셈)
      ’-‘ (뺄셈)
      ‘*‘ (곱셈)
      ’/’ (나눗셈)
      ’%’ (나머지)
    
  
  2. 비교 연산자.
    
      ’==’ (동등)
      ’!=’ (부등)
      ’&gt;’ (크다)
      ’&lt;’ (작다)
      ’&gt;=’ (크거나 같다)
      ’&lt;=’ (작거나 같다)
    
  
  3. 논리 연산자.
    
      ‘&amp;&amp;’ (논리적 AND)
      
        
          
            
              **’
               
              ‘** (논리적 OR)
            
          
        
      
    
  
  4. 비트 연산자
    
      ‘&amp;’ (비트 AND)
      
        
          
            
              **’
              ‘** (비트 OR)
            
          
        
      
      ’^’ (비트 XOR)
    
  
  5. 할당 연산자
    
      ’=’ (기본 할당)
      ’+=’, ‘-=’, ‘*=’, ‘/=’, ‘%=’ (복합 할당 연산자)
      
        
          
            
              **‘&amp;=’, ‘
              =’, ‘^=’, ‘«=’, ‘»=’, ‘»&gt;=’** (비트 복합 할당 연산자)
            
          
        
      
    
  
  6. 시프트 연산자
    
      ’«‘ (왼쪽 시프트)
      ’»‘ (오른쪽 시프트, 부호 유지)
      ’»&gt;’ (오른쪽 시프트, 부호 비트 없음)
    
  


2.3 예제 코드

public class BinaryOperatorsExample {
    public static void main(String[] args) {
        int a = 10, b = 5;
        int sum = a + b; // 15
        int difference = a - b; // 5
        boolean isEqual = (a == b); // false
        boolean isGreater = (a &gt; b); // true

        int bitAnd = a &amp; b; // 비트 AND 연산
        int shiftedLeft = a &lt;&lt; 2; // 왼쪽으로 2 비트 시프트

        System.out.println("Sum: " + sum);
        System.out.println("Difference: " + difference);
        System.out.println("Is Equal: " + isEqual);
        System.out.println("Is Greater: " + isGreater);
        System.out.println("Bitwise AND: " + bitAnd);
        System.out.println("Left Shifted: " + shiftedLeft);
    }
}


  이항 연산자들은 기본적인 산술 연산부터 복잡한 논리 연산에 이르기까지 프로그래밍에서 광범위하게 사용됩니다.
    
      이를 통해 효과적으로 데이터를 조작하고, 조건을 평가하며, 복잡한 문제를 해결할 수 있습니다.
    
  




3.1 삼항 연산자(Ternary Operator).
자바 프로그래밍에서 삼항 연산자(Ternary Operator), 또는 조건 연산자(Conditional Operator)라고 불리는 ’?:’ 는 세 개의 피연산자를 사용하는 유일한 연산자입니다.

이 연산자는 간결한 조건문을 구현할 때 사용되며, 간단한 조건식을 기반으로 두 가지 선택지 중 하나를 반환합니다.

3.2 삼항 연산자의 구조.

조건식 ? 값1 : 값2



  1. 조건식 : 이 부분은 ‘true’ 또는 ‘false’ 를 반환하는 불리언 식입니다.
  2. 값2 : 조건식이 ‘true’ 일 때 반환됩니다.
  3. 값3 : 조건식이 ‘false’ 일 때 반환됩니다.


조건식의 평가 결과에 따라 ‘값1’ 또는 값2 중 하나가 결과값으로 선택되어 반환됩니다.

이 연산자는 일반적으로 간단한 조건에 따라 변수에 값을 할당하거나 특정 표현식의 결과를 결정할 때 유용하게 사용됩니다.

3.3 예제 사용.

public class TernaryExample {
    public static void main(String[] args) {
        int a = 10, b = 5;
        int max = (a &gt; b) ? a : b; // a와 b 중 큰 값을 max에 할당.
        System.out.println("Max value: " + max);
        
        String response = (a &gt; b) ? "a is greater than b" : " b is greater or equal to a";
        System.out.println(response);
    }
}


  이 예제에서 삼항 연산자를 사용하여 두 숫자 중 더 큰 숫자를 결정하고, 문자열 메시지도 조건에 따라 선택합니다.
    
      이러한 사용은 코드를 더 간결하게 만들고, ‘if-else’ 구조를 보다 간단하게 대체할 수 있게 해 줍니다.
    
  
  삼항 연산자는 그 효율성과 간결함 때문에 자바 프로그래밍에서 자주 사용되는 유용한 도구입니다.
    
      그러나 복잡한 로직이나 여러 조건이 연속적으로 필요한 경우에는 가독성을 위해 전통적인 ‘if-else’ 문을 사용하는 것이 더 나을 수 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-05-VariousOperator-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-05-VariousOperator-2.html"><h1 class="title_post">☕️[Java] 여러가지 연산자(2)</h1></a>
                        <a href="/Backend/Java/2024-05-05-VariousOperator-2.html" class="txt_post">
                            1️⃣ 비트 연산자에 대한 이해

1. 2진법.
자바 프로그래밍에서의 이진법은 컴퓨터의 지본 숫자 시스템을 참조하는 것입니다.
컴퓨터는 데이터를 0과 1의 형태, 즉 이진수로 처리합니다.
자바에서도 이러한 이진법을 사용하여 데이터를 저장, 처리하며 다양한 연산을 수행할 수 있습니다.

1.1 자바에서 2진법을 사용하는 예.

  1. 이진 리터럴 : 자바 7 이상부터는 정수를 이진 리터럴로 직접 표현할 수 있습니다.
    
      예를 들어, ‘int x = 0b1010;’ 은 이진수 ‘1010’ 이고, 십진수로 10입니다.
    
  
  2. 비트 연산자 : 자바는 비트 연산을 수행할 수 있는 여러 연산자를 제공합니다.
    
      예를 들어, 다음과 같습니다.
        
          '&amp;' (AND 연산자)
          '|' (OR 연산자)
          '^' (XOR 연산자)
          '~' (NOT 연산자)
          '&lt;&lt;' (왼쪽 시프트)
          '&gt;&gt;' (오른쪽 시프트)
          '&gt;&gt;&gt;' (부호 없는 오른쪽 시프트)
            
              이들 연산자는 주로 효율적인 수치 계산, 저수준 프로그래밍, 암호와 작업 등에 사용됩니다.
            
          
        
      
    
  
  3. 이진 데이터 조작 : 파일이나 네트워크를 통해 바이트 단위로 데이터를 읽고 쓸 때, 이진 형식으로 데이터를 처리합니다.
    
      자바에서는 'byte' 자료형을 이용하여 이진 데이터를 직접 다룰 수 있습니다.
    
  


📝 정리
이진법을 사용하는 주된 이유는 컴퓨터 하드웨어가 전기 신호로 작동하기 때문에 0과 1, 즉 이진 상태를 나타내는 전기의 켜짐과 꺼짐 상태로 모든 데이터를 표현하기 편리하기 때문입니다.
이렇게 함으로써, 프로그래밍에서 더욱 직접적이고 효율적인 하드웨어 조작이 가능해집니다.



2. 2의 보수.
자바 프로그래밍에서의 2의 보수(2’s complement)는 음수를 표현하기 위한 방법입니다.
컴퓨터 시스템은 보통 이진법을 사용하여 데이터를 저장하고 처리하는데, 이진법에서 음수를 표현하기 위해 가장 널리 사용되는 방법이 2의 보수입니다.

2.1 2의 보수 생성 과정.

  1. 원래 숫자의 이진 표현을 얻습니다.
    
      예를 들어, 5의 이진 표현은 ‘0101’ 입니다.
    
  
  2. 이진 표현의 모든 비트를 반전시킵니다.
    
      즉, 0은 1로, 1은 0으로 변경합니다.
      5의 경우 ‘0101’ 이 ‘1010’ 이 됩니다.
    
  
  3. 반전된 값에 1을 더합니다.
    
      이렇게 하면 ‘1011’ 이됩니다.
    
  


이렇게 생성된 ‘1011’ 은 -5를 나타냅니다.
이 방법은 자바를 포함한 대부분의 프로그래밍 언어와 컴퓨터 시스템에서 음수를 표현하는 표준 방법입니다.

2.2 2의 보수의 장점.

  덧셈 연산만으로 뺄셈을 할 수 있습니다.
    
      예를 들어, 5-5를 계산하려면 5와 -5의 2의 보수를 더하면 됩니다.
        
          이진법으로는 ‘1010 + 1011 = 10000’ 이고, 최상위 비트(캐리 비트)는 무시합니다.
            
              따라서 결과는 ‘0000’ 이 됩니다.
            
          
        
      
    
  
  오버플로 처리가 간단합니다.
    
      캐리 비트는 무시하면서 자연스럽게 오버플로를 처리할 수 있습니다.
    
  


2.3 자바에서의 활용.
자바에서는 정수형 타입(‘int’, ‘long’, ‘short’, ‘byte’) 이 이진법으로 2의 보수 형태로 저장되고 처리됩니다.
이는 자바의 모든 정수 연산에 내장된 메커니즘입니다.
예를 들어, 자바에서 ‘-5’ 를 선언하면 내부적으로는 ‘5’ 의 2의 보수인 ‘111…11011’ (32비트 시스템에서의 표현)으로 저장됩니다.

📝 정리
2의 보수 방식은 음수를 다루기 위한 효과적인 방법이며, 프로그래머가 별도의 조치를 취하지 않아도 시스템이 자동으로 처리해 주기 때문에 매우 편리합니다.



3. 비트 논리연산자.
자바 프로그래밍에서 비트 논리연산자는 비트 단위로 논리 연산을 수행하는 연산자입니다.
이들 연산자는 주로 정수 타입의 변수에 사용되며, 각 비트를 독립적으로 비교하여 결과를 반환합니다.
비트 논리연산자는 주로 저수준 프로그래밍, 효율적인 데이터 처리, 상태 플래그 관리, 암호화 등의 작업에 활용됩니다.

자바에서 사용되는 주요 비트 논리 연산자는 다음과 같습니다.


  1. AND 연산자(‘&amp;’) : 두 피연산자의 비트가 모두 1일 경우에만 결과의 해당 비트를 1로 설정합니다.
    
      예를 들어, ‘5 &amp; 3’ 은 이진수로 ‘0101 &amp; 0011’ 을 계산하여 ‘0001’ 이 되므로, 결과는 ‘1’ 입니다.
    
  
  
    
      
        
          **2. OR 연산자(‘
          ’) :** 두 피연산자 중 하나라도 비트가 1이면 결과의 해당 비트를 1로 설정합니다.
        
      
    
    
      
        
          
            
              예를 들어, **‘5
              3’** 은 이진수로 **‘0101
              0011’** 을 계산하여 ‘0111’ 이 되므로, 결과는 ‘7’ 입니다.
            
          
        
      
    
  
  3. XOR 연산자(‘^’) : 두 피연산자의 비트가 서로 다를 경우 결과의 해당 비트를 1로 설정합니다.
    
      예를 들어, ‘5 ^ 3’ 은 이진수로 ‘0101 ^ 0011’ 을 계산하여 ‘0110’ 이 되므로, 결과는 ‘6’ 입니다.
    
  
  4. NOT 연산자(‘~’) : 피연산자의 모든 비트를 반전시킵니다.(1은 0으로, 0은 1로).
    
      예를 들어, ‘~5’ 는 이진수로 ‘~0101’ 을 계산하여 ‘…1010’(무한히 많은 1 다음에 1010)이 되고, 이는 보통 32비트 시스템에서 ‘-6’ 으로 해석됩니다.
    
  
  5. 왼쪽 시프트(‘«’) : 모든 비트를 왼쪽으로 지정된 수만틈 이동시키고, 오른쪽은 0으로 채웁니다.
    
      예를 들어.‘3 « 2’ 는 ‘0011’ 을 왼쪽으로 2비트 이동하여 ‘1100’ 이 되므로, 결과는 ‘12’ 입니다.
    
  
  6. 오른쪽 시프트(‘»’) : 모든 비트를 오른쪽으로 지정된 수만큼 이동시키고, 왼쪽은 최상위 비트(부호 비트)의 값으로 채웁니다.
    
      예를 들어, ‘-8 » 2’ 는 ‘11111000’ 을 오른쪽으로 2비트 이동하여 ‘11111110’ 이 되므로, 결과는 ‘-2’ 입니다.
    
  
  7. 부호 없는 오른쪽 시프트(‘»&gt;’) : 모든 비트를 오른쪽으로 지정된 수만큼 이동시키고, 왼쪽은 0으로 채웁니다. 이는 부호 비트를 무시하고, 순수하게 비트를 오른쪽으로 이동시키기 때문에 음수에 사용했을 때 결과가 달라집니다.


📝 정리

이러한 비트 논리 연산자들은 데이터의 특정 비트를 직접 조작할 필요가 있는 경우에 유용하며, 자바 프로그래밍에서 중요한 도구입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html"><h1 class="title_post">☕️[Java] 변수와 자료형(4)</h1></a>
                        <a href="/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html" class="txt_post">
                            변수와 자료형(4)

1️⃣ 자료형에 대한 이해

1. List
자바 프로그래밍에서 List 는 일련의 요소를 저장하는 데 사용되는 순차적인 컬렉션을 나타냅니다.
이는 자바의 java.util.List 인터페이스를 통해 제공되며, 이는 주문된 컬렉션을 관리하기 위한 다양한 메소드를 제공합니다.
List 는 중복된 요소를 포함할 수 있고, 각 요소는 리스트 내에서 특정 위치를 가집니다.
사용자는 이 위치를 인덱스로 사용하여 리스트의 요소에 접근할 수 있습니다.

List 인터페이스의 주요 특징은 다음과 같습니다.


  1. 순서 보장 : 리스트는 요소들이 추가된 순서를 유지하며, 각 요소는 특정 인덱스를 통해 접근할 수 있습니다.
  2. 요소의 중복 허용 : 같은 값을 가진 요소를 여러 개 포함할 수 있습니다.
  3. 동적 배열 : 리스트의 크기는 고정되어 있지 않고, 요소를 추가하거나 삭제함에 따라 동적으로 조절됩니다.


자바에서는 List 인터페이스를 구현하는 몇 가지 클래스가 있습니다.
가장 흔히 사용되는 구현체는 다음과 같습니다.


  'ArrayList' : 내부적으로 배열을 사용하여 요소를 저장합니다.
    
      요소의 추가와 인덱스를 통한 접근이 매우 빠르지만, 크기 조절이 필요할 때는 비용이 많이 들 수 있습니다.
    
  
  'LinkedList' : 각 요소가 다음 요소에 대한 참조와 함께 저장되는 연결 리스트를 사용합니다.
    
      요소의 추가와 삭제는 빠르지만, 인덱스를 통한 요소 접근은 시작부터 요소를 찾을 때까지 순차적으로 검색해야 하므로 시간이 더 걸립니다.
    
  
  'Vector' : 'ArrayList' 와 비슷하지만, 다중 스레드 환경에서 안전하게 사용할 수 있도록 동기화된 메소드를 제공합니다.


📝 정리.
'List' 는 자바 컬렉션 프레임워크의 일부이며, 데이터를 관리하고 처리하는 데 매우 유용합니다.
프로그래머는 이러한 컬렉션을 사용하여 데이터를 유연하게 조작할 수 있습니다.

1.2 List의 주요 메서드.
자바의 'List' 인터페이스에는 여러 가지 중요한 메서드들이 포함되어 있으며, 이를 통해 리스트 내의 요소들을 조작하고 접근할 수 있습니다.

다음은 'List' 인터체이스에서 제공하는 몇 가지 주요 메서드들입니다.


  'add(E e)': 리스트의 끝에 요소를 추가합니다.
  'add(int index, E element)': 지정된 위치에 요소를 삽입합니다.
  'addAll(Collection&lt;? extends E&gt; c)': 지정된 컬렉션의 모든 요소를 리스트의 끝에 추가합니다.
  'addAll(int index, Collection&lt;? extends E&gt; c)': 지정된 위치부터 컬렉션의 모든 요소를 리스트에 추가합니다.
  'clear()': 리스트에서 모든 요소를 제거합니다.
  'contains(Object o)': 리스트가 특정 요소를 포함하고 있는지 확인합니다.
  'get(int index)': 지정된 위치의 요소를 반환합니다.
  'indexOf(Object o)': 주어진 요소의 첫 번째 인덱스를 반환합니다. 요소가 리스트에 없는 경우 -1을 반환합니다.
  'lastIndexOf(Object o)': 주어진 요소의 마지막 인덱스를 반환합니다. 요소가 리스트에 없는 경우 -1을 반환합니다.
  'isEmpty()': 리스트가 비어 있는지 확인합니다.
  'iterator()': 리스트의 요소에 대한 반복자를 반환합니다.
  'listIterator()': 리스트의 요소를 리스트 순서대로 반복하는 리스트 반복자를 반환합니다.
  'remove(Object o)': 주어진 요소를 리스트에서 처음 발견되는 위치에서 제거하고, 그 결과를 반환합니다.
  'remove(int index)': 지정된 위치에 있는 요소를 리스트에서 제거하고, 그 요소를 반환합니다.
  'replaceAll(UnaryOperator&lt;E&gt; operator)': 주어진 연산자를 사용하여 리스트의 모든 요소를 대체합니다.
  'size()': 리스트에 있는 요소의 수를 반환합니다.
  'sort(Comparator&lt;? super E&gt; c)': 주어진 비교자를 사용하여 리스트를 정렬합니다.
  'subList(int fromIndex, int toIndex)': 지정된 범위의 부분 리스트를 반환합니다.
  'toArray()': 리스트 요소를 배열로 반환합니다.


📝 정리.
이 메서드들을 통해 리스트를 생성, 조회, 수정 및 관리하는 다양한 작업을 수행할 수 있습니다.
List 인터페이스를 사용함으로써 데이터를 효율적으로 처리하고 구조화할 수 있습니다.



2. Map
자바 프로그래밍에서 'Map' 은 키(key)와 값(value)의 쌍을 저장하는 객체입니다.
이는 키를 기반으로 빠르게 값을 검색할 수 있게 해주는 데이터 구조로, 각 키는 고유해야 합니다.(즉, 중복된 키를 가질 수 없습니다.)
'Map' 은 'java.util.Map' 인터페이스를 통해 정의되며, ‘HashMap‘, ‘TreeMap‘, ‘LinkedHashMap‘ 등 다양한 구현체를 가집니다.

자바의 ‘Map‘ 인터페이스는 키-값 쌍으로 데이터를 저장하고 관리하는 데 중점을 두는 데이터 구조로서, 특히 다음과 같은 주요 특징을 가지고 있습니다.


  1. 키에 의한 값 접근 : ‘Map‘ 은 각 값에 고유한 키를 할당하며, 이 키를 사용하여 빠르게 해당 값을 검색할 수 있습니다.
    
      이는 데이터베이스의 인덱스와 유사한 방식으로 작동합니다.
    
  
  2. 키의 유일성 : 맵 내에서 모든 키는 고유해야 합니다.
    
      즉, 같은 키가 두 번 이상 존재할 수 없으며, 새로운 키-값 쌍을 추가할 때 이미 존재하는 키를 사용하면 기존의 값이 새 값으로 대체됩니다.
    
  
  3. 값의 중복 허용 : 키는 유일해야 하지만 값은 중복될 수 있습니다.
    
      다른 키가 동일한 값을 가리킬 수 있습니다.
    
  
  4. 순서의 유무 : 일반적인 ‘Map‘ 구현체들은 키-값 쌍의 순서를 보장하지 않습니다.
    
      그러나 ‘LinkedHashMap‘ 과 같은 일부 구현체는 요소가 추가된 순서대로 반복할 수 있는 기능을 제공합니다.
      ‘TreeMap‘ 은 키에 따라 정렬된 순서를 유지합니다.
    
  
  5. 비동기화 및 동기화 : 기본적으로 대부분의 ‘Map‘ 구현체는 동기화되지 않습니다.(‘HashMap‘). 이는 멀티 스레드 환경에서 동시 수정이 발생할 경우 안전하지 않을 수 있음을 의미합니다.
    
      반면에 ‘Hashtable‘ 과 같은 구현체는 기본적으로 동기화가 되어 있어 멀티 스레드 환경에서 안전합니다.
      또한, ‘Collections.synchronizeMap‘ 메소드를 사용하여 맵을 동기화된 맵으로 변환할 수 있습니다.
    
  
  6. Null 허용 : 대부분의 ‘Map‘ 구현체는 키와 값으로 ‘null‘ 을 허용합니다.(‘HashMap‘, ‘LinkeHashMap‘).
    
      하지만 ‘Hashtable‘ 은 ‘null‘ 키나 값을 허용하지 않으며, ‘TreeMap‘ 은 자연 정렬 또는 ‘Comparator‘ 가 ‘null‘ 을 처리할 수 있는 경우에만 ‘null‘ 키를 허용합니다.
    
  


📝 정리.
이러한 특징들로 인해 ‘Map‘ 은 다양한 애플리케이션에서 유연하고 효율적인 데이터 관리를 가능하게 합니다.
데이터를 쉽게 추가, 검색, 삭제할 수 있어 데이터 관리의 복잡성을 줄이고 성능을 최적화하는 데 기여합니다.



3. Generics.
자바 프로그래밍에서 제네릭스(Generics)는 클래스나 메소드에서 사용될 데이터 타입을 추상화하여 코드 작성 시점에는 구체적인 타입을 명시하지 않고, 객체 생성이나 메소드 호출 시점에 실제 사용할 타입을 지정할 수 있도록 하는 프로그래밍 기법입니다.

제네릭스(Generics)는 코드의 재사용성을 높이고, 타입 안정성을 강화하며, 캐스팅에 대한 오류 가능성을 줄이는 데 도움을 줍니다.

3.1 제네릭스(Generics)의 주요 특징.

  
    1. 타입 안전성(Type Safety) : 제네릭스를 사용하면 컴파일 시점에 타입 체크가 가능하여, 실행 시점에서 발생할 수 있는 'ClassCastException' 과 같은 오류를 사전에 방지할 수 있습니다.
  
  2. 재사용성(Reusability) : 하나의 코드를 다양한 타입에 대해 재사용할 수 있습니다.
    
      예를 들어, 제네릭 클래스나 메소드를 정의하면, 다양한 타입의 객체를 저장하거나 처리하는 로직을 단 한번만 작성하여 여러 타입에 걸쳐 사용할 수 있습니다.
    
  
  3. 코드 간결성(Code Clarity) : 캐스팅을 줄여 코드가 더욱 간결하고 읽기 쉬워집니다.


3.2 제네릭스의 기본 문법.

  클래스 선언 : 클래스 이름 뒤에 '&lt;T&gt;' 를 추가하여 제네릭 클래스를 선언합니다.
    
      ‘T’ 는 타입 파라미터를 나타내며, 이는 클래스 내에서 사용될 데이터 타입을 대체하는 플레이스홀더 역할을 합니다.
    
  


public class Box&lt;T&gt; {
    private T t; // T 타입의 객체를 위한 변수
    
    public void set(T t) {
        this.t = t;
    }
    
    public T get() {
        return t;
    }
}



  메소드 선언 : 메소드 반환 타입 앞에 ’&lt;T&gt;‘ 를 추가하여 제네릭 메소드를 선언합니다.


public &lt;T&gt; T genericMethod(T t) {
    return t;
}



  제네릭 타입 제한(Bounded Type Parameters) : 특정 클래스의 하위 클래스만 타입 파라미터로 받도록 제한할 수 있습니다.
    
      이는 'extends' 키워드를 사용하여 지정합니다.
    
  


public class Box&lt;T extends Number&gt; {
    private T t;
    
    public void set(T t) {
        this.t = t;
    }
    
    public T get() {
        return t;
    }
}


📝 정리.
제네릭스(Generics)를 사용함으로써 개발자는 보다 타입-안전하고 유지보수가 용이한 코드를 작성할 수 있으며, 실행 시 타입 관련 문제를 효과적으로 줄일 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-04-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-04-TIL.html"><h1 class="title_post">📝 [TIL] 240504 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-04-TIL.html" class="txt_post">
                            
  자바 - 변수와 자료형(4)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-03-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-03-TIL.html"><h1 class="title_post">📝 [TIL] 240503 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-03-TIL.html" class="txt_post">
                            
  자바 - 변수와 자료형(2)
  자바 - 타입 비교
  자바 - 변수와 자료형(3)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html"><h1 class="title_post">☕️[Java] 변수와 자료형(3)</h1></a>
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html" class="txt_post">
                            변수와 자료형(3).

1️⃣ 자료형에 대한 이해.

1. String.
String 클래스는 불변(immutable)의 문자열을 다룹니다.

  이는 한 번 생성된 String 객체의 내용이 변경될 수 없다는 것을 의미합니다.
  문자열을 변경하려고 할 때마다 실제로 새로운 String 객체가 생성되고, 기존 객체는 변경되지 않습니다.


1.1 String의 주요 메소드.

  charAt(int index) : 지정된 위치의 문자를 반환합니다.
  concat(String str) : 현재 문자열의 끝에 지정된 문자열을 붙여 새로운 문자열을 반환합니다.
  contains(CharSequence s) : 특정 문자열이 포함되어 있는지 확인합니다.
  startsWith(String prefix) : 문자열이 특정 문자열로 시작하는지 확인합니다.
  endsWith(String suffix) : 문자열이 특정 문자열로 끝나는지 확인합니다.
  equals(Object anObject) : 문자열이 주어진 객체와 동일한지 비교합니다.
  indexOf(int ch), indexOf(String str) : 주어진 문자 또는 문자열의 위치를 찾습니다.
  length() : 문자열의 길이를 반환합니다.
  replace(char oldChar, char newChar) : 문자열 중 일부 문자를 다른 문자로 대체합니다.
  substring(int beginIndex, int endIndex) : 문자열의 부분을 추출합니다.
  toLowerCase(), toUpperCase() : 문자열을 소문자 또는 대문자로 변환합니다.
  trim() : 문자열의 앞뒤 공백을 제거합니다.


2. StringBuffer.
StringBuffer 클래스는 가변(mutable)의 문자열을 다루며, 문자열 변경 작업이 빈번할 때 사용하면 효율적입니다.

  StringBuffer 객체는 내용을 직접 변경할 수 있어, 새로운 객체를 계속 생성하지 않아도 됩니다.


2.1 StringBuffer의 주요 메소드.

  append(String str): 문자열의 끝에 주어진 문자열을 추가합니다.
  delete(int start, int end): 문자열의 시작 인덱스부터 종료 인덱스 전까지의 부분을 삭제합니다.
  deleteCharAt(int index): 지정된 위치의 문자를 삭제합니다.
  insert(int offset, String str): 지정된 위치에 문자열을 삽입합니다.
  replace(int start, int end, String str): 시작 인덱스부터 종료 인덱스 전까지의 문자열을 새로운 문자열로 대체합니다.
  reverse(): 문자열의 순서를 뒤집습니다.
  length(): 문자열의 길이를 반환합니다.
  capacity(): 현재 버퍼의 크기를 반환합니다.
  setCharAt(int index, char ch): 지정된 위치의 문자를 다른 문자로 설정합니다.


📝 정리.
StringBuffer 는 스레드에 안전(thread-safe)합니다, 즉 멀티스레드 환경에서 동시에 접근해도 안전하게 사용할 수 있습니다.

  이는 내부적으로 메소드들이 동기화되어 있기 때문입니다.


반면, StringBuilder 는 StringBuffer 와 유사하지만 멀티스레드 환경에서의 동기화 자원이 없어 단일 스레드에서 더 빠르게 작동합니다.

이처럼 String 과 StringBuffer 는 각각의 특성에 맞게 선택하여 사용할 수 있으며, 성능과 사용상황에 따라 적절히 활용하면 됩니다.



3. Array.
자바 프로그래밍에서 배열(Array)은 동일한 타입의 여러 데이터를 연속적인 메모리 위치에 저장하기 위한 자료구조입니다.
배열은 고정된 크기를 가지며, 배열의 각 요소는 같은 데이터 타입을 가집니다.
배열을 사용하면 여러 데이터를 하나의 변수 이름으로 관리할 수 있어 코드를 간결하게 작성할 수 있습니다.

3.1 배열의 특징.

  고정된 크기 : 배열은 생성 시 지정된 크기를 변경할 수 없습니다.
    
      배열의 크기는 프로그램 실행 도중에 변경할 수 없으며, 더 많은 데이터를 저장해야 할 경우 새로운 배열을 생성하고 데이터를 복사해야 합니다.
    
  
  인덱스 접근 : 배열의 각 요소는 인덱스를 통해 접근할 수 있습니다.
    
      인덱스는 0부터 시작하여 배열의 크기 -1까지 번호가 할당됩니다.
    
  
  동일 타입 : 모든 배열 요소는 동일한 데이터 타입을 가져야 합니다.
    
      예를 들어, int 타입의 배열은 int 타입의 값만을 요소로 가질 수 있습니다.
    
  


3.2 배열의 선언과 초기화.
배열을 선언하고 사용하기 위해서는 다음 단계를 따라야 합니다.


  1. 배열 선언 : 데이터 타입 뒤에 대괄호 [] 를 사용하여 배열을 선언합니다.


int[] myArray;
String[] stringArray;



  2. 배열 생성 : new 키워드를 사용하여 배열을 생성하고, 배열의 크기를 지정합니다.


myArray = new int[10]; // 10개의 정수를 저장할 수 있는 배열
stringArray = new String[5]; // 5개의 문자열을 저장할 수 있는 배열



  3. 배열 초기화 : 배열의 각 요소에 값을 할당합니다.
    
      인덱스를 사용하여 접근할 수 있습니다.
    
  


myArray[0] = 50;
myArray[1] = 100;
stringArray[0] = "Hello";
stringArray[1] = "World";


3.3 배열 사용 예.
다음은 자바에서 int 배열을 선언, 생성, 초기화하는 예제 코드입니다.

public class ArrayExample {
    public static void main(Stringp[] args) {
        // 배열 선언과 동시에 생성
        int[] numbers = new int[3];
        
        // 배열 초기화
        numbers[0] = 7;
        numbers[1] = 20;
        numbers[2] = 33;
        
        // 배열 사용
        System.out.println("첫 번째 숫자: " + numbers[0]);
        System.out.println("두 번째 숫자: " + numbers[1]);
        System.out.println("세 번째 숫자: " + numbers[2]);
    }
}

📝 정리
이 예제에서는 numbers 라는 이름의 int 배열을 생성하고, 세 개의 정수를 저장한 후 출력합니다.
배열을 사용하는 이점 중 하나는 이처럼 단일한 이름으로 여러 데이터를 효율적으로 관리할 수 있다는 것입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html"><h1 class="title_post">☕️[Java] 자바 - 변수와 자료형(2)</h1></a>
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html" class="txt_post">
                            ☕️ 자바 - 변수와 자료형(2)

1. 자료형에 대한 이해
자바 프로그래밍에서 사용되는 자료형은 크게 기본형(Primitive types) 과 참조형(Reference types) 두 가지로 나눌 수 있습니다.
각각의 자료형에 대해 설명드리겠습니다.

1️⃣ 기본형(Primitive types)
기본형 자료형은 실제 값을 저장하는 타입으로, 총 8가지가 있습니다.


  정수형
    
      byte : 8비트 정수형, 값의 범위는 -128에서 127까지.
      short : 16비트 정수형, 값의 범위는 -32,768에서 32,767까지.
      int : 32비트 정수형, 값의 범위는 약 -2.14억에서 2.14억까지.
      long : 64비트 정수형, 값의 범위는 약 -9.22경에서 9.22경까지
    
  
  실수형
    
      float : 32비트 부동 소수점 형. 부정확할 수 있으며, 대략 6~7 자리의 정밀도를 가짐.
      double : 64비트 부동 소수점 형. float보다 더 정밀하며, 대략 15자리의 정밀도를 가짐.
    
  
  문자형
    
      char : 단일 16비트 유니코드 문자를 저장.
    
  
  논리형
    
      boolean : true 또는 false 값만을 가짐.
    
  


2️⃣ 참조형(Reference types)
참조형 자료형은 객체의 참조(메모리 주소)를 저장합니다.
기본형과 달리 메모리의 특정 위치를 가리키는 포인터를 저장하므로, 객체의 크기에 관계없이 참조 변수 크기는 항상 일정합니다.
참조형의 예를 들면 다음과 같습니다.


  클래스(Class)
    
      예: String, Integer, File 등
    
  
  인터페이스(Interface)
    
      예: List, Map, Serializable 등
    
  
  배열(Array)
    
      예: int[], double[], String[] 등
    
  




1.1 인터페이스(Interface)?
자바에서 인터페이스(Interface)는 특정 클래스가 구현해야 할 메소드를 정의하는 “계약”의 역할을 합니다.
이는 클래스가 인터페이스에 정의된 모든 메소드를 반드시 구현하도록 강제합니다.
인터페이스는 메소드의 실제 구현을 포함하지 않고, 메소드의 시그니처(이름, 매개변수 리스트, 반환 유형)만을 정의합니다.
인터페이스를 사용하는 주된 목적은 다음과 같습니다.


  1. 추상화(Abstraction) : 인터페이스를 통해 구현의 세부 사항을 숨기고, 사용자에게 필요한 기능만을 제공할 수 있습니다.
    
      이렇게 함으로써 코드의 복잡성을 줄이고, 유지 관리가 쉬워집니다.
    
  
  2. 다형성(Polymorphism) : 다양한 클래스들이 동일한 인터페이스를 구현함으로써, 다양한 타입의 객체를 동일한 방식으로 처리할 수 있습니다.
    
      이는 코드의 유연성과 재사용성을 높입니다.
    
  
  3. 결합도 감소(Decoupling) : 인터페이스를 통해 서로 다른 코드 부분 간의 결합도를 낮추어, 각 부분을 독립적으로 개발하고 테스트할 수 있게 합니다.


👉 인터페이스 예시

  예를 들어, List 인터페이스는 add ,remove, get, size 등의 메소드를 정의하며, 이 인터페이스를 구현하는 ArrayList, LinkedList 등의 클래스는 이 메소드들을 실제로 구현해야 합니다.
    
      이를 통해 사용자는 구체적인 리스트의 구현 방법을 몰라도 이 인터페이스를 통해 리스트를 사용할 수 있습니다.
        
          이런 방식으로 인터페이스는 참조형 자료형 중 하나로서, 객체의 행동을 정의하고 다양한 구현을 가능하게 합니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-03-TypeComparison.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-03-TypeComparison.html"><h1 class="title_post">☕️[Java] 타입 비교.</h1></a>
                        <a href="/Backend/Java/2024-05-03-TypeComparison.html" class="txt_post">
                            타입 비교.
자바 프로그래밍에서 두 변수의 타입이 같은지 비교하는 방법은 몇 가지 상황에 따라 다릅니다.
여기서는 변수가 기본형(Primitive types) 인 경우와 참조형(Reference types) 인 경우로 나누어 설명하겠습니다.

1️⃣ 기본형 변수의 타입 비교.
기본형 변수의 경우, 자바는 정적 타입 언어이기 때문에 변수의 타입이 코드 작성 시 결정됩니다.
두 변수가 같은 기본형 타입인지 비교하는 일반적인 상황은 적으며, 주로 타입을 확인하거나 변환할 때 컴파일러가 자동으로 처리합니다.
그러나 명시적으로 확인하고 싶다면, 두 변수의 타입을 직접 코드에서 확인할 수 있습니다.
이는 일반적인 코딩 상황보다는 주로 제네릭 코드나 리플렉션을 사용할 때 발생합니다.

2️⃣ 참조형 변수의 타입 비교.
참조형 변수의 경우 타입 비교는 다음 두 가지 방법으로 이루어질 수 있습니다.

2.1 instanceof 연산자 사용.
instanceof 연산자는 특정 객체가 지정된 클래스의 인스턴스이거나 그 서브클래스의 인스턴스인지를 검사합니다.

  이 방법은 주로 객체의 타입을 확인할 때 사용됩니다.


Object a = "Hello";
Object b = new String("Hello");

if (a instanceof String &amp;&amp; b instanceof String) {
    System.out.println("두 객체는 같은 타입입니다.");
}


2.2 getClass() 메서드 사용.
객체의 정확한 클래스를 알고 싶을 때 getClass() 메서드를 사용할 수 있습니다.
이 메서드는 객체의 런타임 클래스를 리턴합니다.

  두 객체의 클래스가 정확히 같은지 비교할 때 유용합니다.


Object a = new Integer(5);
Object b = new Double(5.0);

if (a.getClass().equals(b.getClass())) {
    System.out.println("두 객체는 같은 클래스입니다.")
} else {
    System.out.println("두 객체는 다른 클래스입니다.")
}


📝 마무리.
이 방법들은 객체의 타입을 정확히 확인할 수 있으며, 특히 다형석을 활용하는 객체지향 프로그래밍에서 유용하게 사용됩니다.
또한, 테스트 코드나 동적 타입 처리가 필요한 상황에서 자주 사용됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-02-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-02-TIL.html"><h1 class="title_post">📝 [TIL] 240502 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-02-TIL.html" class="txt_post">
                            
  기초수학 - 소개(수학과 자바 프로그래밍, 자료구조, 알고리즘의 관계)
  코테 맛보기(1) - 코테를 위한 자바 프로그래밍 언어 사용 숙련도
  코테 맛보기(2) - 코테를 위한 자료구조와 알고리즘 개념 구현 방법 숙지
  자바 - 소개
  자바 - 변수와 자료형(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-05-02-Math.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-05-02-Math.html"><h1 class="title_post">[Math] 기초수학 - 소개</h1></a>
                        <a href="/Backend/Math/2024-05-02-Math.html" class="txt_post">
                            자바 프로그래밍, 수학, 자료구조 / 알고리즘

수학은 자바 프로그래밍과 자료구조 / 알고리즘 사이의 “중간 다리 역할”을 합니다.

자바 프로그래밍, 수학, 자료구조 그리고 알고리즘은 컴퓨터 과학과 소프트웨어 개발의 중요한 구성 요소들이며 서로 긴밀하게 연결되어 있습니다.

각각의 분야가 어떻게 상호작용하는지 살펴봅시다.

1. 수학과 프로그래밍.

🙋‍♂️ 수학과 자바 프로그래밍 사이의 상관관계는 매우 밀접하며, 효과적인 프로그래밍 기술과 문제 해결 능력을 개발하는 데 중요한 역할을 합니다. 수학은 프로그래밍의 논리적 사고, 구조적 접근, 그리고 복잡한 문제의 해결에 기초를 제공합니다.

  다음은 수학이 자바 프로그래밍과 어떻게 연결되는지에 대한 몇 가지 주요 포인트입니다.
    
      1. 논리적 사고와 알고리즘 개발 : 수학은 논리적이고 체계적인 사고를 필요로 합니다. 자바 프로그래밍에서도 마찬가지로, 문제를 분석하고 효과적인 알고리즘을 설계하는 데 이러한 사고방식이 요구됩니다.
        
          예를 들어, 조건문, 반복문, 함수 등의 기본적인 프로그래밍 구조는 수학적 조작과 비슷한 추론을 통해 최적화될 수 있습니다.
        
      
      2. 복잡도 분석 : 프로그램의 성능을 평가하고 최적화하기 위해 수학적인 복잡도 분석이 사용됩니다.
        
          빅 오 표기법 같은 수학적 도구는 알고리즘의 실행 시간과 필요한 메모리 곤간을 예측하는 데 도움을 줍니다.
            
              이는 효율적인 자바 프로그램을 작성하는 데 필수적인 요소입니다.
            
          
        
      
      3. 문제 해결 : 수학적 모델링과 이론은 자바 프로그래밍에서 복잡한 문제를 단순화하고 구조화하는데 사용됩니다.
        
          예를 들어, 경로 찾기, 스케줄링 문제, 최적화 문제 등을 해결할 때 수학적 기법이 프로그래밍 로직의 기반을 형성합니다.
        
      
      4. 데이터 구조 : 수학적 개념, 특히 집합론은 자바에서 사용되는 다양한 데이터 구조의 이해를 돕습니다.
        
          배열, 리스트, 스택, 큐, 트리, 그래프 등의 자료구조는 모두 수학적 원리에 기반을 두고 있으며, 이를 이해하고 활용하는 것은 효율적인 프로그래밍에 직결됩니다.
        
      
      5. 인공 지능과 머신 러닝 : 자바 프로그래밍에서 머신 러닝과 인공 지능 애플리케이션을 개발할 때, 선형대수학, 확률론, 통계학 등의 수학적 분야가 필수적입니다.
        
          이러한 수학적 지식은 데이터를 분석하고, 알고리즘을 구현하는 데 필요합니다.
        
      
      6. 암호화와 보안 : 암호화 알고리즘과 보안 기술의 개발에도 수학이 깊숙이 관련되어 있습니다.
        
          예를 들어, 공개 키 암호화 같은 기술은 수학적 난제에 기반을 두고 있으며, 이는 자바 보안 기능의 핵심 부분입니다.
        
      
    
  


👉 이처럼 수학은 자바 프로그래밍에서 논리적 구조, 효율성, 그리고 문제 해결 능력을 개발하는 데 필수적인 도구입니다.
👉 수학적 사고방식은 효과적인 소프트웨어 개발을 위한 기초적인 스킬로, 프로그래머가 보다 복잡한 문제에 접근하고 해결하는 데 큰 도움을 줍니다.

2. 수학과 자료구조.

🙋‍♂️ 수학과 자료구조 간의 상관관계는 컴퓨터 과학의 깊은 수학적 기반을 통해 잘 드러납니다.

  다음은 수학과 자료구조 간의 몇 가지 중요한 상호작용을 설명합니다.
    
      1. 이론적 기반 제공 : 수학은 자료구조를 이해하고 분석하는 데 필요한 이론적 지반을 제공합니다.
        
          예를 들어, 집합 이론은 자료구조 설계의 기본이 되며, 다양한 자료구조들이 데이터의 집합을 어떻게 조직화하고 관리하는지 이해하는 데 도움을 줍니다.
        
      
      2. 복잡도 분석 : 자료구조의 효율성을 평가하기 위해 수학적 도구가 필요합니다.
        
          빅 오 표기법(O notation)은 알고리즘과 자료구조의 시간 복잡도와 공간 복잡도를 표현하는 데 사용되며, 이는 수학적 함수로 표현됩니다.
            
              이를 통해 개발자들은 자료구조의 성능을 정량적으로 비교하고 분석할 수 있습니다.
            
          
        
      
      3. 그래프 이론 : 그래프 이론은 네트워크, 소셜 미디어, 경로 탐색 등 다양한 문제를 모델링하는 데 사용되는 자료구조인 그래프의 분석과 최적화에 사용됩니다.
        
          이는 컴퓨터 네트워크, 최단 경로 문제, 최소 스패닝 트리 등의 문제 해결에 필수적입니다.
        
      
      4. 논리와 증명 : 수학적 논리와 증명 기법은 자료구조의 올바른 작동을 보장하는 데 중요합니다.
        
          예를 들어, 자료구조릐 구현을 검증하거나, 특정 알고리즘이 주어진 자료구조에서 올바르게 작동함을 증명할 때 사용됩니다.
          또한, 재귀적 자료구조와 알고리의 증명에도 수학적 귀납법이 활용됩니다.
        
      
      5. 최적화 문제 : 다양한 자료구조는 종종 최적화 문제를 해결하는 데 사용됩니다.
        
          예를 들어, 트리 구조를 사용하여 데이터베이스 쿼리의 응답 시간을 최소화하거나, 해시 테이블을 사용하여 데이터 접근 시간을 최적화할 수 있습니다.
            
              이러한 최적화 문제는 수학적 모델링과 알고리즘을 통해 접근됩니다.
            
          
        
      
      6. 확률론과 통계 : 일부 자료구조는 확률론과 통계적 방법에 기반을 둔 설계가 필요합니다.
        
          예를 들어, 블룸 필터와 같은 확률적 자료구조는 데이터의 존재를 빠르게 검사하면서 오차를 허용하는 구조입니다.
            
              이러한 자료구조는 확률론적 모델을 사용하여 성능과 오차 확률을 예측합니다.
            
          
        
      
    
  


👉 이처럼 수학은 자료구조의 설계, 분석, 최적화 및 검증에 깊이 관여하여, 효율적인 소프트웨어 시스템과 알고리즘의 개발을 가능하게 합니다.
👉 수학적 사고는 컴퓨터 과학에서 중요한 문제 해결 도구로 활용되며, 이를 통해 보다 정교하고 효율적인 프로그래밍이 이루어집니다.

3. 수학과 알고리즘.

🙋‍♂️ 수학과 알고리즘 사이의 상관관계는 컴퓨터 과학에서 매우 깊고 중요합니다. 수학은 알고리즘의 기초를 제공하며, 효율적인 알고리즘 설계와 분석을 위해 필수적인 도구와 개념들을 제공합니다.

  다음은 수학이 알고리즘과 어떻게 연결되는지에 대한 몇 가지 주요 사례입니다.
    
      1. 알고리즘 분석 : 알고리즘의 효율성을 평가하기 위해 수학적 도구가 필수적입니다. 시간 복잡도와 공간 복잡도를 정량화하기 위해 빅 오 표기법(O-notation), 빅 세타 표기법(Θ-notation), 빅 오메가 표기법(Ω-notation)등이 사용됩니다.
        
          이러한 복잡도 분석은 알고리즘을 선택하고 최적화하는 데 중요한 기준을 제공합니다.
        
      
      2. 최적화 : 수학적 최적화 기법은 알고리즘에서 특정 목표(예: 최소 비용, 최대 이익, 최소 시간)를 달성하기 위해 사용됩니다.
        
          선형 프로그래밍, 정수 프로그래밍. 동적 프로그래밍 등의 방법이 알고리즘 설계에 자주 사용됩니다.
            
              이러한 방법들은 복잡한 문제를 더 효율적으로 해결할 수 있도록 도와줍니다.
            
          
        
      
      3. 그래프 이론 : 그래프 이론은 네트워크 경로, 소셜 네트워크, 웹 페이지 링크 구조와 같은 다양한 알고리즘 문제를 표현하고 해결하는 데 사용됩니다.
        
          최단 경로 찾기(다익스트라 알고리즘, 벨만-포드 알고리즘), 최소 신장 트리(프림 알고리즘, 크루스칼 알고리즘)와 같은 알고리즘은 모두 그래프 이론을 기반으로 합니다.
        
      
      4. 확률론과 통계 : 확률론은 불확실성 하에서 문제 해결과 의사 결정에 중요한 역할을 합니다.
        
          예를 들어, 랜덤화 알고리즘, 몬테 카를로 방법, 라스베가스 알고리즘과 같은 확률적 알고리즘은 이론적 분석과 함께 실제 응용에서도 중요합니다.
          또한, 기계 학습 알고리즘의 기초로서 확률 모델을 사용합니다.
        
      
      5. 논리학 : 수학적 논리는 알고리즘의 정확성을 증명하는 데 필요합니다.
        
          증명 기법, 예를 들어 귀납법과 수학적 귀납법은 알고리즘의 정확성을 보장하며, 특정 조건에서의 알고리즘의 동작을 증명하는 데 사용됩니다.
        
      
      6. 기하학과 알고리즘 : 기하학은 컴퓨터 그래픽, 로봇 공학, 컴퓨터 비전 들에서 중요한 알고리즘을 제공합니다.
        
          예를 즐어, 충돌 감지, 물체 인식, 경로 계획 등에 사용되는 계산 기하학은 복잡한 기하학적 구조를 효율적으로 계산하는 알고리즘을 개발하는 데 필요합니다.
        
      
    
  


👉 이와 같이, 수학은 알고리즘을 설계하고 분석하는 데 필수적인 도구이며, 효율적이고 신뢰할 수 있는 소프트웨어 시스템을 개발하는 데 중요한 역할을 합니다.
👉 수학적 사고는 알고리즘의 성능을 최적화하고 문제 해결과정을 체계화 하는 데 큰 도움이 됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html"><h1 class="title_post">☕️[Java] 자바 - 변수와 자료형(1)</h1></a>
                        <a href="/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html" class="txt_post">
                            변수와 자료형(1)

🙋‍♂️ 변수 이름 규칙
자바 프로그래밍에서 변수를 명명할 때 따라야 할 몇 가지 기본적인 규칙과 관례가 있습니다.
이러한 규칙을 준수하는 것은 코드의 가독성과 유지보수성을 높이는 데 중요합니다.
다음은 자바에서 변수 이름을 지정할 때 고려해야 할 주요 규칙들 입니다.

1️⃣ 기본 규칙.

  **문자와 숫자, (Underscore), $ 사용가능 :** 변수 이름은 문자(letter) 나 밑줄(, Underscore) 또는 $(달러 기호)로 시작할 수 있습니다.
    
      그러나 숫자로 시작할 수는 없습니다.
    
  
  숫자로 시작할 수 없다 : 첫 글자로는 숫자로 변수 이름을 시작할 수 없습니다.
    
      그러나 첫 글자 이후에는 숫자가 포함될 수 있습니다.
    
  
  대문자와 소문자를 구분함 : 변수 이름을 명명시, 대문자와 소문자를 구분합니다.
    
      예를 들어 int apple = 1;, int Apple = 2;, int APPLE = 3;은 모두 다른 변수로 취급됩니다.
    
  
  공백을 허용하지 않음 : 변수 이름을 명명시 공백이 들어가서는 않됩니다.
    
      예를 들어 int my friends = 7;과 같이 공백이 들어가서는 안됩니다.
    
  
  특수 문자 제한 : ‘_(underscore)’와 ‘$’를 제외한 특수 문자는 변수명으로 사용할 수 없습니다.
    
      예를 들어 ‘@’, ‘#’, ‘%’ 등은 변수 이름으로 사용할 수 없습니다.
    
  
  자바 예약어 사용 금지 : int, class, static 등 자바에서 이미 의미를 갖는 예약어는 변수 이름으로 사용할 수 없습니다.


2️⃣ 표기법 및 관례(컨벤션)

  카멜 케이스 : 첫 단어는 소문자로 시작하고, 이어지는 각 단어의 첫 글자는 대문자로 시작합니다.
    
      예를 들어, firstName, totalAmount 등 입니다.
    
  
  파스칼 케이스 : 각 문자의 첫 문자를 대문자로 표기합니다.
    
      예를 들어, MyFriends, ToTalCount 등 입니다.
    
  
  의미 있는 이름 : 변수 이름은 그 변수가 무엇을 의미하는지 명확하게 표현해야 합니다.
    
      예를 들어, numberOfStudents 는 학생 수를, temperature는 온도를 나타내는 등의 명확한 이름을 사용하는 것이 좋습니다.
    
  
  상수 이름 규칙 : 상수(변하지 않는 값)는 모두 대문자를 사용하며, 단어 사이는 밑줄(‘_‘)로 구분합니다.
    
      예를 들어 MAX_HEIGHT, TOTAL_COUNT 등 입니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-2.html"><h1 class="title_post">☕️[Java] 코테 맛보기(2) - 코테를 위한 자료구조와 알고리즘 개념 구현 방법 숙지</h1></a>
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-2.html" class="txt_post">
                            😋 코테 맛보기.

코딩 테스트를 준비하기 위해서 자료구조와 알고리즘은 매우 중요한 영역입니다.
이 분야들에 대한 깊이 있는 이해와 숙지는 테스트에서 성공적인 성과를 내는 데 결정적인 역할을 합니다.
다음은 코딩 테스트를 위해 필요한 자료구조와 알고리즘의 개념 및 구현 방법에 대한 가이드입니다.

1️⃣ 자료구조.

  기본 자료구조 : 배열, 스택, 큐, 링크드 리스트.
    
      이러한 자료구조들은 다양한 문제에서 데이터를 효율적으로 관리하는 기본적인 방법을 제공합니다.
    
  
  고급 자료구조 : 트리(특히 이진 검색 트리), 힙, 그래프, 해시 테이블, 집합 등
    
      이들은 보다 복잡한 데이터 관계를 다루는 데 사용되며, 특정 유형의 문제를 해결하는 데 특화되어 있습니다.
    
  
  응용 자료구조 : 트라이, 세그먼트 트리, 유니온 파인드, 비트마스크 등.
    
      이들은 특정 알고리즘 문제에 최적화된 솔루션을 제공합니다.
    
  


2️⃣ 알고리즘.

  정렬 알고리즘 : 버블 정렬, 삽입 정렬, 선택 정렬, 퀵 정렬, 병합 정렬 등.
    
      정렬은 많은 문제에서 데이터를 조작하는 기본적인 방법입니다.
    
  
  검색 알고리즘 : 선형 검색, 이진 검색 등
    
      데이터 내에서 특정 항목을 찾는 방법입니다.
    
  
  재귀 알고리즘과 백트래킹 : 문제를 더 작은 문제로 나누어 해결하는 기법입니다.
  동적 프로그래밍 : 복잡한 문제를 간단한 하위 문제로 나누어 해결하고, 그 결과를 저장하여 효율적으로 최종 결과를 도출합니다.
  그래프 알고리즘 : 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS), 최단 경로 문제(다익스트라, 플로이드-워셜), 최소 신장 트리(크루스칼, 프림) 등을 포함합니다.


3️⃣ 코테 준비 방법.

  이론 학습 : 자료구조와 알고리즘의 이론을 철저히 학습합니다.
    
      이론적인 이해는 효과적인 구현의 기초가 됩니다.
    
  
  실습 연습 : 이론을 바탕으로 다양한 문제를 실제로 코딩해 봄으로써 실력을 키웁니다.
    
      LeetCode, HackerRank, Codeforces, 백준, 프로그래머스 등의 플랫폼에서 문제를 풀어봅니다.
    
  
  알고리즘 패턴 학습 : 자주 출제되는 문제 유형과 그에 대한 표준적인 해결 방법을 익힙니다.
  시간 관리 연습 : 코딩 테스트에서는 제한된 시간 내에 문제를 해결해야 하므로, 시간 관리 능력을 향상시킬 필요가 있습니다.


📝 정리.
코테를 위한 준비 과정에서 이러한 자료구조와 알고리즘에 대한 이해와 숙련도는 문제를 정확하고 효율적으로 해결할 수 있는 능력을 직접적으로 높여 줍니다.
따라서, 이 분야에 대한 철저한 준비와 연습을 통해 자신감을 갖고 테스트에 임할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-IntroJava.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-IntroJava.html"><h1 class="title_post">☕️[Java] 자바 - 소개</h1></a>
                        <a href="/Backend/Java/2024-05-02-IntroJava.html" class="txt_post">
                            자바 - 소개

🙋‍♂️ 1. 자바의 특징.
자바는 세계적으로 널리 사용되는 프로그래밍 언어로, 웹 개발, 모바일 애플리케이션, 대규모 시스템 구축 등 다양한 분야에 활용됩니다.
자바의 주요 특징들은 다음과 같습니다.

1️⃣ 플랫폼 독립성.

  “Write Once, Run Anywhere”(WORA) : 자바 프로그램은 자바 가상 머신(JVM) 위에서 실행되기 때문에, 한 번 작성하면 어떤 플랫폼에서도 실행할 수 있습니다.
    
      이는 자바 컴파일러가 소스 코드를 플랫폼 독립적인 바이트코드로 변환하기 때문입니다.
    
  


2️⃣ 객체 지향 프로그래밍(OOP).

  자바는 객체 지향 프로그래밍 언어로, 캡슐화, 상속, 다형성 등을 완전히 지원합니다.
    
      이는 코드 재사용, 유지 관리의 용이성 및 시스템 모듈화를 가능하게 합니다.
    
  


3️⃣ 강력한 표준 라이브러리.

  자바는 방대한 표준 라이브러리를 제공하여, 네트워킹, 파일 시스템 접근, 그래픽 인터페이스 제작 등 다양한 작업을 쉽게 처리할 수 있도록 돕습니다.


4️⃣ 메모리 관리.

  자동 가비지 컬렉션
    
      자바는 사용하지 않는 객체를 자동으로 감지하고 메모리에서 제거하는 가비지 컬렉터를 내장하고 있습니다. 이는 개발자가 메모리 누수에 대해 걱정할 필요가 적어지게 해줍니다.
    
  


5️⃣ 보안.

  자바는 샌드박스 환경에서 애플리케이션을 실행하여 시스템 리소스에 대한 무단 접근을 방지합니다.
    
      또한, 클래스 로더, 바이트코드 검증기 등을 통해 애플리케이션이 안전하게 실행될 수 있도록 합니다.
    
  


6️⃣ 멀티스레딩.

  자바는 내장된 멀티스레딩 기능을 지원하여, 여러 스레드가 동시에 실행되도록 하여 애플리케이션의 효율성을 높입니다.
    
      이는 특히 네트워크 서버와 실시간 시스템에서 큰 장점입니다.
    
  


7️⃣ 로버스트와 포터빌리티.

  자바 프로그램은 다른 플랫폼으로의 이동성이 뛰어나며, 높은 수준의 안정성을 제공합니다.
    
      예외 처리 기능을 통해 오류를 쉽게 관리하고, 시스템의 안정성을 높일 수 있습니다.
    
  


📝 마무리.
자바의 이러한 특징들은 그것을 매우 유연하고, 다양한 애플리케이션 개발에 적합하게 만듭니다.
이로 인해 자바는 세계적으로 인기 있는 프로그래밍 언어 중 하나로 자리 잡게 되었습니다.



🙋‍♂️ 2. 자바 프로그램의 작성과 실행과정.



1️⃣ 소스 코드 작성.

  개발자는 자바의 문법에 맞추어 .java 확장자 파일에 소스 코드를 작성합니다.
    
      이 파일에는 하나 이상의 클래스가 포함되며, 각 클래스는 데이터와 메서드를 정의합니다.
    
  


2️⃣ 컴파일.

  소스 코드 파일을 자바 컴파일러(javac)를 사용하여 컴파일합니다.
    
      컴파일러는 소스 코드를 읽고, 문법 오류를 검사한 후, 바이트코드라는 중간 형태의 코드로 변환합니다.
        
          이 바이트 코드는 .class 파일로 저장됩니다.
        
      
    
  
  바이트코드는 플랫폼 독립적이기 때문에, 한 번 컴파일된 .class 파일은 다양한 운영 체제에서 실행될 수 있습니다.


3️⃣ 로딩.

  자바 가상 머신(JVM)은 .class 파일을 로드합니다.
    
      클래스 로더(component of JVM)가 이 작업을 수행하며, 필요한 클래스 파일들을 메모리에 로드합니다.
    
  


4️⃣ 링킹.

  로드된 클래스 파일들은 링킹 과정을 거칩니다. 링킹은 검증, 준비, 그리고(선택적으로) 해석 단계를 포함합니다.
    
      검증 : 로드된 바이트코드가 올바르게 포맷되었는지, 안전한지 검사합니다.
      준비 : 클래스 변수와 기본값을 위한 메모리를 할당합니다.
      해석 : 심볼릭 메모리 참조를 직접 참조로 변환합니다(선택적).
    
  


5️⃣ 초기화.

  클래스 초기화 단계에서 정적 변수들에 대한 초기화가 수행되며, 정적 블록이 실행됩니다.


6️⃣ 실행.

  프로그램 실행 동안 JVM 내부에서 가비지 컬렉터가 사용되지 않는 객체를 자동으로 감지하고, 할당된 메모리를 해제하여 메모리를 관리합니다.


📝 마무리.
자바의 이러한 실행 과정은 코드의 플랫폼 독립성을 보장하고, 안정적이며 보안적인 실행 환경을 제공합니다.
이 모든 과정은 개발자로부터 대부분 숨겨져 있으며, 개발자는 주로 소스 코드 작성과 일부 디버깅에 집중할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-1.html"><h1 class="title_post">☕️[Java] 코테 맛보기(1) - 코테를 위한 자바 프로그래밍 언어 사용 숙련도</h1></a>
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-1.html" class="txt_post">
                            😋 코테 맛보기.

코딩 테스트를 위해 자바 프로그래밍 언어를 사용하려면 몇 가지 중요한 요소에 숙력도를 갖추어야 합니다.
자바는 많은 기업들이 코딩 테스트에 사용하는 언어 중 하나이며, 효과적인 문제 해결을 위해 다음과 같은 능력을 개발하는 것이 중요합니다.
효과적인 문제 해결을 위해 다음과 같은 능력을 개발하는 것이 중요합니다.

1️⃣ 기본 문법 숙지.

  자바의 기본 문법과 프로그래밍 구조에 익숙해져야 합니다.
    
      변수, 데이터 타입, 연산자, 제어문(if, for, while 등), 메소드 호출 등 기본적인 구성 요소를 이해하고 사용할 수 있어야 합니다.
    
  


2️⃣ 객체 지향 프로그래밍(OOP)이해.

  자바는 객체 지향 프로그래밍 언어입니다.
    
      클래스, 객체, 상속, 다형성, 캡슐화 등의 객체 지향 개념을 이해하고 이를 문제 해결에 적절히 적용할 수 있어야 합니다.
      OOP 개념은 코드의 재사용성과 모듈성을 높여줘 효율적인 프로그래밍을 가능하게 합니다.
    
  


3️⃣ 표준 라이브러리 사용.

  자바의 표준 라이브러리에는 다양한 자료구조와 알고리즘이 구현되어 있습니다.
    
      java.util 패키지 내의 컬렉션 프레임워크(리스트, 맵, 셋 등)를 비롯해, 유용한 유틸리티 클래스들을 활용할 줄 알아야 합니다.
        
          이러한 라이브러리들은 코딩 테스트에서 효율적인 코드 작성을 돕습니다.
        
      
    
  


4️⃣ 알고리즘과 자료구조.

  다양한 알고리즘과 자료구조에 대한 이해가 중요합니다.
    
      정렬, 탐색, 그래프 이론, 동적 프로그래밍 등의 알고리즘과 배열, 스택, 큐, 링크드 리스트, 트리 등의 자료구조에 대한 깊은 이해가 필요합니다.
        
          이는 문제를 효과적으로 분석하고 최적의 해결책을 구현하는 데 결정적입니다.
        
      
    
  


5️⃣ 문제 해결 능력.

  실제 코딩 테스트에서는 다양한 유형의 문제가 제시됩니다.
    
      문제를 빠르게 이해하고 효과적인 해결책을 설계할 수 있는 능력이 필요합니다.
        
          이는 실전 연습을 통해 향상시킬 수 있으며, 온라인 코딩 플랫폼에서 다양한 문제를 풀어 보는 것이 좋습니다.
        
      
    
  


6️⃣ 테스트와 디버깅

  코드가 예상대로 동작하는지 검증하고, 오류를 찾아 수정할 수 있는 능력도 중요합니다.
    
      자바에서 제공하는 디버깅 도구를 사용하여 코드를 단계별로 실행하고, 변순의 상태를 확인하며 문제를 진단할 수 있어야 합니다.
    
  


📝 정리.
코딩 테스트를 위한 자바 숙련도는 이론적 지식과 실제 적용 능력의 조합을 요구합니다.
이를 위해 개념 학습과 함께 많은 실습을 병행하는 것이 중요합니다.
시간을 정해두고 실전처럼 문제를 풀어보는 연습을 꾸준히 하면, 효과적으로 자바를 활용하여 코딩 테스트에서 좋은 성과를 낼 수 있을 것입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-01-AboutJava.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-01-AboutJava.html"><h1 class="title_post">☕️[Java] 자바란?</h1></a>
                        <a href="/Backend/Java/2024-05-01-AboutJava.html" class="txt_post">
                            자바란?
자바 언어 특징.

1. 타 언어에 비해 배우기 쉽습니다.
2. 플랫폼에 독립적입니다.
- 자바 언어가 플랫폼에 독립적인 이유는 그 설계 철학과 메커니즘에 근거합니다.
- 자바는 "한 번 작성하면, 어디서든 실행된다(Write Once, Run Anywhere, WORA)" 라는 철학을 실현하기 위해 개발되었습니다.
    - 이를 가능하게 하는 핵심 요소는 자바 가상 머신(Java Virtual Machine, JVM)과 자바 바이트코드의 도입입니다.


자바의 플랫폼 독립성의 주요 요인
1. 자바 가상 머선(JVM)

  JVM은 자바 바이트 코드를 실행할 수 있는 런타임 환경을 제공합니다. 자바 프로그램이 컴파일되면, 플랫폼에 독립적인 바이트코드로 변환됩니다.
    
      이 바이트코드는 어떤 특정 하드웨어나 운영 체제의 기계어 코드가 아닌, JVM이 이해할 수 있는 중간 형태의 코드입니다.
    
  
  JVM은 바이트코드를 받아 각 플랫폼에 맞는 기계어 코드로 변환하고 실행합니다.
    
      따라서, 자바 애플리케이션은 다양한 운영 체제에서 JVM만 설치되어 있으면 실행될 수 있습니다.
2. 컴파일과 실행의 분리
    
  
  자바 프로그램은 소스 코드(.java 파일)에서 바이트코드(.class 파일)로 컴파일되는 과정과, 실행 시 바이트 코드가 실제로 실행되는 과정으로 나누어집니다. 이 두 단계의 분리는 프로그램을 한 번 컴파일하면, 그 컴파일된 코드가 다양한 환경의 JVM에서 실행될 수 있게 합니다.
3. 표준화된 API
  자바는 풍부하고 표준화된 API를 제공합니다. 이 API들은 플랫폼에 관계없이 일관된 방식으로 작동하므로, 개발자는 운영 체제의 특징을 신경 쓰지 않고도 애플리케이션을 개발할 수 있습니다. 예를 들어, 파일 시스템 접근, 네트워크 프로그래밍 등의 기능은 모든 플랫폼에서 동일한 자바 코드로 작동합니다.
4. 언어와 라이브러리의 독립성
  자바 언어와 표준 라이브러리는 플랫폼에 특화된 구현으로부터 독립적입니다.
    
      즉, 자바의 표준 라이브러리 구현은 다양한 하드웨어와 운영 체제에서 동일하게 작동하도록 설계되었습니다.
    
  


3. 객체지향 프로그래밍입니다.

  객체지향 프로그래밍?
    
      자바에서의 객체지향 프로그래밍(Object-Oriented Programming, OOP)은 소프트웨어를 설계하고 구현할 때 객체라는 개념을 중심으로 프로그래밍하는 방식을 말합니다.
        
          객체지향 프로그래밍은 코드의 재사용성, 확장성 및 관리 용이성을 높이는 데 도움이 됩니다.
          자바는 객체지향 언어의 특징을 강하게 반영하고 있으며, 다음과 같은 기본 원칙에 따라 프로그래밍 됩니다.
            
              1. 캡슐화(Encapsulation)
                
                  객체의 데이터(속성)와 그 데이터를 조작하는 메소드를 하나의 단위로 묶는 것을 말합니다.
                  캡슐화를 사용하면 객체의 세부 구현 내용을 외부에서 알 필요 없이 객체가 제공하는 기능만을 사용할 수 있으며, 이는 코드의 유지보수를 용이하게 합니다.
                
              
              2. 상속(Inheritance)
                
                  한 클래스가 다른 클래스의 특성을 상속 받아 사용할 수 있게 하는 것입니다.
                  이를 통해(상속을 통해) 기존 코드를 재사용하면서 확장할 수 있고, 코드의 중복을 줄이며 유지 보수가 쉬워집니다.
                
              
              3. 다형성(Polymorphism)
                
                  같은 이름의 메소드가 다른 작업을 수행할 수 있도록 하여 메소드의 오버라이딩(Overriding)이나 오버로딩(Overloading)을 가능하게 합니다.
                    
                      오버라이딩(Overriding) : 자식 클래스가 상속 받은 부모 클래스의 메소드를 재정의 하는 행위를 말합니다. 오버라이딩을 통해 자식 클래스는 상속 받은 메소드와 동일한 시그니처(메소드 이름, 매개변수 리스트)를 가지지만, 그 내용을 자신의 특정한 요구에 맞게 새롭게 구현할 수 있습니다. 오버라이딩된 메소드는 실행 시 다형성을 활용하여 해당 객체의 실제 타입에 따라 적절한 메소드가 호출됩니다.
                        
                          예시 코드
  java
      class Animal {
          void display() {
              System.out.println("This is an animal.");
          }
      }
      class Cat extends Animal {
          @Override
          void display() {
              System.out.println("This is a cat.")
          }
      }
     
                        
                      
                      오버로딩(Overloading) : 같은 클래스 내에서 같은 이름의 메소드를 여러 개 정의할 수 있도록 하지만, 매개변수의 타입, 개수 또는 순서가 달라야 합니다. 이를 통해 메소드에 다양한 입력 파라미터를 제공할 수 있으며, 프로그래머가 같은 동작을 하는 메소드에 대해 다양한 옵션을 제공할 수 있습니다. 오버로딩은 컴파일 시간에 결정되며, 메소드 호출 시 전달된 매개변수에 따라 적절한 메소드가 선택됩니다.
                        
                          예시 코드
                                  class Display {
          void show(int a) {
              System.out.println("Number: " + a);
          }
                                    
          void show(String a) {
              System.out.println("String: " + a);
          }
                                    
          void show(int a, int b) {
              System.out.println("Two numbers: " + a + ", " + b);
          }
      }
                            
                          
                          이처럼 오버라이딩과 오버로딩은 자바 프로그래밍에서 메소드의 기능을 확장하거나 변경할 때 유용하게 쓰이는 기법입니다.
                          오버라이딩은 주로 다형성을 활용한 동적 바인딩을 목적으로 하며, 오버로딩은 같은 이름의 메소드에 여러 입력 형태를 제공하기 위해 사용됩니다.
                        
                      
                    
                  
                
              
              4. 추상화(Abstraction)
                
                  복잡한 실제 상황을 단순화하는 과정에서 중요한 특징만을 추출하여 프로그램 코드에 반영하는 것을 의미합니다.
                  추상 클래스와 인터페이스를 통해 구현될 수 있습니다.
                    
                      이러한 원칙들은 자바를 사용하여 복잡한 시스템을 개발할 때 코드의 모듈화를 가능하게 하고, 이로 인해 대규모 소프트웨어 개발과 프로젝트 관리가 용이해집니다.
                        
                          코드의 모듈화(Modularization): 큰 프로그램을 작은 세부 모듈로 나누는 프로세스를 의미합니다. 이러한 모듈은 각각 독립적인 기능을 수행하며, 전체 시스템의 한 부분으로 기능합니다. 모듈화의 주요 목적은 프로그램의 관리를 용이하게 하고, 개발을 효율적으로 만들며, 코드의 재사용성을 높이는 것입니다.
                          모듈화의 주요 이점은 다음과 같습니다.
                            
                              1. 유지보수성
                                
                                  모듈화된 코드는 각 모듈이 분리되어 있기 때문에, 하나의 모듈에서 발생한 문제가 다른 모듈에 미치는 영향을 최소화할 수 있습니다. 따라서 개별 모듈을 독립적으로 수정, 업데이트, 테스트할 수 있어 전체 코드베이스의 유지보수가 더 쉬워 집니다.
                                    
                                      모듈(Module): 소프트웨어 설계에서 사용되는 기본 개념 중 하나로, 관련된 기능들을 논리적으로 그룹화하고 독립적으로 사용할 수 있는 코드의 단위를 의미합니다. 모듈은 프로그램의 특정 기능을 담당하며, 독립적인 개발, 테스트, 재사용이 가능하도록 설계됩니다. 모듈화된 코드는 대체로 명확하고 관리하기 쉬운 구조를 갖습니다.
                                      모듈의 특징으로는 다음과 같습니다.
                                        
                                          1. 독립성
                                            
                                              모듈은 가능한 한 다른 모듈과 독립적으로 동작할 수 있어야 하며, 이를 통해 시스템의 복잡성을 줄이고, 각 모듈의 재사용성을 높일 수 있습니다.
                                            
                                          
                                          2. 캡슐화
                                            
                                              모듈은 자신의 구현 세부사항을 숨기고, 필요한 기능만을 외부에 제공하는 인터페이스를 통해 상호작용합니다. 이로 인해 모듈 간의 상호 의존성이 줄어들고, 변경 관리가 용이해집니다.
                                            
                                          
                                          3. 인터페이스
                                            
                                              모듈은 정의된 인터페이스를 통해 외부와 통신합니다. 인터페이스는 모듈이 제공하는 기능과 해당 기능을 어떻게 접근할 수 있는지를 명시합니다.
                                            
                                          
                                        
                                      
                                      모듈의 예로는 다음으로 들 수 있습니다.
                                        
                                          라이브러리
                                            
                                              특정 기능을 제공하는 함수나 데이터 구조를 모아 놓은 코드 집합. 예를 들어, 수학 연산을 위한 수학 라이브러리, 데이터베이스 작업을 위한 데이터베이스 접근 라이브러리 등이 있습니다.
                                            
                                          
                                          클래스
                                            
                                              객체지향 프로그래밍에서 클래스는 속성(데이터)과 메소드(함수)를 캡슐화하여 모듈을 형성합니다. 클래스는 독립적으로 사용될 수 있으며, 다른 클래스와 상호작용할 수 있습니다.
                                            
                                          
                                          패키지
                                            
                                              관련된 여러 클래스나 모듈을 하나의 더 큰 단위로 그룹화한 것 입니다. 예를 들어, Java에서는 java.util 패키지가 여러 유틸리티 클래스와 인터페이스를 제공합니다.
                                                
                                                  모듈은 개발 과정을 체계화하고, 코드의 재사용성을 증가시키며, 유지 관리를 용이하게 하는 중요한 역할을 합니다.
                                                  모듈은 크기가 클 수도 있고 작을 수도 있으며, 프로젝트의 요구와 설계에 따라 그 범위와 기능이 결정됩니다.
                                                
                                              
                                            
                                          
                                        
                                      
                                    
                                  
                                
                              
                              2. 재사용성
                                
                                  잘 설계된 모듈은 다른 프로그램에서도 재사용할 수 있습니다. 이는 소프트웨어 개발 시간과 비용을 줄이는 데 도움이 되며, 일관된 기능을 여러 프로젝트에 걸쳐 사용할 수 있습니다.
                                
                              
                              3. 확장성
                                
                                  모듈화는 시스템의 확장성을 향상시킵니다. 새로운 기능이 필요할 때 기존 모듈을 수정하거나 새로운 모듈을 추가하기가 더 쉬워집니다. 이는 시스템의 유연성을 증가시키고, 변화하는 요구사항에 더 잘 대응할 수 있게 합니다.
                                
                              
                              4. 가독성
                                
                                  작은 모듈로 나뉘어진 코드는 각각의 모듈이 명확한 기능을 수행하기 때문에, 전체 코드의 구조를 이해하기가 더 쉽습니다. 개발자가 프로그램의 특정 부분만을 이해하고도 효과적으로 작업할 수 있습니다.
                                
                              
                              5. 팀 협업 향상
                                
                                  모듈화는 여러 개발자가 동시에 다른 모듈에서 작업할 수 있게 함으로써 팀 작업을 용이하게 합니다. 각 팀원이 특정 모듈에 집중할 수 있으며, 전체 프로젝트에 대한 의존성을 줄이면서 협업을 효율적으로 진행할 수 있습니다.
                                    
                                      이처럼 코드의 모듈화는 소프트웨어 개발 과정에서 중요한 역할을 하며, 특히 대규모 프로젝트나 복잡한 시스템 개발에 있어 필수적인 접근 방식입니다.
                                    
                                  
                                
                              
                            
                          
                        
                      
                    
                  
                
              
            
          
        
      
    
  


4. Garbage Collector로 사용되지 않는 메모리를 자동적으로 정리해줍니다.

  Garbage Collector(GC): 프로그램이 동적으로 할당한 메모리 영역 중에서 더 이상 사용하지 않는 부분을 자동으로 찾아서 해제하는 시스템을 말합니다. 이 과정을 통해 프로그램에서 발생할 수 있는 메모리 누수를 방지하고, 사용 가능한 메모리 리소스를 최적화합니다.
    
      프로그램이 동적으로 할당한 메모리 영역 : 프로그램 실행 중에 필요에 따라 할당되고 해제되는 메모리를 말합니다. 이는 프로그램의 런타임 중에 사용자의 요구나 데이터의 양에 따라 변화하는 메모리 요구 사항을 수용하기 위해 사용됩니다. 동적 메모리 할당은 프로그램이 시작할 때 필요한 메모리 양을 미리 알 수 없는 경우나, 실행 도중에 메모리 사용량이 변할 때 유용합니다.
        
          동적 메모리 할당의 특징은 아래와 같습니다.
            
              1. 유연성 : 동적 메모리 할당은 프로그램 실행 중에 필요한 메모리 크기를 조정할 수 있게 해줍니다. 이로 인해 프로그램은 사용자의 입력, 파일 크기, 또는 다른 실행 시 요소들에 따라 메모리 사용을 최적화할 수 있습니다.
              2. 효율성 : 필요할 때만 메모리를 할당하고, 더 이상 사용하지 않는 메모리를 해제함으로써 시스템 리소스를 보다 효율적으로 사용할 수 있습니다.
              3. 메모리 관리 : 동적 메모리는 일반적으로 힙(Heap) 영역에서 관리됩니다. 힙은 프로그램의 데이터 영역 중 하나로, 동적으로 할당되는 객체와 데이터에 사용됩니다. 힙 영역의 크기는 프로그램 실행 도중에 확장되거나 축소될 수 있습니다.
                
                  동적 메모리 할당의 예는 다음과 같습니다.
                    
                      자바에서는 new 키워드를 사용하여 객체를 생성할 때 동적 메모리 할당이 일어납니다. 예를 들어, new ArrayList() 를 호출하면, 자바 런타입은 필요한 메모리를 힙에서 할당하여 ArrayList 객체를 저장합니다.
                      객체 사용이 끝나면 자바의 GC가 더 이상 참조되지 않는 객체가 사용하던 메모리를 자동으로 해제합니다.
                        
                          동적 메모리 할당은 프로그램이 더 유연하고 효율적으로 동작하도록 돕지만, 관리가 제대로 이루어지지 않을 경우 메모리 누수나 성능 저하 같은 문제를 초래할 수 있습니다. 따라서 프로그래머는 동적 메모리 관리를 신중하게 수행해야 합니다.
                        
                      
                    
                  
                  GC의 주요 기능은 다음과 같습니다.
                    
                      1. 메모리 관리 자동화 : 프로그래머가 메모리 할당 및 해제를 직접 관리하는 대신 자바 런타입이 이를 자동으로 처리합니다. 이로 인해 개발자는 메모리 관리에 신경 쓰지 않고, 애플리케이션 로직 개발에 더 집중할 수 있습니다.
                      2. 메모리 누수 방지 : GC는 참조되지 않는 객체들을 정기적으로 청소하여 메모리 누수를 방지합니다. 객체가 더 이상 필요 없을 때 자동으로 메모리에서 제거됩니다.
                      3. 효율적인 메모리 사용 : 사용되지 않는 객체들을 정리함으로써 메모리를 효율적으로 사용하고, 애플리케이션의 성능을 유지할 수 있도록 도와줍니다.
                    
                  
                  GC의 작동 원리는 다음과 같습니다.
                    
                      GC은 크게 두 단계로 진행됩니다.
                        
                          1. 객체 탐지 : GC는 더 이상 어떤 객체에도 참조되지 않는 객체들을 탐지합니다. 이러한 객체들은 프로그램에서 더 이상 사용되지 않는 것으로 간주됩니다.
                          2. 메모리 회수 : 탐지된 객체들이 차지하고 있는 메모리를 해제합니다. 이 메모리는 다시 사용 가능한 상태가 되어, 새로운 객체를 위해 재할당될 수 있습니다.
                        
                      
                    
                  
                  GC 알고리즘
                    
                      자바는 다양한 GC 알고리즘을 제공합니다. 대표적인 몇 가지는 다음과 같습니다.
                        
                          Mark-and-Sweep : 사용 중인 객체를 “표시(mark)”하고, 표시되지 않은 객체를 “쓸어내는(sweep)” 방식입니다.
                          Generational GC : 객체를 세대별로 분류하여, 생성된지 얼마 되지 않은 객체들(Young Generation)과 오래된 객체들(Old Generation)을 다르게 관리합니다. 이 방식은 대부분의 객체가 생성 후 짧은 시간 내에 소멸된다는 관찰에 기반합니다.
                          Compacting : 사용 중인 객체들을 메모리의 한쪽으로 몰아넣어(Compact), 메모리의 연속성을 높이고, 메모리 단편화를 방지합니다.
                            
                              GC은 메모리 관리를 자동화하지만, 때로는 성능 저하를 일으킬 수 있습니다. 특히 GC가 실행되는 동안에는 프로그램의 다른 모든 작업이 일시적으로 중단(Stopping the world)될 수 있기 때문에, GC 동작 방식과 설정을 잘 이해하고 조절하는 것이 중요합니다.
                            
                          
                        
                      
                    
                  
                
              
            
          
        
      
    
  




JVM(Java Virtual Machine)
JVM은 자바 애플리케이션을 실행하기 위한 가상 머신으로, 자바 바이트코드를 로컬 기계 코드로 변환하여 실행하는 역할을 합니다.

  자바 바이트코드(Java Bytecode) : 자바 소스 코드가 컴파일된 후의 중간 형태입니다.
    
      자바 소스 파일(.java 파일)을 자바 컴파일러가 컴파일하면, 결과적으로 생성되는 것이 .class 파일로 저장되는 자바 바이트코드입니다.
      이 바이트코드는 기계어 코드는 아니지만, CPU가 직접 실행할 수는 없고, JVM이 이해하고 실행할 수 있는 명령어 세트로 구성되어 있습니다.
      바이트코드는 플랫폼에 독립적이기 때문에, 한 번 컴파일된 자바 프로램은 어떤 JVM이 설치된 시스템에서든 실행할 수 있습니다.
        
          이는 자바의 “한 번 작성하면, 어디서든 실행된다”라는 이점을 제공합니다.
        
      
    
  
  로컬 기계 코드(Local Machine Code) : 로컬 기계 코드는 특정 하드웨어 플랫폼의 CPU가 직접 이해하고 실행할 수 있는 명령어 코드입니다.
    
      이 코드는 플랫폼에 종속적이며, 다양한 운영 체제와 하드웨어 아키텍처는 각각의 기계어 코드를 가지고 있습니다.
      자바 바이트코드는 JVM을 통해 실행될 때, 두 가지 방법 중 하나로 실행될 수 있습니다.
        
          1. 인터프리터 : JVM은 바이트코드를 한 줄씩 읽고, 각 명령을 로컬 기계 코드로 변환하면서 실행합니다. 이 방법은 간단하지만, 실행 속도가 느릴 수 있습니다.
          2. JIT 컴파일러(Just-In-Time Compiler) : 이 방식에서는 JVM이 바이트코드 전체 또는 핵심 부분을 분석하여, 실행 전에 전체 코드를 로컬 기계 코드로 한번에 변환합니다. 이렇게 하면 프로그램의 실행 속도가 크게 향상됩니다.
            
              결국, 자바 바이트코드는 플랫폼 독립적인 중간 코드로서의 역할을 하며, 로컬 기계 코드는 실제 하드웨어에서 실행되기 위한 최종적인 코드 형태입니다. 이 두 코드의 변환과 실행은 JVM 내에서 처리되며, 사용자는 이 과정을 명시적으로 관리할 필요가 없습니다. 이것이 자바가 제공하는 큰 이점 중 하나입니다.
            
          
        
      
    
  


JVM은 자바의 “한 번 작성하면, 어디서든 실행된다(Write Once, Run Anywhere, WORA)” 라는 철학을 가능하게 하는 중요한 구성 요소입니다.

JVM 덕분에 자바 애플리케이션은 운영 체제나 하드웨어 플랫폼에 구애받지 않고 동일하게 실행될 수 있습니다.

JVM의 주요 기능.
1. 플랫폼 독립성 : 자바 프로그램은 JVM 위에서 실행되므로, JVM이 설치되어 있는 모든 운영 체제에서 같은 자바 프로그램을 실행할 수 있습니다.

  이는 JVM이 플랫폼에 특화된 코드로 바이트 코드를 변환하기 때문입니다.


2. 메모리 관리 : JVM은 자동 메모리 관리 기능을 제공합니다. 이는 GC를 통해 메모리 할당과 해제를 관리하여, 프로그래머가 메모리 누수 없이 효율적인 메모리 사용을 할 수 있도록 돕습니다.

3. 보안 : 자바 바이트코드는 JVM에 의해 검증되며 실행되기 전에 다양한 검사를 통해 안전성이 확보됩니다.

  이는 악의적인 코드 실행과 시스템 오류를 방지하는 데 도움이 됩니다.


4. 실행 환경 : JVM은 자바 애플리케이션에 필요한 실행 환경을 제공합니다.

  이 환경은 클래스 로더, 바이트코드 실행 엔진, 쓰레드 관리 등을 포함합니다.


JVM의 구성 요소.
1. 클래스 로더(Class Loader) : 클래스 파일들을 읽고 바이트코드를 JVM 메모리에 로드하는 역할을 합니다.
2. 실행 엔진(Excution Engine) : 로드된 클래스 파일의 바이트코드를 실행합니다. 이 엔진은 바이트코드를 해것하거나 필요에 따라 JTI(Just-In-Time) 컴파일러를 사용하여 바이트코드를 직접 기계 코드로 변환하여 실행 속도를 높일 수 있습니다.
3. 가비지 컬렉터(Garbage Collector) : JVM이 사용하지 않는 메모리 자원을 자동으로 회수합니다.
4. 메모리(Runtime Data Area) : JVM은 프로그램 실행을 위해 필요한 다양한 메모리 영역을 관리합니다. 이는 힙(Heap), 스택(Stack), 메소드 영역(Method Area), 프로그램 카운터(Program Counter) 등이 포함됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-01-AnD-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/AnD.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-01-AnD-1.html"><h1 class="title_post">[AnD] 두 수의 합.</h1></a>
                        <a href="/Backend/AnD/2024-05-01-AnD-1.html" class="txt_post">
                            문제 설명 🤓

0 이상의 두 정수가 문자열 a, b로 주어질 때, a + b의 값을 문자열로 return 하는 solution 함수를 작성해 주세요.

솔루션 📝

import java.math.BigInteger;

class Solution {
    public String solution(String a, String b) {
        String answer = "";

        BigInteger bigNumberA = new BigInteger(a);
        BigInteger bigNumberB = new BigInteger(b);

        answer = bigNumberA.add(bigNumberB).toString();

        return answer;
    }
}


트러블슈팅 🏀

1. NumberFormatException 에러(1).

입출력의 예시 중 가장 긴 입력 예시인 a : “18446744073709551615”, b : “305793246910280479981” 에서 에러가 발생 했습니다.

1️⃣ 콘솔에 나타난 에러 메시지

콘솔에 나타난 에러 메시지는 아래와 같았습니다.

Exception in thread "main" java.lang.NumberFormatException: For input string: "18446744073709551615"
	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)
	at java.base/java.lang.Integer.parseInt(Integer.java:662)
	at java.base/java.lang.Integer.valueOf(Integer.java:989)
	at programmers.test1.Solution.solution(Solution.java:8)
	at programmers.test1.SolutionMain.main(SolutionMain.java:7)

Process finished with exit code 1


2️⃣ 본격적인 트러블슈팅

이 메시지를 하나씩 해석하고 트러블슈팅을 이어갔습니다.

먼저 이 오류 메시지는 NumberFormatException 이 발생했다는 것을 나타냅니다.

  특히 “For input string: “18446744073709551615”는 Java에서 정수로 변환하려는 문자열이 정부 범위를 벗어났음을 의미합니다.


Java의 Integer.parseInt() 메소드는 문자열을 정수(Int)로 변환할 때 사용됩니다.

  그러나 Int 자료형은 -2,147,483,648,648 부터 2,147,483,648,647까지의 값을 저정할 수 있습니다.
    
      제공된 문자열 “18446744073709551615”는 이 범위를 훨씬 초과합니다.
    
  


3️⃣ 해결 방법

이 문제를 해결하려면 다음과 같은 방법을 고려할 수 있습니다.

1. 타입 변경

  int 대신 long 타입을 사용하거나, 이보다 더 큰 범위가 필요하다면, BigInteger 클래스를 사용할 수 있습니다.
  long 의 범위는 -9,223,372,036,854,775,808부터 9,223,372,036,854,775,807 까지입니다.


2. 입력 검증

  입력 값이 정수 타입으로 변환 가능한지, 그리고 해당 타입의 범위 내에 있는지 검증하는 로직을 추가합니다.



  코드를 수정할 때는 적절한 데이터 타입을 사용하도록 주의해야 합니다.
예를 들어, long 으로 변경하려면 Long.parseLong() 을 사용할 수 있습니다.


2. NumberFormatException 에러(2)

이번에는 위의 트러블슈팅을 활용하여 코드를 만든 결과 NumberFormatException 에러를 다시 발생 시킨 케이스 입니다.

  이번에는 Long.parseLong() 메소드를 사용하면서 발생했습니다.
    
      문자열 “18446744073709551615”는 이번에도 범위를 벗어난 값으로 처리되었습니다.
    
  


long 자료형의 최대값은 9,223,372,036,854,775,807dlqslek.

  제공된 값 “18446744073709551615”는 이 최대값을 초과합니다.
    
      따라서, long 으로도 처리할 수 없으며, Java에서 이러한 큰 숫자를 다루려면 BigInteger 클래스를 사용해야 합니다.
        
          BigInteger 는 사실상 제한 없는 정밀도의 정수를 다룰 수 있어 이와 같은 큰 숫자를 취급할 때 유용합니다.
        
      
    
  


BigInteger를 사용하는 예시 코드.
import java.math.BigInteger;

public class Solution {
    public void solution(String input) {
        BigInteger bigNumber = new BigInteger(input);
        // bigNumber를 사용한 다른 로직
    }
}

public class SolutionMain {
    public static void main(String[] args) {
        new Solution().solution("18446744073709551615");
    }
}


  이 코드는 BigInteger 를 사용하여 입력된 숫자를 처리하고, 필요한 로직을 수행할 수 있도록 구성되어 있습니다.


3. BigInteger 클래스를 사용하여 두 큰 정수를 더하는 방법.
두 문자열을 받아 큰 범위의 문자열을 BigInteger 클래스를 사용하여 받아오고 변환하는 데 까지는 성공하였으나 입력된 두 개의 큰 범위 값의 BigInteger 를 어떻게 합쳐야 할지를 몰라 검색해 봤습니다.

1️⃣ Java에서 BigInteger 클래스를 사용하여 두 큰 정수를 더하는 방법

  BigInteger 클래스는 불변(immutable) 객체 이므로 두 BigInteger 인스턴스를 더할 때, 새로운 BigInteger 객체가 반환됩니다.


2️⃣ BigInteger 객체를 더하는 방법 예시 코드
import java.math.BigInteger;

public class Main {
    public static void main(String[] args) {
        // 두 큰 수를 BigInteger로 생성
        BigInteger number1 = new BigInteger("12345678901234567890");
        BigInteger number2 = new BigInteger("98765432109876543210");
        
        // 두 수를 더함
        BigInteger sum = number1.add(number2);
        
        // 결과 출력
        System.out.println("Sum: " + sum.toSting())
    }
}


이 코드는 다음과 같은 단계를 거칩니다.

1. 두 개의 BigInteger 인스턴스 number1 과 number2 를 생성합니다.

  이들은 문자열로부터 생성되며, 매우 큰 수를 나타낼 수 있습니다.


2. add 메소드를 사용하여 number1 과 number2 를 더합니다.

  이 메소드는 두 수의 합을 나타내는 새로운 BigInteger 객체를 반환합니다.


3. 덧셈 결과를 출력합니다.


  BigInteger 를 사용하면 정수의 범위에 제한 없이 수학적 연산을 수행할 수 있어, 매우 큰 수를 처리해야 할 때 유용합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-26-MathAndRandomClass.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-26-MathAndRandomClass.html"><h1 class="title_post">☕️[Java] Math, Random 클래스</h1></a>
                        <a href="/2024/Java/2024-04-26-MathAndRandomClass.html" class="txt_post">
                            Math, Random 클래스

Math 클래스
Math는 수 많은 수학 문제를 해결해주는 클래스입니다.
너무 많은 기능을 제공하기 때문에 대략 이런 것이 있구나 하는 정도면 충분합니다.
실제 필요할 때 검색하거나 API 문서를 찾아봅시다.

1. 기본 연산 메서드

  abs(x) : 절대값
  max(a, b) : 최대값
  min(a, b) : 최소값


2. 지수 및 로그 연산 메서드

  exp(x) : e^x 계산
  log(x) : 자연 로그
  log10(x) : 로그 10
  pow(a, b) : a의 b 제곱


3. 반올림 및 정밀도 메서드

  ceil(x) : 올림
  floor(x) : 내림
  rint(x) : 가장 가까운 정수로 반올림
  round(x) : 반올림


4. 삼각 함수 메서드

  sin(x) : 사인
  cos(x) : 코사인
  tan(x) : 탄젠트


5. 기타 유용한 메서드

  sqrt(x) : 제곱근
  cbrt(x) : 세제곱근
  random() : 0.0과 1.0 사이의 무작위 값 생성


Math에서 자주 사용하는 기능들을 예제로 만들어서 실행해봅시다.

package lang.math;

public class MathMain {

  public static void main(String[] args) {
    System.out.println("max(10, 20): " + Math.max(10, 20)); // 최대값
    System.out.println("min(10, 20): " + Math.min(10, 20)); // 최소값
    System.out.println("abs(-10): " + Math.abs(-10)); // 절대값

    // 반올림 및 정밀도 메서드
    System.out.println("ceil(2.1): " + Math.ceil(2.1)); // 올림
    System.out.println("floor(2.1): " + Math.floor(2.1)); // 내림
    System.out.println("round(2.5): " + Math.round(2.5)); // 반올림

    // 기타 유용한 메서드
    System.out.println("sqrt(4): " + Math.sqrt(4)); // 제곱근
    System.out.println("random(): " + Math.random()); // 0.0 ~ 1.0 사이의 double 값을 반환
  }
}


실행 결과
max(10, 20): 20
min(10, 20): 10
abs(-10): 10
ceil(2.1): 3.0
floor(2.1): 2.0
round(2.5): 3
sqrt(4): 2.0
random(): 0.45992290098234856



  참고 : 아주 정밀한 숫자와 반올림 계산이 필요하다면 BigDecimal을 검색해봅시다.


Random 클래스
랜덤의 경우 Math.random()을 사용해도 되지만 Random 클래스를 사용하면 더욱 다양한 랜덤값을 구할 수 있습니다.
참고로 Math.random()도 내부에서는 Random 클래스를 사용합니다.

참고로 Random 클래스는 java.util 패키지 소속입니다.

package lang.math;

import java.util.Random;

public class RandomMain {

  public static void main(String[] args) {
    Random random = new Random();

    int randomInt = random.nextInt();
    System.out.println("randomIntL " + randomInt);

    double randomDouble = random.nextDouble(); // 0.0d ~ 1.0d 사이값이 출력됨
    System.out.println("randomDouble: " + randomDouble);

    boolean randomBoolean = random.nextBoolean();
    System.out.println("randomBoolean: " + randomBoolean);

    // 범위 조회
    int randomRange1 = random.nextInt(10); // 0 ~ 9까지 출력
    System.out.println("0 ~ 9: " + randomRange1);

    int randomRange2 = random.nextInt(10) + 1; // 1 ~ 10까지 출력
    System.out.println("1 ~ 10: " + randomRange2);
  }
}


실행 결과
실행 결과는 항상 다르다.
randomIntL -1662566800
randomDouble: 0.14362030528813963
randomBoolean: false
0 ~ 9: 4
1 ~ 10: 10



  random.nextInt(): 랜덤 int 값을 반환합니다.
  nextDouble() : 0.0d ~ 1.0d 사이의 랜덤 double 값을 반환합니다.
  nextBoolean() : 랜덤 boolean 값을 반환합니다.
  nextInt(int bound): 0 ~ bound 미만의 숫자를 랜덤으로 반환합니다. 예를 들어서 3을 입력하면 0, 1, 2를 반환합니다.


1부터 특정 숫자의 int 범위를 구하는 경우 nextInt(int bound)의 결과에 +1을 하면 됩니다.

씨드 - Seed
랜덤은 내부에서 씨드(Seed) 값을 사용해서 랜덤 값을 구합니다.
그런데 이 씨드 값이 같으면 항상 같은 결과가 출력됩니다.
// Random random = new Random();
Random random = new Random(1); // seed가 같으면 Random의 결과가 같다.


실행 결과
Seed가 같으면 실행 결과는 반복 실행해도 같습니다.
randomIntL -1155869325
randomDouble: 0.10047321632624884
randomBoolean: false
0 ~ 9: 4
1 ~ 10: 5


  new Random(): 생성자를 비워두면 내부에서 System.nanoTime()에 여러가지 복잡한 알고리즘을 섞어서 씨드값을 생성합니다.
    
      따라서 반복 실행해도 결과가 항상 달라집니다.
    
  
  new Random(int seed): 생성자에 씨드 값을 직접 전달할 수 있습니다. 씨드 값이 같으면 여러번 반복 실행해도 실행 결과가 같습니다.
    
      이렇게 씨드 값을 직접 사용하면 결과 값이 항상 같기 때문에 결과가 달라지는 랜덤 값을 구할 수 없습니다.
      하지만 결과가 고정되기 때문에 테스트 코드 같은 곳에서 같은 결과를 검증할 수 있습니다.
        
          참고로 마인크래프트 같은 게임은 게임을 시작할 때 지형을 랜덤으로 생성하는데, 같은 씨드값을 설정하면 같은 지형을 생성할 수 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-04-25-CISCandRISC.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-04-25-CISCandRISC.html"><h1 class="title_post">💾 [CS] CISC와 RISC</h1></a>
                        <a href="/2024/CS/2024-04-25-CISCandRISC.html" class="txt_post">
                            CISC와 RISC.

명령어 파이프라이닝과 슈퍼스칼라 기법을 실제로 CPU에 적용하려면 명령어가 파이프라이닝에 최적화되어 있어야 합니다.
쉽게 말해 CPU가 파이프라이닝과 슈퍼스칼라 기법을 효과적으로 사용하려면 CPU가 인출하고 해석하고 실행하는 명령어가 파이프라이닝 하기 쉽게 생겨야 합니다.


  ‘파이프라이닝 하기 쉬운 명령어’란 무엇일까요?
  명령어가 어떻게 생겨야 파이프라이닝에 유리할까요?
    
      이와 관련해 CPU의 언어인 ISA와 각기 다른 성격의 ISA를 기반으로 설계된 CISC와 RISC를 알아봅시다.
    
  


명령어 집합
세상에는 수많은 CPU 제조사들이 있고, CPU마다 규격과 기능 만듦새가 다 다릅니다.
그러므로 CPU가 이해하고 실행하는 명령어들이 다 똑같지 않습니다.

  물론 명령어의 기본적인 구조와 작동원리는 큰 틀에서 크게 벗어나지 않습니다.
    
      그러나 명령어의 세세한 생김새, 명령어로 할 수 있는 연산, 주소 지정 방식 등은 CPU마다 조금씩 차이가 있습니다.
    
  
  명령어 집합(instruction set) 또는 명령어 집합 구조(ISA: Instruction Set Architecture) : CPU가 이해할 수 있는 명령어들의 모음.
    
      CPU마다 ISA가 다를 수 있습니다.
    
  



  명령어 집합에 ‘구조’라는 단어가 붙은 이유는 CPU가 어떤 명령어를 이해하는지에 따라 컴퓨터 구조 및 설계 방식이 달라지기 때문입니다.


가령 인텔의 노트북 속 CPU는 x86 혹은 x86-64 ISA를 이해하고, 애플의 아이폰 속 CPU는 ARM ISA를 이해합니다.

  x86(x86-64)과 ARM은 다른 ISA이기 때문에 인텔 CPU를 사용하는 컴퓨터와 아이폰은 서로의 명령어를 이해할 수 없습니다.
    
      실행 파일은 명령어로 이루어져 있고 서로의 컴퓨터가 이해할 수 있는 명령어가 다르기 때문입니다.
    
  



  x86은 32비트용, x86-64는 64비트용 x86 ISA입니다.


어셈블리어는 명령어를 읽기 편하게 표현한 언어입니다.

  ISA가 다르다는 건 CPU가 이해할 수 있는 명령어가 다르다는 뜻입니다.
    
      명령어가 달라지면 어셈블리어도 달라집니다.
        
          다시 말해 같은 소스 코드로 만들어진 같은 프로그램이라 할지라도 ISA가 다르면 CPU가 이해할 수 있는 명령어도 어셈블리어도 달라진다는 것입니다.
        
      
    
  


예를 들어 보겠습니다.

  동일한 소스 코드를 작성하고 ISA가 다른 컴퓨터에서 어셈블리어로 컴파일하면 아래와 같은 결과를 얻을 수 있습니다.





  왼쪽은 x86-64 ISA, 오른쪽은 ARM ISA입니다.
    
      똑같은 코드로 만든 프로그램임에도 CPU가 이해하고 실행할 수 있는 명령어가 달라 어셈블리어도 다른 것을 알 수 있습니다.
      참고로 사용한 컴파일러에 따라서도 어셈블리어가 달라질 수 있는데, 위 예시에서는 gcc 11.2라는 동일한 컴파일러를 이용했습니다.
    
  


ISA가 같은 CPU끼리는 서로의 명령어를 이해할 수 있지만, ISA가 다르면 서로의 명령어를 이해하지 못합니다.

  이런 점에서 볼 때 ISA는 일종의 CPU의 언어인 샘입니다.


CPU가 이해하는 명령어들이 달라지면 비단 명령어의 생김새만 달라지는게 아닙니다

  ISA가 다르면 그에 따른 나비 효과로 많은 것이 달라집니다.
    
      제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법 등 많은 것이 달라집니다.
        
          그리고 이는 곧 CPU 하드웨어 설계에도 큰 영향을 미칩니다.
        
      
    
  


ISA는 CPU의 언어임과 동시에 CPU를 비롯한 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이라고도 볼 수 있습니다.

앞서 명령어 병렬 처리 기법들을 학습했습니다.

  이를 적용하기에 용이한 ISA가 있고, 그렇지 못한 ISA도 있습니다.
    
      다시 말해 명령어 파이프라인, 슈퍼스칼라, 비순차적 명령어 처리를 사용하기에 유리한 명령어 집합이 있고, 그렇지 못한 명령어 집합도 있습니다.
    
  


그렇다면 명령어 병렬 처리 기법들을 도입하기 유리한 ISA는 무엇일까요?

  이와 관련해 현대 ISA의 양대 산맥인 CISC와 RISC에 대해 알아보겠습니다.


CISC


  CISC(Complex Instruction Set Computer) : ‘복잡한 명령어 집합을 활용하는 컴퓨터’
    
      여기서 ‘컴퓨터’를 ‘CPU’라고 생각해도 좋습니다.
      이름 그대로 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식입니다.
      ISA의 한 종류로 소개한 x86, x86-64는 대표적인 CISC 기반의 ISA입니다.
      다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용합니다.
      메모리에 접근하는 주소 지정 방식도 다양해서 아주 특별한 상황에서만 사용되는 독특한 주소 지정 방식들도 있습니다.
        
          다양하고 강력한 명령어를 활용한다는 말은 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다는 것을 의미합니다.
        
      
    
  



  프로그램을 실행하는 명령어 수가 적다는 말은 ‘컴파일된 프로그램의 크기가 작다’는 것을 의미합니다.
같은 소스 코드를 컴파일해도 CPU마다 생성되는 실행 파일의 크기가 다를 수 있다는 것입니다.


이런 장점 덕분에 CISC는 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았습니다.

  ‘적은 수의 명령어만으로도 프로그램을 동작시킬 수 있다’는 점은 메모리 공간을 절약할 수 있다는 장점이기 때문입니다.


하지만 CISC에는 치명적인 단점이 있습니다.

  활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기와 실행되기까지의 시간이 일정하지 않습니다.
  그리고 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 쿨럭 주기를 필요로 합니다.
    
      이는 명령어 파이프라인을 구현하는 데에 큰 걸림돌이 됩니다.
    
  


명령어 파이프라인 기법을 위한 이상적인 명령어는 다음 그림과 같이 각 단계에 소요되는 시간이 (가급적 1 클럭으로) 동일해야 합니다.

  그래야 파이프라인이 마치 공장의 생산 라인처럼 결과를 내기 때문입니다.




하지만 CISC가 활용하는 명령어는 명령어 수행 시간이 길고 가지각색이기 때문에 파이프라인이 효율적으로 명령어를 처리할 수 없습니다.

  한마디로 규격화되지 않은 명령어가 파이프라이닝을 어렵게 만든 셈입니다.
    
      명령어 파이프라인이 제대로 동작하지 않는다는 것은 현대 CPU에서 아주 치명적인 약점입니다.
        
          현대 CPU에서 명령어 파이프라인은 높은 성능을 내기 위해 절대 놓쳐서는 안 되는 핵심 기술이기 때문입니다.
        
      
    
  




게다가 CISC가 복잡하고 다양한 명령어를 활용할 수 있다고는 하지만, 사실 대다수의 복잡한 명령어는 그 사용 빈도가 낮습니다.

1974년 IBM 연구소의 존 코크(John Cocke)는 CISC 명령어 집합 중 불과 20% 정도의 명령어가 사용된 전체 명령어의 80%가량을 차지한다는 것을 증명하기도 했습니다.

CISC 명령어 집합이 다양하고 복잡한 기능을 지원하지만 실제로는 자주 사용되는 명령어만 쓰였다는 것입니다.

정리하자면, CISC 명령어 집합은 복잡하고 다양한 기능을 제공하기에 적은 수의 명령으로 프로그램을 동작시키고 메모리를 절약할 수 있지만, 명령어의 규격화가 어려워 파이프라이닝이 어렵습니다.

그리고 대다수의 복잡한 명령어는 그 사용 빈도가 낮습니다.

이러한 이유로 CISC 기반 CPU는 성장에 한계가 있습니다.

RISC

CISC의 한계가 우리들에게 준 교훈은 크게 아래와 같습니다.


  빠른 처리를 위해 명령어 파이프라인을 십분 활용해야 한다. 원활한 파이프라이닝을 위해 ‘명령어 길이와 수행 시간이 짧고 규격화’되어 있어야 한다.
  어차피 자주 쓰이는 명령어만 줄곧 사용된다. 복잡한 기능을 지원하는 명령어를 추가하기보다는 ‘자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것’이 중요하다.


이런 원칙 하에 등장한 것이 RISC입니다.


  RISC(Reduced Instruction Set Computer) : 이름처럼 CISC에 비해 명령어의 종류가 적습니다. 그리고 CISC와는 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향합니다.
    
      즉, 고정 길이 명령어를 활용합니다.
    
  


명령어가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에 RISC 명령어 집합은 명령어 파이프라이닝에 최적화되어 있습니다.



그리고 RISC는 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할 만큼 메모리 접근을 단순화하고 최소화를 추구합니다.

  그렇기 때문에 CISC보다 주소 지정 방식의 종류가 적은 경우가 많습니다.



  이런 점에서 RISC를 load-store 구조라고 부르기도 합니다.


RISC는 메모리 접근을 단순화, 최소화하는 대신 레지스터를 적극적으로 활용합니다.

  그렇기에 CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많습니다.
    
      다만 사용 가능한 명령어 개수가 CISC보다 적기 때문에 RISC는 CISC보다 많은 명령으로 프로그램을 작동시킵니다.
    
  




키워드로 정리하는 핵심 포인트

  ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속입니다.
  CISC는 복잡하고 다양한 종류의 가변 길이 명령어 집합을 활용합니다.
  RISC는 단순하고 적은 종류의 고정 길이 명령어 집합을 활용합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/DataStructure/2024-04-23-DataStructure.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/DataStructure/2024-04-23-DataStructure.html"><h1 class="title_post">📦[DataStructure] 변수와 배열이 중요한 이유와 이진 탐색</h1></a>
                        <a href="/2024/DataStructure/2024-04-23-DataStructure.html" class="txt_post">
                            변수와 배열이 중요한 이유.
변수와 배열은 초급 프로그래밍 수업의 필수 요소이며, 그래서 재미없어 보일 수 있지만 컴퓨터 프로그래밍과 자료 구조의 근간을 제공하기 때문에 꼭 탐구해야 할 중요한 개념입니다.

  또 이런 개념은 알고리즘에 미치는 동적 자료 구조의 영향을 평가하는 기준을 제공합니다.


이진 탐색(binary search).
이진 탐색(binary search) 은 정렬된 리스트에서 특정 값을 빠르게 찾는 알고리즘입니다.

  이 알고리즘은 리스트를 반으로 나워서 목푯값이 어느 쪽 절반에 속하는지 결정하고, 나머지 절반은 버리면서 목푯값이 포함될 가능성이 있는 절반을 탐색하는 방식으로 동작합니다.


이 알고리즘의 구현 방법과 논리적 간결성은 컴퓨터 과학 입문 과목에 적합하기 때문에 거의 모든 컴퓨터 과학 교과서와 강의에서 이진 탐색 알고리즘을 다룹니다.

“정렬된 리스트에서 탐색하는 일이 얼마나 자주 있을까?” 혹은 더 구체적으로 “내 정렬된 리스트에서 탐색 함수를 직접 구현할 일이 얼마나 자주 있을까? 이미 수백만 명이 이 짓을 하지 않았나? 라이브러리에 있지 않은가?” 라고 생각할 수도 있습니다.

  하지만 언젠가 자신만의 이진 탐색이 필요할 가능성을 배제헤서는 안 되며, 이진 탐색의 진정한 중요성은 단순히 이진 탐색을 구현하는 일을 넘어섭니다.


이진 탐색은 똑똑한 알고리즘이 정렬된 데이터처럼 아주 단순한 자료 주고에서 조차 데이터가 저장되어 있는 구조를 활용해 상당한 계산 비용을 절약할 수 있음을 보여주는 예입니다.

  이진 탐색은 정확성과 효율성을 쉽게 분석할 수 있고 속도와 정확성 모두를 보장하며 데이터와 알고리즘의 상호 작용을 잘 보여줍니다.
    
      그렇기 때문에 이진 탐색은 연결 리스트, 배열, 그 외의 여러 트리 기반 알고리즘과 같은 데이터 저장 기법들의 차이점을 살펴보는 훌륭한 렌즈가 될 수 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/DataStructure/2024-04-23-DataStructure-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/DataStructure/2024-04-23-DataStructure-2.html"><h1 class="title_post">📦[DataStructure] 문제 정의와 선형 스캔</h1></a>
                        <a href="/2024/DataStructure/2024-04-23-DataStructure-2.html" class="txt_post">
                            문제 정의.

새로운 알고리즘을 정의하기 전에, 항상 그 알고리즘이 해결하려는 문제를 정의해야 합니다.

여기서는 리스트에서 주어진 목푯값과 일치하는 원소를 하나 찾을 수 있는 효율적인 알고리즘을 만들려고 합니다.

이 탐색 문제를 형식적으로 정의하면 다음과 같습니다.



일상생활에서는 이러한 작업을 ‘어떤 것을 찾아줘’ 라고 표현합니다.

  이 탐색 문제는 우리가 하루에도 몇 번씩 직면하는 문제입니다.
    
      사전에서 단어를 찾거나 연락처 목록에서 이름을 찾거나 역사적 사건 목록에서 특정 날짜를 찾거나 상품으로 꽉 찬 슈퍼마켓 선반에서 좋아하는 커피 브랜드를 찾는 경우 등이 있습니다.
        
          우리에게는 대상 목록과 목푯값의 일치 여부를 확인할 수 있는 방법이 필요합니다.
        
      
    
  


선형 스캔
이진 참색의 이점을 이해하기 위해 비교 대상을 제공하겠습니다.

더 간단한 알고리즘은 선형 스캔(linear scan) 부터 살펴봅시다.

  선형 스캔은 리스트에서 한 번에 하나씩 값을 목푯값을 찾거나 목록의 끝에 도달할 때까지 비교해 목푯값을 찾습니다.


수로 이뤄진 배열 A에서 목푯값을 찾으려 한다고 가정해봅시다.

  이 경우 target = 21을 사용합니다.
    
      배열의 각 상자 안에 든 값이 21과 같은지 반복해서 확인합니다.
        
          이 과정이 아래의 그림에 묘사되어 있습니다.
        
      
    
  




LinearScan(Array: A, Integer: target):
    Integer: i = 0
    WHILE i &lt; length(A):
        IF A[i] == target:
            return i
                i = i + 1
            return -1


위 코드는 선형 스캔 코드를 보여줍니다.

  이 코드는 일치하는 원소의 인덱스를 반환하고 탐색에 실패하면 원소가 없으므로 -1을 인덱스로 반환합니다.
    
      단일 WHILE 루프는 배열의 각 원소를 반복하고, 내부 IF 문은 인덱스에 해당하는 원소를 목푯값과 비교합니다.
        
          목푯값을 찾은 경우 즉시 해당 인덱스를 반환합니다.
            
              배열의 끝까지 확인한 경우 -1을 반환합니다.
            
          
        
      
    
  


선형 스캔은 멋지거나 똑똑하지 않습니다.

목표가 데이터에 있는지 찾기 위해 가능한 항목을 모두 확인하기 때문에 ‘무식한 검사’입니다.

  특히 원소가 아주 많은 리스트에서 비효율적입니다.


A의 자료 구조에 대해 아무것도 모르면 프로세스를 최적화할 수 있는 방법이 없습니다.

  목푯값이 모든 상자에 있을 수 있으므로 모든 상자를 확인해야 할 수도 있습니다.


선형 스캔의 한계를 보여주기 위해, 교실 바깥에 줄 서 있는 기초 프로그래밍 과목을 듣는 학생들 같은 물리적인 시퀀스에서 이러한 탐색을 수행한다고 상상해보자.

  특정 학생의 숙제를 반환하려는 교사는 각 학생에게 “이름이 제레미입니까?” 라고 묻고 다음 학생으로 이동할 수 있습니다.
    
      교사가 올바른 학생을 찾거나 줄 끝까지 이동하면 탐색이 중지됩니다.
        
          학생들은 교사가 비효율적이라고 생각하면서 궁시렁될 것 입니다.
        
      
    
  


때로 선형 탐색에서 각각의 비교를 더 빨리 할 수 있는 방법이 있는 경우가 가끔 있습니다.

  예를 들어, 복잡한 데이터가 문자열일 때는 앞서 올린 포스팅에서 설명한 것처럼 최초로 일치하지 않는 글자에서 비교를 멈춤으로써 비교에 걸리는 시간을 최적화할 수 있습니다.
    
      그러나 이런 최적화에도 한계가 있습니다.
        
          여전히 모든 원소를 하나씩 확인해야 하기 때문입니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/TIL/2024-04-22-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/TIL/2024-04-22-TIL.html"><h1 class="title_post">📝 [TIL] 240422 Today I Learned.</h1></a>
                        <a href="/2024/TIL/2024-04-22-TIL.html" class="txt_post">
                            자료구조


  삽입 정렬
  문자열


OS

  리눅스와 우분투의 차이점
  커널(Kernel)이란?


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/OS/2024-04-22-OS.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/os.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/OS/2024-04-22-OS.html"><h1 class="title_post">💻[Operating System] 리눅스와 우분투의 차이점</h1></a>
                        <a href="/2024/OS/2024-04-22-OS.html" class="txt_post">
                            리눅스와 우분투의 차이점.

“리눅스” 와 “우분투” 의 차이점을 이해하려면 먼저 리눅스가 무엇인지, 그리고 우분투가 어떻게 이와 관련되어 있는지를 알아야 합니다.

리눅스(Linux).

리눅스는 주로 운영 체제의 커널을 가리키는 용어입니다.

  커널은 하드웨어와 소프트웨어 컴포넌트 사이에서 통신을 중재하고, 시스템 리소스를 관리하는 핵심 소프트웨어 컴포넌트입니다.



  여기서 컴포넌트란 무엇일까요?
  
    “컴포넌트” 란 일반적으로 더 큰 시스템의 일부로 기능하는 개별적인 부품이나 요소를 의미합니다
      
        이 용어는 다양한 분야에서 사용되며, 각각의 맥락에 따라 다소 다른 의미를 가질 수 있습니다.
          
            이 포스팅에서는 소프트웨어 개발에서의 컴포넌트만 설명하겠습니다.
          
        
      
    
  

  소프트웨어 개발에서의 컴포넌트
  
    소프트웨어 개발에서는 컴포넌트가 소프트웨어의 모듈이나 라이브러리 형태로 존재할 수 있습니다.
      
        이런 컴포넌트들은 재사용 가능하며, 특정 기능을 수행하기 위해 독립적으로 개발되고 통합될 수 있습니다.
          
            예를 들어, 웹 애플리케이션에서 로그인 모듈, 검색 엔진, 사용자 인터페이스 요소 등이 각각의 컴포넌트로 구성될 수 있습니다.
          
        
      
    
  


리눅스 커널은 오픈 소스이며, 1991년 리누스 토발즈에 의해 처음 개발되었습니다.

  리눅스 커널 자체는 독립적으로 사용할 수 없으며, 보통 시스템 라이브러리, 유틸리티, 필수 프로그램 등과 함께 배포되어 전체 운영 체제의 기반을 형성합니다.


우분투(Ubuntu).

우분투는 리눅스 커널을 기반으로 한 리눅스 배포판 중 하나입니다.

  이는 사용자 친화적인 인터페이스, 풍부한 소프트웨어 저장소, 정기적인 업데이트 및 지원을 제공하며, 개인용 컴퓨터, 서버, 클라우드 등 다양한 완경에서 사용할 수 있습니다.
    
      우분투는 데비안(Debian) 리눅스 배포판을 기반으로 만들어졌으며, 쉽게 접근할 수 있고 설치 및 사용이 간편하다는 점에서 초보자에게 인기가 많습니다.
    
  


리눅스와 우분투의 주요 차이점.

1. 정의와 범위 : 리눅스는 커널의 이름이며, 우분투는 리눅스 커널을 포함한 전체 운영 체제의 한 배포판입니다.
2. 사용성 : 커널 자체는 기술적인 측면에서만 다루어지지만, 우분투는 끝 사용자를 대상으로 한 GUI와 사용자 친화적 도구를 제공합니다.
3. 목적 : 리눅스 커널은 다양한 운영 체제의 기반으로 사용됩니다. 반면, 우분투는 개인 사용자와 기업 환경 모두를 겨냥해 특정한 목적과 요구를 충족시키기 위해 개발되었습니다.

요약.
리눅스는 기술적인 컴포넌트(커널)를 지칭하고 우분투는 그 커널을 사용하여 만들어진 하나의 완성된 운영 체제 배포판 입니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/OS/2024-04-22-OS-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/os.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/OS/2024-04-22-OS-2.html"><h1 class="title_post">💻[Operating System] 커널(kernel)이란?</h1></a>
                        <a href="/2024/OS/2024-04-22-OS-2.html" class="txt_post">
                            커널(kernel)이란?

커널의 역할.
커널(kernel)은 컴퓨터 운영 체제의 핵심 구성 요소로서, 하드웨어와 소프트웨어 리소스 간의 통신을 중재하고 시스템의 모든 주요 기능을 관리하는 역할을 합니다.

커널의 기능.
커널의 기능은 매우 광범위하며, 그 중 몇 가지 주요 기능을 다음과 같이 설명할 수 있습니다.

1. 프로세스 관리.

  커널은 시스템에서 실행되는 모든 프로세스(활성 프로그램)의 생성, 실행 및 종료를 관리합니다.
    
      프로세스 관리는 프로세스 스케줄링, 상태 관리, 우선순위 할당 등을 포함합니다.
        
          이를 통해 시스템 리소스가 효율적으로 활용되고, 여러 프로세스 간에 시스템 리소스를 공정하게 분배할 수 있습니다.
        
      
    
  


2. 메모리 관리.

  커널은 시스템의 물리적 메모리(RAM)를 관리하고 각 프로그램에 필요한 메모리 공간을 할당 및 회수합니다.
    
      메모리 관리 기능은 메모리 보호, 메모리 할당, 가상 메모리 시스템을 포함하여, 프로그램이 안정적으로 실행될 수 있도록 지원합니다.
    
  


3. 디바이스 드라이버와 I/O 관리.

  커널은 하드웨어 디바이스와의 통신을 담당하는 디바이스 드라이버를 관리합니다.
    
      입력 및 출력(I/O)장치(예: 키보드, 마우스, 디스플레이, 저장 장치 등)에 대한 접근과 데이터 전송을 총괄하며, 하드웨어의 올바른 동작을 보장합니다.
    
  


4. 파일 시스템 관리.

  커널은 파일 시스템을 통해 데이터의 저장 및 검색을 관리합니다.
    
      이는 파일 생성, 삭제, 읽기, 쓰기 등의 작업을 포함하며, 사용자와 응용 프로그램이 파일과 디렉토리를 효율적으로 사용할 수 있도록 합니다.
    
  


5. 보안 및 접근 제어.

  커널은 시스템 보안을 유지하기 위해 사용자 권한 및 접근 제어를 관리합니다.
    
      이를 통해 사용자의 권한에 따라 리소스 접근을 제한하고, 시스템의 안전성을 유지합니다.
    
  


6. 네트워킹

  커널을 네트워크 통신을 관리하여, 컴퓨터가 네트워크를 통해 다른 시스템과 데이터를 교환할 수 있도록 지원합니다.


마무리.

  커널은 일반적으로 시스템의 가장 낮은 수준에서 실행되며, 운영 체제의 나머지 부분과 사용자 애플리케이션으로부터 분리되어 있습니다.
    
      이는 시스템의 핵심적인 부분을 안정적이고 효율적으로 관리할 수 있도록 하기 위함입니다.
    
  
  커널의 설계와 구현은 운영 체제의 성능, 안정성 및 확장성에 직접적인 영향을 미칩니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/DataStructure/2024-04-22-DataStructure.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/DataStructure/2024-04-22-DataStructure.html"><h1 class="title_post">📦[DataStructure] 삽입 정렬</h1></a>
                        <a href="/2024/DataStructure/2024-04-22-DataStructure.html" class="txt_post">
                            삽입 정렬.
배열 구조를 어떻게 사용할 수 있는지 이해하는 가장 좋은 방법은 실제 알고리즘을 검토하는 것입니다.

  삽입 정렬(insertion sort) 은 배열의 값을 정렬하는 알고리즘으로, 순서를 정할 수 있는 모든 유형의 값에서 작동합니다.
    
      정수, 문자열, 심지어 유통기한에 따라 저장된 창고 안 커피까지 삽입 정렬로 정렬할 수 있습니다.
    
  


삽입 정렬은 배열의 일부를 정렬하고, 이 정렬된 범위를 전체 배열이 정렬될 때까지 확장합니다.

  알고리즘은 정렬되지 않은 배열의 각 원소를 반복하면서 정렬된 부분의 올바른 위치로 이동합니다.


i의 반복을 시작하는 시점에 i-1 이하의 위치에 있는 원소는 모두 정렬되 있습니다.

  알고리즘은 이제 인덱스 i에 있는 원소를 선택하고, 정렬된 접두사에서 이 원소의 올바른 위치를 찾아 나머지 원소를 뒤로 이동시켜서 선택한 원소가 들어갈 공간을 만든 수 삽입합니다.
    
      그러면 정렬된 접두사가 하나 더 커지면서 0에서 i까지 모든 상자가 정렬된 상태가 됩니다.
        
          처음에는 첫 번째 원소를 초기 정렬된 접두사로 선언하고 i = 1부터 반복을 시작할 수 있습니다.
        
      
    
  


커피 컬렉션을 신선도순으로 정렬하고 싶다고 합시다.

무엇보다 프리미엄 커피가 창고 깊숙이 박혀 있다 상해버리는 비극은 바람직하지 않습니다.

  따라서 유통기한이 제일 짧게 남은 커피를 가장 앞쪽에 넣어서 쉽게 접근할 수 있게 해야합니다.


우선 커피백 하나를 정렬된 부분으로 선언하고, 이를 기준으로 정렬 범위를 설정함으로써 커피 정렬을 시작합니다.

  그 다음에는 가장 앞쪽에서 두 번째 백부터 날짜를 비교해 정렬된 부분의 백보다 더 앞에 넣어야 할지를 판단합니다.
    
      위치를 바꿀 필요가 있는 경우엔 순서를 바꾸고, 그렇지 않은 경우엔 자리를 유지합니다.
        
          이제 자신 있게 맨 앞의 두 백이 정렬됐다고 말할 수 있습니다.
        
      
    
  


이렇게 부분적으로 정렬하는 과정을 마지막 백까지 진행하면서 위치를 바꾸는 작업을 반복하면, 커피 컬렉션을 완벽하게 정리할 수 있습니다.

아래 코드와 같이 중첩된 루프를 이용해 삽입 정렬을 구현할 수 있습니다.

InsertionSort(array: A):
    Integer: N = length(A)
    Integer: i = 1
    WHILE i &lt; N: // 1
        Type: current = A[i]
        Integer: j = i - 1
            WHILE j &gt;= 0 AND A[j] &gt; current: // 2
                A[j + 1] = A[j]
                j = j - 1
            A[j + 1] = current
            i = i +1



  바깥쪽 루프는 최초의 정렬되지 않은 원소인 인덱스 i가 1인 원소부터 시작하고 정렬되지 않은 범위에 있는 각 값을 반복합니다(1)
    
      안쪽 루프는 인덱스 j를 사용해 정렬된 접두사의 원소를 맨 뒤에서부터 하나씩 반복합니다(2)
        
          반복 각 단계에서 현재 값과 정렬된 접두사 안에 있는 인덱스 j의 값을 비교해 확인합니다.
          j에 있는 원소가 더 크면 두 값의 순서가 잘못됐으므로 교환해야 합니다.
          현재 값을 별도의 변수인 current에 저장했기 때문에 이전 상자에서 데이터를 직접 복사합니다.
            
              즉, i번째와 j번째의 값을 완전히 교환할 필요가 없습니다.
              내부 루프는 현재 값을 배열의 맨 앞에 밀어넣거나 현재 값보다 이전 값이 더 작을 때까지만(이 경우가 바로 현재 값이 정렬된 접두사의 올바른 위치에 있음을 나타냅니다.) 계속 진행합니다.
                
                  이제 내부 루프의 끝에서 현재 값을 올바른 위치에 쓰기만 하면 됩니다.
                  바깥쪽 루프는 다음 정렬되지 않은 값으로 진행합니다.
                
              
            
          
        
      
    
  


아래 그림은 알고리즘이 어떻게 동작하는지 시각화해 보여줍니다.




  각 줄은 반복 시작 시 배열의 상태를 보여줍니다.
    
      빨간색 상자는 현재 위치에 있는 원소를 나타내며, 화살표는 현재 위치의 원소를 삽입하면서 발생하는 이동을 나타냅니다.
    
  


삽입 정렬은 그렇게 효율적이지 않습니다.

  배열에 원소를 삽입할 때, 상당 부분을 이동해야 할 수도 있습니다.
  최악의 경우(worst-case), 알고리즘의 비용은 시퀀스 원소 수의 제곱에 비례합니다.
    
      즉, 최악의 경우 리스트의 모든 원소마다 앞의 모든 원소를 이동해야합니다.
        
          배열의 크기를 2배로 늘리면, 최악의 경우 비용이 4배 증가합니다.
        
      
    
  


그럼에도 불구하고 삽입 정렬은 배열이 어떻게 작동하는지 중요한 통찰을 제공합니다.

이 간단한 알고리즘은 인덱스를 사용해 원소레 직접 접근할 수 있어야 하며, 새 원소를 삽입할 때 값을 교환할 수 있어야 하며, 모든 원소를 반복(iteration)할 수 있어야 한다는 배열의 여러 특성을 보여줍니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/DataStructure/2024-04-22-DataStructure-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/DataStructure/2024-04-22-DataStructure-2.html"><h1 class="title_post">📦[DataStructure] 문자열</h1></a>
                        <a href="/2024/DataStructure/2024-04-22-DataStructure-2.html" class="txt_post">
                            문자열(String) 은 종종 특수한 종류의 배열로 생각할 수 있는, 순서가 지정된 문자의 리스트다.

문자열의 각 칸에는 문자, 숫자, 기호, 공뱁 또는 제한된 특수 기호 중 하나가 포함됩니다.

  마지막 칸에 있는 특수 기호 /는 종종 문자열의 끝을 나타냅니다.


인덱스를 사용해 문자열의 문자에 직접 접근할 수 있습니다.



일부 프로그래밍 언어에서는 문자열을 그냥 문자 배열로 직접 구현합니다.

몇몇 다른 언어에서는 문자열이 객체일 수 있으며, 문자열 클래스는 문자를 담고 있는 배열이나 다른 자료 구조를 감싼 래퍼(wrapper) 클래스 역할을 합니다.

  문자열 래퍼 크래스는 문자열의 크기를 동적으로 조정하거나 부분 문자열을 탐색하는 등 추가 기능을 제공합니다.
    
      두 경우 모두 일반 배열과 유사한 구조가 문장열에 대한 작업에 어떤 영향을 미칠지 생각해보는 것이 유용합니다.
    
  


컴퓨터 화면에 문자열을 표시할 때는 문자열의 각 문자를 반복하면서 하나씩 문자를 표시합니다.

동등성(equality) 검사는 더 흥미롭습니다.

  한 번의 연산으로 직접 비교할 수 있는 정수와 달리, 문자열은 각 문자를 반복하면서 비교해야 합니다.
    
      두 문자열을 비교할 때는 서로 일치하지 않는 문자를 발견할 때까지 두 문자열에서 같은 위치에 존재하는 문자를 서로 비교합니다.
    
  


아래의 코드는 두 문자열의 동등성을 확인하는 알고리즘을 보여줍니다.
StringEqual(String: str1, String: str2):
    IF length(str1) != length(str2):
        return False
    Integer: N = length(str1)
    Integer: i = 0
    WHILE i &lt; N AND str1[i] == str2[i]:
        i = i + 1
    return i == N



  알고리즘은 먼저 문자열의 크기를 비교합니다.
    
      길이가 다르면 알고리즘은 해당 시점에 중지됩니다.
      길이가 같으면 알고리즘은 각 위치를 반복하면서 해당 위치에 있는 두 문자를 비교합니다.
        
          이때 두 문자가 서로 일치하지 않으면 루프를 중지할 수 있습니다.
            
              문자열을 모두 비교했는데 불일치가 일어나지 않았다면 두 문자열을 같다고 선언할 수 있습니다.
            
          
        
      
    
  


아래의 그림은 이 알고리즘이 두 문자열에 대해 어떻게 작동하는지 보여줍니다. =는 비교할 때 서로 일치한 문자 쌍을 나타냅니다.



  X는 최초 불일치로 인해 검사가 종료된 문자쌍을 나타냅니다.


문자열 비교에서 최악의 경우 계산 비용은 문자열의 길잉 비례해 증가합니다.

  두 작은 문자열을 비교하는 작업에서는 무시할 수 있지만, 두 긴 문자열을 비교하는 작업에서는 시간이 오래 걸릴 수 있습니다.
    
      예를 들어, 어떤 책의 1판과 2판을 처음부터 한 글자씩 비교하면서 두 책의 본문 문자 배열의 차이를 찾는 지겨운 과정을 상상해볼 수 있습니다.
        
          가장 좋은 경우에는 초기에 일치하지 않는 부분을 찾을 수 있지만, 최악의 경우에는 책의 대부분을 검사해야 합니다.
        
      
    
  


많은 프로그래밍 언어, 예를 들어 파이썬과 같은 언어는 직접 비교할 수 있는 문자열 클래스를 제공합니다.

  따라서 위 코드와 같은 비교 코드를 직접 구현할 필요가 없습니다.
    
      그러나 간단한 비교 함수의 뒤에는 모든 문자를 반복하는 루프가 있습니다.
        
          이 중요한 세부 사항을 이해하지 않으면 문자열 비교 비용을 과소평가할 수 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/DataStructure/2024-04-21-DataStructure3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/DataStructure/2024-04-21-DataStructure3.html"><h1 class="title_post">📦[DataStructure] 배열</h1></a>
                        <a href="/2024/DataStructure/2024-04-21-DataStructure3.html" class="txt_post">
                            배열.
일반적으로 배열(array) 은 관련된 다수의 값을 저장할 때 사용합니다.

예를 들어, 1년간 매일 마신 커피의 양을 추적하고 싶다고 합시다.

  이때 개별 변수(AmountDay1, AmountDay2, AmountDay3 등)를 365개 만들어서 저장할 수 있겠지만, 이 방식은 입력하기도 귀찮고 데이터를 어떤 구조로도 사용할 수 없습니다.
    
      AmountDay2는 단지 텍스트 꼬리표일 뿐이며, AmountDay2 전날의 정보를 AmountDay1이 저장하고 AmountDay2 다음 날의 정보를 AmountDay3가 저장한다는 사실을 프로그램이 알 수 없습니다.
        
          개발자만 이 정보를 알고 있습니다.
        
      
    
  


배열은 여러 값을 연속적으로 인데스(Index) 가 부여된 상자에 저장하는 간단한 메커니즘을 제공합니다.

아래의 그림처럼 배열은 사실 개별 변수들을 한 줄로 세워둔 것이며, 컴퓨터 메모리에 존재하는 같은 크기의 상자들이 연속적으로 배치된 블록입니다.




  개별 변수처럼 배열도 어떤 메모리 덩어리를 차지하며 임의의 다른 정보와 인접할 수 있습니다.
  배열의 각 상자에는 숫자, 문자, 포인터 또는 다른(크기가 정해져 있는) 자료 구조와 같은 타입의 값을 저장할 수 있습니다.


일상생활에서도 배열을 매우 많이 사용합니다.

  예를 들어, 고등학교 복도에 늘어선 사물함은 학생들의 책과 외투를 저장하는 물리적인 배열입니다.
    
      우리는 개별 사물함을 열어 내부 공간에 쉽게 접근할 수 있습니다.
    
  


배열의 구조는 위치(또는 인덱스)를 지정하여 배열 내 개별 값, 즉 원소(element) 에 접근할 수 있게 해줍니다.

  배열 내 상자들은 컴퓨터 메모리에서 서로 인접해 있으므로, 첫 번째 원소로부터 오프셋(offset)을 계산해서 해당하는 위치의 메모리를 읽는 방식으로 각 상자에 쉽게 접근할 수 있습니다.
    
      이는 접근하려는 상자의 위치와 관계없이 덧셈 한 번과 메모리 접근만 필요하다는 뜻입니다.
        
          이러한 구조는 우리의 일일 커피 섭취량을 추적하는 것과 같이 순서가 있는 항목을 저장할 때 특히 편리합니다.
        
      
    
  


형식적으로 배열 A에서 인덱스 i에 있는 값을 A[i]로 참조합니다.

  사물함 예제에서 인덱스는 사물함 앞에 표시된 숫자에 해당합니다.


대부분의 프로그래밍 언어는 0부터 시작하는(zero based) 인덱스를 사용합니다.

  이 말은 아래의 그림처럼 배열의 첫 번째 값은 인덱스 0, 두 번째 값은 인덱스 1, …에 위치한다는 뜻입니다.




아래 그림은 컴퓨터 메모리 안 배열 모습을 보여줍니다.

  여기서 흰 칸이 배열 원소에 해당합니다.



0을 기준으로 인덱싱하면 메모리 내에서 배열의 시작점부터 오프셋을 사용해 위치를 계산할 때 편리합니다.

i번째 원소의 위치는 다음과 같이 계산할 수 있습니다.
위치(인덱스 i의 원소) = 위치(배열 시작) + 각 원소의 크기 x i


인덱스 0의 위치는 배열 시작점과 같습니다.

  예를 들어, 위 그림에서 배열 A의 다섯 번째 원소는 A[4]이며 그림 1-4를 찾아보면 그 위치에는 9라는 값이 들어 있습니다.



  노트
인덱스를 1부터 시작하는 것도 가능하며, 일부 프로그래밍 언어는 이 규칙을 따릅니다.
1을 기준으로 인덱싱하는 경우 상자의 주소를 계산하는 식은 다음과 같습니다.
  위치(인덱스 i의 원소) = 위치(배열 시작) + 각 원소의 크기 x (i-1)
  


대부분의 프로그래밍 언어에서는 배열 이름과 인덱스를 조합해 값을 가져오거나 설정합니다.

  예를 들어, 다음과 같이 인덱스가 5인 상자의 값을 16으로 설정할 수 있습니다.


A[5] = 16


커피 추적 예제에서 하루 동안 섭취한 커피 컵 수를 저장하기 위해 Amount라는 배열을 정의하고, 해당 수량을 Amount[0] 부터 Amount[364]까지 저장할 수 있습니다.

  배열을 사용하면 단 하나의 이름으로 365개 다른 값에 순서대로 접근 할 수 있는데, 이름은 비슷하지만 서로 독립적인 변수들을 연속적으로 위치시켰던 것을 수학적인 오프셋으로 전환한 것입니다.


이 개념의 장점을 이해하려면 학교 사물함을 생각하면 됩니다.

  개별 사물함을 ‘제레미의 사물함’이나 ‘K로 시작하는 세 번째 학생의 사물함’처럼 이름 붙이면 빠르게 찾기가 거의 불가능합니다.
    
      이런 방식을 사용하면 그냥 인덱스를 사용하는 경우와 달리 모든 사물함에 붙은 꼬리표를 일일이 찾아봐야 합니다.
    
  


하지만 배열 인덱스를 사용하면 학생들은 오프셋을 사용해 사물함이 어디 있는지 결정하고 직접 해당 사물함에 접근할 수 있습니다.

종종 배열을 전체 자료 구조로 시각화하고 논의하지만, 각 상자가 개별 변수처럼 작동한다는 사실을 기억하는 것이 중요합니다.

  배열을 전체적으로 바꾸려면 모든 상자를 하나하나 바꿔야 합니다.
    
      예를 들어, 원소를 한 칸 앞으로 이동시키고 싶으면 아래 그림처럼 해야 합니다.

    
  


배열은 책장에 꽂혀 있는 책들과 다릅니다.

  ‘커피 애호가를 위한 최고의 공정 무역 커피 가이드’를 끼워넣기 위해 책 컬렉션 전체를 밀어낼 수 있지만, 배열을 그렇지 않습니다.


배열은 오히려 일렬로 늘어선 가게와 같습니다.

  서점과 미용실 사이에 커피숍을 끼어넣을 수 없습니다.
    
      커피숍 공간을 확보하려면 인접한 건물로 서점(또는 미용실)을 이전해서 기존 공간을 비우는 방식으로 가게를 하나씩 옮겨야만 합니다.
    
  


실제로 배열에서 단순히 두 값을 교환하고 싶은 경우에도 값들을 미묘하게 조정해야 합니다.

  예를 들어, 어떤 인덱스 i와 j에 있는 두 값을 교환하려면 먼저 둘 중 하나를 임시 변수에 할당해야 합니다.
    Temp = A[i]
A[i] = A[j]
A[j] = Temp
    
  
  그렇지 않으면 어떤 한 상자 안 값을 덮어쓰게 되어 두 상자가 동일한 값을 가지게 됩니다.


마찬가지로 커피숍과 서점의 위치를 바꾸려고 한다면, 먼저 서점의 가구와 물품 등을 비어 있는 세 번째 임시 위치로 커피숍의 것들을 넣을 수 있는 공간을 확보해야 합니다.

  그 후 커피숍을 옮길 수 있고, 서점의 가구와 물품 등을 세 번째 임시 위치에서 커피숍의 이전 위치로 옮길 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/DataStructure/2024-04-21-DataStructure2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/DataStructure/2024-04-21-DataStructure2.html"><h1 class="title_post">📦[DataStructure] 복합 자료 구조</h1></a>
                        <a href="/2024/DataStructure/2024-04-21-DataStructure2.html" class="txt_post">
                            복합 자료 구조.
다양한 프로그래밍 언어가 복합(composite) 자료 구조를 만들 수 있는 기능을 제공합니다.

예를 들어, 여러 개별 변수를 한 그룹으로 엮은 구조체(struct)나 객체(object)가 복합 자료 구조에 속합니다.

  복합 자료 구조는 관련있는 데이터 조각을 한데 모아서 한꺼번에 전달할 수 있는 손쉬운 방법을 제공합니다.
    
      예를 들어, 우리가 시음한 커피 종류에 대한 정보를 모은 CoffeeRecord를 정의할 수 있습니다.
    
  


CoffeeRecord {
    String: Name
    String: Brand
    Integer: Rating
    Float: Cost_Per_Pound
    Boolean: Is_Dark_Roast
    String: Other_Notes
}



  커피의 속성을 추적하기 위해 변수 여섯 개를 따로따로 유지하는 대신, 모든 정보를 하나의 복합 자료 구조 CoffeeRecord에 저장합니다.


속성이 추가되면 복합 자료 구조를 사용하는 것이 더 중요해집니다.

  복합 자료 구조가 없다면 수백 개의 관련 변수를 전달하는 방식으로 처리해야 하는데, 이는 변수를 잘못된 순서로 함수에 전달하는 등 프로그래머의 실수를 야기할 가능성도 더 높습니다.


자바(Java)나 파이썬(Python)을 비롯한 많은 프로그래밍 언어에서, 복합 데이터는 자신의 데이터와 작동에 대한 함수를 모두 포함하는 ‘객체(object)’가 될 수 있습니다.

객체의 함수는 파이썬의 self 참조처럼 특별한 구문을 사용해 해당 객체 자신의 데이터에 접급합니다.

객체는 내부 데이터를 객체 외부에서 공객적으로 접근하도록 허용할지 아니면 비공개적으로 객체 내부 함수에서만 접근하게 할지를 지정하는 가시성(visibility) 규칙을 제공할 수 있습니다.

복합 자료 구조나 객체를 사용하는 코드에서는 다음 예제처럼 ‘변수이름.필드이름’ 이라는 구문을 사용해 복합 자료 구조의 필드에 접근합니다.

last_record.name = "Sublime Blend"


  이 코드는 커피 기록에 있는 lastest_record 레코드의 name 필드를 Sublime Blend로 설정합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/DataStructure/2024-04-21-DataStructure.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/DataStructure/2024-04-21-DataStructure.html"><h1 class="title_post">📦[DataStructure] 변수</h1></a>
                        <a href="/2024/DataStructure/2024-04-21-DataStructure.html" class="txt_post">
                            변수.

개변 데이터 조각을 종종 변수(variable)에 저장하곤 합니다.


  변수(variable) : 컴퓨터 메모리 내 데이터 위치(또는 주소)를 표현하는 이름입니다.
    
      프로그램 실행 중 변경되는 정보를 추적할 수 있게 합니다.
        
          예를 들어 For 루프를 몇 번지나갔는지 세어야 할 경우, 게임에서 플레이어의 점수를 추적해야하는 경우 등
        
      
    
  


변수가 없으면 프로그램의 내부 상태를 추적, 평가(evaluate), 변경(update)할 수 없습니다.

  변수를 생성하면 시스템이 그것을 자동으로 할당하고 위치를 지정합니다.
    
      그리고 나서 원하는 변수 이름을 사용해 자유롭게 해당 위치에 데이터를 쓰고, 데이터를 쓸 때 사용한 변수 이름을 사용해 저장된 데이터를 읽을 수 있습니다.
    
  


변수 이름만 알고 있다면 데이터의 메모리 위치를 알 필요가 없습니다.

컴퓨터 메모리를 여러 상자가 일렬로 늘어선 것처럼 생각할 수도 있습니다.

  각 변수는 저장한 데이터의 크기에 따라 하나 이상의 인접한 상자를 차지합니다.


아래 그림은 Level, Score, AveScore라는 세 변수를 보여줍니다.




  여기서 평균 점수(AveScore)는 메모리 상자를 두 개 사용하는 부동 소수점 수(floating point number, 소수점이 있는 숫자)입니다.


어떤 측면에서 변수는 종이 문서를 담는 폴더에 붙은 종이 라벨과 비슷합니다.

아래 그림처럼 라벨을 붙인 후에는 폴더의 순서나 정확한 위치를 기억할 필요가 없습니다.

  그 이유는 라벨로 폴더를 찾으면 되기 때문입니다.
    
      이때 충분한 정보가 포함된 이름을 사용하는 것이 중요합니다.
        
          만약에 파일 캐비닛에 할 일, 중요한 일, 다른 할 일, 그 밖의 일과 같이 이름이 겹치는(이를 오버로드(overload)라고 말합니다) 폴더가 많을 경우 내용을 파악하기 어렵습니다.
            
              마찬가지로, 변수의 이름이 모호하면 변수가 어떤 값을 나타내는지 추측하기 어려워집니다.
            
          
        
      
    
  




많은 프로그래밍 언어에서 변수는 정수(integer), 부동 소수점 값(float), 불린 값(Boolean) 등과 같이 저장된 데이터의 타입과 연관이 있습니다.

  타입은 변수가 얼마나 많은 메모리를 차지하고 메모리에 저장된 내용을 어떻게 사용해야 하는지를 프로그램에 알려줍니다.
    
      예를 들어, 불린 변수는 제한된 범위의 값(즉, 참과 거짓)만 저장하며 적은 양의 메모리만 사용하는 경우가 많습니다.
      반면, 2배 정밀도(double-precision) 부동 소수점 수는 훨씬 더 크고 정확한 숫자를 저장하므로 여러 상자를 사용합니다.
    
  


타입을 정의하는 문법이나 타입을 명시적으로 정의해야만 하는지 여부는 프로그래밍 언어마다 다릅니다.

아래 예제를 봐봅시다.

예제에서는 변수를 명시할 때 언어와 무관한 &lt;타입&gt;: &lt;변수이름&gt;이라는 의사 코드(pseudocode) 형식을 사용합니다.

Integer: coffee_count = 5
Float: percentage_words_spelled_correctly = 21.0
Boolean: had_enough_coffee = False


가씀 Type이라는 타입이 지정된 변수도 있습니다.

  이 타입은 어떻게 구현하는지에 따라 다양한 타입이 될 수 있다는 사실을 나타냅니다.
    
      대부분의 프로그래밍 언어에서 일반적으로 사용되는 구문을 사용해 변수를 다룰 것입니다.
    
  


예를 들어, 변수에 값을 대입할 때는 =을 사용합니다.
coffee_count = coffee_count + 1


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-04-19-DesignTechniquesForFastCPUs.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-04-19-DesignTechniquesForFastCPUs.html"><h1 class="title_post">💾 [CS] 빠른 CPU를 위한 설계 기법</h1></a>
                        <a href="/2024/CS/2024-04-19-DesignTechniquesForFastCPUs.html" class="txt_post">
                            빠른 CPU를 위한 설계 기법.

클럭
조금이라도 더 빠른 CPU를 만들려면 어떻게 CPU를 설계해야 할까요?

이전에 학습한 내용을 상기해봅시다.

  컴퓨터 부품들은 ‘클럭 신호’에 맞춰 일사분란하게 움직인다.
  CPU는 ‘명령어 사이클’이라는 정해진 흐름에 맞춰 명령어들을 실행한다.


클럭 신호가 빠르게 반복되면 CPU를 비롯한 컴퓨터 부품들은 그만큼 빠른 박자에 맞춰 움직일 것 입니다.

  즉, 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복할 것이고, 다른 부품들도 그에 발맞춰 더 빠르게 작동할 것입니다.


실제로 클럭 속도가 높은 CPU는 일반적으로 성능이 좋습니다.

  
    그래서 클럭 속도는 CPU 속도 단위로 간주되기도 합니다.
  
  
    클럭 속도: 헤르츠(Hz) 단위로 측정합니다. 이는 1초에 클럭이 몇 번 반복되는지를 나타냅니다.
    
      가령 클럭이 ‘똑-딱-‘하고 1초에 한 번 반복되면 CPU 클럭 속도는 1Hz인 것이고, 클럭이 1초에 100번 반복되면 CPU 클럭 속도는 100Hz인 셈입니다.
    
  




실제 CPU 클럭 속도는 위 사진 속 CPU를 보면 알 수 있습니다.

  위 사진 속 CPU를 보면 기본 속도(Base)는 2.5GHz, 최대 속도(Max)는 4.9GHz라는 것을 알 수 있습니다.
    
      이는 1초에 클럭이 기본적으로 25억(2.5 x 10⁹)번 반복된다는 것을 나타냅니다.
        
          참고: 1GHz는 1,000,000,000(10⁹)Hz입니다.
        
      
    
  



  “클럭 속도는 일정하지 않다.”
‘클럭’이라는 단어만 보고 시계를 떠올려 클럭 속도가 매번 일정하게 유지된다고 생각할 수도 있지만, 실제로는 그렇지 않습니다.

  CPU 사진을 다시 보면 기본 클럭 속도(Base)와 최대 속도(Max)로 나위어 있습니다.
이처럼 CPU는 계속 일정한 클럭 속도를 유지하기보다는 고성능을 요하는 순간에는 순간적으로 쿨럭 속도를 높이고, 그렇지 않을 때는 유연하게 쿨럭 속도를 낮추기도 합니다.
최대 클럭 속도를 강제로 더 끌어올릴 수도 있는데, 이런 기법을 오버클럭킹(overclocking) 이라고 합니다.


클럭 속도를 무지막지하게 높이면 CPU는 무작정 빨라지지 않습니다.

  그래픽이 많이 요구되는 게임이나 영상 편집과 같이 CPU에 무리가 가는 작업을 장시간 하면 컴퓨터가 뜨겁게 달아오르는 것을 경험해 본 적이 있을 겁니다.
    
      클럭 속도를 무작정 높이면 이러한 발열 문제가 더 심각해집니다.
        
          이처럼 클럭 속도를 높이는 것은 분명 CPU를 빠르게 만들지만, 클럭 속도만으로 CPU의 성늘을 올리는 것에는 한계가 있습니다.
        
      
    
  


코어와 멀티 코어
클럭 속도를 높이는 방법 외에 CPU의 성능을 높이는 방법에는 대표적으로 CPU의 코어와 스레드 수를 늘리는 방법이 있습니다.

먼저 코어를 늘리는 방법을 알아봅시다.

코어를 이해하려면 현대적인 관점에서 CPU라는 용어를 재해석해야 합니다.

앞서 CPU를 ‘명령어를 실행하는 부품’이라고 소개했습니다.
많은 전공 서적들의 전통적인 관점에서 ‘명령어를 실행하는 부품’은 원칙적으로 하나만 존재했습니다.
하지만 오늘날 CPU는 많은 기술적 발전을 거듭하였고, 그 결과 CPU 내부에는 ‘명령어를 실행하는 부품’을 얼마든지 만들 수 있게 되었습니다.

우리가 지금까지 CPU의 정의로 알고 있었던 ‘명령어를 실행하는 부품’은 오늘날 코어(core) 라는 용어로 사용됩니다.

  다시 말해, 오늘날의 CPU는 단순히 ‘명령어를 실행하는 부품’에서 ‘명령어를 실행하는 부품을 여러 개 포함하는 부품’으로 명칭의 범위가 확장 되었습니다.
    
      예를 들어 8코어(Core) CPU는 ‘명령어를 실행하는 부품’을 여덟 개 포함하고 있다고 보면 됩니다.
    
  




코어를 여러 개 포함하고 있는 CPU를 멀티코어(multi-core) CPU 또는 멀티코어 프로세서라고 부릅니다.

  이는 CPU 내에 명령어를 처리하는 일꾼이 여러 명 있는 것과 같습니다.
  당연히 멀티코어의 처리 속도는 단일코어보다 더 빠릅니다.
    
      다령 클럭 속도가 2.4GHz인 단일 코어 CPU와 클럭 속도가 1.9GHz인 멀티코어 CPU를 비교하면 일반적으로 후자의 성능이 더 좋습니다.
    
  


CPU 종류는 CPU 안에 코어가 몇 개 포함되어 있는지에 따라 아래 표와 같이 싱글코어, 듀얼코어, 트리플코어 등으로 나뉩니다.



코어를 늘릴수록 연산 처리 속도도 빨라질까요?

  CPU의 연산 속도가 꼭 코어 수에 비례하여 증가하지는 않습니다.
    
      코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례하여 연산 속도가 증가하지 않습니다.
      또한 처리하고자 하는 작업량보다 코어 수가 지나치게 많아도 성능에는 크게 영향이 없습니다.
        
          중요한 것은 코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐이고 그에 따라서 연산 속도는 크게 달라집니다.
        
      
    
  


스레드와 멀티스레드

  스레드(thread): 사전적 의미는 ‘실행 흐름의 단위’입니다.
    
      하지만 이 정의를 활자 그대로 받아들이지 말고 더욱 엄밀하게 이해해야 합니다.
      CPU에서 사용되는 스레드와 프로그래밍에서 사용되는 스레드는 용례가 다르기 때문입니다.
    
  


스레드에는 CPU에서 사용되는 하드웨어적 스레드가 있고, 프로그램에서 사용되는 소프트웨어적 스레드가 있습니다.

하드웨어적 스레드
스레드를 하드웨어적으로 정의하면 ‘하나의 코어가 동시에 처리하는 명령어 단위’를 의미합니다.
CPU에서 사용하는 스레드라는 용어는 보통 CPU 입장에서 정의된 하드웨어적 스레드를 의미합니다.

하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 멀티스레드(multithread) 프로세서 또는 멀티스레드 CPU라고 합니다.


  하이퍼스레딩(hyper-threading): 인텔의 멀티스레드 기술을 의미합니다.
    
      인텔이 자신들의 멀티스레드 기술에 하이퍼스레딩이라는 명칭을 부여한 것입니다.
    
  


소프트웨어적 스레드
소프트웨어적으로 정의된 스레드는 ‘하나의 프로그램에서 독립적으로 실행되는 단위’를 의미합니다.

  프로그래밍 언어나 운영체제를 학습할 때 접하는 스레드는 보통 이렇게 소프트웨어적으로 정의된 스레드를 의미합니다.


하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수도 있지만, 프로그램의 여러 부분이 동시에 실행될 수도 있습니다.



가령 워드 프로세서 프로그램을 개발한다고 가정해봅시다.
그리고 아래의 기능이 동시에 수행되길 원한다고 해 봅시다.

  사용자로부터 입력받은 내용을 화면에 보여 주는 기능
  사용자가 입력한 내용이 맞춤법에 맞는지 검사하는 기능
  사용자가 입력한 내용을 수시로 저장하는 기능


이 기능들을 작동시키는 코드를 각각의 스레드로 만들면 동시에 실행할 수 있습니다.



정리하면, 스레드의 하드웨어적 정의는 ‘하나의 코어가 동시에 처리하는 명령어의 단위’를 의미하고, 소프트웨어적 정의는 ‘하나의 프로그램에서 독립적으로 실행되는 단위’를 의미합니다.

한 번에 하나씩 명령어를 처리하는 1코어 1스레드 CPU도 소프트웨어적 스레드를 수십 개 실행할 수 있습니다.
1 코어 1 스레드 CPU로도 프로그램의 여러 부분을 동시에 실행할 수 있습니다.

만약 스레드의 사전적 정의(실행 흐름의 단위)만을 암기한다면 ‘1코어 1스레드 CPU가 여러 스레드로 만들어진 프로그램을 실행할 수 있다’라는 말이 어려울 겁니다.

  이런 이유로 하드웨어적 스레드와 소프트웨어적 스레드는 구분하여 기억하는 것이 좋습니다.


멀티스레드 프로세서
하나의 코어로 여러 명령어를 동시에 처리하는 기술인 하드웨어적 스레드를 “멀티스레드 프로세서” 라고 합니다.

멀티스레드 프로세서는 하나의 코어로 여러 명령어를 동시에 처리하는 CPU라고 했었습니다. 어떨게 이런 일이 가능할까요?

  “멀티스레드 프로세서” 를 실제로 설계하는 일은 매우 복잡하지만, 가장 큰 핵심은 레지스터입니다.
    
      하나의 코어로 여러 명령어를 동시에 처리하도록 만들려면 프로그램 카운터, 스택 포인터, 메모리 버퍼 레지스터, 메모리 주소 레지스터와 같이 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러개 가지고 있으면 됩니다.
        
          가열 프로그램 카운터가 두 개 있다면 ‘메모리에서 가져올 명령어 주소’를 두 개 지정할 수 있을 것이고, 스택 포인터가 두 개 있다면 두 개의 스택을 관리할 수 있을것 입니다.
        
      
    
  


아래의 그림을 봅시다.

하나의 명령어를 실행하기 위해 꼭 필요한 레지스터들을 편의상 ‘레지스터 세트’라고 표기했습니다.

  레지스터 세트가 한 개인 CPU는 한 개의 명령어를 처리하기 위한 정보들을 기억할 뿐이지만, 레지스터 세트가 두 개인 CPU는 두 개의 명령어를 처리하기 위한 정보들을 기억할 수 있습니다.
    
      여기서 ALU와 제어장치가 두 개의 레지스터 세트에 저장된 명령어를 해석하고 실행하면 하나의 코어에서 두 개의 명령어가 동시에 실행됩니다.
    
  




하드웨어 스레드를 이용해 하나의 코어로도 여러 명령어를 동시에 처리할 수 있습니다.

  그러나 메모리 속 프로그램 입장에서 봤을 때 하드웨어 스레드는 마치 ‘한 번에 하나의 명령어를 처리하는 CPU’나 다름없습니다.
    
      가령 2코어 4스레드 CPU는 한 번에 네 개의 명령어를 처리할 수 있는데, 프로그램 입장에서 봤을 땐 한 번에 하나의 명령어를 처리하는 CPU가 네 개 있는 것처럼 보입니다.
        
          그래서 하드웨어 스레드를 논리 프로세서(logical processor) 라고 부르기도 합니다.
        
      
    
  




“코어” 는 명령어를 실행할 수 있는 ‘하드웨어 부품’이고, “스레드” 는 ‘명령어를 실행하는 단위’입니다.
“멀티코어 프로세서” 는 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU를 의미하고, “멀티스레드 프로세서” 는 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU를 의미합니다.

키워드로 정리하는 핵심 포인트

  클럭 속도가 높은 CPU는 빠르게 작동합니다.
  코어 란 CPU 내에서 명령어를 실행하는 부품입니다.
  멀티코어 프로세서란 여러 개의 코어를 포함하는 CPU를 말합니다.
  스레드에는 하드웨어적 스레드와 소프트웨어적 스레드가 있습니다.
  멀티스레드 프로세서란 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU를 말합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-19-SystemClass.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-19-SystemClass.html"><h1 class="title_post">☕️[Java] System 클래스</h1></a>
                        <a href="/2024/Java/2024-04-19-SystemClass.html" class="txt_post">
                            System 클래스
System 클래스는 시스템과 관련된 기본 기능들을 제공합니다.

package lang.system;

import java.util.Arrays;

public class SystemMain {

  public static void main(String[] args) {
    // 현재 시간(밀리초)를 가져옵니다.
    long currentTimeMillis = System.currentTimeMillis();
    System.out.println("currentTimeMillis = " + currentTimeMillis);

    // 현재 시간(나노초)를 가져옵니다.
    long currentTimeNano = System.nanoTime();
    System.out.println("currentTimeNano = " + currentTimeNano);

    // 환경 변수를 읽습니다.
    System.out.println("getenv = " + System.getenv());

    // 시스템 속성을 읽습니다.
    System.out.println("properties = " + System.getProperties());
    System.out.println("Java version = " + System.getProperty("java.version"));

    // 배열을 고속으로 복사합니다.
    char[] originalArray = { 'h', 'e', 'l', 'l', 'o' };
    char[] copiedArray = new char[5];
    System.arraycopy(originalArray, 0, copiedArray, 0, originalArray.length);

    // 배열 출력
    System.out.println("copiedArray = " + copiedArray);
    System.out.println("Arrays.toString = " + Arrays.toString(copiedArray));

    // 프로그램 종료
    System.exit(0);
  }
}


실행 결과
currentTimeMillis = 1713485140558

currentTimeNano = 694481339313708

getenv = {HOMEBREW_PREFIX=/opt/homebrew, MANPATH=/Users/kobe/.nvm/versions/node/v20.10.0/share/man:/opt/local/share/man:/opt/homebrew/share/man::, COMMAND_MODE=unix2003, INFOPATH=/opt/homebrew/share/info:...

properties = {java.specification.version=21, sun.jnu.encoding=UTF-8, java.class.path=/Users/kobe/Desktop/practiceJavaMidPart1/java-mid1/out/production/java-mid1, java.vm.vendor=Oracle Corporation, sun.arch.data.model=64, java.vendor....

Java version = 21.0.2

copiedArray = [C@77459877
Arrays.toString = [h, e, l, l, o]

Process finished with exit code 0



  표준 입력, 출력, 오류 스트림: System.in, System.out, System.err은 각각 표준 입력, 표준 출력, 표준 오류 스트림을 나타냅니다.
  시간 측정: System.currentTimeMillis()와 System.nanoTime()은 현재 시간을 밀리초 또는 나노초 단위로 제공합니다.
  환경 변수: System.getProperties()를 사용해 현재 시스템 속성을 얻거나 System.getProperty(Stringkey)로 특정 속성을 얻을 수 있습니다. 시스템 속성은 자바에서 사용하는 설정 값입니다.
  시스템 종료: System.exit(int status) 메서드는 프로그램을 종료하고, OS에 프로그램 종료의 상태 코드를 전달합니다.
    
      상태 코드0 : 정상 종료
      상태 코드 0이 아님: 오류나 예외적인 종료
    
  
  배열 고속 복사: System.arraycopy는 시스템 레벨에서 최적화된 메모리 복사 연산을 사용합니다. 직접 반복문을 사용해서 배열을 복사할 때 보다 수 배 이상 빠른 성능을 제공합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/TIL/2024-04-19-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/TIL/2024-04-19-TIL.html"><h1 class="title_post">📝 [TIL] 240419 Today I Learned.</h1></a>
                        <a href="/2024/TIL/2024-04-19-TIL.html" class="txt_post">
                            Java


  Java ‘Class 클래스’ 학습
  Java ‘Class 클래스’ 정리
  Java ‘System 클래스’ 학습
  Java ‘System 클래스’ 정리


CS


  ‘빠른 CPU를 위한 설계 기법’
  ‘명령어 병렬 처리 기법’


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-19-Class.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-19-Class.html"><h1 class="title_post">☕️[Java] Class 클래스</h1></a>
                        <a href="/2024/Java/2024-04-19-Class.html" class="txt_post">
                            Class 클래스.
자바에서 Class 클래스는 클래스의 정보(메타데이터)를 다루는데 사용됩니다.
Class 클래스를 통해 개발자는 실행 중인 자바 애플리케이션 내에서 필요한 클래스의 속성과 메소드에 대한 정보를 조회하고 조작할 수 있습니다.

Class 클래스의 주요 기능은 다음과 같습니다.

  타입 정보 얻기: 클래스의 이름, 슈퍼클래스, 인터페이스, 접근 제한자 등과 같은 정보를 조회할 수 있습니다.
  리플렉션: 클래스에 정의된 메소드, 필드, 생성자 등을 조회하고, 이들을 통해 객체 인스턴스를 생성하거나 메소드를 호출하는 등의 작업을 할 수 있습니다.
  동적 로딩과 생성: Class.forName() 메서드를 사용하여 클래스를 동적으로 로드하고, newInstance() 메서드를 통해 새로운 인스턴스를 생성할 수 있습니다.
  애노테이션 처리: 클래스에 적용된 애노테이션(annotation)을 조회하고 처리하는 기능을 제공합니다.


예를 들어, String.class는 String 클래스에 대한 Class 객체를 나타내며, 이를 통해 String 클래스에 대한 메타데이터를 조회하거나 조작할 수 있습니다.

다음 코드를 실행해봅시다.
package lang.clazz;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ClassMetaMain {

  public static void main(String[] args) throws Exception {
    // Class 조회
    Class clazz = String.class; // 1. 클래스에서 조회
    //Class clazz = new String().getClass(); // 2. 인스턴스에서 조회
    //Class clazz = Class.forName("java.lang.String"); // 3. 문자열로 조회

    // 모든 필드 출력
    Field[] fields = clazz.getDeclaredFields();
    for (Field field : fields) {
      System.out.println("field = " + field.getType() + " " + field.getName());
    }

    // 모든 메서드 출력
    Method[] methods = clazz.getDeclaredMethods();
    for (Method method : methods) {
      System.out.println("method = " + method);
    }

    // 상위 클래스 정보 출력
    System.out.println("Superclass: " + clazz.getSuperclass().getName());

    // 인터페이스 정보 출력
    Class[] interfaces = clazz.getInterfaces();
    for (Class i : interfaces) {
      System.out.println("Interface: = " + i.getName());
    }
  }
}


class vs clazz - class는 자바의 예약어입니다. 따라서 패키지명, 변수명으로 사용할 수 없습니다.
이런 이유로 자바 개발자들은 class 대신 clazz라는 이름을 관행으로 사용합니다.
clazz는 class와 유사하게 들리고, 이 단어가 class를 의미한다는 것을 쉽게 알 수 있습니다.

주의!
main() 옆에 throws Exception이 추가된 부분에 주의합시다. 이 코드가 없으면 컴파일 오류가 발생합니다.

실행 결과
field = class [B value
...
method = byte[] java.lang.String.value()
method = public boolean java.lang.String.equals(java.lang.Object)
...
Superclass: java.lang.Object
Interface: = java.io.Serializable
Interface: = java.lang.Comparable
...


Class 클래스는 다음과 같이 3가지 방법으로 조회할 수 있습니다.
Class clazz = String.class; // 1. 클래스에서 조회
Class clazz = new String().getClass(); // 2. 인스턴스에서 조회
Class clazz = Clazz.forName("java.lang.String"); // 3. 문자열로 조회


Class 클래스의 주요 기능

  getDeclaredFields(): 클래스의 모든 필드를 조회합니다.
  getDeclaredMethods(): 클래스의 모든 메서드를 조회합니다.
  getSuperclass(): 클래스의 부모 클래스를 조회합니다.
  getInterface(): 클래스의 인터페이스들을 조회합니다.


실행 결과를 보면 String 클래스의 다양한 정보를 확인할 수 있습니다.

클래스 생성하기
Class 클래스에는 클래스의 모든 정보가 들어있습니다. 이 정보를 기반으로 인스턴스를 생성하거나, 메서드를 호출하고, 필드의 값도 변경할 수 있습니다.

여기서는 간단하게 인스턴스를 생성해봅시다.

package lang.clazz;

public class ClassCreatMain {

  public static void main(String[] args) throws Exception {
    //Class helloClass = Hello.class;
    Class helloClass = Class.forName("lang.clazz.Hello");

    Hello hello = (Hello) helloClass.getDeclaredConstructor().newInstance();
    String result = hello.hello();
    System.out.println("result = " + result);
  }
}


실행 결과
result = hello!

getDeclaredConstructor().newInstance()

  getDeclaredConstructor() : 생성자를 선택합니다.
  newInstance() : 선택된 생성자를 기반으로 인스턴스를 생성합니다.


리플랙션 - reflection
Class를 사용하면 클래스의 메타 정보를 기반으로 클래스에 정의된 메소드, 필드, 생성자 등을 조회하고, 이들을 통해 객체 인스턴스를 생성하거나 메소드를 호출하는 작업을 할 수 있습니다.
이런 작업을 리플렉션이라고 합니다.
추가로 애노테이션 정보를 읽어서 특별한 기능을 수행할 수도 있습니다.
최신 프레임워크들은 이런 기능을 적극 활용합니다.
지금은 Class가 뭔지, 그리고 대략 어떤 기능들을 제공하는지만 알아두면 충분합니다.
지금은 리플랙션을 학습하는 것 보다 훨씬 더 중요한 기본기들을 학습해야 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-04-19-InstructionParallelProcessingTechnique.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-04-19-InstructionParallelProcessingTechnique.html"><h1 class="title_post">💾 [CS] 명령어 병렬 처리 기법</h1></a>
                        <a href="/2024/CS/2024-04-19-InstructionParallelProcessingTechnique.html" class="txt_post">
                            명령어 병렬 처리 기법

  
    명령어 병령 처리 기법(ILP: Instruction-Level Parallelism): 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 기법.
  
  
    대표적인 명령어 병렬 처리 기법
    
      명령어 파이프 라이닝
      슈퍼스칼라
      비순차적 명령어 처리
    
  


명령어 파이프라인
명령어 파이프라인을 이해하려면 하나의 명령어가 처리되는 전체 과정을 비슷한 시간 간격으로 나누어 보아야 합니다.

명령어 처리 과정을 클럭 단위로 나누어 보면 일반적으로 다음과 같이 나눌 수 있습니다.

  명령어 인출(Instruction Fetch)
  명령어 해석(Instruction Decode)
  명령어 실행(Execute Instruction)
  결과 저장(Write Back)



  참고: 이 단계가 정답은 아닙니다.
전공서에 따라 명령어 인출 -&gt; 명령어 실행으로 나누기도 하고, 
명령어 인출 -&gt; 명령어 해석 -&gt; 명령어 실행 -&gt; 메모리 접근 -&gt; 결과 저장으로 나누기도 합니다.


여기서 중요한 점은 같은 단계가 겹치지만 않는다면 CPU가 ‘각 단계를 동시에 실행할 수 있다’는 것입니다.

  예를 들어 CPU는 한 명령어를 ‘인출’하는 동안에 다른 명령어를 ‘실행’할 수 있고, 한 명령어가 ‘실행’되는 동안에 연산 결과를 ‘저장’할 수 있습니다.


이를 그림으로 표현하면 다음과 같습니다.

  t1에는 명령어 1, 2를 동시에 처리할 수 있고 t2에는 명령어 1,2,3을 동시에 처리할 수 있습니다.


이처럼 명령어를 겹처서 수행하면 명령어를 하나하나 실행하는 것보다 훨씬 더 효율적으로 처리할 수 있습니다.



이처럼 마치 공장 생산 라인과 같이 명령어들을 “명령어 파이프라인(instruction pipeline)” 에 넣고 동시에 처리하는 기법을 “명령어 파이프라이닝(instruction pipelining)” 이라고 합니다.

명령어 파이프라인을 사용하지 않고 모든 명령어를 순차적으로만 처리한다면 아래와 같이 처리했을것입니다.

  한눈에 봐도 명령어 파이프라이닝을 이용하는 것이 더 효율적임을 알 수 있습니다.




파이프라이닝이 높은 성능을 가져오기는 하지만, 특정 상황에서는 성능 향상에 실패하는 경우도 있습니다.

  이러한 상황을 파이프라인 위험(pipeline hazard) 이라고 부릅니다.


파이프라인 위험에는 크게 3가지가 있습니다.

  데이터 위험
  제어 위험
  구조적 위험


데이터 위험

  데이터 위험(data hazard) 은 명령어 간 ‘데이터 의존성’에 의해 발생합니다.
    
      모든 명령어를 동시에 처리할 수는 없습니다.
        
          어떤 명령어는 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우가 있습니다.
        
      
    
  


예를 들어 아래 두 명령어를 봅시다.

편의상 레지스터 이름을 R1, R2, R3, R4, R5라 하고 ‘왼쪽 레지스터에 오른쪽 결과를 저장하라’는 기호는 &lt;- 기호로 표기하겠습니다.

명령어 1: R1 &lt;- R2 + R3 // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1 레지스터에 저장
명령어 2: R4 &lt;- R1 + R5 // R1 레지스터 값과 R5 레지스터 값을 더한 값을 R4 레지스터에 저장


위의 경우 명령어 1을 수행해야만 명령어 2를 수행할 수 있습니다.

  즉, R1에 R2 + R3 결괏값이 저장되어야 명령어 2를 수행할 수 있습니다.
    
      만약 명령어 1 실행이 끝나기 전에 명령어 2를 인출하면 R1에 R2 + R3 결괏값이 저장되기 전에 R1 값을 읽어 들이므로 원치 않은 R1 값으로 명령어 2를 수행합니다.
        
          따라서 명령어 2는 명령어 1의 데이터에 의존적입니다.
            
              이처럼 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대호 작동하지 않는 것을 ‘데이터 위험’이라고 합니다.
            
          
        
      
    
  


제어 위험

  제어 위험(control hazard) 은 주로 분기 등으로 인한 ‘프로그램 카운터의 갑작스러운 변화’에 의해 발생합니다.
    
      기본적으로 프로그램 카운터는 ‘현재 실행 중인 명령어의 다음 주소’로 갱신됩니다.
        
          하지만 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들은 아무 쓸모가 없어집니다.
            
              이를 ‘제어 위험’이라고 합니다.
            
          
        
      
    
  





  참고: 참고로 이를 위해 사용하는 기술 중 하나가 분기 예측(branch prediction) 입니다.
분기 예측은 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술입니다.


구조적 위험

  구조적 위험(structural hazard) 은 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생합니다.
    
      구조적 위험은 자원 위험(resource hazard) 이라고도 부릅니다.
    
  


슈퍼스칼라

파이프라이닝은 단일 파이프라인으로도 구현이 가능하지만, 오늘날 대부분의 CPU에서는 여러 개의 파이프라인을 이용합니다.

  이처럼 CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 슈퍼스칼라(superscalar) 라고 합니다.




명령어 파이프라인을 하나만 두는 것이 마치 공장 생산 라인을 한 개 두는 것과 같다면, 슈퍼스칼라는 공장 생산 라인을 여러 개 두는 것과 같습니다.

슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서 또는 슈퍼스칼라 CPU라고 합니다.

  슈퍼스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수도 있어야 합니다.
    
      가령 멀티스레드 프로세서는 한 번에 여러 명령어를 인출하고, 해석하고, 실행할 수 있기 때문에 슈퍼스칼라 구조를 사용할 수 있습니다.
    
  


슈퍼스칼라 프로세서는 이론적으로 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라집니다.

  하지만 파이프라인 위험 등의 예상치 못한 문제가 있어 실제로는 반드시 파이프라인 개수에 비례하여 빨라지지는 않습니다.
    
      이 때문에 슈퍼스칼라 방식을 차용한 CPU는 파이프라인 위험을 방지하기 위해 고도로 설계되어야 합니다.
        
          여러 개의 파이프라인을 이용하면 하나의 파이프라인을 사용할 때 보다 데이터 위험, 제어 위험, 자원 위험을 피하기가 더욱 까다롭기 때문입니다.
        
      
    
  


비순차적 명령어 처리

  비순차적 명령어 처리(OoOE: Out-of-order execution): 보통 OoOE로 줄여 부릅니다. 이 기법은 많은 전공서에서 다루지 않지만, 오늘날 CPU 성능 향상에 크게 기여한 기법이자 대부분의 CPU가 차용하는 기법입니다.
    
      비순차적 명령어 처리 기법은 이름에서도 알 수 있듯 명령어들을 순차적으로 실행하지 않는 기법입니다. 명령어의 ‘합법적인 새치기’라고 볼 수 있습니다.
    
  


지금까지 설명했던 명령어 파이프라이닝, 슈퍼스칼라 기법은 모두 여러 명령어의 순차적인 처리를 상정한 방법이었습니다.

  프로그램을 위에서 아래로 차례차례 실행하는 방식이었습니다.
    
      하지만 파이프 라인 위험과 같은 예상치 못한 문제들로 인해 이따금씩 명령어는 곧바로 처리되지 못하기도 합니다.
      만약 모든 명령어를 순차적으로만 처리한다면 이런 예상치 못한 상황에서 명령어 파이프라인은 멈춰버리게 됩니다.
    
  


예를 들어 아래와 같은 명령어들로 이루어진 소스 코드가 있다고 해봅시다.

편의상 ‘메모리 N번지’는 M(N)으로. ‘메모리 N번지에 M을 저장하라’는 M(N) &lt;- M으로 표기하겠습니다.

1. M(100) &lt;- 1
2. M(101) &lt;- 2
3. M(103) &lt;- M(100) + M(101)
4. M(150) &lt;- 1
5. M(151) &lt;- 2
6. M(152) &lt;- 3


여기서 주목해야 할 점은 3번 명령어를 실행하기 위해서는 M(100) 값은 물론 M(101) 값이 결정되어야 하기에 1번과 2번 명령어 실행이 끝날 때까지 기다려야 한다는 점입니다.

이 명령어들을 순차적으로 실행되는 CPU로 실행하면 다음과 같습니다.
2번 명령어 실행이 끝날 때까지 3, 4, 5, 6번 명령어들은 기다립니다.



앞의 코드를 이루는 명령어들 중에 서로 데이터 의존성이 전혀 없는, 순서를 바꿔 처리해도 수행 결과에 영향을 미치지 않는 명령어들이 있습니다.

  가령 3번은 다음과 같이 뒤의 명령어와 순서를 바꾸어 실행해도 크게 문제될 것이 없습니다.




이렇게 순서를 바꿔 실행하면 아래와 같이 수행됩니다.

  순차적으로 명령어를 처리할 때보다 더 효율적입니다.
    
      이렇게 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법을 비순차적 명령어 처리 기법 이라고 합니다.
    
  




하지만 아무 명령어나 순서를 바꿔서 수행할 수는 없습니다.

예를 들어서 다음 예시를 봅시다.
1. M(100) &lt;- 1
2. M(101) &lt;- 2
3. M(102) &lt;- M(100) + M(101)
4. M(103) &lt;- M(102) + M(101)
5. M(104) &lt;- M(100)



  위 코드에서 3번 명령어와 1번 명령어의 순서를 바꿀 수는 없습니다.
    
      3번 명령어를 수행하려면 반드시 M(100) 값이 결정되어야 하기 때문입니다.
        
          마찬가지로 4번 명령어와 1번 명령어는 순서를 바꿀 수 없습니다.
            
              1번 명령어를 토대로 3번 명령어가 수행되고, 3번 명령어를 토대로 4번이 수행되기 때문입니다.
            
          
        
      
    
  


하지만 위 코드에서 4번 명령어와 5번 명령어는 순서를 바꾸어 실행할 수 있습니다.

  다시 말해 이 두 명령어는 어떤 의존성도 없기에 순서를 바꿔도 전체 프로그램의 실행 흐름에는 영향이 없습니다.




이처럼 비순차적 명령어 처리가 가능한 CPU는 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지를 판단할 수 있어야 합니다.

키워드로 정리하는 핵심 포인트

  명령어 파이프라이닝은 동시에 여러 개의 명령어를 겹쳐 실행하는 기법입니다.
  슈퍼 스칼라는 여러 개의 명령어 파이프라인을 두는 기법입니다.
  비순차적 명령어 처리 기법은 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 기법입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/TIL/2024-04-18-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/TIL/2024-04-18-TIL.html"><h1 class="title_post">📝 [TIL] 240418 Today I Learned.</h1></a>
                        <a href="/2024/TIL/2024-04-18-TIL.html" class="txt_post">
                            JAVA

  Java ‘래퍼 클래스 - 주요 메서드와 성능’ 학습.
  Java ‘래퍼 클래스 - 주요 메서드와 성능’ 정리.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-18-WrapperClass-MainMethodsAndPerformance.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-18-WrapperClass-MainMethodsAndPerformance.html"><h1 class="title_post">☕️[Java] 래퍼 클래스 - 주요 메서드와 성능</h1></a>
                        <a href="/2024/Java/2024-04-18-WrapperClass-MainMethodsAndPerformance.html" class="txt_post">
                            래퍼 클래스 - 주요 메서드와 성능.

래퍼 클래스 - 주요 메서드.
래퍼 클래스가 제공하는 주요 메서드를 알아봅시다.

package lang.wrapper;

public class WrapperUtilsMain {

  public static void main(String[] args) {
    Integer i1 = Integer.valueOf(10); // 숫자, 래퍼 객체 변환.
    Integer i2 = Integer.valueOf("10"); // 문자열, 래퍼 객체 변환.
    int intValue = Integer.parseInt("10"); // 문자열 전용, 기본형 변환.

    // 비교
    int compareResult = i1.compareTo(20);
    System.out.println("compareResult = " + compareResult);

    // 산술 연산
    System.out.println("sum: " + Integer.sum(10, 20));
    System.out.println("min: " + Integer.min(10, 20));
    System.out.println("max: " + Integer.max(10, 20));
  }
}


실행 결과
compareResult = -1
sum: 30
min: 10
max: 20



  valueOf(): 래퍼 타입을 반환합니다. 숫자, 문자열을 모두 지원합니다.
  parseInt(): 문자열을 기본형으로 변환합니다.
  compareTo(): 내 값과 인수로 넘어온 값을 비교합니다. 내 값이 크면 1, 같으면 0, 내 값이 작으면 -1을 반환합니다.
  Integer.sum(), Integer.min(), Integer.max(): static 메서드 입니다. 간단한 덧셈, 작은 값, 큰 값 연산을 수행합니다.


pareInt() vs valueOf()
원하는 타입에 맞는 메서드를 사용하면 됩니다.

  valueOf("10")는 래퍼 타입을 반환합니다.
  parseInt("10")는 기본형을 반환합니다.
    
      Long.parseLong() 처럼 각 타입에 parseXxx()가 존재합니다.
    
  


래퍼 클래스와 성능
래퍼 클래스는 객체이기 때문에 기본형보다 다양한 기능을 제공합니다.
그렇다면 더 좋은 래퍼 클래스만 제공하면 되지 기본형을 제공하는 이유는 무엇일까요?

다음 코드를 실행해서 기본형과, 래퍼 클래스의 성능 차이를 비교해봅시다.

package lang.wrapper;

public class WrapperVsPrimitive {

  public static void main(String[] args) {
    int iterations = 1_000_000_000; // 반복 횟수 설정, 10억
    long startTime, endTime;

    // 기본형 long 사용
    long sumPrimitive = 0;
    startTime = System.currentTimeMillis();
    for (int i = 0; i &lt; iterations; i++) {
      sumPrimitive += i;
    }
    endTime = System.currentTimeMillis();
    System.out.println("sumPrimitive = " + sumPrimitive);
    System.out.println("기본 자료형 long 실행 시간: " + (endTime - startTime) + "ms");

    // 래퍼 클래스 Long 사용
    Long sumWrapper = 0L;
    startTime = System.currentTimeMillis();
    for (int i = 0; i &lt; iterations; i++) {
      sumWrapper += i; // 오토 박싱 발생
    }
    endTime = System.currentTimeMillis();
    System.out.println("sumWrapper = " + sumWrapper);
    System.out.println("래퍼 클래스 Long 실행 시간: " + (endTime - startTime) + "ms");
  }
}


  단순히 값을 반복해서 10억 번 더합니다.
  기본형 long에 더하는 것과 래퍼 클래스 Long에 더하는 부분으로 나누어 테스트 합니다. 결과 값은 같습니다.


실행 결과 - M1 맥북 기준
sumPrimitive = 499999999500000000
기본 자료형 long 실행 시간: 381ms
sumWrapper = 499999999500000000
래퍼 클래스 Long 실행 시간: 1640ms


  기본형 연산이 래퍼 클래스보다 대략 5배 정도 빠른 것을 확인할 수 있습니다. 참고로 계산 결과는 시스템 마다 다릅니다.
  기본형은 메모리에서 단순히 그 크기만큼의 공간을 차지합니다. 예를 들어 int 는 보통 4바이트의 메모리를 사용합니다.
  래퍼 클래스의 인스턴스는 내부에 필드로 가지고 있는 기본형의 값 뿐만 아니라 자바에서 객체 자체를 다루는데 필요한 객체 메타데이터를 포함하므로 더 많은 메모리를 사용합니다. 자바 버전과 시스템마다 다르지만 대략 8-16바이트의 메모리를 추가로 사용합니다.


기본형, 래퍼 클래스 어떤 것을 사용?

  이 연산은 10억 번의 연산을 수행했을 때 0.3초와, 1.5초의 차이입니다.
  기본형이든 래퍼 클래스든 이것을 1회로 환산하면 둘다 매우 빠르게 연산이 수행됩니다.
    
      0.3초 나누기 10억, 1.5초 나누기 10억이다.
    
  
  일반적인 애플리케이션을 만드는 관점에서 보면 이런 부분을 최적화해도 사막의 모래알 하나 정도의 차이가 날 뿐입니다.
  CPU 연산을 아주 많이 수행하는 특수한 경우이거나, 수만 ~ 수십만 이상 연속해서 연산을 수행해야 하는 경우라면 기본형을 사용해서 최적화를 고려합시다.
  그렇지 않은 일반적인 경우라면 코드를 유지보수하기 더 나은 것을 선택하면 됩니다.


유지보수 vs 최적화
유지보수 vs 최적화를 고려해야 하는 상황이라면 유지보수하기 좋은 코드를 먼저 고민해야 합니다.
특히 최신 컴퓨터는 매우 빠르기 때문에 메모리 상에서 발생하는 연산을 몇 번 줄인다고해도 실질적인 도움이 되지 않는 경우가 많습니다.

  코드 변경 없이 최적화를 하면 가장 좋겠지만, 성능 최적화는 대부분 단순함 보다는 복잡함을 요구하고, 더 많은 코드들을 추가로 만들어야 합니다. 최적화를 위해 유지보수 해야 하는 코드가 더 늘어나는 것입니다. 그런데 진짜 문제는 최적화를 한다고 했지만 전체 애플리케이션의 성능 관점에서 보면 불필요한 최적화를 할 가능성이 있습니다.
  특히 웹 애플리케이션의 경우 메모리 안에서 발생하는 연산 하나보다 네트워크 호출 한 번이 많게는 수십만배 더 오래 걸립니다. 자바 메모리 내부에서 발생하는 연산을 수천번에서 한 번으로 줄이는 것 보다, 네트워크 호출 한 번을 더 줄이는 것이 더 효과적인 경우가 많습니다.
  권장하는 방법은 개발 이후에 성능 테스트를 해보고 정말 문제가 되는 부분을 찾아서 최적화 하는 것입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/TIL/2024-04-17-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/TIL/2024-04-17-TIL.html"><h1 class="title_post">📝 [TIL] 240417 Today I Learned.</h1></a>
                        <a href="/2024/TIL/2024-04-17-TIL.html" class="txt_post">
                            Java 학습 및 정리

  Java ‘래퍼 클래스 - 기본형의 한계2’ 학습.
  Java ‘래퍼 클래스 - 기본형의 한계2’ 정리.
  Java ‘래퍼 클래스 - 자바 래퍼 클래스’ 학습
  Java ‘래퍼 클래스 - 자바 래퍼 클래스’ 정리


자료구조

  삽입정렬 복습 part 1
  삽입정렬 복습 part 2
  삽입정렬 복습 part 3


C++ 의 ‘sizeof()’
C++ 에서 ‘sizeof()’ 는 연산자로 사용되며, 주어진 타입이나 변수의 메모리 크기를 바이트 단위로 반환합니다.
이 연산자는 컴파일 시간에 그 크기를 결정하므로, 프로그램 실행 도중에는 크기가 변경되지 않습니다.

‘sizeof()’ 연산자의 사용 예시는 다음과 같습니다.


  타입의 크기 확인 : ‘sizeof(int)’ 은 ‘int’ 타입의 크기를 바이트 단위로 반환합니다. 보통 ‘int’ 는 4바이트를 사용하지만 시스템에 따라 다를 수 있습니다.
  변수의 크기 확인 : ‘int x; sizeof(x)’ 는 변수 ‘x’ 의 타입인 ‘int’ 의 크기를 반환합니다.
  배열의 전체 크기 확인 : ‘int arr[10]; sizeof(arr)’ 는 배열 ‘arr’ 의 전체 크기를 반환합니다. 이 경우 ‘10 * sizeof(int)’ 와 같은 결과를 나타냅니다.


‘sizeof()’ 는 특히 메모리 관리를 할 때나 데이터 타입의 크기가 중요한 연산에서 매우 유용합니다.

.gitignore란?


  보안상으로 위험성이 있는 파일
  프로젝트와 관계없는 파일
  용량이 너무 커서 제외해야되는 파일


위와 같은 파일들을 .gitignore 이라는 디렉토리를 만들어 무시할 파일을 넣어 줄 수 있습니다.

사용법

  git init을 한 폴더에 .gitignore 이라는 이름으로 파일을 만듭니다.
    
      그 파일 내부에 제외할 파일 혹을 폴더를 명시하면 됩니다.
    
  



  특정 파일 fileName 제외하기
fileName.js
  현재 경로에 있는 fileName_1 만 제외하기(다른경로 fileName_1은 제외되지 않음.)
/fileName.js
  특정 폴더 node_module 안의 파일 다 제외하기
node_module/
  특정 경로의 특정 파일 제외하기
folder/my.txt
  특정 경로 아래의 모든 fileName_2 제외하기
folder/**/fileName_2.txt
  특정 확장자 파일 다 제외하기
*.txt
  예외 만들기
!fileName.txt


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-17-WrapperClass-JavaWrapperClass.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-17-WrapperClass-JavaWrapperClass.html"><h1 class="title_post">☕️[Java] 래퍼 클래스 - 자바 래퍼 클래스</h1></a>
                        <a href="/2024/Java/2024-04-17-WrapperClass-JavaWrapperClass.html" class="txt_post">
                            래퍼 클래스 - 자바 래퍼 클래스.
지금까지 설명한 래퍼 클래스는 기본형을 객체로 감싸서 더 편리하게 사용하도록 도와주기 때문에 상당히 유용합니다.
쉽게 이야기해서 래퍼 클래스는 기본형의 객체 버전입니다.

자바는 기본형에 대응하는 래퍼 클래스를 기본으로 제공합니다.


  byte -&gt; Byte
  short -&gt; Short
  int -&gt; Integer
  long -&gt; Long
  float -&gt; Float
  double -&gt; Double
  char -&gt; Character
  boolean -&gt; Boolean


그리고 자바가 제공하는 기본 래퍼 클래스는 다음과 같은 특징을 가지고 있습니다.

  불변이다.
  equals로 비교해야 한다.


자바가 제공하는 래퍼 클래스의 사용법을 알아봅시다.

package lang.wrapper;

public class WrapperClassMain {

  public static void main(String[] args) {
    Integer newInteger = new Integer(10); // 미래에 삭제 예정, 대신에 valueOf()를 사용
    Integer integerObj = Integer.valueOf(10); // valueOf() 사용, -128 ~ 127 자주 사용하는 숫자 값 재사용, 불변
    Long longObj = Long.valueOf(100);
    Double doubleObj = Double.valueOf(10.5);

    System.out.println("newInteger = " + newInteger);
    System.out.println("integerObj = " + integerObj);
    System.out.println("longObj = " + longObj);
    System.out.println("doubleObj = " + doubleObj);

    System.out.println("내부 값 읽기");
    int intValue = integerObj.intValue();
    System.out.println("intValue = " + intValue);
    long longValue = longObj.longValue();
    System.out.println("longValue = " + longValue);

    System.out.println("비교");
    System.out.println("==: " + (newInteger == integerObj));
    System.out.println("equals: " + (newInteger.equals(integerObj)));
  }
}


실행 결과
newInteger = 10
integerObj = 10
longObj = 100
doubleObj = 10.5

내부 값 읽기
intValue = 10
longValue = 100

비교
==: false
equals: true


래퍼 클래스 생성 - 박싱(Boxing)

  기본형을 래퍼 클래스로 변경하는 것을 마치 박스에 물건을 넣는 것 같다고 해서 박싱(Boxing) 이라고 합니다.
  new Integer(10)은 직접 사용하면 안됩니다.
    
      내부에서 new Integer(10)을 사용해서 객체를 생성하고 돌려줍니다.
    
  
  추가로 Integer.valueOf()에는 성능 최적화 기능이 있습니다. 개발자들이 일반적으로 자주 사용하는 -128~127 범위의 Integer 클래스를 미리 생성해줍니다.
    
      해당 범위의 값을 조회하면 미리 생성된 Integer 객체를 반환합니다.
        
          해당 범위의 값이 없으면 new Integer()를 호출합니다.
            
              마치 문자열 풀과 비슷하게 자주 사용하는 숫자를 미리 생성해두고 재사용합니다.
              참고로 이런 최적화 방식은 미래에 더 나은 방식으로 변경될 수 있습니다.
            
          
        
      
    
  


intValue() - 언박싱(Unboxing)

  래퍼 클래스에 들어있는 기본형 값을 다시 꺼내는 메서드입니다.
  박스에 들어있는 물건을 꺼내는 것 같다고 해서 언박싱(Unboxing) 이라 합니다.


비교는 equals() 사용

  래퍼 클래스는 객체이기 때문에 == 비교를 하면 인스턴스의 참조값을 비교합니다.
  래퍼 클래스는 내부의 값을 비교하도록 equals()를 재정의 해두었습니다.
    
      따라서 값을 비교하려면 equals()를 사용해야합니다.
    
  



  참고로 래퍼 클래스는 객체를 그대로 출력해도 내부에 있는 값을 문자로 출력하도록 toString()을 재정의 해두었습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-17-WrapperClass-AutoBoxing.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-17-WrapperClass-AutoBoxing.html"><h1 class="title_post">☕️[Java] 래퍼 클래스 - 오토 박싱</h1></a>
                        <a href="/2024/Java/2024-04-17-WrapperClass-AutoBoxing.html" class="txt_post">
                            래퍼 클래스 - 오토 박싱.

오토 박싱 - Autoboxing

자바에서 int를 Integer로 변환하거나, Integer를 int로 변환하는 부분을 정리해봅시다.
다음과 같이 valueOf(), intValue() 메서드를 사용하면 됩니다.

package lang.wrapper;

public class AutoboxingMain1 {

  public static void main(String[] args) {
    // Primitive -&gt; Wrapper
    int value = 7;
    Integer boxedValue = Integer.valueOf(value);

    // Wrapper -&gt; Primitive
    int unboxedValue = boxedValue.intValue();

    System.out.println("boxedValue = " + boxedValue);
    System.out.println("unboxedValue = " + unboxedValue);
  }
}


실행 결과
boxedValue = 7
unboxedValue = 7



  박싱: valueOf()
  언박싱: xxxValue() (예: intValue(), doubleValue())


개발자들이 오랜기간 개발을 하다 보니 기본형을 래퍼 클래스로 변환하거나 또는 래퍼 클래스를 기본형으로 변환하는 일이 자주 발생했습니다.
그래서 많은 개발자들이 불편함을 호소했습니다.

  자바는 이런 문제를 해결하기 위해 자바 1.5부터 오토 박싱(Auto-boxing), 오토 언박싱(Auto-unboxing)을 지원합니다.


오토 박싱, 언박싱
package lang.wrapper;

public class AutoboxingMain2 {

  public static void main(String[] args) {
    // Primitive -&gt; Wrapper
    int value = 7;
    Integer boxedValue = value; // 오토 박싱(Auto-boxing)

    // Wrapper -&gt; Primitive
    int unboxedValue = boxedValue; // 오토 언박싱(Auto-Unboxing)

    System.out.println("boxedValue = " + boxedValue);
    System.out.println("unboxedValue = " + unboxedValue);
  }
}


실행 결과
boxedValue = 7
unboxedValue = 7


오토 박싱과 오토 언박싱은 컴파일러가 개발자 대신 valueOf, xxxValue() 등의 코드를 추가해주는 기능입니다.
덕분에 기본형과 래퍼형을 서로 편리하게 변환할 수 있습니다.
따라서 AutoboxingMain1과 AutoboxingMain2는 동일하게 작동합니다.

Integer boxedValue = value; // 오토 박싱(Auto-boxing)
Integer boxedValue = Integer.valueOf(value); // 컴파일 단계에서 추가

int unboxedValue = boxedValue; // 오토 언박싱(Auto-Unboxing)
int unboxedValue = boxedValue.intValue(); // 컴파일 단계에서 추가


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-17-WrapperClass-LimitationOfBaseTypes2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-17-WrapperClass-LimitationOfBaseTypes2.html"><h1 class="title_post">☕️[Java] 래퍼 클래스 - 기본형의 한계 2</h1></a>
                        <a href="/2024/Java/2024-04-17-WrapperClass-LimitationOfBaseTypes2.html" class="txt_post">
                            래퍼 클래스 - 기본형의 한계 2

기본형과 null
기본형은 항상 값을 가져야 합니다.
하지만 때로는 데이터가 ‘없음’이라는 상태가 필요할 수 있습니다.
다음 코드를 작성해봅시다.

package lang.wrapper;

public class MyIntegerNullMain0 {

  public static void main(String[] args) {
    int[] intArr = {-1, 0, 1, 2, 3};
    System.out.println(findValue(intArr, -1)); // -1
    System.out.println(findValue(intArr, 0));
    System.out.println(findValue(intArr, 1));
    System.out.println(findValue(intArr, 100)); // -1
  }

  private static int findValue(int[] intArr, int target) {
    for (int value : intArr) {
      if (value == target) {
        return value;
      }
    }
    return -1;
  }
}



  findValue()는 배열에 찾는 값이 있으면 해당 값을 반환하고, 찾는 값이 없으면 -1을 반환합니다.
  findValue()는 결과로 int를 반환합니다.
    
      int와 같은 기본형은 항상 값이 있어야 합니다.
        
          여기서도 값을 반환할 때 값을 찾지 못하면 숫자 중 하나를 반환해야 하는데 보통 -1 또는 0을 사용합니다.
        
      
    
  


실행 결과
-1
0
1
-1


실행 결과를 보면 입력값이 -1일 때 -1을 반환합니다.
그런데 배열에 없는 값인 100을 입력해도 같은 -1을 반환합니다.
입력값이 -1일 때를 생각해보면, 배열에 -1 값이 있어서 -1을 반환한 것인지, 아니면 -1 값이 없어서 -1을 반환한 것인지 명확하지 않습니다.

객체의 경우 데이터가 없다는 null이라는 명확한 값이 존재합니다.

다음 코드를 작성해봅시다.

package lang.wrapper;

public class MyIntegerNullMain1 {

  public static void main(String[] args) {
    MyInteger[] intArr = {new MyInteger(-1), new MyInteger(0), new MyInteger(1)};
    System.out.println(findValue(intArr, -1)); // -1
    System.out.println(findValue(intArr, 0));
    System.out.println(findValue(intArr, 1));
    System.out.println(findValue(intArr, 100)); // null
  }

  private static MyInteger findValue(MyInteger[] intArr, int target) {
    for (MyInteger myInteger : intArr) {
      if (myInteger.getValue() == target) {
        return myInteger;
      }
    }
    return null;
  }
}


실행 결과
-1
0
1
null



  앞서 만든 MyInteger 래퍼 클래서를 사용했습니다.
  실행 결과를 보면 -1을 입력했을 때는 -1을 반환합니다.
  100을 입력했을 때는 값이 없다는 null을 반환합니다.


기본형은 항상 값이 존재해야 합니다.
숫자의 경우 0, -1 같은 값이라도 항상 존재해야 합니다.
반면에 객체인 참조형은 값이 없다는 null을 사용할 수 있습니다.
물론 null 값을 반환하는 경우 잘못하면 NullPointerException이 발생할 수 있기 때문에 주의해서 사용해야 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/TIL/2024-04-15-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/TIL/2024-04-15-TIL.html"><h1 class="title_post">📝 [TIL] 240415 Today I Learned.</h1></a>
                        <a href="/2024/TIL/2024-04-15-TIL.html" class="txt_post">
                            1. 리눅스 명령어

  pwd(print working directory)
    
      ~ 은 Home이라는 경로
    
  
  ls(list): 내 폴더 안에 있는 폴더 &amp; 파일 내역을 보여줌
  la -a(list all): 숨겨진 파일(보통 .으로 시작함)도 모두 볼 수 있음
  cd 폴더명(change directory): 폴더 위치 이동
    
      ls 명령어에서 확인된 폴더로 이동 가능
    
  
  cd .. : 한 단계 위의 폴더라는 뜻
  mkdir(make directory): 현재 경로에서 폴더를 생성
  touch: 현재 경로에서 파일을 생성하는 명령어
    
      정확히는 파일의 생성과 파일의 날짜, 시간을 변경하는 명령어
    
  


2.git

  코드 변경점을 기록하는 것
  버전 관리 도구(형상 관리 도구)
    
      소프트웨어의 변경사항을 체계적으로 추적하고 통제하는 것
    
  


3. github

  백업과 공유가 가능한 온라인 코드 저장소
  협업이 가능한 온라인 코드 저장소


4. git 필수 명령어



  코드 관리를 시작하는 명령어 - git init
    
      초기화하다, 초기 세팅하다의 준말
      프로젝트 시작 전 딱 한 번만 입력하면 됨
      정확한 프로젝트 폴더(경로)에서 입력해야 함
    
  
  코드를 저장하는 명령어 - git add &amp; commit
    
      git add 파일명: 저장하기 전 저장할 파일 “지정”
      git commit -m “메세지 작성”: 실제로 파일을 “저장”
    
  
  저장 여부 확인하는 명령어 - git status
  내 프로젝트의 변경사항을 한 번에 지정하는 법 - git add .
    
      working directory, staging area, repository에 대해서 알아봅시다.
    
  
  저장 내역을 확인하는 명령어 - git log
    
      커밋 메시지로 코드 변경점 추측 가능
      git diff 코드 변경 확인
      git reset 과거로 돌아가기 가능
    
  
  변경 사항을 원격 저장소(예: github등)에 업로드 하는 명령어 - git push
    
      git push &lt;원격 저장소 이름&gt; &lt;브랜치 이름&gt;
        
          git push origin main
        
      
    
  
  원격 저장소의 내용을 복사하여 새로운 로컬 저장소를 생성하는 데 사용하는 명령어 - git clone
    
      새로운 프로젝트에 참여하거나 기존 프로젝트의 소스 코드를 로컬 컴퓨터로 가져오고 싶을 때 사용.
      원격 저장소의 모든 파일, 디렉터리, 버전 기록을 포함합니다. 이를 통해 원격 저장소의 정확한 복사본을 로컬에 생성할 수 있습니다.
      원격 저장소에 설정된 브랜치, 원격 추적 정보 등이 자동으로 설정됩니다. 이는 로털에서 작업을 시작하기 위해 필요한 초기 설정을 간소화합니다.
      git clone &lt;원격 저장소 URL&gt;
      특정 브랜치 클론: git clone -b &lt;브랜치 이름&gt; &lt;원격 저장소 URL&gt;
    
  
  원격 저장소에서 최신 변경사항을 가져와서 현재 로컬 브랜치와 병합하는 데 사용하는 명령어 - git pull
    
      이 명령은 git fetch와 git merge 두 단계의 작업을 한 번에 수행합니다.
      이 명령어의 사용은 특히 팀 환경에서 다른 사람들의 작업을 지속적으로 로컬 환경에 통합할 필요가 있을 때 매우 유용합니다.
        
          자세히 설명
            
              
                
                  ‘git fetch’ 단계 : 이 단계에서는 원격 저장소의 최신 데이터를 로컬 저장소로 가져오지만, 현재 작업 중인 로컬 브랜치에는 자동으로 병합되지 않습니다. 원격 저장소의 변경사항은 로컬의 원격 추적 브랜치에 저장됩니다.
                
              
              
                
                  ‘git merge’ 단계 : ‘git fetch’ 로 가져온 변경사항을 현재 작업 중인 브랜치와 병합합니다. 이 병합 과정을 통해 로컬 코드베이스에 원격 저장소의 최신 변경사항이 반영됩니다.
                
              
            
          
        
      
      git pull &lt;원격 저장소 이름&gt; &lt;브랜치 이름&gt;
      예를 들어, 원격 저장소 origin의 main 브랜치에서 최신 변경사항을 가져오고 싶다면 다음 명령어를 사용합니다.
        
          git pull origin main
        
      
      주의사항 및 활용 팁
        
          자동 병합 충돌 : git pull 을 실행할 때 로컬에서 아직 커밋되지 않은 변경사항이 있다면, 원격의 변경사항과 충돌이 발생할 수 있습니다. 이 경우, Git은 사용자에게 충돌을 해결하고 커밋할 것을 요청합니다.
          명시적인 병합 옵션 사용 : 병합 방식을 제어하고 싶을 때는 ’–rebase’ 옵션을 사용하여 기존 커밋 위에 원격 변경사항을 재배치할 수 있습니다. 이는 커밋 히스토리를 더 깔끔하게 유지하는 데 도움을 줍니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-15-WrapperClass-LimitationsOfBaseTypes1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-15-WrapperClass-LimitationsOfBaseTypes1.html"><h1 class="title_post">☕️[Java] 래퍼 클래스 - 기본형의 한계 1</h1></a>
                        <a href="/2024/Java/2024-04-15-WrapperClass-LimitationsOfBaseTypes1.html" class="txt_post">
                            래퍼 클래스 - 기본형의 한계 1

기본형의 한계
자바는 객체 지향 언어입니다.
그런데 자바 안에 객체가 아닌 것이 있습니다.

  바로 int, double 같은 기본형(Primitive Type)입니다.


기본형은 객체가 아니기 때문에 다음과 같은 한계가 있습니다.

  객체가 아님: 기본형 데이터는 객체가 아니기 때문에, 객체 지향 프로그래밍의 장점을 살릴 수 없습니다. 예를 들어 객체는 유용한 메서드를 제공할 수 있는데, 기본형은 객체가 아니므로 메서드를 제공할 수 없습니다.
    
      추가로 객체 참고가 필요한 컬렉션 프레임워크를 사용할 수 없습니다. 그리고 제네릭도 사용할 수 없습니다.
    
  
  null 값을 가질 수 없음: 기본형 데이터 타입은 null 값을 가질 수 없습니다. 때로는 데이터가 없음 이라는 상태를 나타내야 할 필요가 있는데, 기본형은 항상 값을 가지기 때문에 이런 표현을 할 수 없습니다.


기본형의 한계를 이해하기 위해, 두 값을 비교해서 다음과 같은 결과를 출력하는 간단한 코드를 작성해봅시다.

  왼쪽의 값이 더 작다 -1
  두 값이 같다 0
  왼쪽의 값이 더 크다 1


package lang.wrapper;

public class MyIntegerMethodMain0 {

  public static void main(String[] args) {
    int value = 10;
    int i1 = compareTo(value, 5);
    int i2 = compareTo(value, 10);
    int i3 = compareTo(value, 20);
    System.out.println("i1 = " + i1);
    System.out.println("i2 = " + i2);
    System.out.println("i3 = " + i3);
  }

  public static int compareTo(int value, int target) {
    if (value &lt; target) {
      return -1;
    } else if (value &gt; target) {
      return 1;
    } else {
      return 0;
    }
  }
}


실행 결과
i1 = 1
i2 = 0
i3 = -1



  여기서는 value와 비교 대상 값을 compareTo()라는 외부 메서드를 사용해서 비교합니다.
    
      그런데 자기 자신인 value와 다른 값을 연산하는 것이기 때문에 항상 자기 자신의 값인 value가 사용됩니다.
        
          이런 경우 만약 value가 객체라면 value 객체 스스로 가지 자신의 값과 다른 값을 비교하는 메서드를 만드는 것이 더 유용할 것입니다.
        
      
    
  


직접 만든 래퍼 클래스.
int를 클래스로 만들어 봅시다.

  int는 클래스가 아니지만, int 값을 가지고 클래스를 만들면 됩니다.


다음 코드는 마치 int를 클래스로 감싸서 만드는 것 처럼 보입니다.

  이렇게 특정 기본형을 감싸서(Wrap) 만드는 클래스를 래퍼 클래스(Wrapper class)라 합니다.


package lang.wrapper;

public class MyInteger {
  private final int value;

  public MyInteger(int value) {
    this.value = value;
  }

  public int getValue() {
    return value;
  }

  public int compareTo(int target) {
    if (value &lt; target) {
      return -1;
    } else if (value &gt; target) {
      return 1;
    } else {
      return 0;
    }
  }

  @Override
  public String toString() {
    return String.valueOf(value);
  }
}



  MyInteger는 int value라는 단순한 기본형 변수를 하나 가지고 있습니다.
    
      그리고 이 기본형 변수를 편리하게 사용하도록 다양한 메서드를 제공합니다.
      앞에서 본 compareTo() 메서드를 클래스 내부로 캡슐화 했습니다.
      이 클래스는 불변으로 설계했습니다.
    
  


MyInteger 클래스는 단순한 데이터 조각인 int를 내부에 품고, 메서드를 통해 다양한 기능을 추가했습니다.

  덕분에 데이터 조각에 불과한 int를 MyInteger를 통해 객체로 다룰 수 있게 되었습니다.


package lang.wrapper;

public class MyIntegerMethodMain1 {

  public static void main(String[] args) {
    MyInteger myInteger = new MyInteger(10);
    int i1 = myInteger.compareTo(5);
    int i2 = myInteger.compareTo(10);
    int i3 = myInteger.compareTo(20);
    System.out.println("i1 = " + i1);
    System.out.println("i2 = " + i2);
    System.out.println("i3 = " + i3);
  }
}


실행 결과
i1 = 1
i2 = 0
i3 = -1


  myInteger.compareTo()는 자기 자신의 값을 외부의 값과 비교합니다.
  MyInteger는 객체이므로 자신이 가진 메서드를 편리하게 호출할 수 있습니다.
  참고로 int는 기본형이기 때문에 스스로 메서드를 가질 수 없습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-04-15-InstructionCycleAndIntrrupts.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-04-15-InstructionCycleAndIntrrupts.html"><h1 class="title_post">💾 [CS] 명령어 사이클과 인터럽트</h1></a>
                        <a href="/2024/CS/2024-04-15-InstructionCycleAndIntrrupts.html" class="txt_post">
                            명령어 사이클과 인터럽트.


  
    명령어 사이클 : CPU가 하나의 명령어를 처리하는 과정에는 어떤 정해진 흐름이 있고, CPU는 그 흐름을 반복하며 명령어를 처리해 나갑니다. 이렇게 하나의 명령어를 처리하는 정형화된 흐름을 “명령어 사이클” 이라고 합니다.
  
  
    인터럽트 : CPU는 정해진 흐름에 따라 명령어를 처리해 나가지만, 이 흐름이 끊어지는 상황이 발생합니다. 이를 “인터럽트” 라고 합니다.
  


명령어 사이클
프로그램은 수많은 명령어로 이루어져있고, CPU는 이 명령어들을 하나씩 실행합니다.

  이때 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 명령어 사이클(instruction cycle) 이라고 합니다.
    
      즉, 프로그램 속 각각의 명령어들은 명령어 사이클이 반복되며 실행됩니다.
    
  


메모리에 저장된 명령어 하나를 실행한다고 가정해 봅시다.
가장 먼저 해야할 것은 명령어를 메모리에서 CPU로 가져와야 합니다.
이게 명령어 사이클의 첫 번째 과정입니다.


  인출 사이클(fetch cycle) : 메모리에 있는 명령어를 CPU로 가지고 오는 단계.




CPU로 명령어를 인출했다면 이제 명령어를 실행합니다.
이것이 명령어 사이클의 두 번째 과정입니다.


  실행 사이클(execution cycle) : CPU로 가져온 명령어를 실행하는 단계, 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계.




프로그램을 이루는 수많은 명령어는 일반적으로 인출과 실행 사이클을 반복하며 실행됩니다.

  즉, CPU는 프로그램 속 명령어를 가져오고 실행하고, 또 가져오고 실행하고를 반복하는 것입니다.





  하지만 모든 명령어가 이렇게 간단히 실행되는 건 아닙니다.
    
      명령어를 인출하여 CPU로 가져왔다하더라도 곧바로 실행할 수 없는 경우도 있기 때문입니다.
    
  


예를 들어 간접 주소 지정 방식을 생각해 봅시다.

  간접 주소 지정 방식은 오퍼랜드 필드에 유효 주소의 주소를 명시한다고 했습니다.
    
      이 경우 명령어를 인출하여 CPU로 가져왔다 하더라도 바로 실행 사이클에 돌입할 수 없습니다.
      명령어를 실행하기 위해서는 메모리 접근을 한 번 더 해야 하기 때문입니다.
        
          이 단계를 간접 사이클(indirect cycle) 이라고 합니다.
        
      
    
  




인터럽트.
프로그램을 개발하다 보면 아래 인터럽트라는 단어를 쉽게 접할 수 있습니다.

인터럽트는 영어로 interrupt이며, ‘방해하다, 중단시키다’를 의미합니다.

  즉, CPU가 수행 중인 작업은 방해를 받아 잠시 중단될 수 있는데, 이렇게 CPU의 작업을 방해하는 신호를 인터럽트(interrupt) 라고 합니다.


CPU가 작업을 잠시 중단해야 할 정도라면 인터럽트는 ‘CPU가 꼭 주목해야 할 때’ 혹은 ‘CPU가 얼른 처리해야 할 다른 작업이 생겼을 때’ 발생합니다.

인터럽트의 종류에는 크게 동기 인터럽트와 비동기 인터럽트가 있습니다.




  동기 인터럽트(synchronous interrupt) : CPU에 의해 발생하는 인터럽트입니다.
    
      CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때, 가령 CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마추쳤을 때 발생하는 인터럽트입니다.
        
          이런 점에서 동기 인터럽트는 예외(execption) 라고 부릅니다.
        
      
    
  
  비동기 인터럽트(asynchronous interrupt) : 주로 입출력장치에 의해 발생하는 인터럽트입니다.
    
      입출력장치에 의한 비동기 인터럽트는 세탁기 완료 알리므 전자레인지 조리 완료 알림과 같은 알림 역할을 합니다.
    
  


구체적으로 다음과 같이 사용됩니다.

  CPU가 프린터와 같은 입출력장치에 입출력 작업을 부탁하면 작업을 끝낸 입출력장치가 CPU에 완료 알림(인터럽트)을 보냅니다.
  키보드, 마우스와 같은 입출력 장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에 입력 알림(인터럽트)을 보냅니다.


하드웨어 인터럽트
하드웨어 인터럽트는 알림과 같은 인터럽트 입니다.

  CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 이런 알림과 같은 하드웨어 인터럽트를 사용합니다.


하드웨어 인터럽트를 이용하면 CPU는 주기적으로 하드웨어 완료 여부를 확인할 필요가 없습니다.
CPU는 하드웨어로부터 하드웨어 완료 인터럽트를 받을 때까지 다른 작업을 처리할 수 있습니다.

  이렇듯 하드웨어 인터럽트는 입출력 작업 중에도 CPU로 하여금 효율적으로 명령어를 처리할 수 있게 합니다.


하드웨어 인터럽트 처리 순서

  입출력장치는 CPU에 인터럽트 요청 신호를 보냅니다.
  CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인합니다.
  CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인합니다.
  인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업합니다.
  CPU는 인터럽트 백터를 참조하여 인터럽트 서비스 루틴을 실행합니다.
  인터럽트 서비스 루틴이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개합니다.



  인터럽트 요청 신호 : 인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기에 다른 누군가가 인터럽트하기 전에 “지금끼어들어도 되나요?” 하고 CPU에 물어봐야 합니다. 이를 인터럽트 요청 신호라고 합니다.


이때, CPU가 인터럽트 요청을 수용하기 위해서는 플래그 레지스터의 인터럽트 플래그(interrupt flag) 가 활성화되어 있어야 합니다.

  인터럽트 플래그는 말 그래도 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그입니다.
  CPU가 중요한 작업을 처리해야 하거나 어떤 방해도 받지 않아야 할 때 인터럽트 플래그는 불가능으로 설정됩니다.
    
      만약 인터럽트 플래그가 ‘불가능’으로 설정되어 있다면 CPU는 인터럽트 요청이 오더라도 해당 요청을 무시합니다.
      반대로 인터럽트 플래그가 ‘가능’으로 설정되어 있다면 CPU는 인터럽트 요청 신호를 받아들이고 인터럽트를 처리합니다.
    
  


다만, 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아닙니다.
인터럽트 플래그가 불가능으로 설정되어 있을지라도 무시할 수 없는 인터럽트 요청도 있습니다.

  무시할 수 없는 하드웨어 인터럽트 가장 우선순위가 높은, 다시 말해 반드시 가장 먼저 처리해야 하는 인터럽트입니다.
    
      정전이나 하드웨어 고장으로 인한 인터럽트가 이에 해당합니다.
    
  




CPU가 인터럽트 요청을 받아들이기로 했다면 CPU는 서비스 루틴이라는 프로그램을 실행합니다.

  인터럽트 서비스 루틴(ISB: Interrupt Service Routine): 인터럽트를 처리하기 위한 프로그램. 인터럽트 핸들러(Interrupt handler) 라고도 불립니다.
    
      어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램입니다.
      요컨태 ‘CPU가 인터럽트를 처리한다’는 말은 ‘인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다’ 라는 말과 같습니다.
    
  




인터럽트를 처리하는 방법은 입출력장치마다 다르므로 각기 다른 인터럽트 서비스 루틴을 가지고 있습니다.

  즉, 메모리에는 위 그림처럼 여러 개의 인터럽트 서비스 루틴이 저장되어 있습니다.
    
      이들 하나하나가 ‘인터럽트가 발생하면 어떻게 행동해야 할지를 알려주는 프로그램’이라고 보면 됩니다.
    
  
  인터럽트 벡터(Interrupt vector) : CPU는 수많은 인터럽트 서비스 루틴을 구분하기 위해 인터럽트 벡터를 이용합니다. 인터럽트 서비스 루틴을 식별하기 위한 정보입니다.
    
      인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있기 때문에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있습니다.
    
  



  CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받습니다.


가령, CPU가 작업을 수행하는 도중 키보드 인터럽트가 발생한 경우라면 CPU는 인터럽트 벡터를 참조하여 키보드 인터럽트 서비스 루틴의 시작 주소를 알아내고, 이 시작 주소부터 실행해 나가며 키보드 인터럽트 서비스 루틴을 실행합니다.



정리하면 ‘CPU가 인터럽트를 처리한다’는 말은 ‘인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다’는 말과 같습니다.


  그리고 CPU가 인터럽트 서비스 루틴을 실행하려면 인터럽트 서비스 루틴의 시작 주소를 알아야 하는데, 이는 인터럽트 벡터를 통해 알 수 있습니다.


인터럽트 서비스 루틴은 여느 프로그램과 마찬가지로 명령어와 데이터로 이루어져 있습니다.

  그렇기에 인터럽트 서비스 루틴도 프로그램 카운터를 비롯한 레지스터들을 사용하며 실행됩니다.


그럼, 인터럽트가 발생하기 전까지 레지스터에 저장되어 있던 값들은 어떻게 할까요?




  인터럽트 요청을 받기 전까지 CPU가 수행하고 있었던 일은 인터럽트 서비스 루틴이 끝나면 되돌아와서 마저 수행을 해야 하기 때문에 지금까지의 작업 내역들은 어딘가에 백업을 해둬야 합니다.
    
      그렇기에 CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업합니다.
      그러고 나서 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터 값을 갱신하고 인터럽트 서비스 루틴을 실행합니다.
    
  





  인터럽트 서비스 루틴을 모두 실행하면, 다시 말해 인터럽트를 처리하고 나면 스택에 저장해 둔 값을 다시 불러온 뒤 이전까지 수행하던 작업을 재개합니다.


키워드 정리

  인터럽트 요청 신호 : CPU의 작업을 방해하는 인터럽트에 대한 요청
  인터럽트 플래그 : 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트
  인터럽트 벡터 : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
  인터럽트 서비스 루틴 : 인터럽트를 처리하는 프로그램


CPU는 이와 같은 과정을 반복해 나가며 프로그램을 실행한다고 볼 수 있습니다.



키워드로 정리하는 핵심 포인트

  명령어 사이클은 하나의 명령어가 처리되는 주기로, 인출, 실행, 간접, 인터럽트 사이클로 구성되어 있습니다.
  인터럽트 는 CPU의 정상적인 작업을 방해하는 신호입니다.
  인터럽트의 종류에는 예외와 하드웨어 인터럽트가 있습니다.
  인터럽트 서비스 루틴은 인터럽트를 처리하기 위한 동작들로 이루어진 프로그램입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-14-StringClassSummary.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-14-StringClassSummary.html"><h1 class="title_post">☕️[Java] String 클래스 - 정리</h1></a>
                        <a href="/2024/Java/2024-04-14-StringClassSummary.html" class="txt_post">
                            String 클래스 - 정리

1. 자바에서 문자를 다루는 대표적인 타입

  char
  String
  char 배열을 사용하면 문자열을 다룰 수 있으나 불편합니다.
    
      그래서 String이라는 것을 Java에서 제공해줍니다.
    
  


2. String 클래스를 통해 문자열을 생성하는 2가지 방법.
String str1 = "hello"; // 방법 1 -&gt; 문자열 리터럴
String str2 = new String("hello"); // 방법 2


  쌍따옴표 사용: 방법 1
  객체 생성 : 방법 2


문자열 리터럴을 사용하더라도 결국 new String("hello"); 가 되는 것 입니다.

  편의상 쌍따옴표로 문자열을 감싸면(문자열 리터럴) 자바 언어에서 new String("hello"); 와 같이 변경해 줍니다.
    
      이 경우 실제로는 성정 최적화를 위해 문자열 풀을 사용합니다.
    
  



  문자열은 참조형입니다.


3. String 클래스 내부
String 클래스는 대략 다음과 같이 생겼습니다.
public final class String {
    // 문자열 보관
    private final char[] value; // 자바 9 이전
    private final byte[] value; // 자바 9 이후
    
    // 여러 메서드
    public String concat(String str) {...}
    public int length() {...}
}


3. String 클래스 비교.
String 클래스를 비교할 때는 == 비교가 아니라 항상 equals() 비교를 해야합니다.

  동일성(Identity) : == 연산자를 사용해서 두 객체의 참조(Reference) 가 동일한 객체를 가리키고 있는지 확인합니다.
  동등성(Equality) : equals() 메서드를 사용하여 두 객체가 논리적으로 같은지 확인합니다.


4. 문자열 리터럴, 문자열 풀.



  String str3 = "hello" 와 같이 문자열 리터럴을 사용하는 경우 자바는 메모리 효율성과 성능 최적화를 위해 문자열 풀을 사용합니다.
  자바가 실행되는 시점에 클래스에 문자열 리터럴이 있으면 문자열 풀에 String 인스턴스를 미리 만들어 둡니다.
    
      이때 같은 문자열이 있으면 만들지 않습니다.
    
  
  String str3 - "hello"와 같이 문자열 리터럴을 사용하면 문자열 풀에서 "hello"라는 문자를 가진 String 인스턴스를 찾습니다.
    
      그리고 찾은 인스턴스의 참조(x003)를 반환합니다.
    
  
  String str4 = "hello"의 경우 "hello" 문자열 리터럴을 사용하므로 문자열 풀에서 str3과 같은 x003 참조를 사용합니다.
  문자열 풀 덕분에 같은 문자를 사용하는 경우 메모리 사용을 줄이고 문자를 만드는 시간도 줄어들기 때문에 성능도 최적화 할 수 있습니다.



  따라서 문자열 리터럴을 사용하는 경우 같은 참조값을 가지므로 == 비교에 성공합니다.



  참고
풀(Pool)은 자원이 모여있는 곳을 의미합니다.
프로그래밍에서 풀(Pool)은 공용 자원을 모아둔 곳을 뜻합니다.
여러 곳에서 함께 사용할 수 있는 객체를 필요할 때 마다 생성하고, 제거하는 것은 비효율적입니다.
대신에 이렇게 문자열 풀에 필요한 String 인스턴스를 미리 만들어두고 여러곳에서 재사용할 수 있다면 성능과 메모리를 더 최적화할 수 있습니다.
참고로 문자열 풀은 힙 영역을 사용합니다.
그리고 문자열 풀에서 문자를 찾을 때는 해시 알고리즘을 사용하기 때문에 매우 빠른 속도로 원하는 String 인스턴스를 찾을 수 있습니다.


5. String 클래스는 불변객체.
String은 불변 객체입니다.
따라서 생성 이후에 절대로 내부의 문자열 값을 변경할 수 없습니다.
public static void main(String[] args) {
    String str1 = "hello";
    String str2 = str1.concat(" java");
    System.out.println("str1 = " + str1);
    System.out.println("str1 = " + str2);
}


  String은 불변 객체입니다. 따라서 변경이 필요한 경우 기존 값을 변경하지 않고, 대신에 새로운 결과를 만들어서 반환합니다.


실행 결과
str1 = hello
str2 = hello java




  String.concat()은 내부에서 새로운 String 객체를 만들어서 반환합니다.
    
      따라서 불변과 기존 객체의 값을 유지합니다.
    
  


문자열에서 무언가 변경하는 것이 있으면 그 내부에서 인스턴스를 생성하여 반환합니다.

  때문에 반환값을 받아서 사용해야 합니다.


6. String 클래스가 불변으로 설계된 이유.

  사이드 이팩트 문제.
  문자열 풀을 사용시에 불변으로 설계되어 있어야 안전하게 사용할 수 있기 때문입니다.


7. String 클래스 주요 메서드.
주요 메서드 블로그 글 1
주요 메서드 블로그 글 2

참고. CharSequence
CharSequence 는 String, StringBuilder의 상위 타입입니다.
문자열을 처리하는 다양한 객체를 받을 수 있습니다.

8. StringBuilder - 가변 String
불변인 String 클래스의 단점: 뭔가 값을 더하거나 변경하거나 할 때마다 계속 새로운 객체를 만들어내야 한다는 점 입니다. 때문에 성능도 느려질 수 있습니다. (물론, 불변이기 때문에 안전하기는 합니다.)

  이러한 단점들 때문에 StringBuilder 가 있습니다.


StringBuilder: 가변 String 입니다.

  값을 쭉 바꾸고 쓰면 되는데, 마지막에는 다시 String으로 바꾸는 toString()을 사용합니다.
    
      즉, 다시 안전한 불변으로 바꾸는 작업입니다.
      변경이 필요할 때 가변으로, 마지막에는 불변으로 바꿔서 쓰는것을 권장합니다.
      “뭔가 문자열을 변경할 일이 많다” -&gt; StringBuilder 를 사용하면 됩니다.
    
  


9. String 최적화.
그러나 생각보다 StringBuilder를 사용할 때가 많이 없습니다.

  그 이유는 자바가 String을 최적화하기 때문입니다.


컴파일러에서도 최적화를 하고, 변수로 되어있어도 컴파일러가 최적화를 수행합니다.

  예를 들어 Java가 직접 StringBuilder를 사용합니다.
    String result = new StringBuilder().append(str1).append(str2).toString();
    
  


10. String 최적화가 어려운 경우.
다음과 같이 문자열을 루프안에서 문자열을 더하는 경우에는 최적화가 이루어지지 않습니다.
public class LoopStringMain {
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();
        
        String result = "";
        for (int i = 0; i &lt; 100000; i++) {
            result += "Hello Java ";
        }
        long endTime = System.currentTimeMillis();
        
        System.out.println("result = " + result);
        System.out.println("time = " + (endTime - startTime) + "ms");
    }
}


왜냐하면 대략 다음과 같이 최적화가 되기 때문입니다.(최적화 방식은 자바 버전에 따라 다릅니다.)
String result = "";
for (int i = 0; i &lt; 1000000; i++) {
    result = new StringBuilder().append(result).append("Hello Java ").toString();
}


반복문의 루프 내부에서는 최적화가 되는 것 처럼 보이지만, 반복 횟수만큼 객체를 생성해야 합니다.
반복문 내에서의 문자열 연결은, 런타임에 연결할 문자열의 개수와 내용이 결정됩니다.
이런 경우, 컴파일러는 얼마나 많은 반복이 일어날지, 각 반복에서 문자열이 변할지 예측할 수 없습니다.
따라서, 이런 상황에서는 최적화가 어렵습니다.

StringBuilder 는 물론이고, 아마도 대략 반복 횟수인 100,000번의 String 객체를 생성했을 것입니다.

이럴 때는 직접 StringBuilder 를 사용하면 됩니다.
public class LoopStringMain {
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();
        
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; 100000; i++) {
            sb.append("Hello Java ");
        }
        String result = sb.toString();
        long endTime = System.currentTimeMillis();
        
        System.out.println("result = " + result);
        System.out.println("time = " + (endTime - startTime) + "ms");
    }
}


정리

  문자열을 합칠 때 대부분의 경우 최적화가 되므로 + 연산을 사용하면 됩니다.


StringBuilder를 직접 사용하는 것이 더 좋은 경우

  반복문에서 반복해서 문자를 연결할 때
  조건문을 통해 동적으로 문자열을 조합할 때
  복잡한 문자열의 특정 부분을 변경해야 할 때
  매우 긴 대용량 문자열을 다룰 때


11. 메서드 체이닝.
자기 자신의 값을 반환해서 메서드를 쭉 연결해서 사용할 수 있습니다.

자바의 많은 라이브러리들이 메서드 체이닝 기법을 사용하고 있습니다.

메서드 체이닝 블로그 글

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-04-11-register.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-04-11-register.html"><h1 class="title_post">💾 [CS] 레지스터</h1></a>
                        <a href="/2024/CS/2024-04-11-register.html" class="txt_post">
                            레지스터.

  프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장됩니다.
    
      따라서 레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름을 파악할 수 있습니다
        
          다시 말해 레지스터 속 값을 유심히 관찰하면 프로그램을 실행할 때 CPU 내에서 무슨 일이 벌어지고 있는지, 어떤 명령어가 어떻게 수행되는지 알 수 있습니다.
        
      
    
  


반드시 알아야 할 레지스터.


  프로그램 카운터
  명령어 레지스터
  메모리 주소 레지스터
  메모리 버퍼 레지스터
  플래스 레지스터
  범용 레지스터
  스택 포인터
  베이스 레지스터


프로그램 카운터.

  프로그램 카운터(PC: Program Counter) : 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장합니다.
    
      프로그램 카운터를 명령어 포인터(IP: Instruction Pointer) 라고 부르는 CPU도 있습니다.
    
  


명령어 레지스터.

  명령어 레지스터(IR: Instruction Register) : 해석할 명령어, 즉 방금 메로미에서 읽어 들인 명령어를 저장하는 레지스터입니다.
    
      제어장치는 명령어를 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보냅니다.
    
  


메모리 주소 레지스터.

  메모리 주소 레지스터(MAR: Memory Address Register) : 메모리 주소를 저장하는 레지스터입니다. CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 됩니다.


메모리 버퍼 레지스터.

  메모리 버퍼 레지스터(MBR: Memory buffer register) : 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터입니다.
    
      즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거칩니다.
        
          CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거칩니다.
            
              메모리 버퍼 레지스터는 메모리 데이터 레지스터(MDR: Memory Data Register)라고도 불립니다.
            
          
        
      
    
  


메모리에 저장된 프로그램을 실행하는 과정에서 프로그램 카운터, 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터에 어떤 값들이 담기는지 알아봅시다.

1.
CPU로 실행할 프로그램이 1000번지부터 1500번지까지 저장되어 있다고 가정하겠습니다,
그리고 1000번지에는 1101₍₂₎이 저장되어 있다고 가정하겠습니다.



2.
프로그램을 처음부터 실행하기 위해 프로그램 카운터에는 1000이 저장됩니다.
이는 메모리에서 가져올 명령어가 1000번지에 있다는 걸 의미합니다.



3.
1000번지를 읽어 들이기 위해서는 주소 버스로 100번지를 내보내야 합니다.
이를 위해 메모리 주소 레지스터에는 1000이 저장됩니다.



4.
‘메모리 읽기’ 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내집니다.



5.
메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 증가되어 다음 명령어를 읽어 들일 준비를 합니다.



6.
메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동합니다.



7.
제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킵니다.

5단계에서 프로그램 카운터 값이 증가한 것을 확인했습니다.

  프로그램 카운터 값이 증가했으니 1000번지 명령어 처리가 끝나면 CPU는 다음 명령어(1001번지)를 읽어 들입니다.


이처럼 프로그램 카운터는 지속적으로 증가하며 계속해서 다음 명령어를 읽어 들일 준비를 합니다.

  이 과정이 반복되면서 CPU는 프로그램을 차례대로 실행해 나갑니다.
    
      결국 CPU가 메모리 속 프로그램을 순차적으로 읽어 들이고 실행해 나갈 수 있는 이유는 CPU 속 프로그램 카운터가 꾸준히 증가하기 때문입니다.
    
  




범용 레지스터

  범용 레지스터(general purpose register) : 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터입니다.
    
      메모리 버퍼 레지스터는 테이터 버스로 주고받을 값만 저장하고, 메모리 주소 레지스터는 주소 버스로 내보낼 주소값만 저장하지만, 범용 레지스터는 데이터와 주소를 모두 저장할 수 있습니다.
        
          일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있고, 현대 대다수 CPU는 모두 범용 레지스터를 가지고 있습니다.
        
      
    
  


플레그 레지스터

  플래그 레지스터(Flag register) : 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터입니다.


특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식.

  스택 주소 지정 방식 : 스택과 스택 포인터를 이용한 주소 지정 방식
    
      스택은 한쪽 끝이 막혀 있는 통과 같은 저장 공간입니다.
        
          그래서 스택은 가장 최근에 저장하는 값부터 꺼낼 수 있습니다.
            
              여기서 스택 포인터란 스택의 꼭대기를 가리키는 레지스터입니다.
                
                  즉, 스택 포인터는 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터입니다.
                
              
            
          
        
      
    
  


예를 들어 봅시다.

가령 다음과 같이 위에서부터 주소가 매겨져 있고 아래부터 차곡차곡 데이터가 저장되어 있는 스택이 있다고 가정해봅시다.

  이때 스택 포인터는 스택의 제일 꼭대기 주소, 즉 4번지를 저장하고 있습니다.
    
      이는 ‘스택 포인터가 스택의 꼭대기를 가리키고 있다’고 볼 수 있겠죠.
        
          쉽게 말해, 스택 포인터는 스택의 어디까지 데이터가 캐워져 있는지에 대한 표시라고 보면 됩니다.
        
      
    
  






그럼 이 스택에서 데이터를 꺼낼 때는 어떤 데이터부터 꺼내게 될까요?

  1 -&gt; 2 -&gt; 3 순서대로 꺼낼 수 있습니다.
    
      여기서 하나의 데이터를 꺼내면 스택에는 2와 3이 남고, 스택의 꼭대기 주소가 달라졌기 때문에 스택 포인터는 5번지를 가리킵니다.
    
  




반대로 스택에 데이터를 추가한다면 어떻게 될까요?

  현재 스텍세 4라는 데이터를 저장하면 스택의 꼭대기에 4가 저장됩니다.
    
      이때 스택의 꼭대기 주소가 달라졌기 때문에 스택 포인터는 4번지를 가리킵니다.
    
  


그런데 스택이라는 것은 도대체 어디에 있는 걸까요?

  스택은 메모리 안에 있습니다.
    
      정확히는 메모리 안에 스택처럼 사용할 영역이 정해져 있습니다.
        
          이를 스택 영역이라고 합니다.
            
              이 영역은 다른 주소 공간과는 다르게 스택처럼 사용하기 암묵적으로 약속된 영역입니다.
            
          
        
      
    
  


특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식




  변위 주소 지정 방식(displacement addressing mode) : 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식입니다.


그래서 변위 주소 지정방식을 사용하는 명령어는 다음 그림과 같이 연산 코드 필드, 어떤 레지스터의 값과 더할지를 나타내는 레지스터 필드, 그리고 주소를 담고있는 오퍼랜드 필드가 있습니다.



이때, 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식 등으로 나뉩니다.

상대 주소 지정 방식

  상대 주소 지정 방식(relative addressing mode) : 오퍼랜드와 프로그램 카운터와 값을 더하여 유효 주소를 얻는 방식입니다.
    
      프로그램 카운터에는 읽어 들일 명령어의 주소가 저장되어 있습니다.
        
          만약 오퍼랜드가 음수, 가령 -3이였다면 CPU는 읽어 들이기로 한 명령어로부터 ‘세 번째 이전’ 번지로 접근합니다.
            
              한마디로 실행하려는 명령어의 세 칸 이전 번지 명령어를 실행하는 것이지요
            
          
        
      
    
  




반면, 오퍼랜드가 양수, 가열 3이었다면 CPU는 읽어 들이기로 했던 명령어의 ‘세 번째 이후’ 번지로 접근합니다.

  즉, 실행하려는 명령어에서 세 칸 건너뛴 번지를 실행하는 겁니다.




상대 주소 지정 방식은 프로그래밍 언어의 if문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용됩니다.

베이스 레지스터 주소 지정 방식

  베이스 레지스터 주소 지정 방식(base-register addressing mode) : 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식입니다.


여기서 베이스 레지스터는 ‘기준 주소’, 오퍼랜드는 ‘기준 주소로부터 떨어진 거리’로서의 역할을 합니다.

  즉, 베이스 레지스터 주소 지정 방식은 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식입니다.


가령 베이스 레지스터에 200이라는 값이 있고 오퍼랜드가 40이라면 이는 “기준 주소 200번지로부터 40만큼 떨어진 240번지로 접근하라”를 의미합니다.

또 베이스 레지스터에 550이라는 값이 담겨 있고 오퍼랜드가 50이라면 이는 “기준 주소 550번지로부터 50만큼 떨어진 600번지로 접근하라”를 의미하는 명령어 입니다.



키워드로 정리하는 핵심 포인트

  프로그램 카운터 는 메모리에서 가져올 명령어의 주소, 명령어 레지스터는 해석할 명령어를 저장합니다.
  메모리 주소 레지스터는 메모리의 주소, 메모리 버퍼 레지스터는 메모리와 주고받을 데이터를 저장합니다.
  범용 레지스터는 데이터와 주소를 모두 저장하고, 플래그 레지스터는 연산 결과 혹은 CPU 상태에 대한 부가 정보를 저장합니다.
  스택 포인터는 스택 최상단의 위치를 저장합니다.
  베이스 레지스터에 저장된 주소는 기준 주소로서의 역할을 합니다.


더 알아보기

  Jump
    
      Jump 명령어는 프로그램의 실행 흐름을 끊고 지정된 주소로 점프합니다.
    
  
  Conditional Jump
    
      Conditional Jump 명령어는 특정 조건이 충족될 때에만 주어진 주소로 점프합니다.
    
  
  Call
    
      Call 명령어는 현재 위치를 저장하고 지정된 주소로 이동합니다.
      현재 위치를 저장하기 위해 스택을 사용합니다.
      주로 서브루틴(하위 루틴 또는 함수)을 호출할 때 사용됩니다.
    
  
  Return
    
      Return 명령어는 서브루틴에서 호출자로 복귀합니다.
      호출된 서브루틴이 실행을 마치고 호출자로 돌아갈 때 사용됩니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-11-StringOptimization.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-11-StringOptimization.html"><h1 class="title_post">☕️[Java] String 최적화</h1></a>
                        <a href="/2024/Java/2024-04-11-StringOptimization.html" class="txt_post">
                            String 최적화.
자바의 String 최적화
자바 컴파일러는 다음과 같이 문자열 리터럴을 더하는 부분을 자동으로 합쳐줍니다.

문자열 리터럴 최적화
컴파일 전
String helloWorld = "Hello, " + "World!";


컴파일 후
String helloWorld = "Hello, World!";

따라서 런타임에 별도의 문자열 결합 연산을 수행하지 않기 때문에 성능이 향상됩니다.

String 변수 최적화
문자열 변수의 경우 그 안에 어떤 값이 들어있는지 컴파일 시점에는 알 수 없기 때문에 단순하게 합칠 수 없습니다.
String result = str1 + str2;


이런 경우 예를 들면 다음과 같이 최적화를 수행합니다.(최적화 방식은 자바 버전에 따라 달라집니다.)
String result = new StringBuilder().append(str1).append(str2).toString();



  참고: 자바 9부터는 StringConcatFactory를 사용해서 최적화를 수행합니다.


이렇듯 자바가 최적화를 처리해주기 때문에 지금처럼 간단한 경우에는 StringBuilder를 사용하지 않아도 됩니다.

  대신에 문자열을 더하기 연산(+)을 사용하면 충분합니다.


String 최적화가 어려운 경우
다음과 같이 문자열을 루프안에서 문자열을 더하는 경우에는 최적화가 이루어지지 않습니다.
package lang.string.builder;

public class LoopStringMain {

  public static void main(String[] args) {
    long startTime = System.currentTimeMillis();
    String result = "";

    for (int i = 0; i &lt; 100000; i++) {
      result += "Hello Java ";
    }

    long endTime = System.currentTimeMillis();
    System.out.println("result = " + result);
    System.out.println("time = " + (endTime - startTime) + "ms");
  }
}


왜냐하면 대락 다음과 같이 최적화가 되기 때문입니다.(최적화 방식은 자바 버전에 따라 다릅니다.)
String result = "";
for (int i = 0; i &lt; 100000; i++) {
    result = new StringBuilder().append(result).append("Hello Java ").toString();
}


  반복문의 루프 내부에서는 최적화가 되는 것 처럼 보이지만, 반복 횟수만큼 객체를 생성해야 합니다.
    
      반복문 내에서의 문자열 연결은, 런타임에 연결할 문자열의 개수와 내용이 결정됩니다.
        
          이런 경우, 컴파일러는 얼마나 많은 반복이 일어날지, 각 반복에서 문자열이 어떻게 변할지 예측할 수 없습니다.
            
              따라서, 이런 상황에서는 최적화가 어렵습니다.
            
          
        
      
    
  


StringBuilder는 물론이고, 아마도 대략 반복 횟수인 100,000번의 String 객체를 생성했을 것입니다.

실행 결과
result = Hello Java Hello Java ...
time = 2528ms


  1000ms = 1초
  M1 맥북을 기준으로 100000회 더했을 때 약 2.5초가 걸렸습니다.


이럴 때는 직접 StringBuilder를 사용하면 됩니다.
package lang.string.builder;

public class LoopStringBuilderMain {

  public static void main(String[] args) {
    long startTime = System.currentTimeMillis();

    StringBuilder sb = new StringBuilder();

    for (int i = 0; i &lt; 100000; i++) {
      sb.append("Hello Java ");
    }

    long endTime = System.currentTimeMillis();

    String result = sb.toString();
    System.out.println("result = " + result);
    System.out.println("time = " + (endTime - startTime) + "ms");
  }
}


실행 결과
result = Hello Java Hello Java ...
time = 4ms


  1000ms = 1초
  M1 맥북을 기준으로 100000회 더했을 때 약 0.004초가 걸렸습니다.


정리

  문자열을 합칠 때 대부분의 경우 최적화가 되므로 + 연산을 사용하면 됩니다.


StringBuilder를 직접 사용하는 것이 더 좋은 경우

  반복문에서 반복해서 문자를 연결할 때
  조건문을 통해 동적으로 문자열을 조합할 때
  복잡한 문자열의 특정 부분을 변경해야 할 때
  매우 긴 대용량 문자열을 다룰 때



  참고: StringBuilder vs StringBuffer
StringBuilder와 똑같은 기능을 수행하는 StringBuffer 클래스도 있습니다.
StringBuffer는 내부에 동기화가 되어 있어서, 멀티 스레드 상황에 안전하지만 동기화 오버헤드로 인해 성능이 느립니다.
StringBuilder는 멀티 쓰레드에 상황에 안전하지 않지만 동기화 오버헤드가 없으므로 속도가 빠릅니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-11-MethodChaining.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-11-MethodChaining.html"><h1 class="title_post">☕️[Java] 메서드 체이닝 - Method Chaining</h1></a>
                        <a href="/2024/Java/2024-04-11-MethodChaining.html" class="txt_post">
                            메서드 체이닝 - Method Chaining.
간단한 예제 코드로 메서드 체이닝(Method Chaining)에 대해서 알아봅시다.

package lang.string.chaining;

public class ValueAdder {

  private  int value;

  public ValueAdder add(int addValue) {
    value += addValue;
    return this;
  }

  public int getValue() {
    return value;
  }
}



  단순히 값을 누적해서 더하는 기능을 제공하는 클래스입니다.
  add() 메서드를 호출할 때 마다 내부의 value에 값을 누적합니다.
  add() 메서드를 보면 자기 자신(this)의 참조값을 반환합니다. 이 부분을 유의해서 봅시다.


package lang.string.chaining;

public class MethodChainingMain1 {

  public static void main(String[] args) {
    ValueAdder adder = new ValueAdder();
    adder.add(1);
    adder.add(2);
    adder.add(3);

    int result = adder.getValue();
    System.out.println("result = " + result);
  }
}


실행 결과
result = 6



  add() 메서드를 여러번 호출해서 값을 누적해서 더하고 출력합니다.
    
      여기서는 add() 메서드의 반환값은 사용하지 않았습니다.
    
  


이번에는 add() 메서드의 반환값을 사용해봅시다.

package lang.string.chaining;

public class MethodChainingMain2 {

  public static void main(String[] args) {
    ValueAdder adder = new ValueAdder();
    ValueAdder adder1 = adder.add(1);
    ValueAdder adder2 = adder1.add(2);
    ValueAdder adder3 = adder2.add(3);

    int result = adder3.getValue();
    System.out.println("result = " + result);
  }
}


실행 결과
result = 6

실행 결과는 기존과 같습니다.



  adder.add(1)을 호출합니다.
  add() 메서드는 결과를 누적하고 자기 자신의 참조값인 this(x001)를 반환합니다.
  adder1 변수는 adder와 같은 x001 인스턴스를 참조합니다.





  add()메서드는 자기 자신(this) 메서드의 참조값을 반환합니다.
    
      이 반환값을 adder1, adder2, adder3에 보관했습니다.
        
          따라서 adder, adder1, adder2, adder3은 모두 같은 참조값을 사용합니다.
            
              왜냐하면 add() 메서드가 자기 자신(this)의 참조값을 반환했기 때문입니다.
            
          
        
      
    
  


그런데 이 방식은 처음 방식보다 더 불편하고, 코드도 더 잘 읽히지 않습니다.
이런 방식을 왜 사용하는 것 일까요?

이번에는 방금 사용했던 방식에서 반환된 참조값을 새로운 변수에 담아서 보관하지 않고, 대신에 바로 메서드 호출에 사용해봅시다.

package lang.string.chaining;

public class MethodChainingMain3 {

  public static void main(String[] args) {
    ValueAdder adder = new ValueAdder();
    int result = adder.add(1).add(2).add(3).getValue();
    System.out.println("result = " + result);
  }
}


실행 결과
result = 6


실행 순서

  add() 메서드를 호출하면 ValueAdder 인스턴스 자신의 참조값(x001)이 반환됩니다.
    
      이 반환된 참조값을 변수에 담아두지 않아도 됩니다.
        
          대신에 반환된 참조값을 즉시 사용해서 바로 메서드를 호출할 수 있습니다.
        
      
    
  


다음과 같은 순서로 실행됩니다.
adder.add(1).add(2).add(3).getValue(); // value = 0
x001.add(1).add(2).add(3).getValue(); // value = 0, x001.add(1)을 호출하면 그 결과로 x001을 반환합니다.
x001.add(2).add(3).getValue(); // value = 1, x001.add(2)을 호출하면 그 결과로 x001을 반환합니다.
x001.add(3).getValue(); // value = 3, x001.add(3)을 호출하면 그 결과로 x001을 반환합니다.
x001.getValue(); // value = 6
6


메서드 호출의 결과로 자기 자신의 참조값을 반환하면, 반환된 참조값을 사용해서 메서드 호출을 계속 이어갈 수 있습니다.
코드를 보면 .을 찍고 메서드를 계속 연결해서 사용합니다.
마치 메서드가 체인으로 연결된 것 처럼 보입니다.
이러한 기법을 메서드 체이닝이라고 합니다.
물론 실행 결과도 기존과 동일합니다.

기존에는 메서드를 호출할 때 마다 계속 변수명에 .을 찍어야 했습니다. 예) adder.add(1), adder.add(2)
매서드 체이닝 방식은 메서드가 끝나는 시점에 바로 .을 찍어서 변수명을 생략할 수 있습니다.
메서드 체이닝이 가능한 이유는 자기 자신의 참조값을 반환하기 때문입니다.
이 참조값에 .을 찍어서 바로 자신의 메서드를 호출할 수 있습니다.

메서드 체이닝 기법은 코드를 간결하고 읽기 쉽게 만들어줍니다.

StringBuilder와 메서드 체인(Chain)
StringBuilder는 메서드 체이닝 기법을 제공합니다.

StringBuilder의 append() 메서드를 보면 자기 자신의 참조값을 반환합니다.

public StringBuilder append(String str) {
    super.append(str);
    return this;
}


StringBuilder에서 문자열을 변경하는 대부분의 메서드도 메서드 체이닝 기법을 제공하기 위해 자기 자신을 반환합니다. 예) insert(), delete(), reverse()

앞서 StringBuilder를 사용한 코드는 다음과 같이 개선할 수 있습니다.
package lang.string.builder;

public class StringBuilderMain1_2 {

  public static void main(String[] args) {
    StringBuilder sb = new StringBuilder();
    String string = sb.append("A").append("B").append("C").append("D")
      .insert(4, "Java")
      .delete(4,8)
      .reverse()
      .toString();
    
    System.out.println("string = " + string);
  }
}


실행 결과
string = DCBA


정리
“만드는 사람이 수고로우면 쓰는 사람이 편하고, 만드는 사람이 편하면 쓰는 사람이 수고롭다” 는 말이 있습니다.
메서드 체이닝은 구현하는 입장에서는 번거롭지만 사용하는 개발자는 편리합니다.
참고로 자바의 라이브러리와 오픈 소스들은 메서드 체이닝 방식을 종종 사용합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-10-StringBuilder.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-10-StringBuilder.html"><h1 class="title_post">☕️[Java] StringBuilder - 가변 String</h1></a>
                        <a href="/2024/Java/2024-04-10-StringBuilder.html" class="txt_post">
                            StringBuilder - 가변 String.

불변인 String 클래스의 단점.
불변인 String 클래스에도 단점이 있습니다.

다음 예를 봅시다.

  참고로 실제로 작동하는 코드는 아닙니다.


두 문자를 더하는 경우 다음과 같이 작동합니다.
"A" + "B";
String("A") + String("B"); // 문자는 String 타입.
String("A").concat(String("B")); // 문자의 더하기는 concat을 사용.
new String("AB") // String은 불변입니다. 따라서 새로운 객체가 생성됩니다.


불변인 String의 내부 값은 변경할 수 없습니다.

따라서 변경된 값을 기반으로 새로운 String 객체를 생성합니다.

더 많은 문자를 더하는 경우를 살펴봅시다.
String str = "A" + "B" + "C" + "D";
String str = String("A") + String("B") + String("C") + String("D");
String str = new String("AB") + String("C") + String("D");
String str = new String("ABC") + String("D");
String str = new String("ABCD");


  이 경우 총 3개의 String 클래스가 추가로 생성됩니다.
    
      그런데 문제는 중간에 만들어진 new String("AB"), new String("ABC")는 사용되지 않습니다. 최종적으로 만들어진 new String("ABCD")만 사용됩니다.
        
          결과적으로 중간에 만들어진 new String("AB)", new String("ABC")는 제대로 사용되지도 않고, 이후 GC의 대상이 됩니다.
        
      
    
  


불변인 String 클래스의 단점은 문자를 더하거나 변경할 때 마다 계속해서 새로운 객체를 생성해야 한다는 점입니다.
문자를 자주 더하거나 변경해야 하는 상황이라면 더 많은 String 객체를 만들고, GC해야 합니다.
결과적으로 컴퓨터의 CPU, 메모리 자원을 더 많이 사용하게 됩니다.
그리고 문자열의 크기가 클수록, 문자열을 더 자주 변경할수록 시스템의 자원을 더 많이 소모합니다.


  참고 : 실제로는 문자열을 다룰 때 자바가 내부에서 최적화를 적용합니다.


StringBuilder
이 문제를 해결하는 방법은 단순합니다.

  바로 불변이 아닌 가변 String이 존재하면 됩니다.
    
      가변은 내부의 값을 바로 변경하면 되기 때문에 새로운 객체를 생성할 필요가 없습니다.
        
          따라서 성능과 메모리 사용면에서 불변보다 더 효율적입니다.
        
      
    
  


이런 문제를 해결하기 위해 자바는 StringBuilder라는 가변 String을 제공합니다.

  물론 가변의 경우 사이드 이펙트에 주의해서 사용해야 합니다.


StringBuilder는 내부에 final이 아닌 변경할 수 있는 byte[]을 가지고 있습니다.

public final class StringBuilder {
    char[] value; // 자바 9 이전
    char[] value; // 자바 9 이후
    
    // 여러 메서드
    public StringBuilder append(String str) {...}
    public int length() {...}
    ...
}

(실제로는 상속 관계에 있고 부모 클래스인 AbstractStringBuilder에 value 속성과 length() 메서드가 있습니다.)

StringBuilder 사용 예
실제 StringBuilder를 어떻게 사용하는지 확인해 봅시다.

package lang.string.builder;

public class StringBuilderMain1_1 {

  public static void main(String[] args) {
    StringBuilder sb = new StringBuilder();
    sb.append("A");
    sb.append("B");
    sb.append("C");
    sb.append("D");
    System.out.println("sb = " + sb);

    sb.insert(4, "Java");
    System.out.println("sb = " + sb);

    sb.delete(4,8);
    System.out.println("delete = " + sb);

    sb.reverse();
    System.out.println("reverse = " + sb);

    // StringBuilder(가변) -&gt; String(불변)으로 바꿀 수 있음.
    String string = sb.toString();
    System.out.println("string = " + string);
  }
}



  StringBuilder 객체를 생성합니다.
  append() 메서드를 사용해 여러 문자열을 추가합니다.
  insert() 메서드로 특정 위치에 문자열을 삽입합니다.
  delete() 메서드로 특정 범위의 문자열을 삭제합니다.
  reverse() 메서드로 문자열을 뒤집습니다.
  마지막으로 toString() 메소드를 사용해 StringBuilder의 결과를 기반으로 String을 생성해서 반환합니다.


실행 결과
sb = ABCD
sb = ABCDJava
delete = ABCD
reverse = DCBA
string = DCBA


가변(Mutable) vs 불변(Immutable)

  String은 불변합니다. 즉, 한 번 생성되면 그 내용을 변경할 수 없습니다.
    
      따라서 문자열에 변화를 주려고 할 때마다 새로운 String 객체가 생성되고, 기존 객체는 버려집니다.
        
          이 과정에서 메모리와 처리 시간을 더 많이 소모합니다.
        
      
    
  
  반면에, StringBuilder는 가변적입니다.
    
      하나의 StringBuilder 객체 안에서 문자열을 추가, 삭제, 수정할 수 있으며, 이때마다 새로운 객체를 생성하지 않습니다.
        
          이로 인해 메모리 사용을 줄이고 성늘을 향상시킬 수 있습니다. 단 사이드 이펙트를 주의해야 합니다.
        
      
    
  


StringBuilder는 보통 문자열을 변경하는 동안만 사용하다가 문자열 변경이 끝나면 안전한(불변) String으로 변환하는 것이 좋습니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-10-StringClassMethod2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-10-StringClassMethod2.html"><h1 class="title_post">☕️[Java] String 클래스 - 주요 메서드 2</h1></a>
                        <a href="/2024/Java/2024-04-10-StringClassMethod2.html" class="txt_post">
                            String 클래스 - 주요 메서드 2

문자열 조작 및 변환

  substring(int beginIndex) / substring(int beginIndex, int endIndex) : 문자열의 부분 문자열을 반환합니다.
  concat(String str) : 문자열의 끝에 다른 문자열을 붙입니다.
  replace(CharSequence target, CharSequence replacement) : 특정 문자열을 새 문자열로 대체합니다.
  replaceAll(String regex, String replacement) : 문자열에서 정규 표현식과 일치하는 부분을 새 문자열로 대체합니다.
  replaceFirst(String regex, String replacement) : 문자열에서 정규 표현식과 일치하는 첫 번째 부분을 새 문자열로 대체합니다.
  toLowerCase() / toUpperCase() : 문자열을 소문자나 대문자로 변환합니다.
  trim() : 문자열 양쪽 끝의 공백을 제거합니다. 단순 Whitespace만 제거할 수 있습니다.
  strip() : Whitespace 와 유니코드 공백을 포함해서 제거합니다, 자바 11


package lang.string.method;

public class StringChangeMain2 {

  public static void main(String[] args) {
    String strWithSpaces = "   Java Programming ";

    System.out.println("소문자로 변환: " + strWithSpaces.toLowerCase());
    System.out.println("대문자로 변환: " + strWithSpaces.toUpperCase());

    System.out.println("공백 제거(trim): '" + strWithSpaces.trim() + "'");
    System.out.println("공백 제거(strip): '" + strWithSpaces.strip() + "'");
    System.out.println("앞 공백 제거(stripLeading): '" + strWithSpaces.stripLeading() + "'");
    System.out.println("뒤 공백 제거(stripTrailing): '" + strWithSpaces.stripTrailing() + "'");
  }
}


실행 결과
소문자로 변환:    java programming 
대문자로 변환:    JAVA PROGRAMMING 
공백 제거(trim): 'Java Programming'
공백 제거(strip): 'Java Programming'
앞 공백 제거(stripLeading): 'Java Programming '
뒤 공백 제거(stripTrailing): '   Java Programming'


문자열 분할 및 조합

  split(String regex) : 문자열을 정규 표현식을 기준으로 분할합니다.
  join(CharSequence delimiter, CharSequence... elements) : 주어진 구분자로 여러 문자열을 결합합니다.


package lang.string.method;

public class StringSplitJoinMain {

  public static void main(String[] args) {
    String str = "Apple,Banana,Orange";

    // split()
    String[] splitStr = str.split(",");
    for (String s : splitStr) {
      System.out.println(s);
    }

    String joinStr = "";
    for (int i = 0; i &lt; splitStr.length; i++) {
      String string = splitStr[i];
      joinStr += string;
      if (i != splitStr.length-1) {
        joinStr += "-";
      }
    }

    System.out.println("joinStr = " + joinStr);

    // join()
    String joinedStr = String.join("-", "A", "B", "C");
    System.out.println("연결된 문자열  = " + joinedStr);

    // 문자열 배열 연결
    String result = String.join("-", splitStr);
    System.out.println("result = " + result);
  }
}


실행 결과
Apple
Banana
Orange
joinStr = Apple-Banana-Orange
연결된 문자열  = A-B-C
result = Apple-Banana-Orange


기타 유틸리티.

  valueOf(Object obj) : 다양한 타입을 문자열로 변환합니다.
  toCharArray() : 문자열을 문자 배열로 변환합니다.
  format(String format, Object... args) : 형식 문자열과 인자를 사용하여 새로운 문자열을 생성합니다.
  matches(String regex) : 문자열이 주어진 정규 표현식과 일치하는지 확인합니다.


package lang.string.method;

public class StringUtilsMain1 {

  public static void main(String[] args) {
    int num = 100;
    boolean bool = true;
    Object obj = new Object();
    String str = "Hello, Java!";

    // valueOf 메서드
    String numString = String.valueOf(num);
    System.out.println("숫자의 문자열 값: " + numString);
    String boolString = String.valueOf(bool);
    System.out.println("불리언의 문자열 값: " + boolString);
    String objString = String.valueOf(obj);
    System.out.println("객체의 문자열 값: " + objString);

    // 문자 + x -&gt; 문자
    String numString2 = "" + num;
    System.out.println("빈 문자열 + num: " + numString2);

    // toCharArray 메서드
    char[] strCharArray = str.toCharArray();
    System.out.println("문자열을 문자 배열로 변환 : " + strCharArray);
    for (char c : strCharArray) {
      System.out.print(c);
    }
    System.out.println();
  }
}


실행 결과
숫자의 문자열 값: 100
불리언의 문자열 값: true
객체의 문자열 값: java.lang.Object@a09ee92
빈 문자열 + num: 100
문자열을 문자 배열로 변환 : [C@30f39991
Hello, Java!


package lang.string.method;

public class StringUtilsMain2 {

  public static void main(String[] args) {
    int num = 100;
    boolean bool = true;
    String str = "Hello, Java!";

    // format 메서드
    String format1 = String.format("num: %d, bool: %b, str: %s", num, bool, str);
    System.out.println(format1);

    String format2 = String.format("숫자: %.2f ", 10.1234);
    System.out.println(format2);

    //printf
    System.out.printf("숫자: %.2f\n", 10.1234);

    // matches 메서드
    String regex = "Hello, (Java!|World)";
    System.out.println("'str'이 패턴과 일치하는가? " + str.matches(regex));
  }
}


실행 결과
num: 100, bool: true, str: Hello, Java!
숫자: 10.12 
숫자: 10.12
'str'이 패턴과 일치하는가? true


format 메서드에서 %d는 숫자 %b는 boolean, %s는 문자열을 뜻합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-09-StringClassMethod-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-09-StringClassMethod-1.html"><h1 class="title_post">☕️[Java] String 클래스 - 주요 메서드 1</h1></a>
                        <a href="/2024/Java/2024-04-09-StringClassMethod-1.html" class="txt_post">
                            String 클래스 - 주요 메서드 1

주요 메서드 목록
String 클래스는 문자열을 편리하게 다루기 위한 다양한 메서드를 제공합니다.
여기서는 자주 사용하는 기능 위주로 나열했습니다.
참고로 기능이 너무 많기 때문에 메서드를 외우기 보다는 주로 사용하는 메서드가 이런 것이 있구나 대략 알아두고, 필요할 때 검색하거나 API 문서를 통해서 원하는 기능을 찾는 것이 좋습니다.

문자열 정보 조회

  length() : 문자열의 길이를 반환합니다.
  isEmpty() : 문자열이 비어 있는지 확인합니다. (길이가 0).
  isBlank() : 문자열이 비어 있는지 확인합니다. (길이가 0이거나 공백(Whitespace)만 있는 경우), 자바 11
  charAt(int index): 지정된 인덱스에 있는 문자를 반환합니다.


문자열 비교

  equals(Object anObject) : 두 문자열이 동일한지 비교합니다.
  equalsIgnoreCase(String anotherString) : 두 문자열을 대소문자 구분 없이 비교합니다.
  compareTo(String anotherString) : 두 문자열을 사전 순으로 비교합니다.
  compareToIgnoreCase(String str) : 두 문자열을 대소문자 구분 없이 사전적으로 비교합니다.
  startWith(String prefix) : 문자열이 특정 접두사로 시작하는지 확인합니다.
  endWith(String suffix) : 문자열이 특정 접미사로 끝나는지 확인합니다.


문자열 검색

  contains(CharSequence s) : 문자열이 특정 문자열을 포함하고 있는지 확인합니다.
  indexOf(String ch) / indexOf(String ch, int fromIndex): 문자열이 처음 등장하는 위치를 반환합니다.
  lastIndexOf(String ch) : 문자열이 마지막으로 등장하는 위치를 반환합니다.


문자열 조작 및 변환

  substring(int beginIndex) / substring(int beginIndex, int endIndex) : 문자열의 부분 문자열을 반환합니다.
  concat(String str) : 문자열의 끝에 다른 문자열을 붙입니다.
  replace(CharSequence target, CharSequence replacement) : 특정 문자열을 새 문자열로 대체합니다.
  replaceAll(String regex, String replacement) : 문자열에서 정규 표현식과 일치하는 부분을 새 문자열로 대체합니다.
  replaceFirst(String regex, String replacement) : 문자열에서 정규 표현식과 일치하는 첫 번째 부분을 새 문자열로 대체합니다.
  toLowerCase() / toUpperCase() : 문자열을 소문자나 대문자로 변환합니다.
  trim() : 문자열 양쪽 끝의 공백을 제거합니다. 단순 Whitespace만 제거할 수 있습니다.
  strip() : Whitespace 와 유니코드 공백을 포함해서 제거합니다, 자바 11


문자열 분할 및 조합.

  split(String regex) : 문자열을 정규 표현식을 기준으로 분할합니다.
  join(CharSequence delimiter, CharSequence... elements) : 주어진 구분자로 여러 문자열을 결합합니다.


기타 유틸리티.

  valueOf(Object obj) : 다양한 타입을 문자열로 변환합니다.
  toCharArray() : 문자열을 문자 배열로 변환합니다.
  format(String format, Object... args) : 형식 문자열과 인자를 사용하여 새로운 문자열을 생성합니다.
  matches(String regex) : 문자열이 주어진 정규 표현식과 일치하는지 확인합니다.


이제 본격적으로 하나씩 알아봅시다.


  참고: CharSequence 는 String, StringBuilder의 상위 타입입니다.
문자열을 처리하는 다양한 객체를 받을 수 있습니다.


문자열 정보 조회

  length() : 문자열의 길이를 반환합니다.
  isEmpty() : 문자열이 비어 있는지 확인합니다. (길이가 0).
  isBlank() : 문자열이 비어 있는지 확인합니다. (길이가 0이거나 공백(Whitespace)만 있는 경우), 자바 11
  charAt(int index): 지정된 인덱스에 있는 문자를 반환합니다.


package lang.string.method;

public class StringInfoMain {

  public static void main(String[] args) {
    String str = "Hello, Java!";
    System.out.println("문자열의 길이: " + str.length());
    System.out.println("문자열이 비어 있는지: " + str.isEmpty());
    System.out.println("문자열이 비어 있거나 공백인지 1: " + str.isBlank());
    System.out.println("문자열이 비어 있거나 공백인지 2: " + "          ".isBlank());

    char c = str.charAt(7);
    System.out.println("7번째 인덱스의 문자 = " + c);
  }
}


실행 결과
문자열의 길이: 12
문자열이 비어 있는지: false
문자열이 비어 있거나 공백인지 1: false
문자열이 비어 있거나 공백인지 2: true
7번째 인덱스의 문자 = J


문자열 비교

  equals(Object anObject) : 두 문자열이 동일한지 비교합니다.
  equalsIgnoreCase(String anotherString) : 두 문자열을 대소문자 구분 없이 비교합니다.
  compareTo(String anotherString) : 두 문자열을 사전 순으로 비교합니다.
  compareToIgnoreCase(String str) : 두 문자열을 대소문자 구분 없이 사전적으로 비교합니다.
  startWith(String prefix) : 문자열이 특정 접두사로 시작하는지 확인합니다.
  endWith(String suffix) : 문자열이 특정 접미사로 끝나는지 확인합니다.


package lang.string.method;

public class StringComparisonMain {

  public static void main(String[] args) {
    String str1 = "Hello, Java!"; // 대문자 일부 있음
    String str2 = "hello, java!";
    String str3 = "Hello, World!";

    System.out.println("str equals str2: " + str1.equals(str2));
    System.out.println("str equalsIgnoreCase str2: " + str1.equalsIgnoreCase(str2));

    System.out.println("'a' compareTo 'b': " + "a".compareTo("b"));
    System.out.println("'b' compareTo 'a': " + "b".compareTo("a"));
    System.out.println("'c' compareTo 'a': " + "c".compareTo("a"));

    System.out.println("str1 compareTo str3: " + str1.compareTo(str3));
    System.out.println("str1 compareToIgnoreCase str2: " + str1.compareToIgnoreCase(str2));

    System.out.println("str1 starts with 'Hello': " + str1.startsWith("Hello"));
    System.out.println("str1 ends with 'Java!': " + str1.endsWith("Java!"));
  }
}


실행 결과
str equals str2: false
str equalsIgnoreCase str2: true
'a' compareTo 'b': -1
'b' compareTo 'a': 1
'c' compareTo 'a': 2
str1 compareTo str3: -13
str1 compareToIgnoreCase str2: 0
str1 starts with 'Hello': true
str1 ends with 'Java!': true


문자열 검색

  contains(CharSequence s) : 문자열이 특정 문자열을 포함하고 있는지 확인합니다.
  indexOf(String ch) / indexOf(String ch, int fromIndex): 문자열이 처음 등장하는 위치를 반환합니다.
  lastIndexOf(String ch) : 문자열이 마지막으로 등장하는 위치를 반환합니다.


package lang.string.method;

public class StringSearchMain {

  public static void main(String[] args) {
    String str = "Hello, Java! Welcome to Java world.";

    System.out.println("문자열에 'Java'가 포함되어 있는지: " + str.contains("Java"));
    System.out.println("'Java'의 첫 번째 인덱스: " + str.indexOf("Java"));
    System.out.println("인덱스 10부터 'Java'의 인덱스: " + str.indexOf("Java", 10));
    System.out.println("'Java'의 마지막 인덱스: " + str.lastIndexOf("Java"));
  }
}


실행 결과
문자열에 'Java'가 포함되어 있는지: true
'Java'의 첫 번째 인덱스: 7
인덱스 10부터 'Java'의 인덱스: 24
'Java'의 마지막 인덱스: 24


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-09-StringClassImmutableObject.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-09-StringClassImmutableObject.html"><h1 class="title_post">☕️[Java] String 클래스 - 불변객체</h1></a>
                        <a href="/2024/Java/2024-04-09-StringClassImmutableObject.html" class="txt_post">
                            String 클래스 - 불변객체
String은 불변 객체입니다.
따라서 생성 이후에 절대로 내부의 문자열 값을 변경할 수 없습니다.

다음 예를 봅시다.

package lang.string.immutable;

public class StringImmutable1 {

  public static void main(String[] args) {
    String str = "hello";
    str.concat(" java");
    System.out.println("str = " + str);
  }
}


  String.concat() 메서드를 사용하면 기존 문자열에 새로운 문자열을 연결해서 합칠 수 있습니다.
    
      이 경우 어떤 실행 결과가 나올까요?
        
          불변 객체에서 학습한 내용을 떠올려봅시다.
        
      
    
  


실행 결과
str = hello

실행 결과를 보면 뭔가 이상합니다.

  문자가 전혀 합쳐지지 않았습니다.


다음 코드를 봐봅시다.
package lang.string.immutable;

public class StringImmutable2 {

  public static void main(String[] args) {
    String str1 = "hello";
    String str2 = str1.concat(" java");
    System.out.println("str1 = " + str1);
    System.out.println("str2 = " + str2);
  }
}



  String은 불변 객체입니다.
    
      따라서 변경이 필요한 경우 기존 값을 변경하지 않고, 대신에 새로운 결과를 만들어서 반환합니다.
    
  


실행 결과
str1 = hello
str2 = hello java




  String.concat()은 내부에서 새로운 String 객체를 만들어서 반환합니다.
    
      따라서 불변과 기존 객체의 값을 유지합니다.
    
  


String이 불변으로 설계된 이유.
String이 불변으로 설계된 이유는 앞서 불변 객체에서 배운 내용에 추가로 다음과 같은 이유도 있습니다.

  문자열 풀에 있는 String 인스턴스의 값이 중간에 변경되면 같은 문자열을 참고하는 다른 변수의 값도 함께 변경됩니다.


예를 들어봅시다.




  String은 자바 내부에서 문자열 풀을 통해 최적화를 합니다
  만약 String 내부의 값을 변경할 수 있다면, 기존에 문자열 풀에서 같은 문자를 참조하는 변수의 모든 문자가 함께 변경되어 버리는 문제가 발생합니다.
    
      다음의 경우 str3이 참조하는 문자를 변경하면 str4의 문자도 함께 변경되는 사이드 이펙트 문자가 발생합니다.
        
          String str3 = "hello"
          String str4 = "hello"
        
      
    
  


String 클래스는 불변으로 설계되어서 이런 사이드 이펙트 문제가 발생하지 않습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-08-StringClassComparison.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-08-StringClassComparison.html"><h1 class="title_post">☕️[Java] String 클래스 - 비교</h1></a>
                        <a href="/2024/Java/2024-04-08-StringClassComparison.html" class="txt_post">
                            String 클래스 - 비교
String 클래스를 비교할 때는 == 비교가 아니라 항상 equals() 비교를 해야합니다.

  동일성(Identity) : == 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인
  동등성(Equality) : equals() 메서드를 사용하여 두 객체가 논리적으로 같은지 확인


package lang.string.equals;

public class StringEqualsMain1 {

  public static void main(String[] args) {
    String str1 = new String("hello");
    String str2 = new String("hello");
    System.out.println("new String() == 비교: " + (str1 == str2));
    System.out.println("new String() equals 비교:" + (str1.equals(str2)));

    String str3 = "hello";
    String str4 = "hello";
    System.out.println("리터럴 == 비교: " + (str3 == str4));
    System.out.println("리터럴 equals 비교: " + (str3.equals(str4)));
  }
}


실행 결과
new String() == 비교: false
new String() equals 비교:true
리터럴 == 비교: true
리터럴 equals 비교: true




  str1과 str2는 new String()을 사용해서 각각 인스턴스를 생성했습니다.
    
      서로 다른 인스턴스이므로 동일성(==) 비교에 실패합니다.
    
  
  둘은 내부에 같은 "hello" 값을 가지고 있기 때문에 논리적으로 같습니다.
    
      따라서 동등성(equals()) 비교에 성공합니다.
        
          참고로 String 클래스는 내부 문자열 값을 비교하도록 equals() 메서드를 재정의 해두었습니다.
        
      
    
  





  String str3 = "hello"와 같이 문자열 리터럴을 사용하는 경우 자바는 메모리 효율성과 성능 최적화를 위해 문자열 풀을 사용합니다.
  자바가 실행되는 시점에 클래스에 문자열 리터럴이 있으면 문자열 풀에 String 인스턴스를 미리 만들어둡니다.
    
      이때 같은 문자열이 있으면 만들지 않습니다.
    
  
  String str3 - "hello"와 같이 문자열 리터럴을 사용하면 문자열 풀에서 "hello" 라는 문자를 가진 String 인스턴스를 찾습니다.
    
      그리고 찾은 인스턴스의 참조(x003)를 반환합니다.
    
  
  String str4 = "hello"의 경우 "hello" 문자열 리터럴을 사용하므로 문자열 풀에서 str3과 같은 x003 참조를 사용합니다.
  문자열 풀 덕분에 같은 문자를 사용하는 경우 메모리 사용을 줄이고 문자를 만드는 시간도 줄어들기 때문에 성능도 최적화 할 수 있습니다.


따라서 문자열 리터럴을 사용하는 경우 같은 참조값을 가지므로 == 비교에 성공합니다.


  참고 : 풀(pool)은 자원이 모여있는 곳을 의미합니다.
프로그래밍에서 풀(pool)은 공용 자원을 모아둔 곳을 뜻합니다.
여러 곳에서 함께 사용할 수 있는 객체를 필요할 때 마다 생성하고, 제거하는 것은 비효율적입니다.
대신에 이렇게 문자열 풀에 필요한 String 인스턴스를 미리 만들어두고 여러곳에서 재사용할 수 있다면 성능과 메모리를 더 최적화 할 수 있습니다.
참고로 문자열 풀은 힙 영역을 사용합니다.
그리고 문자열 풀에서 문자를 찾을 때는 해시 알고리즘을 사용하기 때문에 매우 빠른 속도로 원하는 String 인스턴스를 찾을 수 있습니다.


그렇다면 문자열 리터럴을 사용하면 == 비교를 하고, new String()을 직접 사용하는 경우에만 equals() 비교를 사용하면 되지 않을까요?

다음 코드를 봅시다.

package lang.string.equals;

public class StringEqualsMain2 {

  public static void main(String[] args) {
    String str1 = new String("hello");
    String str2 = new String("hello");
    System.out.println("메서드 호출 비교1: " + isSame(str1, str2));

    String str3 = "hello";
    String str4 = "hello";
    System.out.println("메서드 호출 비교2: " + isSame(str3, str4));
  }

  private static boolean isSame(String x, String y) {
    return x == y;
    //return x.equals(y);
  }
}


실행 결과
메서드 호출 비교1: false
메서드 호출 비교2: true


main() 메서드를 만드는 개발자와 isSame() 메서드를 만드는 개발자가 서로 다르다고 가정해봅시다.
isSame()의 경우 매개변수로 넘어오는 String 인스턴스가 new String()으로 만들어진 것인지, 문자열 리터럴로 만들어 진것인지 확인할 수 있는 방법이 없습니다.
따라서 문자열 비교는 항상 equals()를 사용해서 동등성 비교를 해야 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-04-08-ALUandControlUnit.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-04-08-ALUandControlUnit.html"><h1 class="title_post">💾 [CS] ALU와 제어장치</h1></a>
                        <a href="/2024/CS/2024-04-08-ALUandControlUnit.html" class="txt_post">
                            ALU와 제어장치.


  CPU: 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치
  ALU: CPU 내부에 계산을 담당
  레지스터: 명령어를 읽어 들이고 해석하는 제어장치, 작은 임시 저장 장치


ALU




  ALU: 레지스터를 통해 피연산자 를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호 를 받아 들입니다.
    
      레지스터와 제어장치로부터 받아들인 피연산자와 제어 신호로 산술 연산, 논리 연산 등 다양한 연산을 수행합니다.
    
  


ALU가 내보내는 정보.
연산을 수행한 결과는 특정 숫자나 문자가 될 수도 있고, 메모리 주소가 될 수도 있습니다.

  그리고 이 결괏값은 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장됩니다.


CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느립니다.

  ALU가 연산할 때마다 결과를 메모리에 저장한다면 당연하게도 CPU는 메모리에 자주 접근하게 되고, 이는 CPU가 프로그램 실행 속도를 늦출 수 있습니다.
    
      그래서 ALU의 결괏값을 메모리가 아닌 레지스터에 우선 저장하는 것 입니다.
    
  


ALU는 계산 결과와 더불어 플래그를 내보냅니다.

  ALU는 결괏값뿐만 아니라 연산 결과에 대한 추가적인 정보를 내보내야 할 때가 있습니다.
    
      연산 결과에 대한 추가적인 상태 정보를 플래그(flag) 라고 합니다.
    
  


ALU가 내보내는 대표적인 플래그는 아래와 같습니다.




  이러한 플래그는 CPU가 프로그램을 실행하는 도중 반드시 기억해야 하는 일종의 참고 정보입니다.
  플래그들은 플래그 레지스터 라는 레지스터에 저장됩니다.
    
      플래그 값들을 저장하는 레지스터입니다.
        
          이 레지스터를 읽으면 연산 결과에 대한 추가적인 정보, 참고 정보를 얻을 수 있습니다.
        
      
    
  


플레그 레지스터 예시와 설명.
예를 들어 플래그 레지스터가 아래와 같은 구조를 가지고 있고, ALU가 연산을 수행한 직후 부호 플래그가 1이 되었다면 연산 결과는 음수임을 알 수 있습니다.



또한 만약 ALU가 연산을 수행한 직후 플래그 레지스터가 아래와 같다면 제로 플래그가 1이 되었으니 연산 결과는 0임을 알 수 있습니다.



이 밖에도 ALU 내부에는 여러 계산을 위한 회로들이 있습니다.
대표적으로

  덧셈을 위한 가산기
  뺄셈을 위한 보수기
  시프트 연산을 수행해 주는 시프터
  오버플로우를 대비한 오버플로우 검출기
  등등


제어장치.

  제어장치: 제어 신호를 내보내고, 해석하는 부품
  제어 신호: 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호




제어장치가 받아들이는 정보.
첫째. 제어장치는 클럭 신호를 받아들입니다.

  클럭(Clock): 컴퓨터의 모든 부품을 일사분란하게 움직일 수 있게하는 시간 단위
    
      클럭의 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동되거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어 들어는 것 입니다.
      다만, “컴퓨터의 모든 부품이 클럭 신호에 맞춰 작동한다” 라는 말을 “컴퓨터의 모든 부품이 한 클럭마다 작동한다”라고 이해하면 안됩니다.
        
          컴퓨터 부품들은 클럭이라는 박자에 맞춰 작동할 뿐 한 박자마다 작동하는 건 아닙니다.
            
              가령 다음 그림처럼 하나의 명령어가 여러 클럭에 걸쳐 실행될 수 있습니다.
            
          
        
      
    
  




둘째, 제어장치는 ‘해석해야 할 명령어’를 받아들입니다.

  CPU가 해석해야 할 명령어는 명령어 레지스터 라는 특별한 레지스터에 저장됩니다.
  제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려줍니다.


셋째, 제어장치는 플래그 레지스터 속 플래그 값을 받아들입니다.

  플래그는 ALU 연산에 대한 추가적인 상태 정보입니다.
  제어장치는 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생 시킵니다.


넷째, 제어장치는 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호를 받아들입니다.

  제어 신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있습니다.
  제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도 합니다.


제어장치가 내보내는 정보.
여기에는 크게 CPU 외부에 전달하는 제어 신호와 CPU 내부에 전달하는 제어 신호가 있습니다.

  제어장치가 CPU 외부에 제어 신호를 전달한다는 말은 곧, 제어 버스로 제어 신호를 내보낸다는 말과 같습니다.
    
      이러한 제어 신호에는 크게 메모리에 전달하는 제어 신호와 입출력장치에 전달하는 제어 신호가 있습니다.
    
  


제어장치가 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶다면 메모리로 제어 신호를 내보냅니다.

  그리고 제어장치가 입출력장치의 값을 읽거나 입출력장치에 새로운 값을 쓰고 싶을 때는 입출력장치로 제어 신호를 내보냅니다.


제어장치가 CPU 내부에 전달하는 제어 신호에는 크게 ALU에 전달하는 제어 신호와 레지스터에 전달하는 제어 신호가 있습니다.

  ALU에는 수행할 연산을 지시하기 위해, 레지스터에는 레지스터 간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해 제어 신호를 내보냅니다.


키워드로 정리하는 핵심 포인트

  ALU는 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어 신호를 받아들입니다.
  ALU는 연산 결과와 플래그를 내보냅니다.
  제어장치는 클럭, 현재 수행할 명령어, 플래그, 제어 신호를 받아들입니다.
  제어장치는 CPU 내부와 외보루 제어 신호 를 내보냅니다.


check point

  이진수의 음수표현
    
      2의 보수: 모든 0과 1을 뒤집고, 거기에 1을 더한 값
    
  


Q1. ALU가 소프트웨어 개발, 특히 iOS 개발에 어떻게 적용될 수 있는지 설명해 주세요. 예를 들어, 어떻게 ALU가 앱의 성능에 영향을 미칠 수 있는지 구체적인 사례를 들어주세요.
iOS 앱 개발에서 ALU의 역할은 직접적으로 보이지 않지만, 앱의 성능 최적화에 중요합니다. 예를 들어, 이미지 처리나 데이터 암호화 같은 작업은 많은 산술 및 논리 연산을 필요로 하며, 이는 ALU에서 처리됩니다. 따라서, ALU의 효율적인 사용은 앱의 반응 속도와 전반적인 성능에 직접적인 영향을 미칩니다.

Q2. ALU(산술 논리 장치)의 기본적인 기능은 무엇이며, 컴퓨터 프로세서 내에서 어떤 역할을 합니까?
ALU는 컴퓨터의 프로세서 내에 있는 하드웨어 구성 요소로, 기본적인 산술 연산(덧셈, 뺄셈, 곱셈, 나눗셈)과 논리 연산(AND, OR, XOR, NOT)을 수행합니다. 이는 모든 종류의 컴퓨터 프로그램 실행에 기본이 되는 연산이며, 프로세서가 복잡한 계산과 데이터 처리 작업을 수행할 수 있게 해줍니다.

Q3. Java 애플리케이션의 성능 최적화와 관련하여, ALU의 역할과 중요성에 대해 설명해 주세요.
Java 애플리케이션의 성능 최적화에서 ALU의 역할은 중요합니다. ALU는 계산 작업의 실제 수행 장소이므로, ALU의 효율성은 애플리케이션의 처리 속도와 직접적인 관련이 있습니다. 특히, 고성능을 요구하는 애플리케이션에서는 ALU를 통해 수행되는 연산의 최적화가 애플리케이션 전체의 성능을 크게 향상시킬 수 있습니다.

Q4. 멀티 쓰레딩 Java 애플리케이션에서 ALU의 처리 능력이 중요한 이유는 무엇이라고 생각하나요?
멀티 쓰레딩 애플리케이션에서는 여러 쓰레드가 동시에 연산을 수행할 수 있으므로, ALU의 처리 능력이 성능의 병목 현상을 방지하는 데 중요합니다. 효율적인 ALU 설계는 복수의 연산을 동시에 빠르게 처리할 수 있게 해주며, 이는 멀티 쓰레딩 환경에서 애플리케이션의 반응 속도와 처리량을 크게 향상시킬 수 있습니다.

Q5. 현대의 CPU가 여러 ALU를 갖고 있는 경우, 이것이 Java 백엔드 시스템의 성능에 어떤 영향을 미칠 수 있나요?
여러 ALU를 갖는 프로세서는 동시에 여러 연산을 수행할 수 있으므로, Java 백엔드 시스템에서의 병렬 처리 능력을 크게 향상시킵니다. 이는 데이터베이스 쿼리 처리, 대규모 데이터 분석, 실시간 트랜잭션 처리 등 다양한 작업에서 성능 이점을 제공할 수 있습니다.

Q6. Java 애플리케이션에서 복잡한 수학적 연산을 효율적으로 처리하기 위해 개발자가 고려해야 할 ALU와 관련된 측면은 무엇인가요?
개발자는 복잡한 수학적 연산을 효율적으로 처리하기 위해, ALU의 연산 처리 능력을 최대화하는 방법을 고려해야 합니다. 이는 알고리즘의 최적화, 복잡한 연산의 분할 및 정복 전략 적용, 필요한 경우 하드웨어 가속기(예: GPU) 사용 등을 포함할 수 있습니다.

Q7. ALU의 한계를 넘어서서 Java 애플리케이션의 성능을 향상시키기 위해 사용할 수 있는 다른 하드웨어 기반 최적화 기술은 무엇이 있을까요?
ALU의 한계를 넘어서 Java 애플리케이션의 성능을 향상시키기 위해, 다중 코어 프로세싱, 병렬 처리, GPU 가속, FPGA(필드 프로그래밍 게이트 어레이)를 활용한 커스텀 하드웨어 가속 등의 기술을 활용할 수 있습니다. 이러한 기술들은 특정 유형의 작업에 대해 상당한 성능 향상을 제공할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-06-StringClassBasic.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-06-StringClassBasic.html"><h1 class="title_post">☕️[Java] String 클래스 - 기본</h1></a>
                        <a href="/2024/Java/2024-04-06-StringClassBasic.html" class="txt_post">
                            String 클래스 - 기본.
자바에서 문자를 다루는 대표적인 타입은 char, String 2가지가 있습니다.

package lang.string;

public class CharArrayMain {

  public static void main(String[] args) {
    char[] charArr = new char[]{'h', 'e', 'l', 'l', 'o'};
    System.out.println(charArr);

    String str = "hello";
    System.out.println("str = " + str);
  }
}


실행 결과
hello
str = hello


기본형인 char는 문자 하나를 다룰 때 사용합니다.

  char를 사용해서 여러 문자를 나열하려면 char[]을 사용해야 합니다.
    
      하지만 이렇게 char[]을 직접 다루는 방법은 매우 불편하기 때문에 자바는 문자열을 매우 편리하게 다룰 수 있는 String 클래스를 제공합니다.
    
  


String 클래스를 통해 문자열을 생성하는 방법은 2가지가 있습니다.
package lang.string;

public class StringBasicMain {

  public static void main(String[] args) {
    String str1 = "hello";
    String str2 = new String("hello");

    System.out.println("str1 = " + str1);
    System.out.println("str2 = " + str2);
  }
}


  쌍따옴표: "hello"
  객체 생성: new String("hello");


String은 클래스입니다.

  int, boolean 같은 기본형이 아니라 참조형입니다.
    
      따라서 str1 변수에는 String 인스턴스의 참조값만 들어갈 수 있습니다.
        
          따라서 다음 코드는 뭔가 어색합니다.
            String str1 = "hello";
            
          
        
      
    
  


문자열은 매우 자주 사용됩니다.

  그래서 편의상 쌍따옴표로 문자열을 감싸면 자바 언어에서 new String("hello")와 같이 변경해 줍니다.(이 경우 실제로는 성능 최적화를 위해 문자열 풀을 사용합니다.)


String str1 = "hello"; // 기존
String str1 = new String("hello"); // 변경


String 클래스 구조
String 클래스는 대략 다음과 같이 생겼습니다.

public final class String {
    
    // 문자열 보관
    private final char[] value; // 자바 9 이전
    private final byte[] value; // 자바 9 이후
    
    // 여러 메서드
    public String concat(String str) {...}
    public int length() {...}
}

클래스이므로 속성과 기능을 가집니다.

속성(필드)
private final char[] value;

여기에는 String의 실제 문자열 값이 보관됩니다.

  문자 데이터 자체는 char[] 에 보관됩니다.
    
      String 클래스는 개발자가 직접 다루기 불편한 char[]을 내부에 감추고 String 클래스를 사용하는 개발자가 편리하게 문자열을 다룰 수 있도록 다양한 기능을 제공합니다.
        
          그리고 메서드 제공을 넘어서 자바 언어 차원에서도 여러 편의 문법을 제공합니다.
        
      
    
  



  참고: 자바 9 이후 String 클래스 변경 사항
자바 9부터 String 클래스에서 char[] 대신에 byte[]을 사용합니다.
  private final byte[] value;
  
  자바에서 문자 하나를 표현하는 char는 2byte를 차지합니다.
그런데 영어, 숫자는 보통 1byte로 표현이 가능합니다.
그래서 단순 영어, 숫자로 표현된 경우 1byte를 사용하고(정확히는 Latin-1 인코딩의 경우 1byte 사용)
그렇지 않은 나머지의 경우 2byte인 UTF-16 인코딩을 사용합니다.
따라서 메모리를 더 효율적으로 사용할 수 있게 변경되었습니다.


기능(메서드)
String 클래스는 문자열로 처리할 수 있는 다양한 기능을 제공합니다.
기능이 방대하므로 필요한 기능이 있으면 검색하거나 API 문서를 찾아봅시다.
주요 메서드는 다음과 같습니다.

  length() : 문자열의 길이를 반환합니다.
  charAt(inte index) : 특정 인덱스의 문자를 반환합니다.
  substring(int beinIndex, int endIndex) : 문자열의 부분 문자열을 반환합니다.
  indexOF(String str) : 특정 문자열이 시작되는 인덱스를 반환합니다.
  toLowerCase(), toUpperCase() : 문자열을 소문자 또는 대문자로 변환합니다.
  trim() : 문자열 양 끝의 공백을 제거합니다.
  concat(String str) : 문자열을 더합니다.


String 클래스와 참조형
String은 클래스입니다.

  따라서 기본형이 아니라 참조형입니다.
    
      참조형은 변수에 계산할 수 있는 값들이 들어있는 것이 아니라 x001과 같이 계산할 수 없는 참조값이 들어있습니다.
        
          따라서 원칙적으로 + 같은 연산을 사용할 수 없습니다.
```java
package lang.string;
        
      
    
  


public class StringConcatMain {

public static void main(String[] args) {
    String a = “hello”;
    String b = “ jave”;

String result1 = a.concat(b);
String result2 = a + b;

System.out.println("result1 = " + result1);
System.out.println("result2 = " + result2);   } } ``` - 자바에서 문자열을 더할 때는 `String`이 제공하는 `concat()`과 같은 메서드를 사용해야 합니다.
- 하지만 문자열은 너무 자주 다루어지기 때문에 자바 언어에서 편의상 특별히 `+` 연산을 제공합니다.


실행 결과
result1 = hello jave
result2 = hello jave


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-05-ImmutableObjectSummary.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-05-ImmutableObjectSummary.html"><h1 class="title_post">☕️[Java] 불변 객체 - 정리</h1></a>
                        <a href="/2024/Java/2024-04-05-ImmutableObjectSummary.html" class="txt_post">
                            불변 객체 - 정리.
지금까지 왜 이렇게 불변 객체 이야기를 많이 했을까요?

  자바에서 가장 많이 사용되는 String 클래스가 바로 불변 객체이기 때문입니다.
  뿐만 아니라 자바가 기본으로 제공하는 Integer, LocalDate 등 수 많은 클래스가 불변으로 설계되어 있습니다.
    
      따라서 불변 객체가 필요한 이유와 원리를 제대로 이해해야, 이런 기본 클래스들도 제대로 이해할 수 있습니다.
    
  


모든 클래스를 불변으로 만드는 것은 아닙니다.
우리가 만드는 대부분의 클래스는 값을 변경할 수 있게 만들어집니다.

  예를 들어서 회원 클래스의 경우 회원의 여러 속성을 변경할 수 있어야 합니다.
    
      가변 클래스가 더 일반적이고, 불변 클래스는 값을 변경하면 안되는 특별한 경우에 만들어서 사용한다고 생각하면 됩니다.
        
          때로는 같은 기능을 하는 클래스를 하나는 불변으로 하나는 가변으로 각각 만드는 경우도 있습니다.
        
      
    
  


클래스를 불변으로 설계하는 이유는 더 많습니다.

  캐시 안정성
  멀티 쓰레드 안정성
  엔티티 값 타입


지금은 이런 부분을 다 이해할 수는 없습니다.

  관련 내용을 학습하다 보면 자연스럽게 이번에 배운 불변 객체가 떠오르면서 관련된 내용을 본질적으로 더 잘 이해할 수 있을 것입니다.
  프로그래밍을 더 깊이있게 학습할 수 록 다양한 불변 클래스 이용 사례를 만나고 이해하게 됩니다.
    
      따라서 지금은 불변 클래스가 어디에 사용되고, 어떻게 활용되는지 보다는 불변 클래스의 원리를 이해하는 정도면 충분합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-05-ImmutableObjectChangeValue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-05-ImmutableObjectChangeValue.html"><h1 class="title_post">☕️[Java] 불변 객체 - 값 변경</h1></a>
                        <a href="/2024/Java/2024-04-05-ImmutableObjectChangeValue.html" class="txt_post">
                            불변 객체 - 값 변경.
불변 객체를 사용하지만 그래도 값을 변경해야 하는 메서드가 필요하면 어떻게 해야할까요?

  예를 들어서 기존 값에 새로운 값을 더하는 add()와 같은 메서드가 있다고 합시다.


먼저 변경 가능한 객체에서 값을 변경하는 간단한 예를 만들어봅시다.

package lang.immutable.change;

public class MutableMain {

  public static void main(String[] args) {
    MutableObj obj = new MutableObj(10);
    obj.add(20);
    // 계산 이후의 기존 값은 사라짐
    System.out.println("obj = " + obj.getValue());
  }
}


실행 결과
obj = 30



  MutableObj을 10이라는 값으로 생성합니다.
    
      이후에 obj.add(20)을 통해서 10 + 20을 수행합니다.
        
          계산 이후에 기존에 있던 10이라는 값은 사라집니다.
          MutableObj의 상태(값)가 10 -&gt; 30으로 변경되었습니다.
        
      
      obj.getValue()를 호출하면 30이 출력됩니다.
    
  


이번에는 불변 객체에서 add() 메서드를 어떻게 구현하는지 알아봅시다.

  참고로 불변 객체는 변하지 않아야 합니다.


package lang.immutable.change;

public class ImmutableObj {

  private final int value;

  public ImmutableObj(int value) {
    this.value = value;
  }

  public ImmutableObj add(int addValue) {
    int result = value + addValue;
    return new ImmutableObj(result);
  }

  public int getValue() {
    return value;
  }
}


  여기서 핵심은 add() 메서드 입니다.
  불변 객체는 값을 변경하면 안됩니다!
    
      그러면 이미 불변 객체가 아닙니다!
      하지만 여기서는 기존 값에 새로운 값을 더해야 합니다.
    
  
  불변 객체는 기존 값은 변경하지 않고 대신에 계산 결과를 바탕으로 새로운 객체를 만들어서 반환합니다.
    
      이렇게 하면 불변도 유지하면서 새로운 결과도 만들 수 있습니다.
    
  


package lang.immutable.change;

public class ImmutableMain1 {

  public static void main(String[] args) {
    ImmutableObj obj1 = new ImmutableObj(10);
    ImmutableObj obj2 = obj1.add(20);

    // 계산 이후에도 기존값과 신규값 모두 확인 가능
    System.out.println("obj1 = " + obj1.getValue());
    System.out.println("obj2 = " + obj2.getValue());
  }
}


실행 결과
obj1 = 10
obj2 = 30


  불변 객체를 설계할 때 기존 값을 변경해야 하는 메서드가 필요할 수 있습니다.
    
      이때는 기존 객체의 값을 그대로 두고 대신에 변경된 결과를 새로운 객체에 담아서 반환하면 됩니다.
        
          결과를 보면 기존 값이 그대로 유지되는 것을 확인할 수 있습니다.
        
      
    
  





  add(20)을 호출합니다.
  기존 객체에 있는 10과 인수로 입력한 20을 더합니다. 이때 기존 객체의 값을 변경하면 안되므로 계산 결과를 기반으로 새로운 객체를 만들어서 반환합니다.
  새로운 객체는 x002 참조를 가집니다. 새로운 객체의 참조값을 obj2에 대입합니다.


만약 여기서 다음과 같이 새로 생성된 반환 값을 사용하지 않으면 어떻게 될까요?
package lang.immutable.change;

public class ImmutableMain2 {

  public static void main(String[] args) {
    ImmutableObj obj1 = new ImmutableObj(10);
    obj1.add(20);

    // 계산 이후에도 기존값과 신규값 모두 확인 가능
    System.out.println("obj1 = " + obj1.getValue());
  }
}


실행 결과
obj1 = 10


  실행 결과처럼 아무것도 처리되지 않은 것 처럼 보일 것입니다.
    
      불변 객체에서 변경과 관련된 메서드들은 보통 객체를 새로 만들어서 반환하기 때문에 꼭! 반환 값을 받아야 합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/SQL/2024-04-04-ReplaceSubstringConcat.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/SQL/2024-04-04-ReplaceSubstringConcat.html"><h1 class="title_post">💉[SQL] REPLACE, SUBSTRING, CONCAT</h1></a>
                        <a href="/2024/SQL/2024-04-04-ReplaceSubstringConcat.html" class="txt_post">
                            REPLACE
‘REPLACE’ 함수는 SQL에서 문자열 내의 특정 부분을 다른 문자열로 바꾸고자 할 때 사용됩니다.

  이 함수는 데이터 정제나 수정 작업에서 특히 유용하며, 기존 문자열 내의 특정 패턴이나 문자를 찾아 이를 새로운 문자열로 대체하는 기능을 제공합니다.
  ‘REPLACE’ 는 로그 데이터 정리, 사용자 입력 데이터의 표준화, 데이터 마이그레이션 작업 등 다양한 상황에서 활용될 수 있습니다.


‘REPLACE’ 사용 예

  특정 문자열 대체: 고객 데이터에서 전화번호 형식을 변경하고 싶을 때
    SELECT REPLACE(phone_number, '-', '') FROM customers;
    
    이 쿼리는 ‘customers’ 테이블의 ‘phone_number’ 열에서 모든 ’-‘ 를 제거합니다.
예를 들어, ‘123-456-7890’ 이라는 전화번호가 있을 경우, ‘1234567890’ 으로 변경됩니다.
  
  데이터 정제: 사용자의 이메일 주소에서 도메인을 변경하고 싶을 때
    UPDATE users SET email = REPLACE(email, '@old_domain.com', '@new_domain.com');
    
    이 쿼리는 ‘users’ 테이블의 ‘email’ 열에서 ‘@old_domail.com’ 을 ‘@new_domain.com’ 으로 변경합니다.
  
  텍스트 내용 수정: 상품 설명에서 특정 단어를 새로운 단어로 바꾸고 싶을 때
    UPDATE products SET description = REPLACE(description, 'oldword', 'newword');
    
    이 쿼리는 ‘products’ 테이블의 ‘description’ 열에서 ‘oldword’ 를 ‘newword’ 로 변경합니다.
  


‘REPLACE’ 함수의 특징.

  ‘REPLACE’ 는 대소문자를 구분하여 작동합니다.
    
      대소문자 구분 없이 대체를 하고자 할 경우, 추가적인 함수나 조건을 사용해야 할 수 있습니다.
    
  
  문자열 내에서 지정된 패턴이나 문자열을 찾아 모두 대체합니다.
    
      찾고자 하는 문자열이 존재하지 않으면, 원본 문자열이 변경 없이 그대로 반환됩니다.
    
  
  ‘REPLACE’ 함수는 ‘SELECT’, ‘UPDATE’ 등의 쿼리 내에서 사용할 수 있으며, 데이터 조회 또는 수정 작업에 모두 적용할 수 있습니다.


사용 시 고려사항

  대량의 데이터를 처리할 때는 ‘REPLACE’ 함수를 사용하는 쿼리의 성능에 주의해야 합니다.
    
      특히 ‘UPDATE’ 작업에서는 대체 작업으로 인해 대량의 데이터가 변경될 수 있으므로, 사전에 작업 범위를 잘 파악하고 필요한 백업을 수행하는 것이 좋습니다.
    
  
  문자열 대체 작업을 수행할 때는 원치 않는 데이터 변경을 방지하기 위해, 대체할 문자열이 정확히 일치하는지 사전에 확인하는 것이 중요합니다.


‘REPLACE’ 함수는 문자열 데이터를 쉽게 수정하고 정제할 수 있는 강력한 도구로, 데이터베이스 내의 데이터 관리 및 유지보수 작업에 널리 사용됩니다.

SUBSTRING
‘SUBSTRING’ 함수는 SQL에서 문자열의 특정 부분을 추출할 때 사용됩니다.

  이 함수는 문자열 데이터 내에서 특정 위치를 기준으로 한 부분 문자열(substring)을 반환하며, 데이터 정제, 특정 형식의 데이터 추출, 또는 문자열 처리 작업에서 매우 유용합니다.
  ‘SUBSTRING’ 은 로그 분석, 데이터 마이그레이션, 사용자 입력의 특정 부분 처리 등 다양한 상황에서 활용될 수 있습니다.


‘SUBSTRING’ 사용 예

  특정 위치의 문자열 추출: 사용자 이메일에서 도메인 부분만을 추출하고 싶을 때
    SELECT SUBSTRING(email FROM POSITION ('@' IN email) + 1) FROM users;
    
    이 쿼리는 ‘users’ 테이블의 ‘email’ 열에서 ’@’ 기호 뒤의 도메인 부분을 추출합니다.
  
  고정된 형식의 문자열 처리: 전화번호에서 지역 코드를 추출하고 싶을 때
    SELECT SUBSTRING(phone_number, 1, 3) FROM customers;
    
    이 쿼리는 ‘customers’ 테이블의 ‘phone_number’ 열에서 처음 3자리(지역 코드)를 추출합니다.
  
  문자열의 특정 부분 수정 작업에 사용: 주소에서 특정 부분을 다른 형식으로 변경하고 싶을 때
    UPDATE addresses SET street = SUBSTRING(street, 1, 10) || '...' WHERE LENGTH(street) &gt; 10;
    
    이 쿼리는 ‘addresses’ 테이블의 ‘street’ 열에서 문자열의 길이가 10자를 초과하는 경우, 처음 10자만을 남기고 그 뒤를 ‘…‘ 으로 대체합니다.
  


‘SUBSTRING’ 함수의 특징

  ‘SUBSTRING’ 은 문자열의 특정 섹션을 반환하는 데 사용되며, 시작 위치와 길이(선택적)를 지정하여 원하는 부분 문자열을 추출할 수 있습니다.
  다양한 문자열 처리 작업에 활용될 수 있으며, 데이터의 형식을 변경하거나, 특정 패턴에 기반한 정보를 추출하는 등의 목적으로 사용됩니다.
  함수의 정확한 구문은 사용하는 SQL 데이터베이스 시스템에 따라 약간씩 다를 수 있으므로, 해당 시스템의 문서를 참조하는 것이 좋습니다.


사용 시 고려사항

  ‘SUBSTRING’ 함수를 사용할 때는 문자열의 인덱스가 1부터 시작한다는 점을 주의해야 합니다.(대부분의 SQL 시스템에서).
  대량의 데이터를 처리할 때는 ‘SUBSTRING’ 함수를 사용하는 쿼리의 성능에 주의해야 합니다. 필요한 경우, 적절한 인덱스 사용과 데이터 필터링을 통해 성능을 최적화할 수 있습니다.


‘SUBSTRING’ 함수는 문자열 데이터를 효과적으로 처리하고 분석하는 데 있어 필수적인 도구로, 데이터베이스 내에서 다양한 문자열 조작 작업을 수행하는 데 널리 사용됩니다.

CONCAT
‘CONCAT’ 함수는 SQL에서 두 개 이상의 문자열을 하나로 결합할 때 사용됩니다.

  이 함수는 데이터베이스 내에서 다양한 문자열 정보를 합쳐 새로운 문자열 값을 생성하고자 할 때 유용하며, 보고서 작성, 데이터 형식의 표준화, 사용자 이름이나 주소와 같은 데이터의 결합 등 다양한 상황에서 활용될 수 있습니다.


‘CONCAT’ 사용 예

  단순한 문자열 결합: 사용자의 이름과 성을 하나의 문자열로 결합하고 싶을 때
    SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM users;
    
    이 쿼리는 ‘users’ 테이블의 ‘first_name’ 과 ‘last_name’ 을 공백으로 구분하여 결합한 후, ‘full_name’ 이라는 새로운 열로 결과를 반환합니다.
  
  복수의 열 결합: 고객의 주소 정보를 하나의 문자열로 결합하고 싶을 때
    SELECT CONCAT(street_address, ', ', city, state, ' ', postal_code) AS full_address FROM customers;
    
    이 쿼리는 ‘customers’ 테이블에서 여러 주소 관련 열을 콤마와 공백을 사용하여 결합하고, 이를 ‘full_address’ 라는 새로운 열로 결과를 반환합니다.
  
  데이터 형식 표준화: 상품 코드와 상품 이름을 결합하여 표준 형식의 상품 정보를 생성하고 싶을 떄
    SELECT CONCAT(product_code, ': ', product_name) AS product_info FROM products;
    
    이 쿼리는 ‘products’ 테이블의 ‘product_code’ 와 ‘product_name’ 을 콜론과 공백으로 구분하여 결합한 후,
‘product_info’ 라는 새로운 열로 결과를 반환합니다.
  


‘CONCAT’ 함수의 특징

  ‘CONCAT’ 함수는 두 개 이상의 문자열을 매개변수로 받아 이들을 순서대로 결합한 새로운 문자열을 생성합니다.
  거의 모든 SQL 데이터베이스 시스템에서 지원되며, 문자열 처리와 데이터 형식의 변환에 널리 사용됩니다.
  
    
      
        
          일부 데이터베이스 시스템에서는 ‘CONCAT’ 대신 연산자(**’
           
          ‘** 등)를 사용하여 문자열을 결합할 수도 있습니다.
        
      
    
  


사용 시 고려사항

  결합하려는 문자열 중 하나라도 ‘NULL’ 값을 포함하는 경우, ‘CONCAT’ 의 동작은 데이터베이스 시스템에 따라 다를 수 있습니다.
    
      예를 들어, 일부 시스템은 ‘NULL’ 을 빈 문자열로 취급할 수 있으나, 다른 시스템에서는 전체 결과가 ‘NULL’ 이 될 수 있습니다.
    
  
  복잡한 문자열 결합을 수행할 때는 성능에 주의해야 하며, 특히 대량의 데이터를 처리할 때는 쿼리 성능을 테스트하고 최적화하는 것이 중요합니다.


‘CONCAT’ 함수는 문자열 데이터를 결합하고 조작하는 과정에서 필수적인 도구로, 데이터베이스 내에서 다양한 문자열 관련 작업을 구행하는 데 활용됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-04-04-commandStructure.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-04-04-commandStructure.html"><h1 class="title_post">💾 [CS] 명령어의 구조</h1></a>
                        <a href="/2024/CS/2024-04-04-commandStructure.html" class="txt_post">
                            명령어의 구조

연산코드와 오퍼랜드

아래 그림을 보면 색 배경 필드는 명령의 ‘작동’, 달리 말해 ‘연산’을 담고 있고 흰색 배경 필드는 ‘연산에 사용할 데이터’ 또는 ‘연산에 사용할 데이터가 저장된 위치’를 담고 있습니다.




  명령어 : 연산 코드와 오퍼랜드로 구성되어 있습니다.
  연산코드(Opreation Code): 색 배경 필드 값, 즉 ‘명령어가 수행할 연산’을 연산코드(Operation Code) 라 합니다.
  오퍼랜드(Operand) : 흰색 배경 필드 값, 즉 ‘연산에 사용할 데이터’ 또는 ‘연산에 사용할 데이터가 저장된 위치’를 오퍼랜드라고 합니다.


연산 코드는 연산자, 오퍼랜드는 피연산자 라고도 부릅니다.


  연산 코드 필드: 연산 코드가 담기는 영역(색칠된 부분)
  오퍼랜드 필드: 오퍼랜드가 담기는 영역(색칠되지 않은 부분)


오퍼랜드
오퍼랜드는 ‘연산에 사용할 데이터’ 또는 ‘연산에 사용할 데이터가 저장된 위치’를 의미합니다.

  그래서 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있습니다.
  다만 오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기보다는, 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담깁니다.
    
      그래서 오퍼랜드 필드를 주소 필드 라고 부르기도 합니다.
    
  


오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한 개만 있을 수도 있고, 두 개 또는 세 개 등 여러개가 있을 수도 있습니다.

  오퍼랜드가 하나도 없는 명령어 0-주소 명령어
  오퍼랜드가 하나인 명령어 1-주소 명령어
  오퍼랜드가 두 개인 명령어 2-주소 명령어
  오퍼랜드가 세 개인 명령어 3-주소 명령어


연산 코드
연산 코드 종류는 매우 많지만, 가장 기본적인 연산 코드 유형은 크게 네 가지로 나눌 수 있습니다.

  데이터 전송
  산술/논리 연산
  제어 흐름 변경
  입출력 제어




주소 지정 방식
연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치를 유효 주소(effective address) 라고 합니다.

오퍼랜드 필드에 데이터가 저장된 위피를 명시 할 때 연산에 사용할 데이터 위치를 찾는 방법을 주소 지정 방식(addressing mode) 이라고 합니다

  다시 말해, 주소 지정 방식은 유효 주소를 찾는 방법입니다.


즉시 주소 지정 방식

  즉시 주소 지정 방식(immediate addressing mode): 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식입니다.
    
      이런 방식은 표현할 수 있는 데이터의 크기가 작아지는 단점이 있지만, 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 이하 설명할 주소 지정 방식들보다 빠릅니다.
    
  


직접 주소 지정 방식

  직접 주소 지정 방식(direct addressing mode): 오퍼랜드 필드에 유효 주소를 직접 명시하는 방식입니다.
    
      오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 더 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들었습니다.
      다시 말해 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있습니다.
    
  


간접 주소 지정 방식

  간접 주소 지정 방식(indirect addressing mode): 유효 주소의 주소를 오퍼랜드 필드에 명시합니다. 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓습니다.
    
      두 번의 메모리 접근이 필요하기 때문에 앞서 설명한 주소 지정 방식들보다 일반적으로 느린 방식입니다.
    
  


레지스터 주소 지정 방식

  레지스터 주소 지정 방식(register addressing mode): 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법입니다.
    
      일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠릅니다.
      그러므로 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있습니다.
      다만, 레지스터 주소 지정 방식은 직접 주소 지정 방식과 비슷한 문제를 공유합니다. 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다는 점입니다.
    
  


레지스터 간접 주소 지정 방식

  레지스터 간접 주소 지정 방식(register indirect addressing mode): 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법입니다.
    
      유효 주소를 찾는 과정이 간전 주소 지정 방식과 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어든다는 차이이자 장점이 있습니다.
      레지스터 간접 주소 지장 방식은 간접 주소 지정 방식보다 빠릅니다.
    
  


정리

  연산에 사용할 데이터를 찾는 방법을 주소 지정 방식 이라고 했습니다.
  연산에 사용할 데이터가 저장된 위치를 유효 주소 라고 했습니다.
  대표적인 주소 지정 방식으로 아래의 다섯 가지 방식을 소개했습니다.
    
      각각의 방식이 오퍼랜드 필드에 명시하는 값을 정리해 보면 아래와 같습니다.
        
          즉시 주소 지정 방식: 연산에 사용할 데이터
          직접 주소 지정 방식: 유효 주소(메모리 주소)
          간접 주소 지정 방식: 유효 주소의 주소
          레지스터 주소 지정 방식: 유효 주소(레지스터 이름)
          레지스터 간접 주소 지정 방식: 유효 주소를 저장한 레지스터
        
      
    
  


키워드로 정리하는 핵심 포인트

  명령어 는 연산 코드와 오퍼랜드로 구성됩니다.
  연산 코드는 명령어가 수행할 연산을 의미합니다.
  오퍼랜드는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 의미합니다.
  주소 지정 방식은 연산에 사용할 데이터 위치를 찾는 방법입니다.


Q1. Swift에서 메모리 주소에 접근하기 위해 어떤 타입을 사용할 수 있는지 설명해 주세요. 그리고 왜 이러한 접근 방식이 필요할까요?
Swift에서 메모리 주소에 직접 접근하기 위해 UnsafePointer&lt;T&gt; 타입과 그 변형인 UnsafeMutablePointer&lt;T&gt;를 사용할 수 있습니다. 이러한 포인터들은 C 언어의 포인터와 유사하게 작동하며, 메모리의 특정 위치를 직접 가리키는 데 사용됩니다. 이러한 접근 방식은 일반적으로 Swift의 안전성 및 추상화 원칙에 어긋나지만, 성능 최적화, 기존 C 기반 코드와의 상호 작용, 혹은 저수준 시스템 인터페이스와의 직접적인 상호 작용이 필요한 경우에 필요할 수 있습니다. 예를 들어, 대량의 데이터 처리나 기존 C 라이브러리의 함수를 호출할 때 이러한 방식이 유용할 수 있습니다.

아래는 주니어 Java 백엔드 개발자 면접 질문에 대한 모범 답안 예시입니다. 이 답변들은 Java의 메모리 관리와 관련된 기본적인 지식을 보여주는 데 목적이 있습니다.

Q2. Java에서는 일반적으로 개발자가 직접 메모리 주소를 다루지 않습니다. 이에 대한 이유를 설명해 주세요. 또한, 자동 메모리 관리는 어떤 장점을 제공하나요?

답변: Java에서 개발자가 직접 메모리 주소를 다루지 않는 주된 이유는 Java가 자동 메모리 관리 시스템인 가비지 컬렉션(Garbage Collection, GC)을 제공하기 때문입니다. 이로 인해 메모리 누수와 같은 오류를 방지하고, 개발자가 메모리 관리에 드는 시간과 노력을 줄일 수 있습니다. 자동 메모리 관리의 장점으로는 안정성의 향상, 메모리 관리 오류의 감소, 그리고 개발자의 생산성 향상 등이 있습니다.

Q3. JVM의 메모리 모델을 설명해 주세요. Heap과 Stack 메모리 영역의 차이점은 무엇이며, 각각 어떤 종류의 데이터를 저장하나요?

답변: JVM의 메모리 모델은 크게 Heap 영역과 Stack 영역으로 나뉩니다. Heap 영역은 모든 스레드에 걸쳐 공유되며, 주로 객체와 클래스의 메타데이터가 저장됩니다. 가비지 컬렉션은 이 Heap 영역에서 주로 작동합니다. 반면, Stack 영역은 스레드 별로 별도로 할당되며, 메소드 호출과 관련된 지역 변수와 참조 변수를 저장합니다. Stack은 LIFO(Last In, First Out) 방식으로 데이터를 관리합니다.

Q4. 대규모 데이터 처리 작업을 수행할 때 Java에서 메모리 효율을 최적화하는 방법에는 어떤 것들이 있나요?

답변: 대규모 데이터 처리 시 메모리 효율을 최적화하기 위해, 객체 재사용, 적절한 컬렉션 선택, 스트림 API 사용, 그리고 메모리 캐싱 전략 등을 적용할 수 있습니다. 예를 들어, 객체 풀링을 통해 빈번히 생성 및 파괴되는 객체의 생성 비용을 줄일 수 있습니다. 또한, 데이터 양에 따라 적절한 자료구조를 선택하여 메모리 사용량과 성능을 균형있게 관리할 수 있습니다.

Q5. JNI(Java Native Interface)는 무엇이며, 왜 사용하나요? Java 애플리케이션에서 JNI를 사용하여 네이티브 코드와 상호 작용하는 예를 들 수 있나요?

답변: JNI(Java Native Interface)는 Java 코드 내에서 C나 C++과 같은 네이티브 코드를 호출하거나, 반대로 네이티브 코드에서 Java 코드를 호출할 수 있는 프로그래밍 프레임워크입니다. JNI는 시스템 레벨의 리소스나 레거시 라이브러리를 사용해야 할 때, 또는 성능상의 이유로 직접 하드웨어를 제어해야 할 때 사용됩니다. 예를 들어,

고성능 그래픽 처리나 특정 하드웨어 장치와의 직접적인 상호작용을 구현할 때 JNI를 사용할 수 있습니다.

Q6. 가비지 컬렉션(Garbage Collection)의 기본 원리를 설명해 주세요. Java에서 가비지 컬렉터의 작동 방식에 영향을 미칠 수 있는 프로그래밍 관행에는 어떤 것들이 있나요?

답변: 가비지 컬렉션은 참조되지 않는 객체를 자동으로 검출하고, 이를 메모리에서 제거하여 메모리를 회수하는 프로세스입니다. Java에서 가비지 컬렉터의 효율성에 영향을 미칠 수 있는 프로그래밍 관행으로는, 객체 참조를 적절히 해제하는 것, 대용량 객체의 재사용, 그리고 적절한 컬렉션 사용 등이 있습니다. 불필요한 객체 참조를 남겨두지 않고, 메모리 사용량이 큰 객체는 풀링 기법을 사용하여 관리함으로써, 가비지 컬렉터의 부하를 줄이고 애플리케이션의 성능을 개선할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-04-ImmutableObjectExample.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-04-ImmutableObjectExample.html"><h1 class="title_post">☕️[Java] 불변 객체 - 예제</h1></a>
                        <a href="/2024/Java/2024-04-04-ImmutableObjectExample.html" class="txt_post">
                            불변 객체 - 예제
조금 더 복잡하고 의미있는 예제를 통해서 불변 객체의 사용 예를 확인해봅시다.
앞의 Address, ImmutableAddress를 그래로 활용합니다.

변경 클래스 사용
package lang.immutable.address;

public class MemberMainV1 {

  public static void main(String[] args) {
    Address address = new Address("서울");

    MemberV1 memberA = new MemberV1("회원A", address);
    MemberV1 memberB = new MemberV1("회원B", address);

    // 회원A, 회원B의 처음 주소는 모두 서울
    System.out.println("memberA = " + memberA);
    System.out.println("memberB = " + memberB);

    // 회원 B의 주소를 부산으로 변경해야함
    memberB.getAddress().setValue("부산");
    System.out.println("부산 -&gt; memberB.address");
    System.out.println("memberA = " + memberA);
    System.out.println("memberB = " + memberB);
  }
}


  회원A와 회원B는 둘다 서울에 살고 있습니다.
    
      중간에 회원B의 주소를 부산으로 변경해야 합니다.
      그런데 회원A와 회원B는 같은 Address 인스턴스를 참조하고 있습니다.
        
          회원B의 주소를 부산으로 변경하는 순간 회원A의 주소도 부산으로 변경됩니다.
        
      
    
  


실행 결과
memberA = MemberV1{name='회원A', address=Address{value='서울'}}
memberB = MemberV1{name='회원B', address=Address{value='서울'}}
부산 -&gt; memberB.address
memberA = MemberV1{name='회원A', address=Address{value='부산'}}
memberB = MemberV1{name='회원B', address=Address{value='부산'}}


package lang.immutable.address;

public class MemberMainV2 {

  public static void main(String[] args) {
    ImmutableAddress address = new ImmutableAddress("서울");

    MemberV2 memberA = new MemberV2("회원A", address);
    MemberV2 memberB = new MemberV2("회원B", address);

    // 회원A, 회원B의 처음 주소는 모두 서울
    System.out.println("memberA = " + memberA);
    System.out.println("memberB = " + memberB);

    // 회원B의 주소를 부산으로 변경해야함
    //memberB.getAddress().setValue("부산"); // 컴파일 오류

    memberB.setAddress(new ImmutableAddress("부산"));
    System.out.println("부산 -&gt; memberB.address");
    System.out.println("memberA = " + memberA);
    System.out.println("memberB = " + memberB);
  }
}


  회원B의 주소를 중간에 부산으로 변경하려고 시도합니다.
    
      하지만 ImmutableAddress에는 값을 변경할 수 있는 메서드가 없습니다.
        
          따라서 컴파일 오류가 발생합니다.
            
              결국 memberB.setAddress(new ImmutableAddress("부산"))와 같이 새로운 주소 객체를 만들어서 전달합니다.
            
          
        
      
    
  


실행 결과
memberA = MemberV1{name='회원A', address=Address{value='서울'}}
memberB = MemberV1{name='회원B', address=Address{value='서울'}}
부산 -&gt; memberB.address
memberA = MemberV1{name='회원A', address=Address{value='서울'}}
memberB = MemberV1{name='회원B', address=Address{value='부산'}}


사이드 이펙트가 발생하지 않습니다. 회원A는 기존 주소를 그대로 유지합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-03-ImmutableObjectsIntroduction.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-03-ImmutableObjectsIntroduction.html"><h1 class="title_post">☕️[Java] 불변 객체 - 도입</h1></a>
                        <a href="/2024/Java/2024-04-03-ImmutableObjectsIntroduction.html" class="txt_post">
                            불변 객체 - 도입
지금까지 발생한 문제를 잘 생각해보면 공유하면 안되는 객체를 여러 변수에서 공유했기 때문에 발생한 문제입니다.

  하지만 앞서 살펴보았듯이 객체의 공유를 막을 수 있는 방법은 없습니다.
    
      그런데 사이드 이펙트의 더 근본적인 원인을 고려해보면, 객체를 공유하는 것 자체는 문제가 아닙니다.
      객체를 공유한다고 바로 사이드 이펙트가 발생하지 않습니다.
        
          문제의 직접적인 원인은 공유된 객체의 값을 변경한 것에 있습니다.
        
      
    
  


앞의 예를 떠올려보면 a, b는 처음 시점에는 둘 다 "서울"이라는 주소를 사용해야 합니다.

  그리고 이후에 b의 주소를 "부산"으로 변경해야 합니다.
    Address a = new Address("서울");
Address b = a;
    
  


따라서 처음에는 b = a와 같이 "서울"이라는 Address 인스턴스를 a, b가 함께 사용하는 것이, 다음 코드와 서로 다른 인스턴스를 사용하는 것 보다 메모리와 성능상 더 효율적입니다.

  인스턴스가 하나이니 메모리가 절약되고, 인스턴스를 하나 생성하지 않아도 되니 생성 시간이 줄어서 성능상 효율적입니다.


Address a = new Address("서울");
Address b = new Address("서울");


여기까지는 Address b = a와 같이 공유 참조를 사용해도 아무런 문제가 없습니다. 오히려 더 효율적입니다.

진짜 문제는 이후에 b가 공유 참조하는 인스턴스의 값을 변경하기 때문에 발생합니다.
b.setValue("부산"); // b의 값을 부산으로 변경해야 합니다.
System.out.println("부산 -&gt; b");
System.out.println("a = " + a); // 사이드 이펙트 발생
System.out.println("b = " + b);


자바에서 여러 참조형 변수가 하나의 객체(인스턴스)를 참조하는 공유 참조 문제는 피할 수 없습니다.

  기본형과 다르게 참조형인 객체는 처음부터 처음부터 여러 참조형 변수에서 공유될 수 있도록 설계되었습니다.
    
      따라서 이것은 문제가 아닙니다.
        
          문제의 직접적인 원인은 공유될 수 있는 Address 객체의 값을 더이선가 변경했기 때문입니다.
        
      
    
  


만약 Address 객체의 값을 변경하지 못하게 설계했다면 이런 사이드 이펙트 자체가 발생하지 않을 것입니다.

불변 객체 도입
객체의 상태(객체 내부의 값, 필드, 멤버 변수)가 변하지 않는 객체를 불변 객체(Immutable Object)라 합니다.

앞서 만들었던 Address 클래스를 상태가 변하지 않는 불변 클래스로 다시 만들어 봅시다.

package lang.immutable.address;

public class ImmutableAddress {
  private final String value;

  public ImmutableAddress(String value) {
    this.value = value;
  }

  public String getValue() {
    return value;
  }

  @Override
  public String toString() {
    return "Address{" +
        "value='" + value + '\'' +
        '}';
  }
}


  내부 값이 변경되면 안됩니다.
    
      따라서 value의 필드를 final로 선언했습니다.
    
  
  값을 변경할 수 있는 setValue()를 제거했습니다.
  이 클래스는 생성자를 통해서만 값을 설정할 수 있고, 이후에는 값을 변경하는 것이 불가능합니다.


불변 클래스를 만드는 방법은 아주 단순합니다.

  어떻게든 필드 값을 변경할 수 없게 클래스를 설계하면 됩니다.


package lang.immutable.address;

public class RefMain2 {

  public static void main(String[] args) {
    // 참조형 변수는 하나의 인스턴스를 공유할 수 있습니다.
    ImmutableAddress a = new ImmutableAddress("서울");
    ImmutableAddress b = a; // 참조값 대입을 막을 수 있는 방법이 없다.

    System.out.println("a = " + a);
    System.out.println("b = " + b);

    // b.setValue("부산"); // 컴파일 오류 발생
    b = new ImmutableAddress("부산");
    System.out.println("부산 -&gt; b");
    System.out.println("a = " + a); // 사이드 이펙트 발생
    System.out.println("b = " + b);
  }
}


  ImmutableAddress의 경우 값을 변경할 수 있는 b.setValue() 메서드 자체가 제거되었습니다.
  이제 ImmutableAddress 인스턴스의 값을 변경할 수 있는 방법은 없습니다.
  ImmutableAddress를 사용하는 개발자는 값을 변경하려고 시도하다가, 값을 변경하는 것이 불가능하다는 사실을 알고, 이 객체가 불변 객체인 사실을 깨닫습니다.
    
      예를 들어 b.setValue("부산")을 호출하려고 했는데, 해당 메서드가 없다는 사실을 컴파일 오류를 통해 인지한다.
        
          따라서 어쩔 수 없이 새로운 ImmutableAddress("부산") 인스턴스를 생성해서 b에 대입한다.
        
      
    
  
  결과적으로 a, b는 서로 다른 인스턴스를 참조하고, a가 참조하던 ImmutableAddress는 그대로 유지됩니다.


실행 결과
a = Address{value='서울'}
b = Address{value='서울'}
부산 -&gt; b
a = Address{value='서울'}
b = Address{value='부산'}


실행 결과를 보면 a의 값은 그대로 유지되는 것을 확인할 수 있습니다.


  자바에서 객체의 공유 참조는 막을 수 없습니다.




  ImmutableAddress는 불변 객체입니다. 따라서 값을 변경할 수 없습니다.




  ImmutableAddress은 불변 객체이므로 b가 참조하는 인스턴스의 값을 서울에서 부산으로 변경하려면 새로운 인스턴스를 생성해서 할당해야 합니다.


정리
불변이라는 단순한 제약을 사용해서 사이드 이펙트라는 큰 문제를 막을 수 있습니다.

  객체의 공유 참조는 막을 수 없습니다.
    
      그래서 객체의 값을 변경하면 다른 곳에서 참조하는 변수의 값도 함께 변경되는 사이드 이펙트가 발생합니다.
      사이드 이펙트가 발생하면 안되는 상황이라면 불변 객체를 만들어 사용하면 됩니다.
      불변 객체는 값을 변경할 수 없기 때문에 사이드 이펙트가 원천 차단됩니다.
    
  
  불변 객체는 값을 변경할 수 없습니다.
    
      따라서 불변 객체의 값을 변경하고 싶다면 변경하고 싶은 값으로 새로운 불변 객체를 생성해야 합니다.
        
          이렇게 하면 기존 변수들이 참조하는 값에는 영향을 주지 않습니다.
        
      
    
  



  참고 - 가변(Mutable) 객체 VS 불변(Immutable) 객체
가변은 이름 그대로 처음 만든 이후 상태가 변할 수 있다는 뜻입니다.(사전적으로 사물의 모양이나 성질이 달라질 수 있다는 뜻입니다.)
불변은 이름 그대로 처음 만든 이후 상태가 변하지 않는다는 뜻입니다.(사전적으로 사물의 모양이나 성질이 달라질 수 없다는 뜻입니다.)

  Address 는 가변 클래스입니다. 이 클래스로 객체를 생성하면 가변 객체가 됩니다.
ImmutableAddress는 불변 클래스입니다. 이 클래스로 객체를 생성하면 불변 객체가 됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-03-SharedReferencesAndSideEffects.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-03-SharedReferencesAndSideEffects.html"><h1 class="title_post">☕️[Java] 공유 참조와 사이드 이펙트</h1></a>
                        <a href="/2024/Java/2024-04-03-SharedReferencesAndSideEffects.html" class="txt_post">
                            공유 참조와 사이드 이펙트.

사이드 이펙트(Side Effect)는 프로그래밍에서 어떤 계산이 주된 작업 외에 추가적인 부수 효과를 일으키는 것을 말합니다.

앞서 b의 값을 부산으로 변경한 코드를 다시 분석해 봅시다.

b.setValue("부산"); //b의 값을 부산으로 변경해야함
System.out.println("부산 -&gt; b");
System.out.println("a = " + a); // 사이드 이펙트 발생
System.out.println("b = " + b);





  개발자는 b의 주소값을 서울에서 부산으로 변경할 의도로 값 변경을 시도했습니다.
  하지만 a, b는 같은 인스턴스를 참조합니다. 따라서 a의 값도 함께 부산으로 변경되어 버립니다.


이렇게 주된 작업 외에 추가적인 부수 효과를 일으키는 것을 사이드 이펙트라고 합니다.
프로그래밍에서 사이드 이펙트는 보통 부정적인 의미로 사용되는데, 사이드 이펙트는 프로그램의 특정 부분에서 발생한 변경이 의도치 않게 다른 부분에 영향을 미치는 경우에 발생합니다.
이로 인해 디버깅이 어려워지고 코드의 안정성이 저하될 수 있습니다.

사이드 이펙트 해결방안
생각해보면 문제의 해결방안은 아주 단순합니다.

다음과 같이 a와 b가 처음부터 서로 다른 인스턴스를 참조하면 됩니다.
Address a = new Address("서울");
Address b = new Address("서울");


코드를 작성해봅시다.

package lang.immutable.address;

public class RefMain1_2 {

  public static void main(String[] args) {
    // 참조형 변수는 하나의 인스턴스를 공유할 수 있습니다.
    Address a = new Address("서울");
    Address b = new Address("서울");

    System.out.println("a = " + a);
    System.out.println("b = " + b);

    b.setValue("부산");
    System.out.println("부산 -&gt; b");
    System.out.println("a = " + a);
    System.out.println("b = " + b);
  }
}


실행 결과
a = Address{value='서울'}
b = Address{value='서울'}
부산 -&gt; b
a = Address{value='서울'}
b = Address{value='부산'}


실행 결과를 보면 b의 주소값만 부산으로 변경된 것을 확인할 수 있습니다.




  a와 b는 서로 다른 Address 인스턴스를 참조합니다.





  a와 b는 서로 다른 인스턴스를 참조합니다.
    
      따라서 b가 참조하는 인스턴스의 값을 변경해도 a에는 영향을 주지 않습니다.
    
  


여러 변수가 하나의 객체를 공유하는 것을 막을 방법은 없다
지금까지 발생한 모든 문제는 같은 객체(인스턴스)를 변수 a, b가 함께 공유하기 때문에 발생했습니다.

  따라서 객체를 공유하지 않으면 문제가 해결됩니다.
  여기서 변수 a,b가 서로 각각 다른 주소지로 변경할 수 있어야 합니다.
    
      이렇게 하려면 서로 다른 객체를 참조하면 됩니다.
    
  


객체를 공유
Address a = new Address("서울");
Address b = a;


  이 경우 a, b 둘 다 같은 Address 인스턴스를 바라보기 때문에 한쪽의 주소만 부산으로 변경하는 것이 불가능합니다.


객체를 공유 하지 않음
Address a = new Address("서울");
Address b = new Address("서울");


  이 경우 a, b는 서로 다른 Address 인스턴스를 바라보기 때문에 한쪽의 주소만 부산으로 변경하는 것이 가능합니다.


이처럼 단순하게 서로 다른 객체를 참조해서, 같은 객체를 공유하지 않으면 문제가 해결됩니다.

쉽게 이야기해서 여러 변수가 하나의 객체를 공유하지 않으면 지금까지 설명한 문제들이 발생하지 않습니다.

  그런데 여기에 문제가 있습니다.
    
      하나의 객체를 여러 변수가 공유하지 않도록 강제로 막을 수 있는 방법이 없다는 것입니다
    
  


다음 예시를 봅시다.

참조값의 공유를 막을 수 있는 방법이 없습니다.
Address a = new Address("서울");
Address b = a; // 참조값 대입을 막을 수 있는 방법이 없습니다.


b = a와 같은 코드를 작성하지 않도록 해서, 여러 변수가 하나의 참조값을 공유하지 않으면 문제가 해결될 것 같습니다.

  하지만 Address를 사용하는 개발자 입장에서 실수로 b = a라고 해도 아무런 오류가 발생하지 않습니다.
    
      왜냐하면 자바 문법상 Address b = a와 같은 참조형 변수의 대입은 아무런 문제가 없기 때문입니다.
    
  


다음과 같이 새로운 객체를 참조형 변수에 대입하든, 또는 기존 객체를 참조형 변수에 대입하든, 다음 두 코드 모두 자바 문법상 정상인 코드입니다.
Address b = new Address("서울"); // 새로운 객체 참조
Address b = a // 기존 객체 공유 참조

참조값을 다른 변수에 대입하는 순간 여러 변수가 하나의 객체를 공유하게 됩니다.

  쉽게 이야기해서 객체의 공유를 막을 수 있는 방법이 없습니다!


기본형은 항상 값을 복사해서 대입하기 때문에 값이 절대로 공유되지 않습니다.

  하지만 참조형의 경우 참조값을 복사해서 대입하기 때문에 여러 변수에서 얼마든지 같은 객체를 공유할 수 있습니다.
  객체의 공유가 꼭 필요할 때도 있지만, 때로는 공유하는 것이 지금과 같은 사이드 이펙트를 만드는 경우도 있습니다.


물론 개발자가 눈을 크게 잘 뜨고! 집중해서 코드를 잘 작성하면서 사이드 이펙트 문제를 일으키지 않을 수 있습니다.

  하지만 실제로는 훨씬 더 복잡한 상황에서 이런 문제가 발생합니다.


다음 코드를 봅시다.

package lang.immutable.address;

public class RefMain1_3 {

  public static void main(String[] args) {
    // 참조형 변수는 하나의 인스턴스를 공유할 수 있습니다.
    Address a = new Address("서울");
    Address b = a;

    System.out.println("a = " + a);
    System.out.println("b = " + b);

    change(b, "부산");
    System.out.println("a = " + a);
    System.out.println("b = " + b);
  }

  private static void change(Address address, String changeAddress) {
    System.out.println("주소 값을 변경합니다 -&gt; " + changeAddress);
    address.setValue(changeAddress);
  }
}



  앞서 작성한 코드와 같은 코드입니다.
    
      단순히 change() 메서드만 하나 추가되었습니다.
      그리고 change() 메서드에서 Address 인스턴스에 있는 value 값을 변경합니다.
    
  
  main() 메서드만 보면 a의 값이 함께 부산으로 변경된 이류를 찾기가 더 어렵습니다.


실행 결과
a = Address{value='서울'}
b = Address{value='서울'}
주소 값을 변경합니다 -&gt; 부산
a = Address{value='부산'}
b = Address{value='부산'}


여러 변수가 하나의 객체를 참조하는 공유 참조를 막을 수 있는 방법은 없습니다.

  그럼 공유 참조로 인해 발생하는 문제를 어떻게 해결할 수 있을까요?
    
      단순히 개발자가 공유 참조 문제가 발생하지 않도록 조심해서 코드를 작성해야 할까요?
    
  



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/SQL/2024-04-02-ORDERBY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/SQL/2024-04-02-ORDERBY.html"><h1 class="title_post">💉[SQL] ORDER BY</h1></a>
                        <a href="/2024/SQL/2024-04-02-ORDERBY.html" class="txt_post">
                            ORDER BY
‘ORDER BY’ 절은 SQL 쿼리의 결과를 특정 기준에 따라 정렬할 때 사용됩니다.

  이를 통해 반환된 데이터를 오름차순(ASC) 또는 내림차순(DESC)으로 정렬할 수 있으며, 숫자, 문자열, 날짜 등 다양한 데이터 타입에 적용할 수 있습니다.
  ‘ORDER BY’ 는 데이터를 보다 읽기 쉽고 분석하기 용이하게 정렬하여 제공함으로써, 데이터 리포팅, 사용자 인터페이스에서의 데이터 표시, 데이터 분석 등 다양한 상황에서 유용하게 사용됩니다.


‘OREDER BY’ 사용 예

  특정 열에 따른 오름차순 정렬: 직원들을 이름순으로 정렬하고 싶을 때
    SELECT * FROM emploees ORDER BY name ASC;
    
    이 쿼리는 ‘employees’ 테이블의 모든 행을 ‘name’ 열 기준으로 오름차순으로 정렬하여 반환합니다.
  
  특정 열에 따른 내림차순 정렬: 최신 주문부터 표시하고 싶을 때
    SELECT * FROM orders ORDER BY order_by DESC;
    
    이 쿼리는 ‘orders’ 테이블의 모든 행을 ‘order_date’ 열 기준으로 내림차순으로 정렬하여 반환합니다.
  
  여러 열에 따른 정렬: 부서별로 그룹화하고, 각 부서 내에서 급여가 높은 순으로 정렬하고 싶을 때
    SELECT * FROM employees ORDER BY department ASC, salary DESC;
    
    이 쿼리는 먼저 ‘department’ 열로 오름차순으로 정렬하고, 같은 부서 내에서는 ‘salary’ 열을 기준으로 내림차순으로 정렬합니다.
  


‘ORDER BY’ 절의 특징

  기본적으로 ‘ORDER BY’ 는 오름차순(ASC)으로 정렬합니다. 내림차순으로 정렬하고 싶다면 각 열 이름 뒤에 ‘DESC’ 키워드를 명시해야 합니다.
  여러 열을 기준으로 정렬할 수 있으며, 이 경우 첫 번째 열을 기준으로 정렬한 후 동일한 값에 대해서는 다음 열의 순서에 따라 정렬합니다.
  ‘SELECT’ 쿼리의 마지막 부분에 위치하며, ‘WHERE’, ‘GROUP BY’, ‘HAVING’ 절 뒤에 명시됩니다.


사용 시 고려사항

  ‘ORDER BY’ 를 사용할 때는 정렬하고자 하는 열이 인덱싱되어 있는지 확인하는 것이 좋습니다. 특히 대규모 데이터셋을 다룰 때, 인덱스의 유무는 쿼리 성능에 큰 영향을 미칩니다.
  복잡한 쿼리에서는 ‘ORDER BY’ 로 인한 추가적인 처리 시간이 필요할 수 있으므로, 성능과 관련하여 적절한 테스트가 필요합니다.


‘ORDER BY’ 절은 SQL 쿼리의 결과를 사용자가 원하는 순서로 쉽게 정렬할 수 있게 해주며, 데이터의 가독성과 분석의 용이성을 크게 향상시킵니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/SQL/2024-04-02-GROUPBY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/SQL/2024-04-02-GROUPBY.html"><h1 class="title_post">💉[SQL] GROUP BY</h1></a>
                        <a href="/2024/SQL/2024-04-02-GROUPBY.html" class="txt_post">
                            GROUP BY
‘GROUP BY’ 절은 SQL에서 특정 열(들)의 값에 기반하여 행(row)들을 그룹화할 때 사용됩니다.

  이 기능은 집계함수(‘SUM’, ‘AVG’, ‘COUNT’, ‘MIN’, ‘MAX’ 등)와 함꼐 사용되어, 각 그룹에 대한 집계된 데이터를 계산하고 반환하는 데 주로 활용됩니다.
  ‘GROUP BY’ 는 데이터를 요약하고, 특정 기준에 따른 데이터의 통계를 분석할 때 유용하게 사용됩니다.


‘GROUP BY’ 사용 예

  그룹별 합계 계산: 각 부서별 총 급여를 계산하고 싶을 때
    SELECT department, SUM(salary) FROM employees GROUP BY departmentl
    
    이 쿼리는 ‘employees’ 테이블에서 ‘department’ 별로 그룹화하고, 각 그룹의 ‘salary’ 합계를 계산합니다.
  
  그룹별 평균 계산: 각 제품 카테고리별 평균 가격을 계산하고 싶을 때
    SELECT category, AVG(price) FROM products GROUP BY category;
    
    이 쿼리는 ‘product’ 테이블에서 ‘category’ 별로 그룹화하고, 각 그룹의 price 평균을 계산합니다.
  
  그룹별 데이터 수 계산: 각 부서에 속한 직원 수를 세고 싶을 때
    SELECT department, COUNT(*) FROM employees GROUP BY department;
    
    이 쿼리는 ‘employees’ 테이블에서 ‘department’ 별로 그룹화하고, 각 그룹의 직원 수를 세어 반환합니다.
  


‘GROUP BY’ 절의 특징

  데이터를 그룹화하고 각 그룹에 대한 집계를 수행하여, 데이터의 요약 정보를 제공합니다.
  여러 열을 기준으로 그룹화할 수 있으며, 이 경우 선택된 모든 열의 조합에 따라 데이터가 그룹화됩니다.
  집계 함수와 함께 사용되어, 각 그룹별로 함계, 평균, 최소값, 최대값 등을 계산할 수 있습니다.
  ‘HAVING’ 절과 함께 사용하여, 집계 결과에 대한 조건을 설정할 수 있습니다. 이는 ‘WHERE’ 절과 유사하지만, ‘GROUP BY’ 로 그룹화된 결과에 대해 조건을 정용하는 점이 다릅니다.


사용 시 고려사항

  ‘GROUP BY’ 를 사용할 때는 선택된 열이 ‘SELECT’ 절에 포함되어야 합니다. 그렇지 않은 경우, SQL 쿼리가 예상대로 작동하지 않을 수 있습니다.
  대규모 데이터셋에서 ‘GROUP BY’ 를 사용할 때는 쿼리의 성능을 고려해야 합니다. 적절한 인덱스 사용과 데이터 구조의 최적화가 성능에 큰 영햫을 미칠 수 있습니다.


‘GROUP BY’ 절은 데이터를 분석하고 요약 정보를 얻기 위한 강력한 도구로, 데이터베이스 내에서 의미 있는 인사이트를 도출하는 데 크게 기여합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-02-SharingOfBasicTypesAndReferenceTypes.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-02-SharingOfBasicTypesAndReferenceTypes.html"><h1 class="title_post">☕️[Java] 기본형과 참조형의 공유</h1></a>
                        <a href="/2024/Java/2024-04-02-SharingOfBasicTypesAndReferenceTypes.html" class="txt_post">
                            기본형과 참조형의 공유.

자바의 데이터 타입을 가장 크게 보면 기본형(Primitive Type)과 참조형(Reference Type)으로 나눌 수 있습니다.

  기본형(Primitive Type): 하나의 값을 여러 변수에서 절대로 공유하지 않습니다.
  참조형(Reference Type): 하나의 객체를 참조값을 통해 여러 변수에서 공유할 수 있습니다.


하나의 값을 공유하거나 또는 공유하지 않는다는 것이 무슨 뜻인지 예제를 통해 알아봅시다.

기본형 예제
기본형은 하나의 값을 여러 변수에서 절대로 공유하지 않습니다.

다음 예를 봅시다.

package lang.immutable.address;

public class PrimitiveMain {

  public static void main(String[] args) {
    // 기본형은 절대로 같은 값을 공유하지 않는다.
    int a = 10;
    int b = a; // a -&gt; b, 값 복사 후 대입
    
    System.out.println("a = " + a);
    System.out.println("b = " + b);
    

    b = 20;
    System.out.println("20 -&gt; b");
    System.out.println("a = " + a);
    System.out.println("b = " + b);
  }
}


실행 결과
a = 10
b = 10
20 -&gt; b
a = 10
b = 20





  기본형 변수 a와 b는 절대로 하나의 값을 공유하지 않습니다.
  b = a라고 하면 자바는 항상 값을 복사해서 대입 합니다. 이 경우 a에 있는 값 10을 복사해서 b에 전달합니다.
  결과적으로 a와 b는 둘 다 10이라는 똑같은 숫자의 값을 가집니다.
    
      하지만 a가 가지는 10과 b가 가지는 10은 복사된 완전히 다른 10입니다.
        
          메모리 상에서도 a에 속하는 10과 b에 속하는 10이 각각 별도로 존재합니다.
        
      
    
  





  b = 20이라고 하면 b의 값만 20으로 변경됩니다.
  a의 값은 10으로 그대로 유지됩니다.
  기본형 변수는 하나의 값을 절대로 공유하지 않습니다.
    
      따라서 값을 변경해도 변수 하나의 값만 변경됩니다.
        
          여기서는 변수 b의 값만 20으로 변경되었습니다.
        
      
    
  


너무 당연한 이야기 입니다.

그렇다면 이번에는 참조형 예제를 봐봅시다.

참조형 예제

package lang.immutable.address;

public class RefMain1_1 {

  public static void main(String[] args) {
    // 참조형 변수는 하나의 인스턴스를 공유할 수 있습니다.
    Address a = new Address("서울");
    Address b = a;

    System.out.println("a = " + a);
    System.out.println("b = " + b);

    b.setValue("부산"); // b의 값을 부산으로 변경해야함.
    System.out.println("부산 -&gt; b");
    System.out.println("a = " + a); // 사이드 이펙트 발생
    System.out.println("b = " + b);
  }
}


  처음에는 a, b 둘다 서울이라는 주소를 가져야 한다고 가정합니다.
    
      따라서 Address b = a 코드를 작성했고, 변수 a, b 둘다 서울이라는 주소를 가집니다.
        
          이후에 b의 주소를 부산으로 변경합니다.
            
              그런데 실행 결과를 보면 b뿐만 아니라 a의 주소도 함께 부산으로 변경되어 버립니다.
            
          
        
      
    
  


실행 결과
a = Address{value='서울'}
b = Address{value='서울'}
부산 -&gt; b
a = Address{value='부산'}
b = Address{value='부산'}


순서대로 코드를 분석해봅시다.
Address a = new Address("서울");
Address b = a;





  참조형 변수들은 같은 참조값을 통해 같은 인스턴스를 참조할 수 있습니다.
  b = a라고 하면 a에 있는 참조값 x001을 복사해서 b에 전달합니다.
    
      자바에서 모든 값 대입은 변수가 가지고 있는 값을 복사해서 전달합니다.
        
          변수가 int 같은 숫자값을 가지고 있으면 숫자값을 복사해서 전달하고, 참조값을 가지고 있으면 참조값을 복사해서 전달합니다.
        
      
    
  
  참조값을 복사해서 전달하므로 결과적으로 a, b는 같은 x001 인스턴스를 참조합니다.
  기본형 변수는 절대로 같은 값을 공유하지 않습니다.
    
      예) a = 10, b = 10과 같이 같은 모양의 숫자 10이라는 값을 가질 수는 있지만 같은 값을 공유하는 것은 아닙니다
        
          서로 다른 숫자 10이 두 개 있는 것입니다.
        
      
    
  
  참조형 변수는 참조값을 통해 같은 객체(인스턴스)를 공유할 수 있습니다.


여기서 b의 주소만 부산으로 변경했는데, a의 주소도 함께 부산으로 변경되어 버린 이유는 무엇일까요?

  메모리 구조를 보면 바로 답이 나오겠지만, 개발을 하다 보면 누구나 이런 실수할 수 있을 것 같다는 생각도 함께 들 것입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/SQL/2024-04-01-sqlFlow.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/SQL/2024-04-01-sqlFlow.html"><h1 class="title_post">💉[SQL] Query 작성시 플로우</h1></a>
                        <a href="/2024/SQL/2024-04-01-sqlFlow.html" class="txt_post">
                            Query 작성시 플로우.



어떤 데이터를 조회해야할 경우 바로 Query를 작성하기 보다는 흐름을 가지고 순서대로 작성해보는 것을 추천합니다.

예를 들어 다음과 같은 데이터를 조회한다고 합시다.

“주문 금액이 30,000원 이상인 주문건의 갯수 구하기.”


  
    
      Query를 적기 전에 흐름을 정리해봅니다.
        
          
            
              어떤 테이블에서 데이터를 뽑을 것인지 생각해 봅니다.
            
          
        
        
          주문 금액이 들어간 데이터를 조회해야 하므로 “주문 테이블” 에서 데이터를 뽑아야 합니다.
    - 2. 어떤 컬럼을 이용할 것인지 생각해 봅니다.
          주문 금액 데이터를 조회해야 하므로 “주문 금액” 컬럼을 이용해야 합니다.
    - 3. 어떤 조건을 지정해야 하는지 생각해봅니다.
          30,000원 이상 이라는 조건이 있으므로 “30,000 이상” 인 조건을 이용해야 합니다.
    - 4. 어떤 함수(수식)을 이용해야 하는지 생각해봅니다.
          주문건의 갯수를 구해야 하므로 “COUNT” 함수를 사용해야 합니다.
        
      
    
  
  
    
      구문으로 만들어봅니다.
        
          
            
              어떤 테이블에서 데이터를 뽑을 것인지 생각해 봅니다.
            
          
        
        
          from food_orders
    - 2. 어떤 컬럼을 이용할 것인지 생각해 봅니다.
          order_id, price
    - 3. 어떤 조건을 지정해야 하는지 생각해봅니다.
          where price &gt;= 30000
    - 4. 어떤 함수(수식)을 이용해야 하는지 생각해봅니다.
          count(order_id) 혹은 count(1)
        
      
    
  
  
    
      전체 구조로 합쳐봅니다.

    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/SQL/2024-04-01-SUMAVGCOUNTMINMAX.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/SQL/2024-04-01-SUMAVGCOUNTMINMAX.html"><h1 class="title_post">💉[SQL] SUM, AVG, COUNT, MIN, MAX</h1></a>
                        <a href="/2024/SQL/2024-04-01-SUMAVGCOUNTMINMAX.html" class="txt_post">
                            SUM

‘SUM’ 함수는 SQL에서 특정 열(column)에 포함된 숫자 값들의 합계를 계산할 때 사용됩니다.

  이는 집계 함수의 한 종류로, 주로 ‘GROUP BY’ 절과 함꼐 사용되어 여러 그룹의 데이터에 대한 합계를 구하거나, 전체 테이블에서 특정 열의 총합을 계산하는 데 적용됩니다.
  ‘SUM’ 함수는 보고서 생성, 데이터 분석, 재무 계산 등 다양한 상황에서 유용하게 활용될 수 있습니다.


‘SUM’ 사용 예

  전체 합계 계산 : 모든 주문의 총 금액을 계산하고 싶을 때
    SELECT SUM(total_price) FROM orders;
    
    이 쿼리는 ‘orders’ 테이블의 ‘total_price’ 열에 있는 모든 값의 합계를 반환합니다.
  
  그룹별 합계 계산 : 각 부서별 직원들의 총 급여를 계산하고 싶을 떄
    SELECT department, SUM(salary) FROM employees GROUP BY department;
    
    이 쿼리는 ‘employees’ 테이블에서 각 ‘department’ 별로 ‘salary’ 열의 합계를 계산하여, 각 부서의 총 급여를 보여줍니다.
  
  조건부 합계 계산 : 2023년에 이루어진 모든 판매의 총액을 계산하고 싶을 때
    SELECT SUM(sales_amount) FROM sales WHERE year = 2023;
    
    이 쿼리는 ‘sales’ 테이블에서 ‘year’ 열이 2023인 모든 행의 ‘sales_amount’ 열 값의 합계를 반환합니다.
  


‘SUM’ 함수의 특징

  ‘SUM’ 함수는 숫자 데이터에 대해서만 사용할 수 있으며, 문자열이나 날짜 등의 데이터 타입에는 사용할 수 없습니다.
  ‘NULL’ 값을 포함하는 열에 ‘SUM’ 함수를 사용할 때, ‘NULL’ 값은 0으로 간주되지 않고, 단순히 무시됩니다.
    
      즉, ‘NULL’ 값은 합계 계산에 영향을 주지 않습니다.
    
  
  ‘SUM’ 은 다른 집계 함수(‘COUNT’, ‘AVG’, ‘MIN’, ‘MAX’ 등)와 함께 사용될 수 있으며, 복잡한 데이터 집합에 대한 요약 정보를 제공하는 데 유용합니다.


사용 시 고려사항

  ‘SUM’ 함수를 사용할 때는 대상 열이 숫자 타입임을 확인해야 합니다.
  큰 데이터 세트에서 ‘SUM’ 함수를 사용할 때는 쿼리 성능에 주의해야 합니다.
    
      필요한 경우 적절한 인덱스를 사용하여 성능을 최적화할 수 있습니다.
    
  
  ‘GROUP BY’ 절과 함께 ‘SUM’ 을 사용할 때는, 그룹화할 열을 명확히 지정해야 합니다.


‘SUM’ 함수는 데이터베이스에서 숫자 데이터의 합계를 계산하는 데 매우 중요한 도구로, 데이터 분석 및 보고서 작성 등 다양한 상황에서 활용될 수 있습니다.

AVG
‘AVG’ 함수는 SQL에서 특정 열(column)에 포함된 숫자 값들의 평균을 계산할 때 사용됩니다.

  이 집계 함수는 특정 데이터 집합의 중간 값을 찾거나, 데이터의 일반적인 경향성을 파악하는 데 유용하며, 데이터 분석, 보고서 작성, 성능 평가 등 다양한 상황에서 활용될 수 있습니다.


‘AVG’ 사용 예

  전체 평균 계산 : 모든 직원의 평균 급여를 계산하고 싶을 때
    SELECT AVG(salary) FROM employees;
    
    이 쿼리는 ‘employees’ 테이블의 ‘salary’ 열에 있는 값들의 평균을 계산합니다.
  
  그룹별 평균 계산 : 각 부서별 직원들의 평균 급여를 계산하고 싶을 때
    SELECT department, AVG(salary) FROM employees GROUP BY department;
    
    이 쿼리는 ‘employees’ 테이블에서 각 ‘department’ 별로 ‘salary’ 열의 평균을 계산하여, 각 부서의 직원들에 대한 평균 급여를 보여줍니다.
  
  조건부 평균 계산 : 2023년에 이루어진 모든 판매 건에 대한 평균 판매액을 계산하고 싶을 때
    SELECT AVG(sales_amount) FROM sales WHERE year = 2023;
    
    이 쿼리는 ‘salse’ 테이블에서 ‘year’ 열이 2023인 모든 행의 ‘sales_amount’ 열 값들의 평균을 반환합니다.
  


‘AVG’ 함수의 특징


  ‘AVG’ 함수는 숫자 데이터에 대해서만 사용할 수 있습니다. 문자열이나 날짜 등 다른 타입의 데이터에는 사용할 수 없습니다.
  ‘NULL’ 값을 포함하는 열에 ‘AVG’ 함수를 사용할 때, ‘NULL’ 값은 계산에서 제외됩니다.
    
      즉, ‘NULL’ 값은 평균 계산에 영향을 주지 않으며, 실제 값이 있는 데이터만을 기준으로 평균이 계산됩니다.
    
  
  ‘AVG’ 는 다른 집계 함수(‘SUM’, ‘COUNT’, ‘MIN’, ‘MAX’ 등)와 함께 사용될 수 있으며, 데이터의 통계적 분석이나 요약 정보 제공에 유용합니다.


사용 시 고려사항

  ‘AVG’ 함수를 사용할 때는 대상 열이 숫자 타입인지 확인해야 합니다.
  데이터 세트의 크기가 클 때 ‘AVG’ 함수를 사용하면 쿼리 성능에 영향을 줄 수 있으므로, 필요한 경우 적절한 인덱스 사용과 데이터 필터링을 통해 성능을 최적화해야 합니다.
  ‘GROUP BY’ 절과 함께 ‘AVG’ 를 사용할 때는, 그룹화할 열을 명확하게 지정해야 하며, 그룹별로 평균값을 계산하고자 할 때 특히 유용합니다.


‘AVG’ 함수는 데이터 세트에서 평균값을 계산하여 중요한 인사이트를 제공하는 집계 함수로, 데이터 분석과 의사 결정 과정에서 핵심적인 역할을 합니다.

COUNT
‘COUNT’ 함수는 SQL에서 행(row)의 수를 세는 데 사용됩니다.

  이 함수는 특정 조건을 만족하는 행의 수를 찾거나, 테이블의 전체 행 수를 계산할 때 매우 유용합니다. 데이터 분석, 보고서 작성, 데이터 집합의 크기를 파악하는 등의 상황에서 활용됩니다.
  ‘COUNT’ 는 다양한 형태로 사용될 수 있으며, 가장 일반적인 사용 방법은 ‘COUNT(*)’, COUNT(열 이름), 그리고 ‘COUNT(DISTINCT 열 이름)’ 입니다.


‘COUNT’ 사용 예

  테이블의 전체 행 수 계산 : ‘employees’ 테이블의 전체 직원 수를 계산하고 싶을 때
    SELECT COUNT(*) FROM employees;
    
    이 쿼리는 ‘employees’ 테이블의 전체 행 수를 반환합니다.
  
  특정 조건을 만족하는 행 수 계산 : 연봉이 $50,000 이상인 직원의 수를 찾고 싶을 때
    SELECT COUNT(*) FROM employees WHERE salary &gt;= 50000;
    
    이 쿼리는 ‘salary’가 $50,000 이상인 행의 수를 반환합니다.
  
  고유값의 수 계산 : ‘employees’ 테이블에서 고유한 부서의 수를 계산하고 싶을 때
    SELECT COUNT(DISTINCT department) FROM employees;
    
    이 쿼리는 중복을 제거한 ‘department’ 열의 고유값 수를 반환합니다.
  


‘COUNT’ 함수의 특징.

  ‘COUNT(*)’ 는 테이블의 전체 행 수를 세며, ‘NULL’ 값을 포함한 모든 행을 계산합니다.
  ‘COUNT(열 이름)’ 는 특정 열에서 ‘NULL’ 이 아닌 행의 수를 세는 데 사용됩니다.
  ‘COUNT(DISTINCT 열 이름)’ 는 특정 열의 고유값 수를 계산할 때 사용되며, 중복된 값은 하나로 취급합니다.
  ‘COUNT’ 함수는 집계 함수로 분류되며, ‘GROUP BY’ 절과 함께 사용하여 특정 조건에 따른 그룹별 행 수를 계산하는 데 유용합니다.


사용 시 고려사항

  ‘COUNT(*)’ 와 COUNT(열 이름) 사이에는 성능 차이가 있을 수 있으므로, 사용 상황에 따라 적절한 형태를 선택하는 것이 중요합니다.
  대규모 데이터베이스에서 ‘COUNT’ 쿼리를 실행할 때는 쿼리 성능에 주의해야 하며, 필요한 경우 적절한 인덱스를 사용하거나 조건을 최적화하여 성능을 개선할 수 있습니다.


‘COUNT’ 함수는 데이터베이스 내 데이터의 양을 측정하고 분석하는 데 필수적인 도구로, 데이터의 크기나 특정 조건을 만족하는 데이터의 수를 파악하는 데 매우 유용합니다.

MIN
MIN 함수는 SQL에서 특정 열(column)의 최소값을 찾을 때 사용됩니다.

  이 함수는 숫자, 문자열, 날짜 데이터 타입 등 다양한 종류의 데이터에 대해 작동하며, 테이블 전체 또는 특정 조건을 만족하는 데이터 집합 내에서 가장 작은 값을 찾는 데 유용합니다.
  ‘MIN’ 은 주로 데이터 분석, 보고서 작성, 데이터의 범위를 이해하고자 할 때 사용됩니다.


‘MIN’ 사용 예

  숫자 데이터의 최소값 찾기 : 직원들의 최소 급여를 찾고 싶을 때
    SELECT MIN(salary) FROM employees;
    
    이 쿼리는 ‘employees’ 테이블의 ‘salary’ 열에서 가장 낮은 급여를 반환합니다.
  
  날짜 데이터의 최소값 찾기 : 가장 오래된 주문의 날짜를 찾고 싶을 때
    SELECT MIN(order_date) FROM orders;
    
    이 쿼리는 ‘orders’ 테이블의 ‘order_date’ 열에서 가장 이른 날짜를 반환합니다.
  
  문자열 데이터의 최소값 찾기 : 알파벳 순으로 가장 먼저 오는 제품 이름을 찾고 싶을 때
    SELECT MIN(product_name) FROM products;
    
    이 쿼리는 ‘products’ 테이블의 ‘product_name’ 열에서 알파벳 순으로 가장 앞서는 이름을 반환합니다. 문자열 데이터의 경우, ‘최소값’은 알파벳 순 또는 설정된 정렬 순서에 따라 결정됩니다.
  


‘MIN’ 함수의 특징

  ‘MIN’ 함수는 집계 함수의 하나로, 단일 열에서 가장 작은 값을 찾는 데 사용됩니다.
  숫자, 문자열, 날짜 등 다양한 타입의 데이터에 대해 최소값을 찾을 수 있습니다.
  ‘GROUP BY’ 절과 함께 사용하면, 특정 기준(예: 부서별, 카테고리별)으로 그룹화된 데이터 내에서 각 그룹의 최소값을 찾는 데 사용할 수 있습니다.


사용 시 고려사항

  ‘MIN’ 함수를 사용할 때는 데이터 타입과 해당 필드의 데이터 구조를 이해하는 것이 중요합니다.
    
      특히, 문자열 데이터에 대한 ‘MIN’ 의 사용은 예상치 못한 결과를 가져올 수 있으므로 주의가 필요합니다.
    
  
  대규모 데이터셋에서 ‘MIN’ 함수를 사용할 때는 쿼리의 성능에 주의해야 합니다.
    
      필요한 경우 적절한 인덱스 사용과 데이터 필터링을 통해 성능을 최적화할 수 있습니다.
    
  


‘MIN’ 함수는 데이터 세트에서 최소값을 식별할 때 필수적인 도구로, 데이터의 범위를 파악하고 특정 조건에 따른 최소값을 분석하는 데 유용합니다.

MAX
‘MAX’ 함수는 SQL에서 특정 열(column)의 최대값을 찾을 때 사용됩니다.

  숫자, 문자열, 날짜 등 다양한 데이터 타입에 적용할 수 있으며, 테이블 전체 또는 특정 조건을 만족하는 데이터 집합 내에서 가장 큰 값을 찾는 데 유용합니다.
  ‘MAX’ 는 데이터의 상한을 파악하거나, 가장 최신 또는 가장 오래된 데이터를 식별하는 등의 상황에서 사용됩니다.


‘MAX’ 사용 예

  숫자 데이터의 최대값 찾기 : 직원들의 최대 급여를 찾고 싶을 때
    SELECT MAX(salary) FROM employees;
    
    이 쿼리는 ‘employees’ 테이블의 ‘salary’ 열에서 가장 높은 급여를 반환합니다.
  
  날짜 데이터의 최대값 찾기 : 가장 최근 주문의 날짜를 찾고 싶을 때
    SELECT MAX(order_date) FROM orders;
    
    이 쿼리는 ‘orders’ 테이블의 ‘order_date’ 열에서 가장 최근의 날짜를 반환합니다.
  
  문자열 데이터의 최대값 찾기 : 알파벳 순으로 가장 마지막에 오는 제품 이름을 찾고 싶을 때
    SELECT MAX(product_name) FROM products;
    
    이 쿼리는 ‘products’ 테이블의 ‘product_name’ 열에서 알파벳 순으로 가장 뒤에 오는 이름을 반환합니다.
문자열 데이터의 경우, ‘최대값’은 알파벳 순 또는 설정된 정렬 순서에 따라 결정됩니다.
  


‘MAX’ 함수의 특징

  ‘MAX’ 함수는 집계 함수의 하나로, 단일 열에서 가장 큰 값을 찾는 데 사용됩니다.
  숫자, 문자열, 날짜 등 다양한 타입의 데이터에 대해 최대값을 찾을 수 있습니다.
  ‘GROUP BY’ 절과 함꼐 사용하면, 특정 기준(예: 부서별, 카테고리별)으로 그룹화된 데이터 내에서 각 그룹의 최대값을 찾는 데 사용할 수 있습니다.


사용 시 고려사항

  ‘MAX’ 함수를 사용할 때는 데이터 타입과 해당 필드의 데이터 구조를 이해하는 것이 중요합니다. 특히, 문자열 데이터에 대한 ‘MAX’ 의 사용은 예상치 못한 결과를 가져올 수 있으므로 주의가 필요합니다.
  대규모 데이터셋에서 ‘MAX’ 함수를 사용할 때는 쿼리의 성능에 주의해야 합니다. 필요한 경우 적절한 인덱스 사용과 데이터 필터링을 통해 성능을 최적화할 수 있습니다.


‘MAX’ 함수는 데이터 세트에서 최대값을 식별할 때 필수적인 도구로, 데이터의 범위를 파악하고 특정 조건에 따른 최대값을 분석하는 데 유용합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-04-01-equals2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-04-01-equals2.html"><h1 class="title_post">☕️[Java] equals() - 2. 구현</h1></a>
                        <a href="/2024/Java/2024-04-01-equals2.html" class="txt_post">
                            equals() - 2. 구현

UserV2 예제
UserV2는 id(고객번호)가 같으면 논리적으로 같은 객체로 정의하겠습니다.

package lang.object.equals;

public class UserV2 {
  private String id;

  public UserV2(String id) {
    this.id = id;
  }

  @Override
  public boolean equals(Object obj) {
    UserV2 user = (UserV2) obj;
    return id.equals(user.id);
  }
}


  Object의 equals() 메서드를 재정의했습니다.
  UserV2의 동등성은 id(고객번호)로 비교합니다.
  equals()는 Object 타입을 매개변수로 사용합니다.
    
      따라서 객체의 특정 값을 사용하려면 다운캐스팅이 필요합니다.
    
  
  여기서는 현재 인스턴스(this)에 있는 id 문자열과 비교 대상으로 넘어온 객체의 id 문자열을 비교합니다.
  UserV2에 있는 id는 String입니다.
    
      문자열 비교는 ==이 아니라 equals()를 사용해야 합니다.
    
  


package lang.object.equals;

public class EqualsMainV2 {

  public static void main(String[] args) {
    UserV2 user1 = new UserV2("id-100");
    UserV2 user2 = new UserV2("id-100");

    System.out.println("identity = " + (user1 == user2));
    System.out.println("equality = " + user1.equals(user2));
  }
}


실행 결과
identity = false
equality = true





  동일성(Identity) : 객체의 참조가 다르므로 동일성은 다릅니다.
  동등성(Equality) : user1, user2는 서로 다른 객체이지만 둘다 같은 id(고객번호)를 가지고 있습니다. 따라서 동등합니다.


정확한 equals() 구현
앞서 UserV2에서 구현한 equals()는 이해를 돕기 위해 매우 간단히 만든 버전이고, 실제로 정확하게 동작하려면 다음과 같이 구현해야 합니다.
정확한 equals() 메서드를 구현하는 것은 생각보다 쉽지 않습니다.

IntelliJ를 포함한 대부분의 IDE는 정확한 equals() 코드를 자동으로 만들어 줍니다.

  generator 단축키 : ⌘N(macOS) / Alt + Insert(Windows / Linux)


@Override
public boolean equals(Object o) {
    if (this == 0) return true;
    if (o == null || getClass() != o.getClass()) return false;
    User user = (User) o;
    return Objects.equalse(id, user.id);
}


equals() 메서드를 구현할 때 지켜야 하는 규칙

  반사성(Reflexivity): 객체는 자기 자신과 동등해야 합니다.(x.equals(x)는 항상 true).
  대칭성(Symmetry): 두 객체가 서로에 대해 동일하다고 판단하면, 이는 양방향으로 동일해야 합니다.(x.equals(y)가 true이면 y.equals(x)도 true).
  추이성(Transitivity): 만약 한 객체가 두 번째 객체와 동일하고, 두 번째 객체가 세 번째 객체와 동일하다면, 첫 번째 객체는 세 번째 객체와도 동일해야 합니다.
  일관성(Consistency): 두 객체의 상태가 변경되지 않는 한, equals() 메소드는 항상 동일한 값을 반환해야 합니다.
  null에 대한 비교: 모든 객체는 null과 비교했을 때 false를 반환해야 합니다.


실무에서는 대부분 IDE가 만들어주는 equalse()를 사용하므로, 이 규칙을 외우기 보다는 대략 이렇구나 정도로 한번 읽어보고 넘어가면 충분합니다.

정리

  참고로 동일성 비교가 항상 필요한 것은 아닙니다. 동일성 비교가 필요한 경우에만 equals()를 재정의하면 됩니다.
  equals()와 hashCode()는 보통 함께 사용됩니다.
    
      이 부분은 추후에 컬렉션 프레임워크를 학습후 정리하겠습니다.
    
  



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-04-01-SourceCodeAndCommands.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-04-01-SourceCodeAndCommands.html"><h1 class="title_post">💾 [CS] 소스코드와 명령어</h1></a>
                        <a href="/2024/CS/2024-04-01-SourceCodeAndCommands.html" class="txt_post">
                            소스코드와 명령어.

  ‘컴퓨터는 명령어를 처리하는 기계’
  명령어는 컴퓨터를 실질적으로 작동시키는 매우 중요한 정보
  모든 소스 코드(C, C++, Java, Python 과 같은 프로그래밍 언어로 만든 소스 코드)는 컴퓨터 내부에서 명령어로 변환됩니다.


고급 언어와 저급 언어

  프로그램을 만들 때 사용하는 프로그래밍 언어, 컴퓨터가 이해하는 언어가 아닌 사람이 이해하고 작성하기 쉽게 만들어진 언어
    
      이렇게 ‘사람을 위한 언어’를 고급 언어(high-level programming language) 라고 합니다.
    
  
  컴퓨터가 직접 이해하고 실행할 수 있는 언어
    
      저급 언어(low-level programming language) 하고 합니다.
    
  
  컴퓨터가 이해하고 실행할 수 있는 언어는 오직 저급 언어뿐입니다.
    
      그래서 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어, 즉 명령어로 변환되어야 합니다.
    
  
  저급 언어에는 두 가지 종류가 있습니다.
    
      기계어
        
          0과 1의 명령어 비트로 이루어진 언어입니다.
          다시 말해 0과 1로 이루어진 명령어 모음입니다.
        
      
      어셈블리어
        
          0과 1로 표현된 명령어(기계어)를 읽기 편한 형태로 번역한 언어
        
      
    
  


컴파일 언어와 인터프리터 언어

  고급 언어는 저급 언어로 변환되는 방식으로는 크게 두 가지 방식이 있습니다.
    
      컴파일 방식
        
          컴파일 방식으로 작동하는 프로그래밍 언어를 컴파일 언어
        
      
      인터프리트 방식
        
          인터프리트 방식으로 작동하는 프로그래밍 언어를 인터프리터 언어
        
      
    
  


컴파일 언어

  컴파일 언어
    
      컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어입니다.
    
  
  컴파일(Compile)
    
      컴파일 언어로 작성된 소스 ㅋ코드는 전체가 저급 언어로 변환되는 과정을 거치는데 이 과정을 “컴파일”이라고 합니다.
    
  
  컴파일러(Compiler)
    
      컴파일을 수행해 주는 도구
      개발자가 작성한 소스 코드 전체를 쭉 훑어보며 소스 코드에 문법적인 오류는 없는지, 실행 가능한 코드인지, 실행 가능한 코드인지, 실행하는 데 불필요한 코드는 없는지 등을 따지며 소스 코드를 처음부터 끝까지 저급 언어로 컴파일합니다.
        
          이때 컴파일러가 소스 코드 내에서 오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패합니다.
        
      
    
  
  목적 코드(Object Code)
    
      컴파일이 성공적으로 수행되면 개발자가 작성한 소스 코드는 컴퓨터가 이해할 수 있는 저급 언어로 변환됩니다.
        
          이렇게 컴파일러를 통해 저급 언어로 변환된 코드를 목적 코드(Object code) 라고 합니다.
        
      
    
  


인터프리어 언어

  인터프리터 언어
    
      인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어입니다
        
          대표적인 인터프리터 언어로 Python이 있습니다.
        
      
    
  
  인터프리터
    
      소스 코드를 한 줄씩 저급 언어로 변환하여 실행해 주는 도구
    
  
  인터프리터 언어는 컴퓨터와 대화하듯 소스 코드를 한 줄씩 실행하기 때문에 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없습니다.
    
      소스 코드 내에 오류가 하나라도 있으면 컴파일이 불가능했던 컴파일 언어와는 달리, 인터프리터 언어는 소스 코드를 한 줄씩 실행하기 때문에 소스 코드 N번째 줄에 문법 오류가 있더라도 N-1번째 줄까지는 올바르게 수행됩니다.
    
  
  일반적으로 인터프리터 언어는 컴파일 언어보다 느립니다.
    
      컴파일을 통해 나온 결과물, 즉 목적 코드는 컴퓨터가 이해하고 실행할 수 있는 저급 언어인 반면, 인터프리터 언어는 소스코드 마지막에 이를 때까지 한 줄 한 줄씩 저급언어로 실행해야 하기 때문입니다.
    
  


목적 파일 vs 실행 파일

  목적 파일
    
      목적 코드로 이루어진 파일입니다.
    
  
  실행 파일
    
      윈도우의 .exe 확장자를 가진 파일이 대표적인 실행 파일입니다.
    
  
  목적 코드가 실행 파일이 되기 위해서는 링킹이라는 작업을 거쳐야 합니다.
  링킹
    
      여러 개의 오브젝트 파일이나 라이브러리를 하나의 실행 파일로 결합하는 과정을 의미합니다. 컴파일러가 소스 코드를 기계어로 번역한 후 링커(Linker)가 이러한 기계어 코드들을 모아 실행 가능한 프로그램을 만듭니다.
    
  


키워드로 정리하는 핵심 포인트

  고급 언어는 사람이 이해하고 작성하기 쉽게 만들어진 언어입니다.
  저급 언어는 컴퓨터가 직접 이해하고 실행할 수 있는 언어입니다.
  저급 언어는 0과 1로 이루어진 명령어로 구성된 기계어와 기계어를 사람이 읽기 편한 형태로 번역한 어셈블리어가 있습니다.
  컴파일 언어는 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 언어입니다.
  인터프리터 언어는 인터프리터에 의해 소스 코드가 한 줄씩 저급 언어로 변환되어 실행되는 언어 입니다.


Q1. Swift는 일반적으로 고급 언어로 분류됩니다. Swift의 어떤 특징이 개발자에게 고급 언어의 장점을 제공한다고 생각하나요?

Swift는 고급 언어의 특징으로 높은 수준의 추상화, 강력한 타입 시스템, 메모리 안전성, 그리고 빠른 개발 시간을 제공합니다. Swift의 옵셔널 타입과 같은 기능은 안전한 코드 작성을 돕고, ARC는 메모리 관리를 단순화합니다.

Q2. 고급 언어와 저급 언어의 차이점은 무엇이라고 생각하나요?

고급 언어는 인간이 이해하기 쉬운 형태로 추상화된 언어로, 복잡한 작업을 간단하게 표현할 수 있게 해줍니다. Java와 같은 고급 언어는 메모리 관리, 객체 지향 프로그래밍, 에러 처리 등 복잡한 컴퓨팅 개념을 추상화하여 개발자가 더 쉽게 소프트웨어를 개발할 수 있도록 돕습니다.

저급 언어는 컴퓨터가 직접 이해할 수 있는 더 낮은 수준의 명령어로 구성됩니다. 이에 해당하는 언어는 어셈블리 언어나 기계어로, 이들은 하드웨어와 밀접한 작업을 수행하는 데 사용됩니다. 저급 언어를 사용하면 성능 최적화와 메모리 관리를 더 세밀하게 제어할 수 있지만, 개발과 디버깅 과정이 복잡해집니다.

Q3. Java는 고급 언어 중 하나로 간주됩니다. Java에서 저급 언어의 특성을 활용할 수 있는 방법에는 어떤 것이 있나요?

Java는 기본적으로 고급 언어의 특성을 많이 가지고 있지만, JNI(Java Native Interface)를 통해 저급 언어 코드와 상호 작용할 수 있습니다. JNI는 Java 애플리케이션 내에서 C나 C++과 같은 저급 언어로 작성된 코드를 호출하고 사용할 수 있는 방법을 제공합니다. 이를 통해 개발자는 특정 작업을 위해 시스템 호출이나 하드웨어 직접 제어와 같은 저급 언어의 성능과 효율성을 Java 애플리케이션에 통합할 수 있습니다. 또한, 고성능을 요구하는 애플리케이션의 특정 부분에서 성능을 최적화할 수 있습니다.

Q4. Java에서 고급 언어의 특성이 백엔드 개발에 어떤 장점을 제공하나요?

Java의 고급 언어 특성은 백엔드 개발에서 여러 가지 장점을 제공합니다. 첫째, 강력한 객체 지향 프로그래밍(OOP) 지원으로 코드의 재사용성, 확장성, 유지 보수성이 향상됩니다. 둘째, 자동 메모리 관리와 가비지 컬렉션으로 메모리 누수와 같은 문제를 방지하며 개발자가 메모리 관리에 덜 신경 쓰고 로직 개발에 더 집중할 수 있게 합니다. 셋째, 다양한 라이브러리와 프레임워크, 그리고 강력한 개발 도구와 커뮤니티 지원으로 개발 속도와 효율성이 증가합니다. 마지막으로, Java는 플랫폼 독립적인 특성을 가지고 있어, 다양한 운영 체제에서 실행될 수 있는 애플리케이션을 개발할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-04-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-31-ObjectAndOCP.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-31-ObjectAndOCP.html"><h1 class="title_post">☕️[Java] Object와 OCP</h1></a>
                        <a href="/2024/Java/2024-03-31-ObjectAndOCP.html" class="txt_post">
                            Object와 OCP.

만약 Object가 없고, 또 Object가 제공하는 toString()이 없다면 서로 아무 관계가 없는 객체의 정보를 출력하기 어려울 것입니다.

여기서 아무 관계가 없다는 것은 공통의 부모가 없다는 뜻 입니다.

아마도 다음의 BadObjectPrinter 클래스와 같이 각각의 클래스마다 별도의 메서드를 작성해야 할 것입니다.

BadObjectPrinter
public class BadObjectPrinter {
    public static void print(Car car) { // Car 전용 메서드
        String string = "객체 정보 출력: " + car.carInfo(); // carInfo() 메서드 만듬
        System.out.println(string);
    }
    
    public static void print(Dog dog) { // Dog 전용 메서드
        String string = "객체 정보 출력: " + dog.dogInfo(); // dogInfo() 메서드 만듬
        System.out.println(string);
    }
}


구체적인 것에 의존
BadObjectPrinter는 구체적인 타입인 Car, Dog를 사용합니다.

  따라서 이후에 출력해야 할 구체적인 클래스가 10개로 늘어나면 구체적인 클래스에 맞추어 메서드도 10개로 계속 늘어나게 됩니다.
    
      이렇게 BadObjectPrinter 클래스가 구체적인 특정 클래스인 Car, Dog를 사용하는 것을 BadObjectPrinter는 Car, Dog에 의존한다고 표현합니다.
    
  


다행히도 자바에는 객체의 정보를 사용할 때, 다형적 참조 문제를 해결해줄 Object 클래스와 메서드 오버라이딩 문제를 해결해줄 Object.toString() 메서드가 있습니다.(물론 직접 Object와 비슷한 공통의 부모 클래스를 만들어서 해결할 수도 있습니다.)

추상적인 것에 의존
앞서 만든 ObjectPrinter 클래스는 Car, Dog 같은 구체적인 클래스를 사용하는 것이 아니라, 추상적인 Object 클래스를 사용합니다.

  이렇게 ObjectPrinter 클래스가 Object 클래스를 사용하는 것을 Object에 클래스에 의존한다고 표현합니다.


public class ObjectPrinter {
    public static void print(Object obj) {
        String string = "객체 정보 출력: " + obj.toString();
        System.out.println(string);
    }
}


ObjectPrinter는 구체적인 것에 의존하는 것이 아니라 추상적인 것에 의존합니다.


  추상적 : 여기서 말하는 추상적이라는 뜻은 단순히 추상 클래스나 인터페이스만 뜻하는 것은 아닙니다.
Animal과 Dog, Cat의 관계를 떠올려봅시다.
Animal 같은 부모 타입으로 올라갈 수록 개념은 더 추상적이게 되고, Dog, Cat과 같이 하위 타입으로
내려갈 수록 개념은 더 구체적이게 됩니다.




ObjectPrinter와 Object를 사용하는 구조는 다형성을 매우 잘 활용하고 있습니다.

  다형성을 잘 활용한다는 것은 다형적 참조와 메서드 오버라이딩을 적절하게 사용한다는 뜻입니다.


ObjectPrinter의 print() 메서드와 전체 구조를 분석해봅시다.

  다형적 참조 : print(Object obj), Object 타입을 매개변수로 사용해서 다형적 참조를 사용합니다. Car, Dog 인스턴스를 포함한 세상의 모든 객체 인스턴스를 인수로 받을 수 있습니다.
  메서드 오버라이딩 : Object는 모든 클래스의 부모입니다. 따라서 Dog, Car와 같은 구체적인 클래스는 Object가 가지고 있는 toString() 메서드를 오버라이딩 할 수 있습니다.
    
      따라서 print(Object obj) 메서드는 Dog, Car와 같은 구체적인 타입에 의존(사용)하지 않고, 추상적인 Object 타입에 의존하면서 런타임에 각 인스턴스의 toString()을 호출할 수 있습니다.
    
  


OCP 원칙
OCP 원칙을 떠올려 봅시다.

  Open : 새로운 클래스를 추가하고, toString()을 오버라이딩해서 기능을 확장할 수 있습니다.
  Closed : 새로운 클래스를 추가해도 Object와 toString()을 사용하는 클라이언트 코드인 ObjectPrinter는 변경하지 않아도 됩니다.


다형적 참조, 메서드 오버라이딩, 그리고 클라이언트 코드가 구체적인 Car, Dog에 의존하는 것이 아니라 추상적인 Object에 의존하면서 OCP 원칙을 지킬 수 있었습니다.

  덕분에 새로운 클래스를 추가하고 toString() 메서드를 새롭게 오버라이딩해서 기능을 확장할 수 있습니다.
    
      그리고 이러한 변화에도 불구하고 클라이언트 코드인 ObjectPrinter는 변경할 필요가 없습니다.
    
  


ObjectPrinter는 모든 타입의 부모인 Object를 사용하고, Object가 제공하는 toString() 메서드만 사용합니다.

  따라서 ObjectPrinter를 사용하면 세상의 모든 객체의 정보(toString())를 편리하게 출력할 수 있습니다.


System.out.println()
지금까지 설명한 ObjectPrinter.print()는 사실 System.out.println()의 작동 방식을 설명하기 위해 만든 것입니다.

  System.out.println() 메서드도 Object 매개변수를 사용하고 내부에서 toString()을 호출합니다.
    
      따라서 System.out.println()를 사용하면 세상의 모든 객체의 정보(toString())를 편리하게 출력할 수 있습니다.
    
  




자바 언어는 객체지향 언어 답게 언어 스스로도 객체지향의 특징을 매우 잘 활용합니다.

  지금까지 배운 toString() 메서드와 같이, 자바 언어가 기본으로 제공하는 다양한 메서드들은 개발자가 필요에 따라 어버라이딩해서 사용할 수 있도록 설계되어 있습니다.


참고 - 정적 의존관계 vs 동적 의존관계

  정적 의존관계는 컴파일 시간에 결정되며, 주로 클래스 간의 관계를 의미합니다. 앞서 보여준 클래스 의존 관계 그림이 바로 정적 의존관계입니다.
    
      쉽게 이야기해서 프로그램을 실행하지 않고, 클래스 내에서 사용하는 타입들만 보면 쉽게 의존관계를 파악할 수 있습니다.
    
  
  동적 의존관계는 프로그램을 실행하는 런타임에 확인할 수 있는 의존관계입니다. 앞서 ObjectPrinter.print(Object obj)에 인자로 어떤 객체가 전달 될 지는 프로그램을 실행해봐야 알 수 있습니다.
    
      어떤 경우에는 Car 인스턴스가 넘어오고, 어떤 경우에는 Dog 인스턴스가 넘어옵니다. 이렇게 런타임에 어떤 인스턴스를 사용하는지를 나타내는 것이 동적 의존관계입니다.
    
  
  참고로 단순히 의존관계 또는 어디에 의존한다고 하면 주로 정적 의존관계를 뜻합니다.
    
      예) ObjectPrinter는 Object에 의존합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/SQL/2024-03-31-sql.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/SQL/2024-03-31-sql.html"><h1 class="title_post">💉[SQL] SQL 문의 기본 구조, SQL</h1></a>
                        <a href="/2024/SQL/2024-03-31-sql.html" class="txt_post">
                            SQL

  SQL은 “데이터베이스와 대화를 하기 위한 언어”
  SQL(Structured Query Language)은 데이터베이스 관리를 위해 널리 사용되는 쿼리 언어.


Query(쿼리)

  데이터베이스에 저장된 데이터에 접근하거나 조직하기 위한 명령어.


SQL 문의 기본 구조
SELECT # '데이터 조회'의 명령어로 필수 구문
FROM # '어디에서 데이터를 조회할까'의 명령어로 필수 구문
WHERE # 조건을 지정해주는 구문


  조건을 지정하는 방법.
    
      비교 연산자: &lt;, &gt;, =, &lt;&gt;(같지 않다)
      다양한 구문: IN, BETWEEN, LIKE
      여러가지 조건의 적용: AND, OR, NOT
    
  


참고 자료

  테이블과 컬럼, SQL
  WHERE란?
  AND, OR, NOT
  BETWEEN, IN, LIKE


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-31-equals1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-31-equals1.html"><h1 class="title_post">☕️[Java] equals() - 1.동일성과 동등성</h1></a>
                        <a href="/2024/Java/2024-03-31-equals1.html" class="txt_post">
                            equals() - 1.동일성과 동등성
Object는 동등성 비교를 위한 equals() 메서드를 제공합니다.

자바는 두 객체가 같다라는 표현을 2가지로 분리해서 제공합니다.

  동일성(Idenriry) : == 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인
  동등성(Equality) : equals() 메서드를 사용하여 두 객체가 논리적으로 동등한지 확인


단어 정리
“동일”은 완전히 같음을 의미합니다. 반면 “동등”은 같은 가치나 수준을 의미하지만 그 형태나 외관 등이 완전히 같지는 않을 수 있습니다.


  쉽게 이야기해서 동일성은 물리적으로 같은 메모리에 있는 객체 인스턴스인지 참조값을 확인하는 것이고, 동등성은 논리적으로 같은지 확인하는 것입니다.
  동일성은 자바 머신 기준이고 메모리 참조가 기준이므로 물리적입니다.
    
      반면 동등성은 보통 사람이 생각하는 논리적인 기준에 맞추어 비교합니다.
    
  


예를 들어 같은 회원 번호를 가진 회원 객체가 2개 있다고 가정해봅시다.
User a = new User("id-100") // 참조 x001
User b = new User("id-100") // 참조 x002



  이 경우 물리적으로 다른 메모리에 있는 다른 객체이지만, 회원 번호를 기준으로 생각해보면 논리적으로는 같은 회원으로 볼 수 있습니다.(주민등록번호가 같다고 가정해도 됩니다.)
    
      따라서 동일성은 다르지만, 동등성은 같습니다.
    
  


문자의 경우도 마찬가지입니다.
String s1 = "hello";
String s2 = "hello";


  이 경우 물리적으로 각각의 “hello” 문자열이 다른 메모리에 존재할 수 있지만, 논리적으로는 같은 "hello"라는 문자열입니다.(사실 이 경우 자바가 같은 메모리를 사용하도록 최적화 합니다. 이 부분은 추후에 학습하겠습니다.)


예제를 통해서 동일성과 동등성을 비교해봅시다.

package lang.object.equals;

public class EqualsMainV1 {

  public static void main(String[] args) {
    UserV1 user1 = new UserV1("id-100");
    UserV1 user2 = new UserV1("id-100");

    System.out.println("identity = " + (user1 == user2));
    System.out.println("equlity = " + (user1.equals(user2)));
  }
}


실행 결과
identity = false
equlity = false




동일성 비교
user1 == user2
x001 == x002
false // 결과


동등성 비교
Object.equals() 메서드
public boolean equals(Object obj) {
    return (this == obj);
}


  Object가 기본적으로 제공하는 equals()는 ==으로 동일성 비교를 제공합니다.


equals 실행 순서 예시
user1.equals(user2)
return (user1 == user2) // Object.equals 메서드 안
return (x001 == x002) // Object.equals 메서드 안
return false
false


동등성이라는 개념은 각각의 클래스 마다 다릅니다.

어떤 클래스는 주민등록번호를 기반으로 동등성을 처리할 수 있고, 어떤 클래스는 고객의 연락처를 기반으로 동등성을 처리할 수 있습니다.
어떤 클래스는 회원 번호를 기반으로 동등성을 처리할 수 있습니다.

따라서 동등성 비교를 사용하고 싶으면 equals() 메서드를 재정의해야 합니다.
그렇지 않으면 Object는 동일성 비교를 기본으로 제공합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/SQL/2024-03-30-ANDORNOT.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/SQL/2024-03-30-ANDORNOT.html"><h1 class="title_post">💉[SQL] AND, OR, NOT</h1></a>
                        <a href="/2024/SQL/2024-03-30-ANDORNOT.html" class="txt_post">
                            AND, OR, NOT

AND
‘AND’ 연산자는 SQL에서 여러 조건을 동시에 만족해야 할 때 사용됩니다.

  즉, ‘AND’ 를 사용하는 쿼리는 모든 조건인 참(TRUE)일 때만 결과를 반환합니다.
  이는 데이터베이스에서 더 세밀한 필터링을 수행하고자 할 때 유용하며, 특히 복잡한 데이터 집합에서 기준에 부합하는 정확한 데이터를 찾고자 할 때 중요한 역할을 합니다.


‘AND’ 사용 예

  여러 기준에 따른 데이터 검색 : 나이가 30세 이상이면서 ‘New York’에 거주하는 모든 사람을 찾고 싶을 때
    SELECT * FROM people WHERE age &gt;= 30 AND city = 'New York' ;
    
    이 쿼리는 ‘age’ 열이 30 이상이면서 동시에 ‘city’ 열이 ‘New York’인 모든 행을 반환합니다.
  
  날짜 범위와 특정 조건을 동시에 만족하는 데이터 검색 : 2023년 1월 1일부터 2023년 3월 31일 사이에 등록되고, 상태가 ‘활성화’인 모든 계정을 찾고 싶을 때
    SELECT * FROM account WHERE registration_date BETWEEN '2023-01-01' AND '2023-03-31' AND status = 'Active';
    
    이 쿼리는 ‘registration_date’ 가 지정된 날짜 범위 내에 있으며, ‘status’ 가 ‘Active’ 인 행을 반환합니다.
  


‘AND’ 연산자의 특징

  ‘AND’ 연산자를 사용할 때는 각 조건이 서로 어떤 관계에 있는지 고려해야 합니다. 예를 들어, 상호 배타적인 조건을 ‘AND’ 로 연결하면 결과가 항상 비어 있을 것입니다.
  성능에 영향을 미칠 수 있는 큰 데이터 세트에서는 인덱스와 조건의 효율적인 사용이 중요합니다. 가능한 한, 성능에 영향을 덜 미치는 조건을 먼저 적용하는 것이 좋습니다.


‘AND’ 연산자는 복수의 조건을 조합하여 데이터를 필터링하고자 할 때 필수적인 도구입니다.
이를 통해 더 정확하고 의미 있는 데이터 집합을 얻을 수 있으며, SQL 쿼리 작성 시 다양한 상황에 맞춰 유연하게 적용할 수 있습니다.



OR
‘OR’ 연산자는 SQL에서 주어진 조건 중 하나 이상이 참(TRUE)일 때 결과를 반환하고자 할 때 사용됩니다.

  ‘OR’ 을 사용하면 여러 조건 중 하나라도 만족하는 데이터를 선택할 수 있어, 데이터베이스 쿼리의 유연성을 크게 향상시킬 수 있습니다.
  ‘OR’ 은 다양한 시나리오에서 유용하게 사용되며, 특히 여러 다른 가능성을 모두 포함해야 할 때 중요한 역할을 합니다.


‘OR’ 사용 예

  여러 다른 값 중 하나를 만족하는 데이터 검색 : ‘Manager’ 또는 ‘Sales’ 부서에 속한 모든 직원을 찾고 싶을 때
    SELECT * FROM employees WHERE department = 'Manager' OR department = 'Sales';
    
    이 쿼리는 ‘department’ 열이 ‘Manager’이거나 ‘Sales’인 모든 행을 반환합니다.
  
  여러 조건 중 하나 이상을 만족하는 데이터 검색 : 나이가 18세 미만이거나 65세 이상인 모든 사람을 찾고 싶을 때
    SELECT * FROM people WHERE age &lt; 18 OR age &gt;= 65;
    
    이 쿼리는 ‘age’ 열이 18세 미만이거나 65세 이상인 모든 행을 반환합니다.
  


‘OR’ 연산자의 특징

  ‘OR’ 연산자를 사용할 때는 주어진 조건 중 하나라도 참이면 결과 집합에 해당 행이 포함됩니다. 모든 조건이 거짓(FALSE)인 경우에만 결과에서 제외됩니다.
  여러 개의 다른 가능성을 허용하는 데 유용하며, 특히 사용자의 입력이나 선택에 따라 다양한 결과를 보여줘야 할 때 자주 사용됩니다.
  ‘AND’ 연산자와 함께 사용될 수 있으나, 이 경우 우선 순위에 주의해야 하며, 괄호를 사용하여 연산자 간의 우선 순위를 명확하게 구분해야 합니다.


사용 시 고려사항

  ‘OR’ 연산자를 사용할 때는 쿼리의 성능에 주의해야 합니다. 특히 대규모 데이터 셋에서는 ‘OR’ 조건이 많을 수록 쿼리 성능이 저하될 수 있습니다.
  가능한 경우, ‘OR’ 을 사용하는 대신 다른 접근 방식을 고려해보는 것도 좋습니다. 예를 들어, ‘IN’ 연산자를 사용하면 ‘OR’ 과 유사한 결과를 더 효율적으로 얻을 수 있을 때가 많습니다.
  복잡한 쿼리에서는 ‘OR’ 과 ‘AND’ 를 혼합하여 사용할 때 괄호를 적절히 사용하여 명확한 논리 구조를 유지하는 것이 중요합니다.


‘OR’ 연산자는 다양한 조건을 유연하게 처리하고자 할 때 매우 유용하며, SQL 쿼리를 작성하는 과정에서 필요한 결과를 얻기 위해 다양한 시나리오를 고려할 수 있게 해줍니다.



NOT
‘NOT’ 연산자는 SQL에서 조건의 논리를 부정할 때 사용됩니다.

  즉, ‘NOT’ 은 특정 조건이 거짓(FALSE)일 때 참(TRUE)인 결과를 반환하도록 합니다.
    
      이를 통해 특정 조건을 만족하지 않는 데이터를 검색하고자 할 때 매우 유용하게 활용할 수 있습니다.
    
  
  ‘NOT’ 연산자는 ‘WHERE’ 절 내에서 다른 연산자(예: ‘IN’, ‘BETWEEN’, ‘LIKE’, ‘EXISTS’)와 함께 사용되어, 해당 조건의 반대되는 결과를 얻고자 할 때 사용됩니다.


‘NOT’ 사용 예

  특정 조건을 만족하지 않는 데이터 검색 : ‘Sales’ 부서에 속하지 않는 모든 직원을 찾고 싶을 때
    SELECT * FROM employees WHERE NOT department = 'Sales';
    
    이는 ‘department’ 가 ‘Sales’ 가 아닌 모든 행을 반환합니다.
  
  특정 범위에 속하지 않는 데이터 검색 : 20세에서 30세 사이가 아닌 사람을 찾고 싶을 때
    SELECT * FROM people WHERE NOT age BETWEEN 20 AND 30;
    
    이는 나이가 20세 이상 30세 이하가 아닌 모든 사람을 찾습니다.
  
  지정된 목록에 포함되지 않는 데이터 검색 : ‘Manager’와 ‘Sales’ 부서에 속하지 않은 모든 직원을 찾고 싶을 때
    SELECT * FROM employee WHERE department NOT IN ('Manager', 'Sales');
    
    이 쿼리는 ‘department’ 가 ‘Manager’ 또는 ‘Sales’가 아닌 모든 행을 반환합니다.
  


‘NOT’ 연산자의 특징.

  ‘NOT’ 연산자는 조건의 논리를 부정하여, 조건이 거짓일 때 참을 반환합니다.
  ‘NOT’ 은 ‘WHERE’ 절에서 다양한 연산자와 함께 사용될 수 있으며, 특정 조건을 제외한 데이터를 선택하고자 할 때 유용합니다.
  복잡한 조건에서는 ‘NOT’ 을 사용하여 예외적인 경우를 쉽게 필터링할 수 있습니다.


사용 시 고려사항.

  ‘NOT’ 연산자를 사용할 때는 쿼리의 성능에 주의해야 합니다. 특히, ‘NOT’ 이 포함된 조건은 인덱스 활용이 어려워 성능 저하를 일으킬 수 있습니다.
  명확하지 않은 논리를 피하기 위해, 가능한 한 ‘NOT’ 의 사용을 최소화하고, 대신 명확한 조건을 사용하여 원하는 결과를 얻는 것이 좋습니다.


‘NOT’ 연산자는 SQL 쿼리에서 특정 조건을 만족하지 않는 데이터를 필터링하고자 할 때 유용하게 사용됩니다.
하지만, 쿼리의 명확성과 성능을 고려하여 신중하게 사용해야 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-30</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/SQL/2024-03-30-BETWEENINLIKE.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/SQL/2024-03-30-BETWEENINLIKE.html"><h1 class="title_post">💉[SQL] BETWEEN, IN, LIKE</h1></a>
                        <a href="/2024/SQL/2024-03-30-BETWEENINLIKE.html" class="txt_post">
                            BETWEEN, IN, LIKE

BETWEEN
‘BETWEEN’ 연산자는 SQL에서 특정 범위 내의 값을 선택할 때 사용됩니다.

  이 연산자는 시작 값과 끝 값 사이에 있는 값을 찾는 데 사용되며, 포함 관계는 양 끝값을 포함합니다.
  ‘BETWEEN’ 은 숫자, 텍스트, 날짜 등 다양한 데이터 타입에 적용할 수 있어, 매우 유연하게 사용됩니다.


‘BETWEEN’ 사용 예

  숫자 범위 : 나이가 20세에서 30세 사이인 모든 사람을 찾고 싶을 때
    SELECT * FROM people WHERE age BETWEEN 20 AND 30;
    
  
  날짜 범위 : 2023년 1월 1일부터 2023넌 12월 31일까지 생성된 모든 주문을 찾고 싶을 때
    SELECT * FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31';
    
  
  텍스트 범위 : 알파벳 순으로 ‘apple’과 ‘banana’사이에 오는 모든 항목을 선택할 때
    SELECT * FROM products WHERE name BETWEEN 'apple' AND 'banana';
    
  


‘BETWEEN’의 특징.

  ‘BETWEEN’ 연산자는 시작 값과 끝 값 모두를 포함하는 “닫힌 범위(closed range)”를 정의합니다.
  범위 검색을 할 때 매우 효과적입니다. 예를 들어, 특정 기간 동안의 데이터 또는 특정 범위의 값을 갖는 데이터를 찾는 경우에 적합합니다.
  ‘BETWEEN’ 대신 ’&gt;=’ 와 ’&lt;=’ 를 사용해 동일한 조건을 표현할 수도 있지만, ‘BETWEEN’ 을 사용하는 것이 더 직관적이고 간결할 수 있습니다.


주의사항

  텍스트 범위를 사용할 때는 데이터베이스가 사용하는 문자열 정렬 규칙(collation)에 주의해야 합니다. 이는 대소문자 구분, 알파벳 순서 등에 영향을 미칠 수 있습니다.
  날짜 범위를 다룰 때는 날짜 포맷과 시간대 설정이 예상한 결과에 영향을 줄 수 있으니, 데이터베이스의 날짜 포맷 설정을 확인해야 합니다.




IN
‘IN’ 연산자는 SQL에서 한 번의 쿼리로 여러 값을 조회할 때 사용됩니다.

  특히, 하나의 열(column)이 여러 개의 가능한 값 중 하나를 갖고 있는지 확인할 때 유용합니다.
  ‘IN’ 은 주어진 값 리스트 중 어느 하나라도 일치하는 행을 찾을 때 사용되며, 리스트 내의 값과 정확히 일치하는 행만을 결과로 반환합니다.
    
      이는 복수의 ‘OR’ 조건을 사용하는 것과 동일한 결과를 나타내지만, 훨씬 간결하고 읽기 쉬운 쿼리를 작성할 수 있게 해줍니다.
    
  


‘IN’ 사용 예

  다수의 명시적 값에 대한 검색 : 이름이 ‘Alice’, ‘Bob’, 또는 ‘Charlie’인 모든 사람을 찾고 싶을 때
    SELECT * FROM people WHERE name IN ('Alice', 'Bob', 'Charlie');
    
  
  서브쿼리와 함께 사용 : 특정 조건을 만족하는 다른 테이블의 값에 해당하는 행을 찾을 때
    SELECT * FROM product WHERE category_id IN (SELECT id FROM categories WHERE type = 'Eletronics')
    
  
  리스트에 포함된 값들로 필터링 : 특정 지역 코드를 가진 모든 전화번호를 찾고 싶을 때
    SELECT * FROM phone_number WHERE area_code IN ('202', '303', '404');
    
  


‘IN’ 연산자의 특징

  ‘IN’ 은 주어진 리스트 안에 있는 값과 일치하는 모든 행을 찾아내는 데 사용됩니다.
  복수의 ‘OR’ 조건을 간단하게 표현할 수 있어, 쿼리의 가독성을 높여줍니다.
  리스트 내의 각 항목은 정확한 일치(match)를 찾는 데 사용되므로, 부분 일치나 패턴 일치를 위해서는 다른 연산자(예: ‘LIKE’)를 사용해야 합니다.
  ‘IN’ 은 서브쿼리와 함께 사용될 때 매우 강력하며, 다른 테이블의 결과에 기반한 쿼리를 작성하는 데 유용합니다.


사용 시 고려사항

  ‘IN’ 리스트에 많은 수의 값이 포함될 경우, 성능이 저하될 수 있습니다. 가능한 한, ‘JOIN’ 이나 다른 방법으로 쿼리를 최적화하는 것을 고려해야 합니다.
  ‘IN’ 으로 서브 쿼리를 사용할 때는 서브쿼리가 많은 양의 데이터를 반환하지 않도록 주의해야 합니다. 서브쿼리의 결과가 크면 큰 만큼, 전체 쿼리의 성능에 영향을 줄 수 있습니다.


‘IN’ 연산자는 SQL에서 특정한 값들의 집합에 대해 검색할 때 매우 유용하며, 쿼리의 복잡성을 줄이고 읽기 쉽게 만들어 줍니다.



LIKE
‘LIKE’ 연산자는 SQL에서 패턴 매칭을 통해 데이터를 검색할 때 사용됩니다.

  이는 주로 텍스트 데이터를 다룰 때 유용하며, 특정 패턴이나 일부 문자열이 포함된 행을 찾고자 할 때 활용됩니다.
  ‘LIKE’ 연산자는 와일드카드 문자와 함께 사용되며, 더 유연한 검색 조건을 제공합니다.
  주로 사용되는 와일드카드에는 ‘%’(어떤 문자열이든지 대체 가능)와 ‘_‘(단인 문자 대체)가 있습니다.


‘LIKE’ 사용 예

  특정 문자열로 시작하는 데이터 검색 : 이름이 ‘J’로 시작하는 사람을 찾고 싶을 때
    SELECT * FROM people WHERE name LIKE 'J%';
    
    이 경우, ‘J’로 시작하는 모든 이름을 찾습니다. ‘%’는 ‘J’ 이후에 어떤 문자열이 와도 괜찮다는 것을 의미합니다.
  
  특정 문자열을 포함하는 데이터 검색 : 이메일 주소에 ‘gmail.com’을 포함하는 모든 사람을 찾고 싶을 때
    SELECT * FROM people WHERE email LIKE '%gmail.com';
    
    여기서 ‘%’는 ‘gmail.com’ 앞에 어떤 문자열이 오든지 상관 없다는 것을 의미합니다.
  
  특정 패턴에 맞는 데이터 검색 : 세 자리 코드 중 두 번째 자리가 ‘A’인 모든 코드를 찾고 싶을 때
    SELECT * FROM codes WHERE code LIKE '_A%';
    
    이 쿼리에서 ‘_‘는 정확히 하나의 문자를 대체하고, ‘%’는 그 뒤에 어떤 문자열이 오든지 상관 없다는 것을 의미합니다.
  


‘LIKE’ 연산자의 특징

  ‘LIKE’ 는 대소문자를 구분하는 데이터베이스에서는 대소문자가 정확히 일치하는 경우에만 결과를 반환합니다. 대소문자 구분 없이 검색하려면, 데이터베이스 또는 컬럼의 설정을 확인하거나, 쿼리에 특정 함수를 사용해야 할 수 있습니다.
  패턴 매칭을 통해 유연한 검색이 가능하지만, 와일드카드를 많이 사용할수록 쿼리의 성능은 떨어질 수 있습니다. 특히, 문자열 시작 부분에 ‘%’를 사용하는 경우 인덱스 활용이 어려워 성능 저하의 원인이 될 수 있습니다.


‘LIKE’ 연산자는 문자열 필드 내에서 특정 패턴이나 부분 문자열을 기반으로 데이터를 검색할 때 매우 유용합니다.
패턴 매칭 기능을 통해 복잡한 조건의 문자열 검색을 수행할 수 있으며, 데이터 분석이나 데이터 정제 과정에서 중요한 역할을 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-30</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/SQL/2024-03-29-WHERE.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/SQL/2024-03-29-WHERE.html"><h1 class="title_post">💉[SQL] WHERE란?</h1></a>
                        <a href="/2024/SQL/2024-03-29-WHERE.html" class="txt_post">
                            WHERE ?

SQL에서 ‘WHERE’ 절은 데이터베이스에서 특정 조건을 만족하는 행(row)을 검색할 때 사용됩니다.

  기본적으로 ‘SELECT’, ‘UPDATE’, ‘DELETE’ 문에서 데이터를 필터링하기 위해 사용되며, 이를 통해 반환되거나 영향을 받는 데이터의 범위를 좁힐 수 있습니다.


WHERE 절의 기본 구조
SELECT column1, column2, ...
FROM table_name
WHERE conditionl


  ‘SELECT’ 문에서는 특정 조건을 만족하는 행을 선택해 반환합니다.
  ‘UPDATE’ 문에서는 특정 조건을 만족하는 행에 대해서만 업데이트를 수행합니다.
  ‘DELETE’ 문에서는 특정 조건을 만족하는 행을 삭제합니다.


조건의 사용
‘WHERE’ 절에서 사용할 수 있는 조건에는 다음과 같은 것들이 있습니다.


  비교 연산자(’=’, ‘!=’, ‘&lt;’, ‘&gt;’, ‘&lt;=’, ‘&gt;=’)
  논리 연산자(‘AND’, ‘OR’, ‘NOT’)
  범위 검색(‘BETWEEN’)
  목록에서 선택(‘IN’)
  패턴 매칭(‘LIKE’)
  NULL 값 검사(‘IS NULL’)


예시
예를 들어, 이름이 ‘Jhon’인 사람의 정보를 찾고 싶다면 다음과 같이 쿼리를 작성할 수 있습니다.
SELECT * FROM users WHERE name = 'Jhon';


또는 나이가 18세 이상인 모든 사용자를 찾고 싶다면 다음과 같이 작성할 수 있습니다.
SELECT * FROM users WHERE age &gt;= 18;


‘WHERE’ 절을 사용함으로써, 큰 데이터베이스 내에서도 필요한 데이터를 효율적으로 찾아낼 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-29</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-29-ObjectPolymorphism.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-29-ObjectPolymorphism.html"><h1 class="title_post">☕️[Java] Object 다형성</h1></a>
                        <a href="/2024/Java/2024-03-29-ObjectPolymorphism.html" class="txt_post">
                            Object 다형성.
Object는 모든 클래스의 부모 클래스입니다.

  따라서 Object는 모든 객체를 참조할 수 있습니다.


예제를 통해서 Object의 다형성에 대해서 알아봅시다.



Dog와 Car은 서로 아무런 관련이 없는 클래스입니다.

  둘다 부모가 없으므로 Object를 자동으로 상속 받습니다.


package lang.object.poly;

public class Car {
 public void move() {
   System.out.println("자동차 이동");
 }
}


package lang.object.poly;

public class Dog {

  public void sound() {
    System.out.println("멍멍");
  }
}


package lang.object.poly;

public class ObjectPolyExample1 {

  public static void main(String[] args) {
    Dog dog = new Dog();
    Car car = new Car();

    action(dog);
    action(car);
  }

  private static void action(Object obj) {
    //obj.sound(); // 컴파일 오류, Object는 sound()가 없다.
    //obj.move(); // 컴파일 오류, Object는 move()가 없다.

    // 객체에 맞는 다운캐스팅이 필요함.
    if (obj instanceof Dog dog) {
      dog.sound();
    } else if (obj instanceof Car car) {
      car.move();
    }
  }
}


실행 결과
멍멍
자동차 이동


Object는 모든 타입의 부모입니다.

부모는 자식을 담을 수 있으므로 앞의 코드를 다음과 같이 변경해도 됩니다.

Object dog = new Dog(): // Dog -&gt; Object
Object car = new Car(): // Car -&gt; Object


Object 다형성의 장점.
action(Object obj) 메서드를 분석해봅시다.

  이 메서드는 Object 타입의 매개변수를 사용합니다.
    
      그런데 Object는 모든 객체의 부모입니다.
        
          따라서 어떤 객체든지 인자로 전달 할 수 있습니다.
        
      
    
  


action(dog) // main에서 dog 전달
void action(Object obj = dog(Dog)) //Object는 자식인 Dog 타입을 참조할 수 있습니다.


action(car)
void action(Object obj = car(Car)) // Object는 자식인 Car 타입을 참조할 수 있습니다.


Object 다형성의 한계.
action(dog) // main에서 dog 전달
private static void action(Object obj) {
    obj.sound(); // 컴파일 오류, Object는 sound()가 없습니다.
}


action() 메서드안에서 obj.sound()를 호출하면 오류가 발생합니다.

  왜냐하면 매개변수인 obj는 Object 타입이기 때문입니다.
    
      Object에는 sound() 메서드가 없습니다.
    
  




obj.sound() 호출

  obj.sound()를 호출합니다.
  obj는 Object 타입이므로 Object 타입에서 sound()를 찾습니다.
  Object에서 sound()를 찾을 수 없습니다.
    
      Object는 최종 부모이므로 더는 올라가서 찾을 수 없습니다.
        
          따라서 오류가 발생합니다.
        
      
    
  


Dog 인스턴스의 sound()를 호출하려면 다음과 같이 다운캐스팅을 해야합니다.
if (obj instanceof Dog dog) {
    dog.sound();
}




  Object obj의 참조값을 Dog dog로 다운캐스팅 하면서 전달합니다.
  dog.sound()를 호출하면 Dog 타입에서 sound()를 찾아서 호출합니다.


Object를 활용한 다형성의 한계.

  Object는 모든 객체를 대상으로 다형적 참조를 할 수 있습니다.
    
      쉽게 이야기해서 Object는 모든 객체의 부모이므로 모든 객체를 담을 수 있습니다.
    
  
  Object를 통해 전달 받은 객체를 호출하려면 각 객체에 맞는 다운캐스팅 과정이 필요합니다.
    
      Object가 세상의 모든 메서드를 알고 있는 것이 아닙니다.
    
  


다형성을 제대로 활용하려면 다형적 참조 + 메서드 오버라이딩을 함께 사용해야 합니다.

  그런면에서 Object를 사용한 다형성에는 한계가 있습니다.


Object는 모든 객체의 부모이므로 모든 객체를 대상으로 다형적 참조를 할 수 있습니다.

  하지만 Object에는 Dog.sound(), Car.move()와 같은 다른 객체의 메서드가 정의되어 있지 않습니다.
    
      따라서 메서드 오버라이딩을 활용할 수 없습니다.
        
          결국 각 객체의 기능을 호출하려면 다운캐스팅을 해야 합니다.
        
      
    
  
  참고로 Object 본인이 보유한 toString() 같은 메서드는 당연히 자식 클래스에서 오버라이딩 할 수 있습니다.
    
      여기서 이야기하는 것은 앞서 설명한 Dog.sound(), Car.move() 같은 Object에 속하지 않은 메서드를 말합니다.
    
  


결과적으로 다형적 참조는 가능하지만, 메서드 오버라이딩이 안되기 때문에 다형성을 활용하기에는 한계가 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-29</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-29-ObjectArray.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-29-ObjectArray.html"><h1 class="title_post">☕️[Java] Object 배열</h1></a>
                        <a href="/2024/Java/2024-03-29-ObjectArray.html" class="txt_post">
                            Object 배열.
이번에는 Object 배열을 알아봅시다.
Object는 모든 타입의 객체를 담을 수 있습니다.

  따라서 Object[]을 만들면 세상의 모든 객체를 담을 수 있는 배열을 만들 수 있습니다.


package lang.object.poly;

public class ObjectPolyExample2 {

  public static void main(String[] args) {
    Dog dog = new Dog();
    Car car = new Car();
    Object object = new Object(); //Object 인스턴스도 만들 수 있습니다.

    Object[] objects = {dog, car, object};
    
    size(objects);
  }

  private static void size(Object[] objects) {
    System.out.println("전달된 객체의 수는: " + objects.length);
  }
}


실행 결과
전달된 객체의 수는: 3


Object[] objects = {dog, car, object};
// 쉽게 풀어서 설명하면 다음과 같습니다.
Object objects[0] = new Dog();
Object objects[1] = new Car();
Object objects[2] = new Object();


Object 타입을 사용한 덕분에 세상의 모든 객체를 담을 수 있는 배열을 만들 수 있었습니다.



size() 메서드
size(Object[] objects) 메서드는 배열에 담긴 객체의 수를 세는 역할을 담당합니다.

  이 메서드는 Object 타입의 배열은 세상의 모든 객체를 담을 수 있기 때문에, 새로운 클래스가 추가되거나 변경되어도 이 메서드를 수정하지 않아도 됩니다.
    
      지금 만든 size() 메서드는 자바를 사용하는 곳이라면 어디든지 사용될 수 있습니다.
    
  


Object가 없다면?
만약 Object와 같은 개념이 없다면 어떻게 될까요?

  void action(Object obj)과 같이 모든 객체를 받을 수 있는 메서드를 만들 수 없습니다.
  Object[] objects 처럼 모든 객체를 저장할 수 있는 배열을 만들 수 없습니다.


물론 Object가 없어도 직접 MyObject와 같은 클래스를 만들고 모든 클래스에서 직접 정의한 MyObject를 상속 받으면 됩니다.

  하지만 하나의 프로젝트를 넘어서 전세계 모든 개발자가 비슷한 클래스를 만들 것이고, 서로 호환되지 않은 수 많은 XxxObject들이 넘쳐날 것입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-29</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-29-toString.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-29-toString.html"><h1 class="title_post">☕️[Java] toString()</h1></a>
                        <a href="/2024/Java/2024-03-29-toString.html" class="txt_post">
                            toString()
Object.toString() 메서드는 객체의 정보를 문자열 형태로 제공합니다.

  그래서 디버깅과 로깅에 유용하게 사용됩니다.
  이 메서드는 Object 클래스에 정의되므로 모든 클래스에서 상속받아 사용할 수 있습니다.


코드로 확인해봅시다.

package lang.object.tostring;

public class ToStringMain1 {

  public static void main(String[] args) {
    Object object = new Object();
    String string = object.toString();

    //toString() 반환값 출력
    System.out.println(string);

    // object 직접 출력
    System.out.println(object);
  }
}


실행 결과
java.lang.Object@a09ee92
java.lang.Object@a09ee92


Object.toString()
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}


  Object가 제공하는 toString() 메서드는 기본적으로 패키지를 포함한 객체의 이름과 객체의 참조값(해시코드)를 16진수로 제공합니다


println()과 toString()
그런데 toString()의 결과를 출력한 코드와 object를 println()에 직접 출력한 코드의 결과가 완전히 같습니다.
String string = object.toString();

//toString() 반환값 출력
System.out.println(string);

// object 직접 출력
System.out.println(object);


System.out.println() 메서드는 사실 내부에서 toString()을 호출합니다.
Object 타입(자식 포함)이 println()에 인수로 전달되면 내부에서 obj.toString() 메서드를 호출해서 결과를 출력합니다.
public void println(Object x) {
    String s = String.valueOf(x);
    // ...
}


public static String valueOf(Object obj) {
    return (obj == null) ? "null" : obj.toString();
}


따라서 println()을 사용할 때, toString()을 직접 호출할 필요 없이 객체를 바로 전달하면 객체의 정보를 출력할 수 있습니다.

toString() 오버라이딩.
Object.toString() 메서드가 클래스 정보와 참조값을 제공하지만 이 정보만으로는 객체의 상태를 적절히 나타내지 못합니다.

  그래서 보통 toString()을 재정의(오버라이딩)해서 보다 유용한 정보를 제공하는 것이 일반적입니다.




package lang.object.tostring;

public class Car {

  private String carName;

  public Car(String carName) {
    this.carName = carName;
  }
}


package lang.object.tostring;

public class Dog {

  private String dogName;
  private int age;

  public Dog(String dogName, int age) {
    this.dogName = dogName;
    this.age = age;
  }

  @Override
  public String toString() {
    return "Dog{" +
        "dogName='" + dogName + '\'' +
        ", age=" + age +
        '}';
  }
}


package lang.object.tostring;

public class ObjectPrinter {
  public static void print(Object obj) {
    String string = "객체 정보 출력: " + obj.toString();
    System.out.println(string);
  }
}


package lang.object.tostring;

public class ToStringMain2 {

  public static void main(String[] args) {
    Car car = new Car("Model Y");
    Dog dog1 = new Dog("멍멍이1", 2);
    Dog dog2 = new Dog("멍멍이2", 5);

    System.out.println("1. 단순 toString 호출");
    System.out.println(car.toString());
    System.out.println(dog1.toString());
    System.out.println(dog2.toString());

    System.out.println("2. println 내부에서 toString 호출");
    System.out.println(car);
    System.out.println(dog1);
    System.out.println(dog2);

    System.out.println("3. Object 다용성 활용");
    ObjectPrinter.print(car);
    ObjectPrinter.print(dog1);
    ObjectPrinter.print(dog2);
  }
}


실행 결과
1. 단순 toString 호출
lang.object.tostring.Car@452b3a41
Dog{dogName='멍멍이1', age=2}
Dog{dogName='멍멍이2', age=5}

2. println 내부에서 toString 호출
lang.object.tostring.Car@452b3a41
Dog{dogName='멍멍이1', age=2}
Dog{dogName='멍멍이2', age=5}

3. Object 다용성 활용
객체 정보 출력: lang.object.tostring.Car@452b3a41
객체 정보 출력: Dog{dogName='멍멍이1', age=2}
객체 정보 출력: Dog{dogName='멍멍이2', age=5}


Car 인스턴스는 toString()을 재정의 하지 않습니다.

  따라서 Object가 제공하는 기본 toString() 메서드를 사용합니다.


Dog 인스턴스는 toString()을 재정의 한 덕분에 객체의 상태를 명확하게 확인할 수 있습니다.




  Object obj의 인수로 car(Car)가 전달됩니다.
  메서드 내부에서 obj.toString()을 호출합니다.
  obj는 Object 타입입니다.
    
      따라서 Object에 있는 toString()을 찾습니다.
        
          이때 자식에 재정의(오버라이딩)된 메서드가 있는지 찾아봅니다. 재정의된 메서드가 없습니다.
            
              Object.toString()을 실행합니다.
            
          
        
      
    
  




ObjectPrinter.print(dog) // main에서 호출
void print(Object obj = dog(Dog)) { // 인수 전달
    String string = "객체 정보 출력: " + obj.toString();
}


  Object obj의 인수로 dog(Dog) 가 전달 됩니다.
  메서드 내부에서 obj.toString()을 호출합니다.
  obj는 Object 타입입니다.
    
      따라서 Object에 있는 toString()을 찾습니다.
        
          이때 자식에 재정의(오버라이딩)된 메서드가 있는지 찾아봅니다. Dog에 재정의된 메서드가 있습니다.
            
              Dog.toString()을 실행합니다.
            
          
        
      
    
  



  참고 - 객체의 참조값 직접 출력
toString()은 기본으로 객체의 참조값을 출력합니다.
그런데 toString()이나 hashCode()를 재정의하면 객체의 참조값을 출력할 수 없습니다.
이때는 다음 코드를 사용하면 객체의 참조값을 출력할 수 있습니다.
  String refValue = Integer.toHexString(System.identityHashCode(dog1));
System.out.println("refValue = " + refValue)
  

  실행 결과
  refValue = 72ea2f77
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-29</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-28-java-langPackage.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-28-java-langPackage.html"><h1 class="title_post">☕️[Java] java.lang 패키지 소개</h1></a>
                        <a href="/2024/Java/2024-03-28-java-langPackage.html" class="txt_post">
                            java.lang 패키지 소개.
자바가 기본적으로 제공하는 라이브러리(클래스 모음)중에 가장 지본이 되는 것이 바로 java.lang 패키지입니다.

여기서 lang은 Language(언어)의 줄임말 입니다.

쉽게 이야기해서 자바 언어를 이루는 가장 기본이 되는 클래스들을 보관하는 패키지를 뜻합니다.

java.lang 패키지의 대표적인 클래스들.

  Object : 모든 자바 객체의 부모 클래스
  String : 문자열
  Integer, Long, Double : 래퍼 타입, 기본형 데이터 타입을 객체로 만든 것
  Class : 클래스 메타 정보
  System: 시스템과 관련된 기본 기능들을 제공


“여기 나열한 클래스들은 자바 언어의 기본을 이루기 때문에 반드시 잘 알아두어야 합니다.”

import 생략 가능
java.lang 패키지는 모든 자바 애플리케이션에 자동으로 임포트(import)됩니다.

따라서 임포트 구문을 사용하지 않아도 됩니다.

다른 패키지에 있는 클래스를 사용하려면 다음과 같이 임포트를 사용해야 합니다.

package lang;

import java.lang.System;

public class LangMain {
    
    public static void main(String[] args) {
        System.out.println("hello.java");
    }
}


System 클래스는 java.lang 패키지 소속입니다. 따라서 다음과 같이 임포트를 생략할 수 있습니다.

package lang;

public class LangMain {

  public static void main(String[] args) {
    System.out.println("hello, java");
  }
}


  import java.lang.System; 코드를 삭제해도 정상 동작합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-28-ObjectClass.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-28-ObjectClass.html"><h1 class="title_post">☕️[Java] Object 클래스</h1></a>
                        <a href="/2024/Java/2024-03-28-ObjectClass.html" class="txt_post">
                            Object 클래스.

자바에서 모든 클래스의 최상위 부모 클래스는 항상 Object 클래스입니다.

다음 그림과 예제 코드를 봐봅시다.



package lang.object;

// 부모가 없으면 묵시적으로 Object 클래스를 상속 받는다.
public class Parent {
    
  public void parentMethod() {
    System.out.println("Parent.parentMethod");
  }
}


앞의 코드는 다음 코드와 같습니다.
package lang.object;

// 부모가 없으면 묵시적으로 Object 클래스를 상속 받는다.
public class Parent extends Object {
    
  public void parentMethod() {
    System.out.println("Parent.parentMethod");
  }
}


  클래스에 상속 받을 부모 클래스가 없으면 묵시적으로 Object 클래스를 상속 받습니다.
    
      쉽게 이야기해서 자바가 extends Object 코드를 넣어줍니다.
        
          따라서 extends Object는 생략하는 것을 권장합니다.
        
      
    
  


package lang.object;

public class Child extends Parent {
    
    public void childMethod() {
        System.out.println("Child.childMethod");
    }
}


  클래스에 상속 받을 부모 클래스를 명시적으로 지정하면 Object를 상속 받지 않습니다.
    
      쉽게 이야기해서 이미 명시적으로 상속했기 때문에 자바가 extends Object 코드를 넣지 않습니다.
    
  



  묵시적(Implicit) vs 명시적(Explicit)
묵시적: 개발자가 코드에 직접 기술하지 않아도 시스템 또는 컴파일러에 의해 자동으로 수행되는 것을 의미합니다.
명시적: 개발자가 코드에 직접 기술해서 작동하는 것을 의미합니다.


package lang.object;

public class ObjectMain {

  public static void main(String[] args) {
   Child child = new Child();
   child.childMethod();
   child.parentMethod();

   // toString()은 Object 클래스의 메서드입니다.
   String string = child.toString();
   System.out.println(string);
  }
}


실행 결과
Child.childMethod
Parent.parentMethod
lang.object.Child@452b3a41


실행 결과 그림
Parent는 Object를 묵시적으로 상속 받았기 때문에 메모리에도 함께 생성됩니다.




  child.toString()을 호출합니다.
  먼저 본인의 타입인 Child에서 toString()을 찾습니다.
    
      없으므로 부모 타입으로 올라가서 찾습니다.
    
  
  부모 타입인 Parent에서 찾습니다.
    
      없으므로 부모 타입으로 올라가서 찾습니다.
    
  
  부모 타입인 Object에 toString()이 있으므로 이 메서드를 호출합니다.


정리

  자바에서 모든 객체의 최종 부모는 Object입니다.


자바에서 Object 클래스가 최상위 부모 클래스인 이유.
모든 클래스가 Object 클래스를 상속 받는 이유는 다음과 같습니다.

  공통 기능 제공
  다형성의 기본 구현


공통 기능 제공.
객체의 정보를 제공하고, 이 객체가 다른 객체와 같은지 비교하고, 객체가 어떤 클래스로 만들어졌는지 확인하는 기능은 모든 객체에게 필요한 기본 기능입니다.

이런 기능을 객체를 만들 때 마다 항상 새로운 메서드를 정의해서 만들어야 한다면 상당히 번거로울 것입니다.

그리고 막상 만든다고 해도 개발자마다 서로 다른 이름의 메서드로 만들어서 일관성이 없을 것입니다.

예를 들어서 객체의 정보를 제공하는 기능을 만든다고 하면 어떤 개발자는 toString()으로 또 어떤 개발자는 objectInfo()와 같이 서로 다른 이름으로 만들 수 있습니다.

객체를 비교하는 기능을 만들 때도 어떤 개발자는 equals()로 어떤 개발자는 same()으로 만들 수 있습니다.

Object는 모든 객체에 필요한 공통 기능을 제공합니다.

  Object는 최상위 부모 클래스이기 때문에 모든 객체는 공통 기능을 편리하게 제공(상속)받을 수 있습니다.


Object가 제공하는 기능은 다음과 같습니다.

  객체의 정보를 제공하는 toString()
  객체의 같음을 비교하는 equals()
  객체의 클래스 정보를 제공하는 getClass()
  기타 여러가지 기능


개발자는 모든 객체가 앞서 설명한 메서드를 지원한다는 것을 알고 있습니다.

  따라서 프로그래밍이 단순화되고, 일관성을 가집니다.


다형성의 기본 구현
부모는 자식을 담을 수 있습니다.
Object는 모든 클래스의 부모 클래스 입니다.

  따라서 모든 객체를 참조할 수 있습니다.


Object 클래스는 다형성을 지원하는 기본적인 메커니즘을 제공합니다.

모든 자바 객체는 Object 타입으로 처리될 수 있으며, 이는 다양한 타입의 객체를 통합적으로 처리할 수 있게 해줍니다.

쉽게 이야기해서 Object는 모든 객체를 다 담을 수 있습니다.

타입이 다른 객체들을 어딘가에 보관해야 한다면 바로 Object에 보관하면 됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Web/2024-03-27-HowWebBrowsersWork.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sparta.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Web/2024-03-27-HowWebBrowsersWork.html"><h1 class="title_post">🌐[Web] 웹 브라우저 작동 원리</h1></a>
                        <a href="/2024/Web/2024-03-27-HowWebBrowsersWork.html" class="txt_post">
                            웹 브라우저 작동 원리


  웹은 “개발의 기초” 입니다.
  
    웹은 개발을 입문할 때 배우는 개발의 기초라고 할 수 있습니다.
  


브라우저의 역할은 1. 요청을 보내고, 2. 받은 HTML 파일을 그려줍니다.


  클라이언트: 요청하는 쪽
  서버: 응답하는 쪽





  HTML : 뼈대
  CSS : 꾸미기
  JS : 움직이기



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/SQL/2024-03-27-TableColumnsAndSQL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/SQL/2024-03-27-TableColumnsAndSQL.html"><h1 class="title_post">💉[SQL] 테이블과 컬럼, SQL</h1></a>
                        <a href="/2024/SQL/2024-03-27-TableColumnsAndSQL.html" class="txt_post">
                            SQL?

  SQL은 “데이터베이스와 대화를 하기 위한 언어” 입니다.
    
      옆의 사람에세 필요한 것을 요청시 “A를 주시겠어요?”와 하는 것과 같이 “DB에게도 A를 주시겠어요?” 라고 이야기할 때 사용하는 언어라고 할 수 있습니다.
    
  



  Query
SQL 이란 언어를 이용하여 데이터베이스에 요청을 하는 질의를 ‘Query’라고 합니다.


테이블과 컬럼?
데이터베이스 : 쉽게 말해 “데이터가 저장되어있는 큰 폴더” 입니다.

  체계적으로 조직된 데이터의 집합으로, 데이터의 저장, 검색, 수정, 삭제 등을 효율적으로 처리할 수 있게 해주는 데이터 구조와 관리 시스템을 말합니다.
  데이터베이스 관리 시스템(DBMS)은 이러한 데이터베이스를 만들고 관리하는 소프트웨어입니다.


데이터베이스의 주요 구성 요소.

  데이터(Data) : 정보의 원시 형태로, 문자, 숫자, 이미지 등 다양한 형태가 있습니다. 데이터베이스에 저장된 데이터는 조직화되어 있어 효율적인 접근과 관리가 가능합니다.
  테이블(Table) : 데이터를 구조화하여 저장하는 기본 단위입니다. 테이블은 행(Row)과 열(Column)로 구성되어 있으며, 각 행은 고유한 데이터 레코드를, 열은 특정 데이터 필드를 나타냅니다.
  스키마(Schema) : 데이터베이스의 구조를 정의하는 메타데이터의 집합입니다. 테이블 구조, 데이터 타입, 관계 등 데이터베이스의 뼈대를 이룹니다.
  쿼리(Query) : 데이터베이스에 저장된 데이터에 접근하거나 조직하기 위한 명령어입니다. SQL(Structured Query Language)은 데이터베이스 관리를 위해 널리 사용되는 쿼리 언어입니다.


데이터베이스의 중요성.

  중복성 감소 : 데이터베이스는 데이터 중복을 최소화하여 저장 공간의 효율성을 높이고 데이터 일관성을 유지합니다.
  데이터 무결성 : 데이터베이스는 데이터의 정확성과 일관성을 유지하기 위한 규칙(제약 조건)을 적용합니다. 이를 통해 데이터의 신뢰성을 보장합니다.
  보안 : 데이터베이스는 사용자의 권한을 관리하여 특정 데이터에 대한 접근을 제어할 수 있습니다. 이는 데이터의 보안을 강화합니다.
  백업 및 복구 : 데이터베이스는 데이터의 백업 및 복구 기능을 제공하여, 시스템 장애나 데이터 손실 시 데이터를 복원할 수 있습니다.


데이터베이스의 종류.

  관계형 데이터베이스(RDBMS) : 테이블 간의 관계를 기반으로 하는 데이터베이스입니다. Oracle, MySQL, PostgreSQL 등이 있습니다.
  비관계형 데이터베이스(NoSQL) : 스키마가 없거나 유연한 데이터 모델을 사용하여 대규모 분산 데이터를 관리하는 데이터베이스입니다. MongoDB, Cassandra, Redis 등이 있습니다.



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/SQL/2024-03-27-DatabaseModeling.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/SQL/2024-03-27-DatabaseModeling.html"><h1 class="title_post">💉[SQL] 데이터베이스 모델링</h1></a>
                        <a href="/2024/SQL/2024-03-27-DatabaseModeling.html" class="txt_post">
                            건물을 짓기 위한 설계도: 데이터베이스 모델링(Database Modeling)
테이블의 구조를 미리 설계하는 개념으로 건출 설계도를 그리는 과정과 비슷합니다.

프로젝트를 진행하기 위해서는 대표적으로 “폭포수 모델(waterfall model)” 을 사용하며, 데이터베이스 모델링은 폭포수 모델의 업무 분석과 시스템 설계 단계에 해당합니다.

  이 단계를 거치면 가장 중요한 데이터베이스 개체인 “테이블 구조” 가 결정되는 것 입니다.


프로젝트 진행 단계.

  “프로젝트(project)”
    
      현실 세계에서 일어나는 업무를 컴퓨터 시스템으로 옮겨놓는 과정.
      대규모 소프트웨어(software) 를 작성하기 위한 전체 과정.
    
  



  프로그램과 소프트웨어의 구분

  프로그래밍 언어(C, 자바, 파이썬 등)를 통해서 만들어진 결과물을 소프트웨어(software)라고 부릅니다.
소프트웨어와 프로그램(program)은 거의 비슷한 용어로 소프트웨어는 좀 더 큰 단위, 프로그램은 좀 더 작은 단위로 부르기도 하지만 대부분의 상황에서 구분 없이 사용하고 있습니다.



  “폭포수 모델(waterfall model)”
    
      소프트웨어 개발 절차 중 하나
      각 단계가 폭포가 떨어지듯 진행되기 때문에 붙여진 이름
    
  
  폭포수 모델의 단계
    
      
        
          프로젝트 계획
        
      
      
        
          업무 분석
        
      
      
        
          시스템 설계
        
      
      
        
          프로그램 구현
        
      
      
        
          테스트
        
      
      
        
          유지보수
        
      
    
  


각 단계의 의미를 예를 들어 설명해보겠습니다.
지금 우리가 슈퍼마켓을 운영하고 있다고 가정해봅시다.
이 슈퍼마켓의 물건을 온라인으로도 판매하기 위해 인터넷 쇼핑몰을 구축하려고 합니다.


  
    
      프로젝트 계획 : 슈퍼마켓의 물건들을 온라인으로 판매하기 위한 계획 단계입니다.
    
  
  
    
      업무 분석 : 슈퍼마켓에서 업무가 어떻게 돌아가는지 파악하는 것입니다. 예로 물건은 어디서 들어오는지, 물건을 어떻게 계산하는지, 재고는 어떻게 관리하는지 등의 업무에 대해서 정리하는 단계입니다.
    
  
  
    
      시스템 설계 : 앞에서 정리한 업무 분석을 컴퓨터에 적용시키기 위해서 알맞은 형태로 다듬는 과정입니다.
    
  
  
    
      프로그램 구현 : 앞에서 완성한 시스템 설계의 결과를 실제 프로그래밍 언어로 코딩하는 단계입니다. 우리가 계획한 내용을 온라인으로 제공하기 위해서는 JavaScript, PHP, JSP 등의 프로그래밍 언어를 사용해야 합니다.
    
  
  
    
      테스트 : 코딩된 프로그램에 오류가 없는지 확인하는 과정입니다.
    
  
  
    
      유지보수 : 실제 온라인 쇼핑몰을 운영하면서 문제점을 보안하고 기능을 추가하는 과정입니다.
    
  
  폭포수 모델의 장.단점
    
      장점 : 각 단계가 구분되어 프로젝트의 진행 단계가 명확하다는 장점.
      단점 : 폭포에서 내려가기는 쉬워도 다시 거슬러 올라가기는 힘든 것처럼 문제가 발생할 경우 다시 앞 단계로 돌아가기가 어렵다는 단점
    
  


데이터베이스 모델링.
현실 세계의 슈퍼마켓을 인터넷 쇼핑몰로 만드는 프로젝트를 바탕으로 데이터베이스 모델링 부분을 살펴보겠습니다.


  “데이터베이스 모델링(Database modeling)”
    
      우리가 살고 있는 세상에서 사용되는 사물이나 작업을 DBMS의 데이터베이스 개체롤 옮기가 위한 과정
      쉽게 이야기하면 현실에서 쓰이는 것을 테이블로 변경하기 위한 작업
    
  




슈퍼마켓(현실 세계)의 고객, 물건, 직원 등을 데이터베이스에 각각의 테이블 이라는 개체로 변환합니다.

  예를 들어 어떤 사람의 신분을 증명하기 위한 신분증에 이름, 주민등록번호, 주소 등의 정보가 있는 것과 비슷한 개념입니다.
    
      인터넷 쇼핑몰에서 판매할 제품들도 마찬가지입니다. 제품의 이름, 가격, 제조일자, 제조회사, 재고량 등을 데이터베이스에 저장하는 것 입니다.
    
  


데이터베이스 모델링에는 정답이 없습니다.

  다만, 좋은 모델링과 나쁜 모델링은 분명히 존재합니다. 이는 다양한 학습과 실무 경험에서 우러나옵니다.


전체 데이터베이스 구성도
앞에서 살펴본 데이터베이스 모델링의 결과로 다음과 같은 구성이 완료되었다고 가정하겠습니다.




  데이터(data) : 하나하나의 단편적인 정보를 말합니다. 이 그림에서는 tess, 아이유, 바나나와 같은 개별적인 정보를 말합니다.
  테이블(table) : 회원이나 제품의 데이터를 입력하기 위해 표 형태로 표현한 것을 말합니다. 지금은 인터넷 쇼핑몰을 구현하기 위해서 회원 정보를 보관할 회원 테이블과 제품 정보를 보관할 제품 테이블, 2개의 테이블을 만들었습니다.
  데이터베이스(database) : 테이블이 저장되는 저장소를 말합니다. 데이터를 저장하는 곳이라는 의미로 그림에서는 원통 모양으로 표현했습니다. 그림에 3개의 데이터베이스를 표현했는데요, 각 데이터베이스는 이름이 서로 달라야합니다.
  DBMS(Database Management System) : 데이터베이스 관리 시스템 또는 소프트웨어를 말합니다. MySQL 과 같은것이 바로 DBMS입니다. 그림에서 MySQL이 3개의 데이터베이스를 관리하고 있습니다.
  열(column) : 테이블의 세로를 말합니다. 각 테이블은 여러 개의 열(컬럼, 필드)로 구성됩니다. 회원 테이블은 3개의 열로, 제품 테이블은 5개의 열로 구성되어 있습니다.
  열 이름 : 각 열을 구분하기 위한 이름입니다. 열 이름은 각 테이블 내에서는 서로 달라야 합니다. 회원 테이블의 아이디, 회원 이름, 주소 등이 열 이름입니다.
  데이터 형식 : 열에 저장될 데이터의 형식을 말합니다. 회원 테이블의 회원 이름은 열은 ‘1234’와 같은 숫자가 아닌 ‘나훈아’와 같은 문자 형식이어야 합니다. 그리고 제품 테이블의 가격 열은 숫자(정수) 형식이어야 합니다. 데이터 형식은 테이블을 생성할 때 열 이름과 함께 지정해줍니다.
  행(row) : 실질적인 진짜 데이터를 말합니다. 예로, ‘tess/나훈아/경기 부천시 중동’이 하나의 행(로우, 레코드)으로 행 데이터라고도 부릅니다. 회원 테이블에서 회원이 몇 명인지는 행 데이터가 몇 개인지로 알 수 있습니다. 즉, 행의 개수가 데이터의 개수입니다. 이 예에서는 4건의 행 데이터가 있으므로 4명의 회원이 가입되어 있는 것입니다.
  기본 키(Primary Key, PK) : 기본 키(또는 주키) 열은 각 행을 구분하는 유일한 열을 말합니다. 더 쉽게는 네이버의 회원 아이디, 학번, 주민등록번호 같은 것이라고 생각하면 됩니다. 그래서 기본 키는 중복되어서는 안 되며, 비어 있어서도 안 됩니다.
    
      네이버 아이디, 학번, 주민등록번호 등이 다른 사람과 중복되지 않습니다. 또 네이버 회원인데 네이버 아이디가 없거나, 한국 사람인데 주민등록번호가 없는 것은 불가능합니다.
        
          테이블에는 열이 여러 개 있지만 기본 키는 1개만 지정해야 하며, 일반적으로 1개의 열에 지정합니다.
        
      
    
  
  SQL(Structure Query Language) : DBMS에서 작업을 하고 싶다면 DBMS가 알아듣는 언어(말)로 해야 합니다. 그것이 SQL(구조화된 질의 언어)입니다. 즉, SQL은 사람과 DBMS가 소통하기 위한 언어입니다.


4가지 핵심 키워드, 핵심 포인트

  프로젝트란 현실 세계에서 컴퓨터 시스템으로 옮겨놓는 일련의 과정입니다.
  폭포수 모델은 소프트웨어 개발 단계 중 하나로, 이름 그대로 폭포가 떨어지듯 개발 단계가 진행됩니다.
  데이터베이스 모델링이란 현실 세계에서 사용되는 작업이나 사물들을 DBMS의 테이블(표 형태로 표현한 데이터베이스 개체)로 옮기기 위한 과정입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-25-Polymorphism-RoleImplementatioonExample3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-25-Polymorphism-RoleImplementatioonExample3.html"><h1 class="title_post">☕️[Java] 다형성 - 역할 구현 예제 3</h1></a>
                        <a href="/2024/Java/2024-03-25-Polymorphism-RoleImplementatioonExample3.html" class="txt_post">
                            다형성 - 역할과 구현 예제 3

다형성을 활용하면 역할과 구현을 분리해서, 클라이언트 코드의 변경 없이 구현 객체를 변경할 수 있습니다.

다음 관계에서 Driver가 클라이언트입니다.

예제를 통해서 자세히 알아봅시다.



앞서 설명한 자동차 예제를 코드로 구현해보겠습니다.

  Driver: 운전자는 자동차(Car)의 역할에만 의존합니다.
    
      구현인 K3, Model3 자동차에 의존하지 않습니다.
        
          Driver 클래스는 Car car 멤버 변수를 가집니다. 따라서 Car 인터페이스를 참조합니다.
          인터페이스를 구현한 K3Car, Model3Car에 의존하지 않고, Car인터페이스에만 의존합니다.
            
              여기서 설명하는 의존은 클래스 의존 관계를 뜩합니다. 클래스 상에서 어떤 클래스를 알고 있는가를 뜻합니다.
                
                  Driver 클래스 코드를 보면 Car 인터페이스만 사용하는 것을 확인할 수 있습니다.
                
              
            
          
        
      
    
  
  Car: 자동차의 역할이고 인터페이스입니다. K3Car, Model3Car 클래스가 인터페이스를 구현합니다.


package poly.car1;

public interface Car {
  void startEngine();
  void offEngine();
  void pressAccelerator();
}


package poly.car1;

public class K3Car implements Car {
  @Override
  public void startEngine() {
    System.out.println("K3Car.startEngine");
  }

  @Override
  public void offEngine() {
    System.out.println("K3Car.offEngine");
  }

  @Override
  public void pressAccelerator() {
    System.out.println("K3Car.pressAccelerator");
  }
}


package poly.car1;

public class Model3Car implements Car{
  @Override
  public void startEngine() {
    System.out.println("Model3Car.startEngine");
  }

  @Override
  public void offEngine() {
    System.out.println("Model3Car.offEngine");
  }

  @Override
  public void pressAccelerator() {
    System.out.println("Model3Car.pressAccelerator");
  }
}


package poly.car1;

public class Driver {
  private Car car;

  public void setCar(Car car) {
    System.out.println("자동차를 설정합니다: " + car);
    this.car = car;
  }

  public void drive() {
    System.out.println("자동차를 운전합니다.");
    car.startEngine();
    car.pressAccelerator();
    car.offEngine();
  }
}


  Driver는 멤버 변수로 Car car를 가집니다.
  setCar(Car car): 멤버 변수에 자동차를 설정합니다.
    
      외부에서 누군가 이 메서드를 호출해주어야 Driver는 새로운 자동차를 참조하거나 변경할 수 있습니다.
    
  
  drive(): Car 인터페이스가 제공하는 기능들을 통해 자동차를 운전합니다.


package poly.car1;

public class CarMain1 {

  public static void main(String[] args) {
    Driver driver = new Driver();

    // 차량 선택(k3)
    K3Car k3Car = new K3Car();
    driver.setCar(k3Car);
    driver.drive();

    // 차량 변경(k3 -&gt; model3)
    Model3Car model3Car = new Model3Car();
    driver.setCar(model3Car);
    driver.drive();
  }
}


실행 결과
자동차를 설정합니다: poly.car1.K3Car@4a574795
자동차를 운전합니다.
K3Car.startEngine
K3Car.pressAccelerator
K3Car.offEngine

자동차를 설정합니다: poly.car1.Model3Car@23fc625e
자동차를 운전합니다.
Model3Car.startEngine
Model3Car.pressAccelerator
Model3Car.offEngine





  먼저 Driver와 K3Car를 생성합니다.
  driver.setCar(k3Car)를 호출해서 Driver의 Car car 필드가 K3Car의 인스턴스를 참조하도록 합니다.
  driver.drive()를 호출하면 x001을 참조합니다.
    
      car 필드가 Car 타입이므로 Car 타입을 찾아서 실행하지만 메서드 오버라이딩에 의해 K3Car의 기능이 호출됩니다.
    
  





  Model3Car를 생성합니다.
  driver.setCar(model3Car)를 호출해서 Driver의 Car car 필드가 Model3Car의 인스턴스를 참조하도록 변경합니다.
  driver.drive()를 호출하면 x002을 참조합니다.
    
      car 필드가 Car 타입이므로 Car 타입을 찾아서 실행하지만 메서드 오버라이딩에 의해 Model3Car의 기능이 호출됩니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-25-OCP.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-25-OCP.html"><h1 class="title_post">☕️[Java] OCP(Open-Closed Principle) 원칙</h1></a>
                        <a href="/2024/Java/2024-03-25-OCP.html" class="txt_post">
                            OCP(Open-Closed Principle) 원칙.
좋은 객체 지향 설계 원칙 중 하나로 OCP 원칙이라는 것이 있습니다.

  Open for extension : 새로운 기능의 추가나 변경 사항이 생겼을 때, 기존 코드는 확장할 수 있어야 합니다.
  Closed for modification : 기존의 코드는 수정되지 않아야 합니다.


확장에는 열려있고, 변경에는 닫혀 있다는 뜻인데, 쉽게 이야기해서 기존의 코드 수정 없이 새로운 기능을 추가할 수 있다는 의미입니다.

  약간 말이 안 맞는 것 같지만 우리가 앞서 개발한 코드가 바로 OCP 원칙을 잘 지키고 있는 코드입니다.


새로운 차량의 추가.
여기서 새로운 차량을 추가해도 Driver의 코드는 전혀 변경하지 않습니다.

운전할 수 있는 차량의 종류가 계속 늘어나도 Car를 사용하는 Driver의 코드는 전혀 변경하지 않습니다.

기능을 확장해도 main() 일부를 제외한 프로그램의 핵심 부분의 코드는 전혀 수정하지 않아도 됩니다.



확장에 열려있다는 의미.
Car 인터페이스를 사용해서 새로운 차량을 자유롭게 추가할 수 있습니다.
Car 인터페이스를 구현해서 기능을 추가할 수 있다는 의미입니다.
Car 인터페이스를 사용하는 클라이언트 코드인 Driver도 Car 인터페이스를 통해 새롭게 추가된 차량을 자유롭게 호출할 수 있습니다.
이것이 확장에 열려있다는 의미입니다.

코드 수정은 닫혀 있다는 의미.
새로운 차를 추가하게 되면 기능이 추가되기 때문에 기존 코드의 수정은 불가피합니다.
당연히 어딘가의 코드는 수정해야 합니다.

변하지 않는 부분.
새로운 자동차를 추가할 때 가장 영향을 받는 중요한 클라이언트는 바로 Car의 기능을 사용하는 Driver입니다.
핵심은 Car 인터페이스를 사용하는 클라이언트인 Driver의 코드를 수정하지 않아도 된다는 뜻입니다.

변하는 부분.
main()과 같이 새로운 차를 생성하고 Driver에게 필요한 차를 전달해주는 역할은 당연히 코드 수정이 발생합니다.
main()은 전체 프로그램을 설정하고 조율하는 역할을 합니다.
이런 부분은 OCP를 지켜도 변경이 필요합니다.

정리.

  Car를 사용하는 클라이언트 코드인 Driver 코드의 변경 없이 새로운 자동차를 확장할 수 있습니다.
  다형성을 활용하고 역할과 구현을 잘 분리한 덕분에 새로운 자동차를 추가해도 대부분의 핵심 코드들을 그대로 유지할 수 있게 되었습니다.



  전략 패턴(Strategy Pattern)
디자인 패턴 중에 가장 중요한 패턴을 하나 뽑으라고 하면 전략 패턴을 뽑을 수 있습니다.
전략 패턴은 알고리즘을 클라이언트 코드의 변경 없이 쉽게 교체할 수 있습니다.
방금 설명한 코드가 바로 전략 패턴을 사용한 코드입니다.
Car 인터페이스가 바로 전략을 정의하는 인터페이스가 되고, 각각의 차량이 전략의 구체적인 구현이 됩니다.
그리고 전략을 클라이언트 코드(Driver)의 변경 없이 손쉽게 교체할 수 있습니다.



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-03-25-HowToRepresentCharactersWithZeroAndOne.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-03-25-HowToRepresentCharactersWithZeroAndOne.html"><h1 class="title_post">💾 [CS] 0과 1로 문자를 표현하는 방법</h1></a>
                        <a href="/2024/CS/2024-03-25-HowToRepresentCharactersWithZeroAndOne.html" class="txt_post">
                            0과 1로 문자를 표현하는 방법.

문자 집합과 인코딩.

반드시 알아야 할 세 가지 용어

  문자 집합
  인코딩
  디코딩



  컴퓨터가 인식하교 표현할 수 있는 문자의 모음을 “문자 집합(character set)” 이라고 합니다.
  문자를 0과 1로 변환하는 과정을 “문자 인코딩(character encoding)” 이라고 합니다.
  0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정을 “문자 디코딩(character decoding)” 이라고 합니다.


아스키 코드.


  아스키(ASCII: American Standard Code for Information Interchang)
    
      초창기 문자 집합 중 하나
      영어 알파벳과 아라비아 숫자, 그리고 일부 특수 문자를 포함합니다.
    
  
  아스키 문자
    
      각각 7비트로 표현되는데, 7비트로 표현할 수 있는 정보의 가짓수는 2⁷개로, 총 128개의 문자를 표현할 수 있습니다.
    
  





  아스키 코드
    
      표를 보면 알 수 있듯 아스키 문자들은 0부터 127까지 총 128개의 숫자 중 하나의 고유한 수에 일대일로 대응됩니다. 아스키 문자에 대응된 고유한 수를 “아스키 코드”라고 합니다.
    
  
  아스키 코드로 인코딩
    
      아스키 코드를 이진수로 표현함으로써 아스키 문자를 0과 1로 표현할 수 있습니다.
      아스키 문자는 이렇게 아스키 코드로 인코딩됩니다.
    
  


아스키 코드의 장,단점.

  장점
    
      매우 간단하게 인코딩됩니다.
    
  
  단점
    
      한글을 표현할 수 없습니다.
      한글뿐만 아니라 아스키 문자 집합 외의 문자, 특수문자도 표현할 수 없습니다.
        
          그 이유는 근본적으로 아스키 문자 집합에 속한 문자들은 7비트로 표현하기에 128개보다 많은 문자를 표현하지 못하기 때문입니다.
        
      
    
  


확장 아스키(Extend ASCII).

  더 다양한 문자 표현을 위해 아스키 코드에 1비트를 추가한 8비트의 아스키 코드.
    
      그럼에도 표현 가능한 문자 수는 256개여서 턱없이 부족했습니다.
    
  


EUC-KR.
한국을 포함한 영어권 외의 나라들은 자신들의 언어를 0과 1로 표현할 수 있는 고유한 문자 집합과 인코딩 방식이 필요하다고 생각했습니다.

  이러한 이유로 등장한 한글 인코딩 방식


EUC-KR은 KS X 1001, KS X 1003이라는 문자 집합을 기반으로하는 대표적인 완성형 인코딩 방식입니다.

  즉, 초성 중성, 종성이 모두 결합된 한글 단어에 2바이크 크기의 코드를 부여합니다.
  EUC-KR로 인코딩된 한글 한 글자를 표현하려면 16비트(한글 한 글자에 2바이트 코드 부여)가 필요합니다.
    
      16비트는 네 자리 십육진수로 표현할 수 있습니다.
        
          즉, EUC-KR로 인코딩된 한글은 네 자리 십육진수로 나타낼 수 있습니다.
        
      
    
  


한글 인코딩의 두 가지 방식.

  완성형 인코딩.
  조합형 인코딩.



  “완성형 인코딩”
    
      초성, 중성, 종성의 조합으로 이루어진 하나의 글자에 고유한 코드를 부여하는 인코딩 방식입니다.
    
  
  조합형 인코딩
    
      초성을 위한 비트열, 중성을 위한 비트열, 종성을 위한 비트열을 할당하여 그것들의 조합으로 하나의 글자 코드를 완성하는 인코딩 방식입니다.
        
          다시 말해 초성, 중성, 종성에 해당하는 코드를 합하여 하나의 글자 코드를 만드는 인코딩 방식입니다.
        
      
    
  


EUC-KR의 문제점.
아스키 코드보다 표현할 수 있는 문자가 많아졌지만(총 2,350여개), 이는 모든 한글 조합을 표현할 수 있을 정도로 많은 양은 아닙니다.

  그래서 문자 집합에 정의되지 않은 ‘쀍’, ‘쀓’, ‘믜’같은 글자는 EUC-KR로 표현할 수 없습니다.


“모든 한글을 표현할 수 없다는 사실은 때때로 크고 작은 문제를 유발합니다.”

  EUC-KR 인코딩을 사용하는 웹사이트의 한글이 깨지는 현상.
  EUC-KR 방식으로는 표현할 수 없는 이름으로 인해 은행, 학교 등에서 피해를 받는 사람이 생김.
    
      이러한 문제를 조금이나마 해결하기 위해 등장한 것이 MS사의 “CP929(Code Page 949)” 입니다.
        
          CP949는 EUC-KR의 확장된 버전
          EUC-KR로는 표현할 수 없는 더욱 다양한 문자를 표현 할 수 있습니다.
          다만, 이마저도 한글 전체를 표현하기에 넉넉한 양은 아닙니다.
        
      
    
  


유니코드와 UTF-8.
모든 나라 언어의 문자 집합과 인코딩 방식이 통일되어 있다면, 다시 말해 모든 언어를 아우르는 문자 집합과 통일된 표준 인코딩 방식이 있다면 언어별로 인코딩하는 수고로움을 덜 수 있을 겁니다.

  그래서 등장한 것이 “유니코드(Unicode)” 문자 집합입니다.


유니코드.

  EUC-KR보다 훨씬 다양한 한글을 포함하며 대부분 나라의 문자, 특수문자, 화살표나 이모티콘까지도 코드로 표현할 수 있는 통일된 문자집합힙니다.
  현대 문자를 표현할 때 가장 많이 사용되는 표준 문자 집합이며, 문자 인코딩 세계에서 매우 중요한 역할을 맡고 있습니다.


UTF-8, 16, 32

  유니코드는 글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고 이 값을 다양한 방법으로 인코딩합니다.
    
      이런 인코딩 방법에는 크게 UTF-8, 16, 32 등이 있습니다.
        
          요컨데 UTF-8, 16, 32는 유니코드 문자에 부여된 값을 인코딩하는 방식입니다.
        
      
    
  


UTF-8

  통상 1바이트부터 4바이트까지의 인코딩 결과를 만들어 냅니다.
    
      UTF-8로 인코딩한 값의 결과는 1바니크가 될 수도 2바이트, 3바이트, 4바이트가 될 수도 있습니다.
      UTF-8로 인코딩한 결과가 몇 바이트가 될지는 유니코드 문자에 부여된 값의 범위에 따라 결정됩니다.
    
  


4가지 키워드로 정리하는 핵심 포인트

  문자 집합은 컴퓨터가 인식할 수 있는 문자의 모음으로, 문자 집합에 속한 문자를 인코딩하여 0과 1로 표현할 수 있습니다.
  아스키 문자 집합에 0부터 127까지의 수가 할당되어 아스키 코드로 인코딩됩니다.
  EUC-KR은 한글을 2바이트 크기로 인코딩할 수 있는 완성형 인코딩 방식입니다.
  유니코드는 여러 나라의 문자들을 광범위하게 표현할 수 있는 통일된 문자 집합이며, UTF-8, 16, 32는 유니코드 문자의 인코딩 방식입니다.


Q1. iOS 개발에서 문자열을 다루는 것은 매우 흔한 작업입니다. 모든 문자는 컴퓨터 내부에서 0과 1의 이진 코드로 표현됩니다. 예를 들어, 유니코드 인코딩 방식 중 하나인 UTF-8을 사용하여 문자를 이진 코드로 변환할 수 있습니다. ‘안녕하세요’라는 문자열을 UTF-8 인코딩을 사용하여 이진 코드로 어떻게 변환할지 설명해 주세요. 또한, 이 과정에서 iOS 개발에 사용되는 Swift 언어에서 이러한 변환을 수행하는 코드 예시를 작성해 보세요.


  UTF-8 인코딩 변환 과정 설명
‘안녕하세요’라는 문자열은 한글 문자로 구성되어 있으며, UTF-8 인코딩에서 한글은 보통 3바이트(24비트)로 인코딩됩니다. UTF-8은 가변 길이 인코딩 방식으로, 각 문자를 1바이트에서 4바이트까지 다양한 길이의 바이트로 인코딩합니다. 예를 들어, ASCII 코드의 경우 1바이트만 사용하지만, 한글과 같은 문자는 더 많은 바이트를 사용합니다.


예시로 ‘안녕하세요’ 중 ‘안’이라는 문자의 유니코드 코드 포인트는 U+548C입니다. 이를 UTF-8로 인코딩하면 다음과 같은 이진수로 표현될 수 있습니다: 1110xxxx 10xxxxxx 10xxxxxx. 실제 이진 코드로 변환하면 특정 이진값을 갖게 됩니다. (‘안’의 경우 실제 이진 변환 결과는 여기서 직접 계산하지 않았으나, 각 문자를 해당 방식으로 변환할 수 있습니다.)

안녕하세요’를 UTF-8로 인코딩하면 다음과 같은 이진 코드로 표현됩니다:

11101100 10010101 10001000 11101011 10000101 10010101 11101101 10010101 10011000 11101100 10000100 10111000 11101100 10011010 10010100

이진 코드는 각 바이트를 8비트 이진수로 표현한 것입니다.

UTF-8 인코딩에서 한글 문자는 대체로 3바이트로 인코딩되므로, 위의 이진 코드는 ‘안녕하세요’의 각 글자를 UTF-8 인코딩으로 변환한 결과를 보여줍니다.

각 부분이 한글 문자 하나를 나타내며, 각 문자는 3개의 바이트(24비트)로 이루어져 있습니다


  Swift에서의 구현 예시
Swift에서 문자열을 UTF-8 이진 코드로 변환하는 것은 간단합니다. Swift의 String 타입은 utf8 프로퍼티를 통해 UTF-8 인코딩을 쉽게 접근할 수 있게 해줍니다.


let message = "안녕하세요"
var binaryString = ""

for codeUnit in message.utf8 {
    binaryString += String(codeUnit, radix: 2) + " "
}

print(binaryString)


이 코드는 각 문자를 UTF-8 인코딩으로 변환한 후, 각 바이트를 이진수로 변환하여 출력합니다.

출력 결과는 각 UTF-8 인코딩된 바이트를 이진수 형태로 나타낸 것으로, 각 바이트 사이에는 공백이 있습니다.

Q2. Java에서는 문자와 문자열을 다루는 일이 자주 발생합니다. 특히 백엔드 시스템을 개발할 때, 다양한 인코딩 방식을 이해하고 이를 적절히 처리할 수 있는 능력이 중요합니다. UTF-8 인코딩 방식은 국제적으로 널리 사용되며, 다양한 언어와 특수 문자를 지원하는 강력한 인코딩 방식입니다. Java에서 문자열 ‘Java 백엔드 개발자’를 UTF-8 인코딩을 사용하여 이진 코드로 변환하는 과정을 설명해 주세요. 또한, 이 과정을 구현하는 Java 코드를 작성해 보세요.

주어진 질문에 대한 답변은 크게 두 부분으로 나눌 수 있습니다: 첫 번째는 UTF-8 인코딩 방식에 대한 이해와 설명이며, 두 번째는 ‘Java 백엔드 개발자’ 문자열을 UTF-8로 인코딩하여 이진 코드로 변환하는 Java 코드의 구현입니다.

1. UTF-8 인코딩 방식에 대한 이해

UTF-8은 유니코드 문자 집합을 인코딩하는 가장 널리 사용되는 방식 중 하나로, 1바이트에서 4바이트까지 다양한 길이의 바이트를 사용하여 전 세계의 거의 모든 문자를 표현할 수 있습니다. UTF-8은 영문 알파벳과 숫자 같은 기본적인 문자들을 1바이트로 표현하고, 그 외의 문자들은 2바이트 이상을 사용합니다. 예를 들어, 한글은 3바이트를 사용하여 표현됩니다. 이러한 특성 때문에, UTF-8은 다국어 처리가 필요한 웹 및 백엔드 시스템 개발에 널리 사용됩니다.

2. Java 코드 구현

‘Java 백엔드 개발자’ 문자열을 UTF-8로 인코딩하여 이진 코드로 변환하는 과정은 다음 Java 코드를 통해 구현할 수 있습니다:

public class Main {
    public static void main(String[] args) {
        String text = "Java 백엔드 개발자";
        byte[] bytes = text.getBytes(java.nio.charset.StandardCharsets.UTF_8);

        StringBuilder binaryString = new StringBuilder();
        for (byte b : bytes) {
            // 각 바이트를 이진수로 변환하고, 8자리 이진수 형태를 유지하기 위해 앞에 0을 채움
            String binary = String.format("%8s", Integer.toBinaryString(b &amp; 0xFF)).replace(' ', '0');
            binaryString.append(binary).append(" ");
        }

        System.out.println(binaryString.toString().trim());
    }
}


이 코드는 다음과 같은 과정을 거칩니다:


  문자열 “Java 백엔드 개발자”를 UTF-8 인코딩을 사용하여 바이트 배열로 변환합니다.
  변환된 바이트 배열을 순회하면서, 각 바이트를 8비트 이진수로 변환합니다. 이 때, &amp; 0xFF 연산을 사용하여 부호 없는 정수로 처리하고, String.format을 사용하여 이진수를 8자리로 맞춥니다.
  변환된 이진수 문자열을 콘솔에 출력합니다.


이 구현을 통해 후보자는 UTF-8 인코딩 방식의 이해, Java에서의 문자열 처리, 그리고 바이트 및 이진수 처리에 대한 자신의 지식과 기술을 면접관에게 보여줄 수 있습니다. 이는 Java 백엔드 개발자로서 갖추어야 할 중요한 기술 중 하나입니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-24-Polymorphism-RoleImplementatioonExample2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-24-Polymorphism-RoleImplementatioonExample2.html"><h1 class="title_post">☕️[Java] 다형성 - 역할 구현 예제 2</h1></a>
                        <a href="/2024/Java/2024-03-24-Polymorphism-RoleImplementatioonExample2.html" class="txt_post">
                            다형성 - 역할과 구현 예제 2
새로운 Model3 차량을 추가해야 하는 요구사항이 들어왔습니다.

이 요구사항을 맞추려면 기존에 Driver 코드를 많이 변경해야 합니다.

드라이버는 K3Car도 운전할 수 있고, Model3Car도 운전할 줄 있어야 합니다.


  참고로 돌을 동시에 운전하는 것은 아닙니다.




package poly.car0;

public class CarMain0 {

  public static void main(String[] args) {
    Driver driver = new Driver();
    K3Car k3Car = new K3Car();
    driver.setK3Car(k3Car);
    driver.drive();

    // 추가
    Model3Car model3Car = new Model3Car();
    driver.setK3Car(null);
    driver.setModel3Car(model3Car);
    driver.drive();
  }
}



  K3를 운전하던 운전자가 Model3로 차량을 변경해서 운전하는 코드입니다.
  driver.setK3Car(null)을 통해서 기존 K3Car의 참조를 제거합니다.
  driver.setModel3Car(model3Car)를 통해서 새로운 model3Car의 참조를 추가합니다.
  driver.drive()를 호출합니다.


실행 결과
자동차를 운전합니다.
K3Car.startEngine
K3Car.pressAccelerator
K3Car.offEngine
자동차를 운전합니다.
Model3Car.startEngine
Model3Car.pressAccelerator
Model3Car.offEngine




여기서 새로운 차량을 추가한다면 또 다시 Driver 코드를 많이 변경해야 합니다.

만약 운전할 수 있는 차량의 종류가 계속 늘어난다면 점점 더 변경해야 하는 코드가 많아질 것입니다.




  “이 코드의 본질적인 문제는 자동차가 늘어나는데, 자동차 운전자의 코드를 계속해서 뜯어 고쳐야한다는 것 입니다.”
  이런 문제가 생기는 이유는 “역할과 구현을 분리하지 않았기 때문입니다”.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-23-WhatIsGoodOOP.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-23-WhatIsGoodOOP.html"><h1 class="title_post">☕️[Java] 좋은 객체 지향 프로그래밍이란?</h1></a>
                        <a href="/2024/Java/2024-03-23-WhatIsGoodOOP.html" class="txt_post">
                            좋은 객체 지향 프로그래밍이란?

객체 지향 특징

  추상화
  캡슐화
  상속
  다형성


객체 지향 프로그래밍?

  객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 “객체” 들의 모임으로 파악하고자 하는 것입니다.
    
      각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있습니다.(협력)
    
  
  객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용됩니다.


유연하고, 변경에 용이?

  레고 블럭 조립하듯이
  키보드, 마우스 갈아 끼우듯이
  컴퓨터 부품 갈아 끼우듯이
  컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법


다형성(Polymorphism)

다형성의 실세계 비유

  실세계와 객체 지향을 1:1로 매칭 X
  그래도 실세계의 비유로 이해하기에는 좋음
  역할과 구현으로 세상을 구분


운전자 - 자동차


공연무대
로미오와 줄리렛 공연


예시

  운전자 - 자동차
  공연 무대
  키보드, 마우스, 세상의 표준 인터페이스들
  정렬 알고리즘
  할인 정책 로직


역할과 구현을 분리

  역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해집니다.


장점

  클라이언트는 대상의 역할(인터페이스)만 알면 됩니다.
  클라이언트는 구현 대상의 내부 구조를 몰라도 됩니다.
  클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않습니다.
  클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않습니다.


역할과 구현을 분리 2
자바 언어

  자바 언어의 다형성을 활용합니다.
    
      역할 = 인터페이스.
      구현 = 인터페이스를 구현한 클래스, 구현 객체.
    
  
  객체를 설계할 때 역할과 구현을 명확히 분리합니다.
  객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체를 만듭니다.


객체의 협력이라는 관계부터 생각

  혼자 있는 객체는 없습니다.
  클라이언트: 요청, 서버 응답
  수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가집니다.




자바 언어의 다형성

  오버라이딩을 떠올려봅시다.
  오버라이딩은 자바 기본 문법입니다.
  오버라이딩 된 메서드가 실행합니다.
  다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있습니다.
  물론 클래스 상속 관계도 다형성, 오버라이딩 적용 가능합니다.




다형성의 본질

  인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있습니다.
  다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야 합니다.
  클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있습니다.


역할과 구현을 분리 3
정리

  실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있습니다.
  유연하고, 변경이 용이합니다.
  확장 가능한 설계입니다.
  클라이언트에 영향을 주지 않는 변경이 가능합니다.
  인터페이스를 안정적으로 잘 설계하는 것이 중요합니다.


한계

  역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생합니다.
  자동차를 비행기로 변경해야 한다면?
  대본 자체가 변경된다면?
  USB 인터페이스가 변경된다면?
  인터페이스를 안정적으로 잘 설계하는 것이 중요합니다.


정리

  다형성이 가장 중요합니다!
  디자인 패턴 대부분은 다형성을 활용하는 것입니다.
  스프링의 핵심인 제어의 역전(IoC), 의존관계 주입(DI)도 결국 다형성을 활용하는 것입니다.
  다형성을 잘 활용하면 마치 레고 블럭 조립하듯이! 공연 무대의 배우를 선택하듯이! 구현을 편리하게 변경할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-23-Polymorphism-RoleImplementatioonExample1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-23-Polymorphism-RoleImplementatioonExample1.html"><h1 class="title_post">☕️[Java] 다형성 - 역할 구현 예제 1</h1></a>
                        <a href="/2024/Java/2024-03-23-Polymorphism-RoleImplementatioonExample1.html" class="txt_post">
                            다형성 - 역할 구현 예제 1
앞서 설명한 내용을 더 깊이있게 이해하기 위해, 간단한 운전자와 자동차의 관계를 개발해봅시다.

먼저 다형성을 사용하지 않고, 역할과 구현을 분리하지 않고 단순하게 개발해봅시다.



Driver는 K3Car를 운전하는 프로그램입니다.

package poly.car0;

public class K3Car {
  public void startEngine() {
    System.out.println("K3Car.startEngine");
  }

  public void offEngine() {
    System.out.println("K3Car.offEngine");
  }

  public void pressAccelerator() {
    System.out.println("K3Car.pressAccelerator");
  }
}


package poly.car0;

public class Driver {

  private K3Car k3Car;

  public void setK3Car(K3Car k3Car) {
    this.k3Car = k3Car;
  }

  public void drive() {
    System.out.println("자동차를 운전합니다.");
    k3Car.startEngine();
    k3Car.pressAccelerator();
    k3Car.offEngine();
  }
}


package poly.car0;

public class CarMain0 {

  public static void main(String[] args) {
    Driver driver = new Driver();
    K3Car k3Car = new K3Car();

    driver.setK3Car(k3Car);
    driver.drive();
  }
}




                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-22-UsingClassesAndInterfaces.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-22-UsingClassesAndInterfaces.html"><h1 class="title_post">☕️[Java] 클래스와 인터페이스 활용</h1></a>
                        <a href="/2024/Java/2024-03-22-UsingClassesAndInterfaces.html" class="txt_post">
                            클래스와 인터페이스 활용

이번에는 클래스 상속과 인터페이스 구현을 함께 사용하는 예를 알아보겠습니다.




  AbstractAnimal은 추상 클래스입니다.
    
      sound() : 동물의 소리를 내기 위한 sound() 추상 메서드를 제공합니다.
      move() : 동물의 이동을 표현하기 위한 메서드 입니다. 이 메서드는 추상 메서드가 아닙니다. 상속을 목적으로 사용됩니다.
    
  
  Fly는 인터페이스 입니다. 나는 동물은 이 인터페이스를 구현할 수 있습니다.
    
      Bird, Chicken은 날 수 있는 동물입니다. fly() 메서드를 구현해야 합니다.
    
  


예제 6
package poly.ex6;

public class SoundFlyMain {

  public static void main(String[] args) {
    Dog dog = new Dog();
    Bird bird = new Bird();
    Chicken chicken = new Chicken();

    soundAnimal(dog);
    soundAnimal(bird);
    soundAnimal(chicken);

    flyAnimal(bird);
    flyAnimal(chicken);
  }

  //AbstractAnimal 사용 가능
  private static void soundAnimal(AbstractAnimal animal) {
    System.out.println("동물 소리 테스트 시작");
    animal.sound();
    System.out.println("동물 소리 테스트 종료");
  }

  //Fly 인터페이스가 있으면 사용 가능
  private static void flyAnimal(Fly fly) {
    System.out.println("날기 테스트 시작");
    fly.fly();
    System.out.println("날기 테스트 종료");
  }
}


실행 결과
동물 소리 테스트 시작
멍멍
동물 소리 테스트 종료

동물 소리 테스트 시작
짹짹
동물 소리 테스트 종료

동물 소리 테스트 시작
꼬끼오
동물 소리 테스트 종료

날기 테스트 시작
새 날기
날기 테스트 종료

날기 테스트 시작
닭 날기
날기 테스트 종료




soundAnimal(AbstractAnimal animal)
AbstractAnimal를 상속한 Dog, Bird, Chicken을 전달해서 실행할 수 있습니다.

실행 과정

  soundAnimal(bird)를 호출한다고 가정합시다.
  메서드 안에서 animal.sound()를 호출하면 참조 대상인 x001 Bird 인스턴스를 찾습니다.
  호출한 animal 변수는 AbstractAnimal 타입입니다. 따라서 AbstractAnimal.sound()를 찾습니다. 해당 메서드는 Bird.sound()에 오버라이딩 되어 있습니다.
  Bird.sound()가 호출됩니다.




flyAnimal(Fly fly)
Fly 인터페이스를 구현한 Bird, Chicken을 전달해서 실행할 수 있습니다.

실행과정

  fly(bird)를 호출한다고 가정합시다.
  메서드 안에서 fly.fly()를 호출하면 참조 대상인 x001 Bird 인스턴스를 찾습니다.
  호출한 fly 변수는 Fly 타입입니다. 따라서 Fly.fly()를 찾습니다. 해당 메서드는 Bird.fly()에 오버라이딩 되어 있습니다.
  Bird.fly()가 호출됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-22-Interface-MultipleImplementation.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-22-Interface-MultipleImplementation.html"><h1 class="title_post">☕️[Java] 인터페이스 - 다중구현</h1></a>
                        <a href="/2024/Java/2024-03-22-Interface-MultipleImplementation.html" class="txt_post">
                            인터페이스 - 다중구현
자바가 다중 상속을 지원하지 않는 이유 - 복습
자바는 다중 상속을 지원하지 않습니다.

그래서 extend 대상은 하나만 선택할 수 있습니다.

  부모를 하나만 선택할 수 있다는 뜻입니다.
    
      물론 부모가 또 부모를 가지는 것은 괜찮습니다.
    
  




만약 비행기와 자동차를 상속 받아서 하늘을 나는 자동차를 만든다고 가정해봅시다.

만약 그림과 같이 다중 상속을 사용하게 되면 AirplaneCar 입장에서 move()를 호출할 때 어떤 부모의 move()를 사용해야 할지 애매한 문제가 발생합니다.

  이것을 다이아몬드 문제라 합니다.


그리고 다중 상속을 사용하면 클래스 계층 구조가 매우 복잡해질 수 있습니다.

이런 문제점 때문에 자바는 클래스의 다중 상속을 허용하지 않습니다.

  대신에 인터페이스의 다중 구현을 허용하여 이러한 문제를 피합니다.


클래스는 앞서 설명한 이유로 다중 상속이 안되는데, 인터페이스의 다중 구현은 허용한 이유는 무엇일까요?

  인터페이스는 모두 추상 메서드로 이루어져 있기 때문입니다.


다음 예제를 봅시다.



InterfaceA, InterfaceB는 둘 다 같은 methodCommon()을 가지고 있습니다.

그리고 Child는 두 인터페이스를 구현했습니다.

  상속 관계의 경우 두 부모 중에 어떤 한 부모의 methodCommon()을 사용해야 할지 결정해야 하는 다이아몬드 문제가 발생합니다.
    
      하지만 인터페이스 자신은 구현을 가지지 않습니다.
        
          대신에 인터페이스를 구현하는 곳에서 해당 기능을 모두 구현해야 합니다.
        
      
    
  


여기서 InterfaceA, InterfaceB는 같은 이름의 methodCommon()를 제공하지만 이것의 기능은 Child가 구현합니다.

  그리고 오버라이딩에 의해 어차피 Child에 있는 methodCommon()이 호출됩니다.
    
      결과적으로 두 부모 중에 어떤 한 부모의 methodCommon()을 선택하는 것이 아니라 그냥 인터페이스들을 구현한 Child에 있는 methodCommon()이 사용됩니다.
        
          이런 이유로 인터페이스는 다이아몬드 문제가 발생하지 않습니다.
            
              따라서 인터페이스의 경우 다중 구현을 허용합니다.
            
          
        
      
    
  


예제를 코드로 작성해봅시다.

package poly.diamond;

public class Child implements InterfaceA, InterfaceB {

  @Override
  public void methodA() {
    System.out.println("Child.methodA");
  }

  @Override
  public void methodB() {
    System.out.println("Child.methodB");
  }

  @Override
  public void methodCommon() {
    System.out.println("Child.methodCommon");
  }
}



  ìmplements InterfaceA, InterfaceB와 같이 다중 구현을 할 수 있습니다.
    
      implements 키워드 위에 ,로 여러 인터페이스를 구분하면 됩니다.
    
  
  methodCommon()의 경우 양쪽 인터페이스에 다 있지만 같은 메서드이므로 구현은 하나만 하면 됩니다.


package poly.diamond;

public class DiamondMain {

  public static void main(String[] args) {
    InterfaceA a = new Child();
    a.methodA();
    a.methodCommon();

    InterfaceB b = new Child();
    b.methodB();
    b.methodCommon();
  }
}


실행 결과
Child.methodA
Child.methodCommon
Child.methodB
Child.methodCommon





  a.methodCommon()을 호출하면 먼저 x001 Child 인스턴스를 찾는다.
  변수 a가 InterfaceA 타입이므로 해당 타입에서 methodCommon()을 찾습니다.
  methodCommon()은 하위 타입인 Child에서 오버라이딩 되어 있습니다. 따라서 Child의 methodCommon()이 호출됩니다.





  b.methodCommon()을 호출하면 먼저 x001 Child 인스턴스를 찾습니다.
  변수 b가 InterfaceB 타입으로 해당 타입에서 methodCommon()을 찾습니다.
  methodCommon()은 하위 타입인 Child에서 오버라이팅 되어 있습니다. 따라서 Child의 methodCommon()이 호출됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-21-Interface.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-21-Interface.html"><h1 class="title_post">☕️[Java] 인터페이스</h1></a>
                        <a href="/2024/Java/2024-03-21-Interface.html" class="txt_post">
                            인터페이스

“자바는 순수 추상 클래스를 더 편리하게 사용할 수 있는 인터페이스라는 기능을 제공합니다.”

순수 추상 클래스
public abstract class AbstractAnimal {
    public abstract void sound();
    public abstract void move();
}


“인터페이스는 class 가 아니라 interface 키워드를 사용하면 됩니다.”

인터페이스
public interface InterfaceAnimal {
    public abstract void sound();
    public abstract void move();
}


인터페이스 - public abstract 키워드 생략 가능
public interface InterfaceAnimal {
    void sound();
    void move();
}


순수 추상 클래스는 다음과 같은 특징을 갖습니다.

  인스턴스를 생성할 수 없습니다.
  상속시 모든 메서드를 오버라이딩 해야 합니다.
  주로 다형성을 위해 사용됩니다.


인터페이스는 앞서 설명한 순수 추상 클래스와 같습니다. 여기에 약간의 편의 기능이 추가 됩니다.

  인터페이스 메서드는 모두 public, abstract입니다.
  메서드에 public abstract를 생략할 수 있습니다.(참고로 생략이 권장됩니다.)
  인터페이스는 다중 구현(다중 상속)을 지원합니다.


인터페이스와 멤버 변수
public interface InterfaceAnimal {
    public static final int MY_PI = 3.14;
}



  인터페이스에서 멤버 변수는 public, static, final이 모두 포함되었다고 간주됩니다.
    
      final은 변수의 값을 한 번 설정하면 수정할 수 없다는 뜻입니다.
      자바에서 static final을 사용해 정적이면서 고칠 수 없는 변수를 상수라 하고, 관례상 상수는 대문자에 언더스코어(_)로 구분합니다.
    
  


해당 키워드는 다음과 같이 생략할 수 있습니다.(생략이 권장됩니다.)
public interface InterfaceAnimal {
    int MY_PI = 3.14;
}


예제 5




  클래스 상속 관계는 UML에서 실선을 사용하지만, 인터페이스 구현(상속)관계는 UML에서 점선을 사용합니다.


package poly.ex5;

public class InterfaceMain {

  public static void main(String[] args) {
    // 인터페이스 생성 불가
    // InterfaceAnimal interfaceAnimal = new InterfaceAnimal();

    Cat cat = new Cat();
    Dog dog = new Dog();
    Caw caw = new Caw();

    soundAnimal(cat);
    soundAnimal(dog);
    soundAnimal(caw);
  }

  // 변하지 않는 부분
  private static void soundAnimal(InterfaceAnimal animal) {
    System.out.println("동물 소리 테스트 시작");
    animal.sound();
    System.out.println("동물 소리 테스트 종료");
  }
}


실행 결과
동물 소리 테스트 시작
야옹
동물 소리 테스트 종료

동물 소리 테스트 시작
멍멍
동물 소리 테스트 종료

동물 소리 테스트 시작
음메
동물 소리 테스트 종료




앞서 설명한 순수 추상 클래스 예제와 거의 유사합니다.

  순수 추상 클래스가 인터페이스가 되었을 뿐입니다.


클래스, 추상 클래스, 인터페이스는 모두 똑같습니다.

  클래스, 추상 클래스, 인터페이스는 프로그램 코드, 메모리 구조상 모두 똑같습니다.
    
      모두 자바에서는 .class로 로 다루어집니다.
        
          인터페이스를 작성할 때도 .java에 인터페이스를 정의합니다.
        
      
    
  
  인터페이스는 순수 추상 클래스와 비슷하다고 생각하면 됩니다.


상속 vs 구현
부모 클래스의 기능을 자식 클래스가 상속 받을 때, 클래스는 상속 받는다고 표현하지만, 부모 인터페이스의 기능을 자식이 상속 받을 때는 인터페이스를 구현한다고 표현합니다.

이렇게 서로 다르게 표현하는 이유를 알아봅시다.


  상속은 이름 그대로 부모의 기능을 물려 받는 것이 목적입니다.
    
      하지만 인터페이스는 모든 메서드가 추상 메서드입니다.
        
          따라서 물려 받을 수 있는 기능이 없고, 오히려 인터페이스에 정의한 모든 메서드를 자식이 오버라이딩 해서 기능을 구현해야 합니다.
            
              따라서 구현한다고 표현합니다.
            
          
        
      
    
  
  인터페이스는 메서드 이름만 있는 설계도이고, 이 설계도가 실제 어떻게 작동하는지는 하위 클래스에서 모두 구현해야 합니다.
    
      따라서 인터페이스의 경우 상속이 아니라 해당 인터페이스를 구현한다고 표현합니다.
    
  


상속과 구현은 사람이 표현하는 단어만 다를 뿐이지 자바 입장에서는 똑같습니다. 일반 상속 구조와 동일하게 작동합니다.

인터페이스를 사용해야 하는 이유.
모든 메서드가 추상 메서드인 경우 순수 추상 클래스로 만들어도 되고, 인터페이스를 만들어도 됩니다.

그런데 왜 인터페이스를 사용해야 할까요? 단순히 편리하다는 이유를 넘어서 다음과 같은 이유가 있습니다.


  제약 : 인터페이스를 만드는 이유는 인터페이스를 구현하는 곳에서 인터페이스의 메서드를 반드시 구현하라는 규약(제약)을 주는 것입니다.
    
      USB 인터페이스를 생각해봅시다. USB 인터페이스에 맞추어 키보드, 마우스를 개발하고 연결해야 합니다. 그렇지 않으면 작동하지 않습니다.
      인터페이스의 규약(제약)은 반드시 구현해야 하는 것입니다.
        
          그런데 순수 추상 클래스의 경우 미래에 누군가 그곳에 실행 가능한 메서드를 끼워 넣을 수 있습니다.
            
              이렇게 되면 추가된 기능을 자식 클래스에서 구현하지 않을 수도 있고, 또 더는 순수 추상 클래스가 아니게 됩니다.
                
                  인터페이스는 모든 메서드가 추상 메서드입니다. 따라서 이런 문제를 원천 차단할 수 있습니다.
                
              
            
          
        
      
    
  
  다중 구현 : 자바에서 클래스 상속은 부모를 하나만 지정할 수 있습니다.
    
      반면에 인터페이스는 부모를 여러명 두는 다중 구현(다중 상속)이 가능합니다.
    
  


좋은 프로그램은 제약이 있는 프로그램입니다.


  참고
자바 8에 등장한 default 메서드를 사용하면 인터페이스도 메서드를 구현할 수 있습니다.
하지만 이것은 예외적으로 아주 특별한 경우에만 사용해야 합니다.
자바 9에서 등장한 인터페이스의 private 메서드도 마찬가지입니다.
지금 학습 단계에서는 이 부분들을 고려하지 않는 것이 좋습니다.
이 부분은 추후에 따로 학습하고 정리할 것 입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-03-21-whyIsComputerMemoryExpressedInhex.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-03-21-whyIsComputerMemoryExpressedInhex.html"><h1 class="title_post">💾 [CS] 컴퓨터 메모리를 16진수로 표시하는 이유</h1></a>
                        <a href="/2024/CS/2024-03-21-whyIsComputerMemoryExpressedInhex.html" class="txt_post">
                            컴퓨터 메모리를 16진수로 표시하는 이유.


  
    이진수와의 호환성 : 컴퓨터는 모든 데이터를 이진수, 즉 0과 1로 처리합니다. 이진수는 매우 기본적이지만, 긴 이진수를 읽고 이해하기는 어렵습니다. 16진수는 이진수를 좀 더 읽기 쉽게 만들어 줍니다. 4비트 이진수 한 덩어리가 16진수 한 자리와 정확히 대응되기 때문에, 이진수를 16진수로 변환하는 것은 자연스럽고 효율적입니다. 예를 들어, 이진수 1111은 16진수 F로 표현됩니다.
  
  
    효율적인 표현 : 16진수를 사용하면 매우 큰 수나 메모리 주소를 훨씬 짧고, 관리하기 쉬운 형태로 표현할 수 있습니다. 예를 들어, 8비트 이진수인 10011011은 16진수로는 단 두 자리 9B로 표현할 수 있습니다. 이는 프로그래머와 기술자가 메모리 주소나 데이터 값을 빠르게 인식하고 작업하기 용이합니다.
  
  
    표준화와 호환성 : 16진수는 컴퓨터 과학과 전자공학에서 널리 표준화되어 사용됩니다. 소프트웨어 개발, 디버깅, 하드웨어 설계 등 다양한 분야에서 16진수 사용은 정보를 일관되게 표현하고 전달하는 데 도움을 줍니다. 이는 서로 다른 시스템과 기술 간의 호환성을 증진시키는 역할을 합니다.
  
  
    디버깅과 분석 용이 : 개발자와 엔지니어가 시스템의 문제를 진단하거나 메모리의 내용을 분석할 때, 16진수 표현은 이진 데이터를 빠르게 읽고 해석할 수 있게 해줍니다. 이는 소프트웨어와 하드웨어의 오류를 찾고 해결하는 과정을 간소화합니다.
  


이렇게 16진수는 이진수의 복잡성을 줄이면서도 정보를 효과적으로 표현하고 처리할 수 있는 효율적인 방법을 제공합니다.
컴퓨터 공학에서 이러한 방식을 사용함으로써, 우리는 컴퓨터 시스템과 소프트웨어를 보다 쉽게 이해하고, 효율적으로 작업할 수 있게 됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-03-21-HowToRepresentNumbersWithZeroAndOne.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-03-21-HowToRepresentNumbersWithZeroAndOne.html"><h1 class="title_post">💾 [CS] 0과 1로 숫자를 표현하는 방법</h1></a>
                        <a href="/2024/CS/2024-03-21-HowToRepresentNumbersWithZeroAndOne.html" class="txt_post">
                            0과 1로 숫자를 표현하는 방법.

정보 단위.
컴퓨터는 0 또는 1밖에 이해하지 못합니다.

  0과 1을 나타내는 나타내는 가장 작은 정보 단위를 “비트(bit)” 라고 합니다.
    
      비트는 0 또는 1, 두 가지 정보를 표현할 수 있습니다.
    
  


“n비트는 2ⁿ가지 정보를 표현할 수 있습니다.”


  바이트(byte) : 여덟 개의 비트를 묶은 단위로, 비트보다 한 단계 큰 단위.
    
      1바이트는 8비트와 같습니다.
      2⁸(256)개의 정보를 표현할 수 있습니다.
    
  
  킬로바이트(kB: kilobyte) : 1바이트 1,000개를 묶은 단위입니다.
  메가바이트(MB: megabyte) : 1킬로바이트 1,000개를 묶은 단위입니다.
  기가바이트(GB: gigabyte) : 1메가바이트 1,000개를 묶은 단위입니다.
  테라바이트(TB: terabyte) : 1기가바이트 1,000개를 묶은 단위입니다.



  더 큰 단위도 있습니다.



  워드(word) : CPU가 한 번에 처리할 수 있는 데이터 크기를 의미합니다.
    
      만약 CPU가 한 번에 16비트를 처리할 수 있다면 1워드는 16비트가 되고, 한 번에 32비트를 처리할 수 있다면 1워드는 32비트가 되는 것입니다.
        
          워드의 절반 크기를 하프 워드(half word), 1배 크기를 풀 워드(full word), 2배 크기를 더블 워드(double word) 라고 부릅니다.
            
              컴퓨터의 워트 크기는 대부분 32비트 또는 64비트 입니다. 가령 인텔의 x86 CPU는 32비트 워드, x64 CPU는 64비트 워드 CPU입니다.
            
          
        
      
    
  


이진법

  0과 1만드로 모든 숫자를 표현하는 방법을 “이진법(binary)” 라고 합니다.
    
      우리가 일상적으로 사용하는 방법은 십진법(decimal) 라고 합니다.
        
          이진법으로 표현한 수를 “이진수”
          십진법으로 표현한 수를 “십진수”
        
      
    
  
  숫자만으로 어떤 수가 어떤 진법으로 표현된 수인지 알 수 없습니다.
    
      이런 혼동을 예방하기 위해 이진수 끝에 아래첨자 (2)를 붙이거나 이진수 앞에 0b를 붙입니다.
        
          전자는 주로 이진수를 수학적으로 표기할 때, 후자는 주로 코드 상에서 이진수를 표기할 때 사용합니다.
        
      
    
  




이진수의 음수 표현

  음수를 표현하는 방법 중 가장 널리 사용되는 방법은 2의 보수(two;s complement) 를 구해 이 값을 음수로 간주하는 방법입니다.
  2의 보수의 사전적 의미: ‘어떤 수를 그보다 큰 2ⁿ에서 뺀 값’을 의미합니다.
    
      예를 들어 11₍₂₎의 2의 보수는 11₍₂₎보다 큰 2ⁿ, 즉 100₍₂₎에서 11₍₂₎을 뺀 01₍₂₎이 되는 것 입니다.
    
  




“굳이 이렇게 사전적 의미로 어렵게 이해할 필요는 없습니다. 2의 보수를 매우 쉽게 표현하자면 다음과 같습니다.”

  ‘모든 0과 1을 뒤집고, 거기에 1을 더한 값’으로 이해하면 됩니다.
    
      예를 들어 11₍₂₎의 모든 0과 1을 뒤집으면 00₍₂₎이고, 거기에 1을 더한 값은 01₍₂₎입니다.
        
          즉, 11₍₂₎의 2의 보수(음수 표현)는 01₍₂₎이 됩니다.
        
      
    
  


“실제로 이진수만 봐서는 이게 음수인지 양수인지 구분하기 어렵습니다. 그래서 컴퓨터 내부에서 어떤 수를 다룰 때는 이 수가 양수인지 음수인지를 구분하기 위해 ‘플래그(flag)’를 사용합니다.”

  플래그는 쉽게 말해 부가 정보입니다.


십육진법(hexadecimal)

  수가 15를 넘어가는 시점에 자리 올림을 하는 숫자 표현 방식입니다.
    
      그리고 십진수 10, 11, 12, 13, 14, 15를 십육진법 체계에서는 각각 A, B, C, D, E, F로 표기합니다.
    
  
  십육진수도 이진수와 마찬가지로 숫자 뒤에 아래첨자 ₍₁₆₎를 븉아고너 숫자 앞에 0x룰 븉여 구분합니다.
    
      전자는 주로 수학적으로 표기할 때 사용되는 방식
      후자는 주로 코드상에서 십육진수를 표기할 때 사용되는 방식
    
  
  십육진법을 사용하는 주된 이유 중 하나는 이진수를 십육진수로, 십육진수를 이진수로 변환하기 쉽기 때문입니다.


십육진수를 이진수로 변환하기.

  십육진수는 한 글자당 열여섯 종류(0~9, A~F)의 숫자를 표현할 수 있습니다.
  십육진수를 이루는 숫자 하나를 이진수로 표현할 때는 4비트가 필요합니다.(2⁴ = 16)
  십육진수를 이준수로 변환하는 간편한 방법 중 하나는 십육진수 한 글자를 4비트의 이진수로 간주하는 것 입니다.
    
      즉, 십육진수를 이루고 있는 각 글자를 따로따로(4개의 숫자로 구성된) 이진수로 변환하고, 그것을 이어 붙이면 십육진수가 이진수로 변환됩니다.
    
  




이진수를 십육진수로 변환하기

  이진수를 십육진수로 변환할 때는 이진수 숫자를 네 개씩 끊고, 끊어 준 네 개의 숫자를 하나의 십육진수로 변환한 뒤 그대로 이어 붙이면 됩니다.




키워드로 정리하는 핵심 포인트

  비트는 0과 1로 표현할 수 있는 가장 작은 정보 단위입니다.
  바이트, 킬로바이트, 메가바이트, 기가바이트, 테라바이트는 비트보다 더 큰 정보 단위입니다.
  이진법은 1을 넘어가는 시점에 자리 올림을 하여 0과 1만으로 수를 표현하는 방법입니다.
  이진법에서 음수는 2의 보수로 표현할 수 있습니다.
  십육진법은 15를 넘어가는 시점에 자리 올림하여 수를 표현하는 방법입니다.


Q1.현대의 컴퓨터와 디지털 기기들은 데이터를 처리하고 저장할 때 기본적으로 0과 1, 즉 이진수를 사용합니다. iOS 개발 과정에서도 이러한 이진수의 원리를 이해하는 것이 중요한데요, 여러분은 이러한 이진수 시스템이 왜 필요하고, 어떻게 우리가 개발하는 앱과 관련이 있는지 설명해주실 수 있나요? 특히, 이진수의 개념이 iOS 앱 개발에서 어떤 실질적인 적용 사례를 가지는지 구체적인 예를 들어 주세요.

이진수 시스템은 컴퓨터와 디지털 기기들이 데이터를 처리하고 저장하는 기본적인 방법입니다. 이 시스템은 0과 1, 두 가지 상태만을 사용하여 정보를 표현하는 방법으로, 컴퓨터 하드웨어는 이러한 이진 상태들을 전기적 신호의 켜짐과 꺼짐으로 해석합니다. 이는 컴퓨터 기술에서 가장 기본이 되는 원리로, 모든 프로그래밍 언어와 운영 체제, 애플리케이션 개발에 깊이 관련되어 있습니다.

iOS 앱 개발에 있어 이진수의 이해는 몇 가지 중요한 측면에서 의미를 가집니다:


  
    데이터 저장과 처리: 앱 내에서 사용자 데이터, 설정, 상태 정보 등을 저장하고 처리할 때, 이진 형식이 기본적으로 사용됩니다. 예를 들어, 사용자가 앱 내에서 사진을 찍거나 파일을 다운로드할 때, 이러한 데이터는 이진 형태로 디바이스에 저장됩니다.
  
  
    통신: 앱이 서버와 데이터를 주고받을 때, 이진 데이터 형식이 널리 사용됩니다. 예를 들어, REST API를 통해 JSON 형식으로 데이터를 교환하더라도, 실제 네트워크를 통한 전송 과정에서는 이진 데이터로 변환되어 처리됩니다.
  
  
    성능 최적화: 이진수를 직접 다루는 지식은 앱의 성능 최적화에 큰 도움이 될 수 있습니다. 예를 들어, 이미지나 동영상 처리, 암호화, 데이터 압축 등 고성능을 요구하는 작업에서는 낮은 수준의 이진 처리가 필요할 수 있습니다.
  
  
    하드웨어 접근과 제어: iOS 앱 개발에서 때로는 하드웨어의 낮은 수준의 기능에 접근하거나 제어해야 할 필요가 있습니다. 이 경우, 이진수 처리 방식을 이해하는 것이 필수적입니다. 예를 들어, Bluetooth 통신이나 기타 특수한 하드웨어 기능을 사용하는 앱을 개발할 때 이진 데이터의 처리가 필요합니다.
  


이진수 시스템의 이해는 따라서, 기본적인 데이터의 표현부터 앱의 성능 최적화, 하드웨어 제어에 이르기까지 iOS 앱 개발의 여러 단계에 걸쳐 중요한 역할을 합니다. 이러한 지식은 개발자로서 문제 해결 능력을 향상시키고, 더 효율적이고 강력한 앱을 만드는 데 기여합니다.

Q2. 우리가 컴퓨터 과학에서 배우는 가장 기본적인 개념 중 하나는 모든 디지털 데이터가 궁극적으로 0과 1, 즉 이진수로 표현된다는 것입니다. 이러한 이진수 체계를 이해하는 것이 왜 Java 백엔드 개발에 있어 중요한지에 대해 설명해 주세요. 또한, 이 개념이 실제 백엔드 시스템 개발과 운영에 어떻게 적용될 수 있는지 구체적인 예를 들어 설명해주실 수 있나요?

이진수 체계의 이해는 Java 백엔드 개발에 있어 여러 가지 이유로 중요합니다:


  
    데이터 표현 및 처리의 기본: 컴퓨터는 모든 정보를 이진수로 처리하고 저장합니다. Java 백엔드 개발자로서 데이터를 저장, 검색, 변환하는 다양한 작업을 수행할 때 이진 데이터의 이해는 필수적입니다. 예를 들어, 파일 시스템에서 데이터를 읽고 쓰거나, 네트워크 통신을 통해 데이터를 송수신할 때 이진 데이터 형식에 대한 지식이 필요합니다.
  
  
    성능 최적화: 이진수에 대한 이해는 데이터 압축, 암호화, 데이터 전송 최적화와 같은 고급 개발 작업에서 성능을 향상시키는 데 도움이 됩니다. 예를 들어, 대용량 데이터를 효율적으로 처리하기 위해 비트 연산을 사용할 수 있으며, 이는 이진수의 원리를 이해할 때 가능해집니다.
  
  
    암호화 및 보안: 현대의 암호화 알고리즘은 대부분 이진수 기반의 복잡한 수학적 연산을 사용합니다. 백엔드 시스템에서 사용자 데이터의 보안을 유지하기 위해 데이터를 암호화하고 해시 함수를 적용할 때, 이진수 원리의 이해는 필수적입니다.
  
  
    하드웨어 및 시스템 인터페이스: 백엔드 시스템은 때로 특정 하드웨어나 시스템과 직접적으로 상호작용해야 할 수 있습니다. 이러한 상호작용은 종종 낮은 수준의 데이터 표현에 대한 깊은 이해를 요구하며, 이는 이진수 체계의 지식이 있을 때 효율적으로 수행될 수 있습니다.
  


이진수 체계의 이해는 Java 백엔드 개발자가 효율적이고 안전한 시스템을 설계하고 구현하는 데 필수적인 기초를 제공합니다. 데이터의 기본적인 표현 방식을 이해함으로써 개발자는 보다 깊은 수준에서 시스템을 이해하고, 성능과 보안 문제를 더 잘 해결할 수 있게 됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-20-AbstractClass2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-20-AbstractClass2.html"><h1 class="title_post">☕️[Java] 추상 클래스 2</h1></a>
                        <a href="/2024/Java/2024-03-20-AbstractClass2.html" class="txt_post">
                            추상 클래스 2
순수 추상 클래스: 모든 메서드가 추상 메서드인 추상 클래스

앞서 만든 예제에서 move()도 추상 메서드로 만들어야 한다고 가정해봅시다.

  이 경우 AbstractAnimal 클래스의 모든 메서드가 추상 메서드가 됩니다.
    
      이런 클래스를 “순수 추상 클래스” 라 합니다.
    
  


move()가 추상 메서드가 되었으니 자식들은 AbstractAnimal의 모든 기능을 오버라이딩 해야 합니다.



예제 4
package poly.ex4;

public class AbstractMain {

  public static void main(String[] args) {
    // 추상클래스 생성 불가
    //AbstractAnimal animal = new AbstractAnimal();

    Dog dog = new Dog();
    Cat cat = new Cat();
    Caw caw = new Caw();

    soundAnimal(dog);
    soundAnimal(cat);
    soundAnimal(caw);

    moveAnimal(dog);
    moveAnimal(cat);
    moveAnimal(caw);
  }

  // 변하지 않는 부분
  private static void soundAnimal(AbstractAnimal animal) {
    System.out.println("동물 소리 테스트 시작");
    animal.sound();
    System.out.println("동물 소리 테스트 종료");
  }

  // 변하지 않는 부분
  private static void moveAnimal(AbstractAnimal animal) {
    System.out.println("동물 이동 테스트 시작");
    animal.move();
    System.out.println("동물 이동 테스트 종료");
  }
}


실행 결과
동물 소리 테스트 시작
멍멍
동물 소리 테스트 종료

동물 소리 테스트 시작
야옹
동물 소리 테스트 종료

동물 소리 테스트 시작
음매
동물 소리 테스트 종료

동물 이동 테스트 시작
댕댕이 이동
동물 이동 테스트 종료

동물 이동 테스트 시작
냥냥이 이동
동물 이동 테스트 종료

동물 이동 테스트 시작
소 이동
동물 이동 테스트 종료




순수 추상 클래스

모든 메서드가 추상 메서드인 순수 추상 클래스는 코드를 실행할 바디 부분이 전혀 없습니다.
public abstract class AbstractAnimal {
    public abstract void sound();
    public abstract void move();
}


  이러한 순수 추상 클래스는 실행 로직을 전혀 가지고 있지 않습니다.
    
      단지 다형성을 위한 부모 타입으로써 껍데기 역할만 제공할 뿐입니다.
    
  


순수 추상 클래스는 다음과 같은 특징을 가집니다.

  인스턴스를 생성할 수 없습니다.
  상속시 자식은 모든 메서드를 오버라이딩 해야 합니다.
  주로 다형성을 위해 사용됩니다.


상속하는 클래스는 모든 메서드를 구현해야 합니다.
“상속시 자식은 모든 메서드를 오버라이딩 해야 합니다.”라는 특징은 상속 받는 클래스 입장에서 보면 부모의 모든 메서드를 구현해야 하는 것 입니다.

  이런 특징을 잘 생각해보면 순수 추상 클래스는 마치 어떤 규격을 지켜서 구현해야 하는 것 처럼 느껴집니다.
  AbstractAnimal의 경우 sound(), move() 라는 규격에 맞추어 구현을 해야 합니다.


이것은 우리가 일반적으로 이야기하는 인터페이스와 같이 느껴집니다.
예를 들어서 USB 인터페이스를 생각해봅시다.
USB 인터페이스는 분명한 규격이 있습니다.
이 규격에 맞추어 제품을 개발해야 연결이 됩니다.

  순수 추상 클래스가 USB 인터페이스 규격이라고 한다면 USB 인터페이스에 맞추어 마우스, 키보드 같은 연결 장치들을 구현할 수 있습니다.


이런 순수 추상 클래스의 개념은 프로그래밍에서 매우 자주 사용됩니다.

  자바는 순수 추상 클래스를 더 편리하게 사용할 수 있도록 인터페이스라는 개념을 제공합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-20</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-20-AbstractClass1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-20-AbstractClass1.html"><h1 class="title_post">☕️[Java] 추상 클래스 1</h1></a>
                        <a href="/2024/Java/2024-03-20-AbstractClass1.html" class="txt_post">
                            추상 클래스 1

추상 클래스

동물(Animal)과 같이 부모 클래스는 제공하지만, 실제 생성되면 안되는 클래스를 추상 클래스라 합니다.

  추상 클래스는 이름 그대로 추상적인 개념을 제공하는 클래스입니다.
    
      따라서 실체인 인스턴스가 존재하지 않습니다.
      대신에 상속을 목적으로 사용되고, 부모 클래스 역할을 담당합니다.
    
  


abstract class AbstractAnimal {...}


  추상 클래스는 클래스를 선언할 때 앞에 “추상”이라는 의미의 abstract 키워드를 붙여주면 됩니다.
  추상 클래스는 기존 클래스와 완전히 같습니다.
    
      다만 new AbstractAnimal()와 같이 직접 인스턴스를 생성하지 못하는 제약이 추가된 것입니다.
    
  


추상 메서드

부모 클래스를 상속 받은 자식 클래스가 반드시 오버라이딩 해야 하는 메서드를 부모 클래스에 정의할 수 있습니다.

  이것을 추상 메서드라 합니다.
  추상 메서드는 이름 그대로 추상적인 개념을 제공하는 메서드입니다.
    
      따라서 실체가 존재하지 않고, 메서드 바디가 없습니다.
    
  


public abstract void sound();


  추상 메서드는 선언할 때 메서드 앞에 추상이라는 의미의 abstract 키워드를 붙여주면 됩니다.
  추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언해야 합니다.
    
      그렇지 않으면 컴파일 오류가 발생합니다.
      추상 메서드는 메서드 바디가 없습니다.
        
          따라서 작동하지 않는 메서드를 가진 불완전한 클래스로 볼 수 있습니다.
            
              따라서 직접 생성하지 못하도록 추상 클래스로 선언해야 합니다.
            
          
        
      
    
  
  추상 메서드는 상속 받는 자식 클래스가 반드시 오버라이딩 해서 사용해야 합니다.
    
      그렇지 않으면 컴파일 오류가 발생합니다.
      추상 메서드는 자식 클래스가 반드시 오버라이딩 해야 하기 때문에 메서드 바디 부분이 없습니다. 바디 부분을 만들면 컴파일 오류가 발생합니다.
      오버라이딩 하지 않으면 자식도 추상 클래스가 되어야 합니다.
    
  
  추상 메서드는 기존 메서드와 완전히 같습니다.
    
      다만 메서드 바디가 없고, 자식 클래스가 해당 메서드를 반드시 오버라이딩 해야 한다는 제약이 추가된 것입니다.
    
  


이제 추상 클래스와 추상 메서드를 사용해서 예제를 만들어봅시다.

예제 3


package poly.ex3;

public abstract class AbstractAnimal {
  public abstract void sound();

  public void move() {
    System.out.println("동물이 움직입니다.");
  }
}



  AbstractAnimal은 abstract가 붙은 추상 클래스입니다.
    
      이 클래스는 직접 인스턴스를 생성할 수 없습니다.
    
  
  sound()는 abstract가 붙은 추상 메서드입니다.
    
      이 메서드는 자식이 반드시 오버라이딩 해야 합니다.
    
  


“이 클래스는 move()라는 메서드를 가지고 있는데, 이 메서드는 추상 메서드가 아닙니다.”

  따라서 자식 클래스가 오버라이딩 하지 않아도 됩니다.



  참고로 추상 클래스라고 AbstractAnimal 처럼 클래스 이름 앞에 꼭 Abstract를 써야하는 것은 아닙니다.
그냥 Animal 이라는 클래스 이름으로도 충분합니다.
여기에서는 예제 코드를 다른 예제 코드와 구분해서 설명하기 위해 앞에 Abstract를 붙였습니다.


package poly.ex3;

public abstract class AbstractAnimal {
  public abstract void sound();

  public void move() {
    System.out.println("동물이 움직입니다.");
  }
}


package poly.ex3;

public class Cat extends AbstractAnimal {
  @Override
  public void sound() {
    System.out.println("야옹");
  }
}


package poly.ex3;

public class Caw extends AbstractAnimal {
  @Override
  public void sound() {
    System.out.println("음매");
  }
}


package poly.ex3;

public class Dog extends AbstractAnimal {

  @Override
  public void sound() {
    System.out.println("멍멍");
  }
}


package poly.ex3;

public class AbstractMain {

  public static void main(String[] args) {
    // 추상클래스 생성 불가
    //AbstractAnimal animal = new AbstractAnimal();

    Dog dog = new Dog();
    Cat cat = new Cat();
    Caw caw = new Caw();

    cat.sound();
    cat.move();

    soundAnimal(dog);
    soundAnimal(cat);
    soundAnimal(caw);
  }

  // 변하지 않는 부분
  private static void soundAnimal(AbstractAnimal animal) {
    System.out.println("동물 소리 테스트 시작");
    animal.sound();
    System.out.println("동물 소리 테스트 종료");
  }
}


실행 결과
야옹
동물이 움직입니다.

동물 소리 테스트 시작
멍멍
동물 소리 테스트 종료

동물 소리 테스트 시작
야옹
동물 소리 테스트 종료

동물 소리 테스트 시작
음매
동물 소리 테스트 종료


추상 클래스는 생성이 불가능합니다.

  다음 코드의 주석을 풀고 실행하면 컴파일 오류가 발생합니다.
      // 추상클래스 생성 불가
  //AbstractAnimal animal = new AbstractAnimal();
    
  


컴파일 오류 - 인스턴스 생성
java: poly.ex3.AbstractAnimal is abstract; cannot be instantiated


  AbstractAnimal가 추상이어서 인스턴스 생성이 불가능하다는 뜻입니다.


추상 메서드는 반드시 오버라이딩 해야 합니다.

  만약 자식에서 오버라이딩 메서드를 만들지 않으면 다음과 같이 컴파일 오류가 발생합니다.


Dog의 sound() 메서드를 잠시 주석처리해봅시다.

package poly.ex3;

public class Dog extends AbstractAnimal {
/*
  @Override
  public void sound() {
    System.out.println("멍멍");
  }
*/
}


컴파일 오류 - 오버라이딩 X
java: poly.ex3.Dog is not abstract and does not override abstract method sound() in poly.ex3.AbstractAnimal


  Dog는 추상클래스가 아닌데 sound()가 오버라이딩 되지 않았다는 뜻 입니다.


지금까지 설명한 제약을 제외하고 나머지는 모두 일반적인 클래스와 동일합니다.

  추상 클래스는 제약이 추가된 클래스일 뿐입니다.
    
      메모리 구조, 실행 결과 모두 동일합니다.
    
  




정리

  추상 클래스 덕분에 실수로 Animal 인스턴스를 생성할 문제를 근본적으로 방지해줍니다.
  추상 메서드 덕분에 동물의 자식 클래스를 만들때 실수로 sound() 오버라이딩 하지 않을 문제를 근본적으로 방지해줍니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-20</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-19-TakeAdvantageOfPolymorphism3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-19-TakeAdvantageOfPolymorphism3.html"><h1 class="title_post">☕️[Java] 다형성 활용3</h1></a>
                        <a href="/2024/Java/2024-03-19-TakeAdvantageOfPolymorphism3.html" class="txt_post">
                            다형성 활용 3

이번에는 배열과 for문을 사용해서 중복을 제거해보겠습니다.

package poly.ex2;

public class AnimalPolyMain2 {

  public static void main(String[] args) {
    Dog dog = new Dog();
    Cat cat = new Cat();
    Caw caw = new Caw();
    Animal[] animalArr = {dog, cat, caw};

    // 변하지 않는 부분
    for (Animal animal : animalArr) {
      System.out.println("동물 소리 테스트 시작");
      animal.sound();
      System.out.println("동물 소리 테스트 종료");
    }
  }
}


실행 결과
동물 소리 테스트 시작
멍멍
동물 소리 테스트 종료

동물 소리 테스트 시작
야옹
동물 소리 테스트 종료

동물 소리 테스트 시작
음메
동물 소리 테스트 종료



  배열은 같은 타입의 데이터를 나열할 수 있습니다.
    
      Dog, Cat, Caw는 모두 Animal의 자식이므로 Animal 타입입니다.
    
  


Animal 타입의 배열을 만들고 다형적 참조를 사용하면 됩니다.
// 둘은 같은 코드입니다.
Animal[] animalArr = new Anima[]{dog, cat, caw};
Animal[] animalArr = {dog, cat, caw};


  다형적 참조 덕분에 Dog, Cat, Caw의 부모 타입인 Animal 타입으로 배열을 만들고, 각각을 배열에 포함했습니다.


이제 배열을 for문을 사용해서 반복하면 됩니다.
// 변하지 않는 부분
for (Animal animal: animalArr) {
    System.out.println("동물 소리 테스트 시작");
    animal.sound();
    System.out.println("동물 소리 테스트 종료");
}



  animal.sound()를 호출하지만 배열에는 Dog, Cat, Caw의 인스턴스가 들어있습니다.
    
      메서드 오버라이딩에 의해 각 인스턴스의 오버라이딩 된 sound() 메서드가 호출됩니다.
    
  


조금 더 개선

package poly.ex2;

public class AnimalPolyMain3 {

  public static void main(String[] args) {
    Animal[] animalArr = {new Dog(), new Cat(), new Cat()};
    for (Animal animal : animalArr) {
      soundAnimal(animal);
    }
  }

  // 변하지 않는 부분
  private static void soundAnimal(Animal animal) {
    System.out.println("동물 소리 테스트 시작");
    animal.sound();
    System.out.println("동물 소리 테스트 종료");
  }
}



  Animal[] animalArr를 통해서 배열을 사용합니다.
  soundAnimal(Animal animal)
    
      하나의 동물을 받아서 로직을 처리합니다.
    
  
  새로운 동물이 추가되어도 soundAnimal(...) 메서드는 코드 변경 없이 유지할 수 있습니다.
    
      이렇게 할 수 있는 이유는 이 메서드는 Dog, Cat, Caw 같은 구체적인 클래스를 참조하는 것이 아니라 Animal이라는 추상적인 부모를 참조하기 때문입니다.
        
          따라서 Animal을 상속 받은 새로운 동물이 추가되어도 이 메서드의 코드는 병경 없이 유지할 수 있습니다.
        
      
    
  
  여기서 잘 보면 새로운 동물이 추가되었을 때 코드가 변하는 부분과 변하지 않는 부분이 있습니다.
    
      main()은 코드가 변하는 부분입니다.
        
          새로운 동물을 생성하고 필요한 메서드를 호출합니다.
            
              soundAnimal(...)는 코드가 변하지 않는 부분입니다.
            
          
        
      
    
  


“새로운 기능이 추가되었을 때 변하는 부분을 최소화 하는 것이 잘 작성된 코드입니다.”

  이렇게 하기 위해서는 코드에서 변하는 부분과 변하지 않는 부분을 명확하게 구분하는 것이 좋습니다.


남은 문제
지금까지 설명한 코드에는 사실 2가지 문제가 있습니다.

  Animal 클래스를 생성할 수 있는 문제
  Animal 클래스를 상속 받는 곳에서 sound() 메서드 오버라이딩을 하지 않을 가능성.


Animal 클래스를 생성할 수 있는 문제

Animal 클래스는 동물이라는 클래스입니다.
이 클래스를 다음과 같이 직접 생성해서 사용할 일이 있을까요?

Animal animal = new Animal();



  개, 고양이, 소가 실제 존재하는 것은 당연하지만, 동물이라는 추상적인 개념이 실제로 존재하는 것은 이상합니다.
    
      이 클래스는 다형성을 위해서 필요한 것이지 직접 인스턴스를 생성해서 사용할 일은 없습니다.
      하지만 Animal도 클래스이기 때문에 인스턴스를 생성하고 사용하는데 아무런 제약이 없습니다.
      누군가 실수로 new Animal()을 사용해서 Animal의 인스턴스를 생성할 수 있다는 것 입니다.
      이렇게 생성된 인스턴스는 작동은 하지만 제대로된 기능을 수행하지는 않습니다.
    
  


Animal 클래스를 상속 받는 곳에서 sound() 메서드 오버라이딩을 하지 않을 가능성.
예를들어서 Animal을 상속 받은 Pig 클래스를 만든다고 가정해봅시다.

  우리가 기대하는 것은 Pig 클래스가 sound() 메서드를 오버라이딩 해서 “꿀꿀”이라는 소리가 나도록 하는 것입니다.
    
      그런데 개발자가 실수로 sound() 메서드를 오버라이딩 하는 것을 빠트릴 수 있습니다.
      이렇게 되면 부모의 기능을 상속받습니다.
        
          따라서 코드상 아무런 문제가 발생하지 않습니다.
            
              물론 프로그램을 실행하면 기대와 다르게 “꿀꿀”이 아니라 부모 클래스에 있는 Animal.sound()가 호출될 것입니다.
            
          
        
      
    
  


좋은 프로그램은 제약이 있는 프로그램입니다.

추상 클래스와 추상 메서드를 사용하면 이런 문제를 한번에 해결할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism2.html"><h1 class="title_post">☕️[Java] 다형성 활용2</h1></a>
                        <a href="/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism2.html" class="txt_post">
                            다형성 활용2

이번에는 앞서 설명한 예제를 다형성을 사용하여 변경해보겠습니다.



다형성을 사용하기 위해 여기서는 상속 관계를 사용합니다.

  Animal(동물) 이라는 부모 클래스를 만들고 sound() 메서드를 정의합니다.
    
      이 메서드는 자식 클래스에서 오버라이딩 할 목적으로 만들었습니다.
    
  
  Dog, Cat, Caw는 Animal 클래스를 상속받았습니다.
    
      그리고 각각 부모의 sound() 메서드를 오버라이딩 합니다.
    
  


기존 코드를 유지하기 위해 새로운 패키지를 만들고 새로 코드를 작성해보겠습니다.
“주의! 패키지 이름에 주의합시다 import를 사용해서 다른 패키지에 있는 같은 이름의 클래스를 사용하면 안됩니다.”

package poly.ex2;

public class Dog extends Animal {
  @Override
  public void sound() {
    System.out.println("멍멍");
  }
}


package poly.ex2;

public class Cat extends Animal {
  @Override
  public void sound() {
    System.out.println("야옹");
  }
}


package poly.ex2;

public class Caw extends Animal {
  @Override
  public void sound() {
    System.out.println("음메");
  }
}


package poly.ex2;

public class Animal {
  public void sound() {
    System.out.println("동물 울음 소리");
  }
}


package poly.ex2;

public class AnimalPolyMain1 {

  public static void main(String[] args) {
    Dog dog = new Dog();
    Cat cat = new Cat();
    Caw caw = new Caw();
    soundAnimal(dog);
    soundAnimal(cat);
    soundAnimal(caw);
  }

  private static void soundAnimal(Animal animal) {
    System.out.println("동물 소리 테스트 시작");
    animal.sound();
    System.out.println("동물 소리 테스트 종료");
  }
}


실행 결과
동물 소리 테스트 시작
멍멍
동물 소리 테스트 종료

동물 소리 테스트 시작
야옹
동물 소리 테스트 종료

동물 소리 테스트 시작
음메
동물 소리 테스트 종료


실행 결과는 기존 코드와 같습니다.

코드를 분석해봅시다.

  soundAnimal(dog)을 호출하면
    
      soundAnimal(Animal animla)에 Dog 인스턴스가 전달됩니다.
        
          Animal animal = dog로 이해하면 됩니다. 부모는 자식을 담을 수 있습니다. Animal은 Dog의 부모입니다.
        
      
    
  
  메서드 안에서 animal.sound() 메서드를 호출합니다.





  animal 변수의 타입은 Animal이므로 Dog 인스턴스에 있는 Animal 클래스 부분을 찾아서 sound() 메서드를 실행합니다.
    
      그런데 하위 클래스인 Dog에서 sound() 메서드를 오버라이딩 했습니다.
        
          따라서 오버라이딩한 메서드가 우선권을 가집니다.
        
      
    
  
  Dog 클래스에 있는 sound() 메서드가 호출되므로 “멍멍”이 출력됩니다.


이 코드의 핵심은 Animal animal 부분입니다.

  다형적 참조 덕분에 animal 변수는 자식인 Dog, Cat, Caw의 인스턴스를 참조할 수 있습니다.(부모는 자식을 담을 수 있습니다.)
  메서드 오버라이딩 덕분에 animal.sound()를 호출해도 Dog.sound(), Cat.sound(), Caw.sound()와 같이 각 인스턴스의 메서드를 호출할 수 있습니다.
    
      만약 자바에 메서드 오버라이딩이 없었다면 모두 Animal의 sound()가 호출되었을 것입니다.
    
  


다형성 덕분에 이후에 새로운 동물을 추가해도 다음 코드를 그대로 재사용 할 수 있습니다.

  물론 다형성을 사용하기 위해 새로운 동물은 Animal을 상속 받아야합니다.
    private static void soundAnimal(Animal animal) {
  System.out.println("동물 소리 테스트 시작");
  animal.sound();
  System.out.println("동물 소리 테스트 종료");
}
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism1.html"><h1 class="title_post">☕️[Java] 다형성 활용1</h1></a>
                        <a href="/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism1.html" class="txt_post">
                            다형성 활용1

지금까지 학습한 다형성을 왜 사용하는지, 그 장점을 알아보기 위해 우선 다형성을 사용하지 않고 프로그램을 개발한 다음에 다형성을 사용하도록 코드를 변경해보겠습니다.

아주 단순하고 전통적인 동물 소리 문제로 접근해보겠습니다.



개, 고양이, 소의 울음 소리를 테스트하는 프로그램을 작성해봅시다.

먼저 다형성을 사용하지 않고 코드를 작성해봅시다.

package poly.ex1;

public class Dog {

  public void sound() {
    System.out.println("멍멍");
  }
}


package poly.ex1;

public class Cat {

  public void sound() {
    System.out.println("야옹");
  }
}


package poly.ex1;

public class Caw {

  public void sound() {
    System.out.println("음메");
  }
}


package poly.ex1;

public class AnimalSoundMain {

  public static void main(String[] args) {
    Dog dog = new Dog();
    Cat cat = new Cat();
    Caw caw = new Caw();

    System.out.println("동물 소리 테스트 시작");
    dog.sound();
    System.out.println("동물 소리 테스트 종료");

    System.out.println("동물 소리 테스트 시작");
    cat.sound();
    System.out.println("동물 소리 테스트 종료");

    System.out.println("동물 소리 테스트 시작");
    caw.sound();
    System.out.println("동물 소리 테스트 종료");
  }
}


실행 결과
동물 소리 테스트 시작
멍멍
동물 소리 테스트 종료

동물 소리 테스트 시작
야옹
동물 소리 테스트 종료

동물 소리 테스트 시작
음메
동물 소리 테스트 종료


단순히 개, 고양이, 소 동물들의 울음 소리를 출력하는 프로그램입니다.

만약 여기서 새로운 동물이 추가되면 어떻게 될까요?

만약 기존 코드에 소가 없다고 가정해봅시다.

소가 추가된다고 가정하면 Caw 클래스를 만들고 다음 코드도 추가해야 합니다.

// Caw를 생성하는 코드
Caw caw = new Caw();

// Caw를 사용하는 코드
System.out.println("동물 소리 테스트 시작");
caw.sound();
System.out.println("동물 소리 테스트 종료");


Caw를 생성하는 부분은 당연히 필요하니 크게 상관이 없지만, Dog, Cat, Caw를 사용해서 출력하는 부분은 계속 중복이 증가합니다.

중복 코드
System.out.println("동물 소리 테스트 시작");
dog.sound();
System.out.println("동물 소리 테스트 종료");

System.out.println("동물 소리 테스트 시작");
cat.sound();
System.out.println("동물 소리 테스트 종료");

System.out.println("동물 소리 테스트 시작");
caw.sound();
System.out.println("동물 소리 테스트 종료");


중복을 제거하기 위해서는 메서드를 사용하거나, 또는 배열과 for문을 사용하면 됩니다.
그런데 Dog, Cat, Caw는 서로 완전히 다른 클래스입니다.

중복 제거 시도
메서드로 중복 제거 시도

메서드를 사용하면 다음과 같이 매개변수의 클래스를 Caw, Dog, Cat 중에 하나로 정해야 합니다.

private static void soundCaw(Caw caw) {
    System.out.println("동물 소리 테스트 시작");
    caw.sound();
    System.out.println("동물 소리 테스트 종료");
}


  따라서 이 메서드는 Caw 전용 메서드가 되고 Dog, Cat은 인수로 사용할 수 없습니다.
    
      Dog, Cat, Caw의 타입(클래스)이 서로 다르기 때문에 soundCaw 메서드를 함께 사용하는 것은 불가능합니다.
    
  


배열과 for문을 통한 중복 제거 시도
Caw[] cawArr = { cat, dog, caw }; // 컴파일 오류 발생!
System.out.println("동물 소리 테스트 시작");
    for (Caw caw : cawArr) {
        cawArr.sound()
}
System.out.println("동물 소리 테스트 종료");


배열과 for문 사용해서 중복을 제거하려고 해도 배열의 타입을 Dog, Cat, Caw 중에 하나로 지정해야 합니다.

  같은 Caw들을 배열에 담아서 처리하는 것은 가능하지만 타입이 서로 다른 Dog, Cat, Caw을 하나의 배열에 담는 것은 불가능합니다.
    
      결과적으로 지금 상황에서는 해결방법이 없습니다.
        
          새로운 동물이 추가될 때 마다 더 많은 중복 코드를 작성해야 합니다.
        
      
    
  


지금까지 설명한 모든 중복 제거 시도가 Dog, Cat, Caw의 타입이 서로 다르기 때문에 불가능합니다.

  “문제의 핵심은 바로 타입이 다르다는 점” 입니다.
    
      반대로 이야기하면 Dog, Cat, Caw가 모두 같은 타입을 사용할 수 있는 방법이 있다면 메서드와 배열을 활용해서 코드의 중복을 제거할 수 있다는 것입니다.
    
  


다형성의 핵심은 다형적 참조와 메서드 오버라이딩입니다.

  이 둘을 활용하면 Dog, Cat, Caw 가 모두 같은 타입을 사용하고, 각자 자신의 메서드로 호출할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-03-18-TheBigPictureOfComputerArchitecture.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-03-18-TheBigPictureOfComputerArchitecture.html"><h1 class="title_post">💾 [CS] 컴퓨터 구조의 큰 그림</h1></a>
                        <a href="/2024/CS/2024-03-18-TheBigPictureOfComputerArchitecture.html" class="txt_post">
                            컴퓨터 구조의 큰 그림

우리가 알아야 할 컴퓨터 구조 지식은 크게 두 가지 입니다.

  컴퓨터가 이해하는 정보
  컴퓨터의 네 가지 핵심 부품


컴퓨터가 이해하는 정보


  데이터
    
      컴퓨터가 이해하는 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
    
  
  명령어
    
      컴퓨터를 실직적으로 작동 시키는 중요한 정보
      데이터 없이는 아무것도 할 수 없는 정보 덩어리
      “데이터를 움직이고 컴퓨터를 작동 시키는 장보”
    
  


“즉, 명령어는 컴퓨터를 작동시키는 정보이고, 데이터는 명령어를 위해 존재하는 일종의 재료입니다.”

  컴퓨터 프로그램은 ‘명령어들의 모음’으로 정의되기도 합니다.
    
      그래서 명령어는 컴퓨터 구조를 학습하는 데 있어 데이터보다 더 중요한 개념.
    
  


컴퓨터의 4가지 핵심 부품.


  중앙처리장치(Central Programming Unit, CPU)
    
      컴퓨터의 두뇌
      메모리에 저장된 명령어를 읽어 들이고, 읽어 들인 명령어를 해석하고, 실행하는 부품입니다.
      CPU 내부 구성 요소 중 가장 중요한 세 가지는 산술논리연산장치(ALU: Arithmetic Logic Unit), 레지스터(register), 제어장치(CU: Control Unit) 입니다.
        
          ALU: 계산기, 계산만을 위해 존재하는 부품, 컴퓨터 내부에서 수행되는 대부분의 계산은 ALU가 도맡아 수행
          레지스터: CPU 내부의 작은 임시 저장 장치, 프로그램을 실행하는 데 필요한 값들을 임시로 저장, CPU 안에는 여러 개의 레지스터가 존재하고 각기 다른 이름과 역할을 가짐
          제어장치: 제어 신호(Control Signal)라는 전기 신호를 내보내고 명령어를 해석하는 장치.
            
              제어 신호란 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호
                
                  CPU가 메모리에 저장된 값을 읽고 싶을 땐 메모리를 향해 “메모리 읽기”라는 제어 신호를 보낸다.
                  CPU가 메모리에 어떤 값을 저장하고 싶을 땐 메모리를 향해 “메모리 쓰기”라는 제어 신호를 보낸다.
                
              
            
          
        
      
    
  
  주기억장치(Main memory, 메모리)
    
      현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품.
      즉, 프로그램이 실행되려면 반드시 메모리에 저장되어 있어야 합니다.
      메모리에 저장된 값의 위치는 주소로 알 수 있습니다.
    
  
  보조기억장치(secondary storage)
    
      메모리보다 크기가 크고 전원이 꺼져도 저장된 내용을 잃지 않는 메모리를 보조할 저장 장치
      보조기억장치는 ‘보관할’ 프로그램을 저장한다고 생각해도 좋다.
    
  
  입출력장치(input/output(I/O) device)
    
      마이크, 스피커, 프린터, 마우스, 키보드처럼 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치를 의미.
      ‘컴퓨터 주변에 붙어 있는 장치’라는 의미에서 “주변장치(peripheral device)”라 통칭하기도 함.
    
  




“주소”

  컴퓨터가 빠르게 작동하기 위해서는 메모리 속 명령어와 데이터가 정돈된 위치에 저장되어 있어야 합니다.
    
      그래서 메모리에는 저장된 값에 빠르게 효율적으로 접근하기 위해 주소(address)라는 개념이 사용됩니다.
      주소로 메모리 내 원하는 위치에 접근할 수 있습니다.
    
  


메인보드와 시스템 버스

  메인보드
    
      마더보드(mother board)라고도 부름
      메인보드에는 앞에서 소개한 부품을 비롯한 여러 컴퓨터 부품을 부착할 수 있는 슬록과 연결 단자가 있습니다.
      메인 보드에 연력된 부품들은 서로 정보를 주고 받을수 있습니다. 이는 메인보드 내부에 “버스(bus)”라는 통로가 있기 때문입니다.
    
  
  시스템 버스(system bus)
    
      여러 버스 가운데 컴퓨터의 네 가지 핵심 부품을 연결하는 가장 중요한 버스입니다.
      주소 버스, 데이터 버스, 제어 버스로 구성되어 있습니다.
        
          주소 버스(address bus): 주소를 주고받는 통로
          데이터 버스(data bus): 명령어롸 데이터를 주고 받는 통로
          제어 버스(control bus): 제어 신호를 주고 받는 통로
        
      
    
  


키워드로 정리하는 핵심 포인트

  컴퓨터가 이해하는 정보에는 “데이터” 와 “명령어” 가 있습니다.
  “메모리” 는 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품입니다.
  “CPU” 는 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 부품입니다.
  “보조기억장치” 는 전원이 꺼져도 보관할 프로그램을 저장하는 부품입니다.
  “입출력장치” 는 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 부품입니다.
  “시스템 버스” 는 컴퓨터의 네 가지 핵심 부품들이 서로 정보를 주고받는 통로입니다.


Q1. “메모리 주소가 무엇이며, iOS 시스템 내에서 어떤 역할을 수행한다고 생각하나요?”

메모리 주소는 컴퓨터 메모리 내에서 데이터나 명령어의 위치를 식별하는 데 사용되는 고유한 식별자입니다. 각 바이트 또는 워드에는 메모리 내의 위치를 나타내는 고유한 주소가 있으며, 이를 통해 CPU와 다른 시스템 구성 요소가 필요한 데이터를 정확히 찾아 읽고 쓸 수 있습니다.

iOS 시스템 내에서 메모리 주소의 역할은 특히 중요합니다. iOS는 메모리 관리에 자동 참조 카운팅(ARC)를 사용하여 객체의 생명 주기를 관리합니다. ARC는 객체에 대한 참조가 더 이상 필요하지 않게 되면 자동으로 메모리를 해제합니다. 이 과정에서 메모리 주소를 사용하여 각 객체의 위치를 파악하고 관리합니다. 따라서, 개발자로서 메모리 주소의 이해는 메모리 누수를 방지하고 앱의 성능을 최적화하는 데 필수적입니다.

또한, 메모리 주소를 이해하는 것은 포인터를 사용한 프로그래밍, 메모리 접근 최적화, 그리고 다양한 메모리 관리 기법을 적용하는 데 중요합니다. 예를 들어, 효율적인 데이터 구조 설계, 대규모 데이터 처리, 멀티스레딩 환경에서의 데이터 공유와 동기화 문제 해결 등은 메모리 주소와 밀접한 관련이 있습니다.

iOS 시스템 내에서 메모리 주소의 관리와 최적화는 앱의 반응 속도, 안정성, 그리고 사용자 경험에 직접적인 영향을 미치기 때문에, 이를 정확히 이해하고 효과적으로 활용하는 능력은 iOS 개발자에게 매우 중요한 자질입니다.

Q2. “메모리 주소가 무엇이며, Java 시스템 내에서 어떤 역할을 수행한다고 생각하나요?”

“메모리 주소는 컴퓨터 메모리 내의 특정 위치를 식별하는 데 사용되는 고유한 식별자입니다. 이 주소를 통해, 컴퓨터 시스템은 메모리 내에서 데이터나 명령어를 정확히 찾아내어 읽고 쓸 수 있습니다. 간단히 말해, 메모리 주소는 컴퓨터 메모리 내의 ‘우편 주소’와 유사한 역할을 수행합니다.

Java 시스템 내에서, 메모리 주소의 역할은 Java 가상 머신(JVM)에 의해 추상화되어 다루어집니다. Java 개발자들은 직접적으로 메모리 주소를 다루지 않으며, 대신 Java가 제공하는 추상화된 메모리 모델을 사용하여 프로그래밍합니다. Java에서는 객체와 배열 등이 힙 메모리에 할당되며, 개발자는 이러한 객체에 대한 참조를 통해 메모리를 접근하게 됩니다. 여기서 ‘참조’는 실제 메모리 주소를 직접적으로 나타내지는 않지만, 특정 객체를 가리키는 역할을 합니다.

JVM은 가비지 컬렉션(Garbage Collection)을 통해 메모리 관리를 자동화합니다. 가비지 컬렉터는 더 이상 사용되지 않는 객체를 자동으로 검출하고, 그 메모리를 회수하여 재사용 가능하게 만듭니다. 이 과정에서 JVM은 내부적으로 메모리 주소를 관리하여, 효율적인 메모리 할당과 해제를 수행합니다.

따라서, Java 시스템 내에서 메모리 주소는 주로 메모리 할당, 객체 참조, 그리고 가비지 컬렉션과 같은 메모리 관리 작업에 중요한 역할을 수행합니다. Java 개발자로서 우리의 역할은 주로 안전하고 효율적인 코드 작성에 초점을 맞추며, JVM이 메모리 관리의 세부 사항을 추상화하고 처리하도록 합니다. 이렇게 함으로써, 개발자는 메모리 관리의 복잡성으로부터 벗어나 비즈니스 로직 구현에 더 집중할 수 있습니다.”

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-17-polymorphismAndMethodOverriding.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-17-polymorphismAndMethodOverriding.html"><h1 class="title_post">☕️[Java] 다형성과 메서드 오버라이딩</h1></a>
                        <a href="/2024/Java/2024-03-17-polymorphismAndMethodOverriding.html" class="txt_post">
                            다형성과 메서드 오버라이딩.

“다형성을 이루는 또 하나의 중요한 핵심 이론은 바로 오버라이딩입니다.”
메서드 오버라이딩에서 꼭! 기억해야 할 점은 “오버라이딩 된 메서드가 항상 우선권을 가진다” 는 점입니다.
그래서 이름도 기존 기능을 덮어 새로운 기능을 재정의 한다는 뜻의 오버라이딩 입니다.

앞서 메서드 오버라이딩을 학습했지만 지금까지 학습한 메서드 오버라이딩은 반쪽짜리입니다.
“메서드 오버라이딩의 진짜 힘은 다형성과 함께 사용할 때 나타납니다.”

다음 코드를 통해 다형성과 메서드 오버라이딩을 알아봅시다.




  Parent, Child 모두 Value 라는 같은 멤버 변수를 가지고 있습니다.
    
      멤버 변수는 오버라이딩 되지 않습니다.
    
  
  Parent, Child 모두 method()라는 같은 메서드를 가지고 있습니다. Child에서 메서드를 오버라이팅 했습니다.
    
      메서드는 오버라이딩 됩니다.
    
  


package poly.overriding;

public class OverridingMain {

  public static void main(String[] args) {
    // 자식 변수가 자식 인스턴스 참조
    Child child = new Child();
    System.out.println("Child -&gt; Child");
    System.out.println("value = " + child.value);
    child.method();

    // 부모 변수가 부모 인스턴스 참조
    Parent parent = new Parent();
    System.out.println("Parent -&gt; Parent");
    System.out.println("value = " + parent.value);
    parent.method();

    // 부모 변수가 자식 인스턴스 참조(다형적 참조)
    Parent poly = new Child();
    System.out.println("Parent -&gt; Child");
    System.out.println("value = " + poly.value); // 변수는 오버라이딩 x
    poly.method(); // 메서드 오버라이딩!
  }
}


실행 결과
Child -&gt; Child
value = child
Child.method

Parent -&gt; Parent
value = parent
Parent.method

Parent -&gt; Child
value = parent
Child.method


그림을 통해 코드를 분석해봅시다.




  child 변수는 Child 타입 입니다.
    
      따라서 child.value, child.method()를 호출하면 인스턴스의 Child 타입에서 기능을 찾아서 실행합니다.
    
  





  parent 변수는 Parent 타입 입니다.
    
      따라서 parent.value, parent.method()를 호출하면 인스턴스의 Parent 타입에서 기능을 찾아서 실행합니다.
    
  





  이 부분이 중요합니다.
  poly 변수는 Parent 타입 입니다.
    
      따라서 poly.value,poly.method()를 호출하면 인스턴스의 Parent 타입에서 기능을 찾아서 실행합니다.
        
          poly.value: Parent 타입에 있는 value 값을 읽습니다.
          poly.method() : Parent 타입에 있는 method()를 실행하려고 합니다.
            
              그런데 Child.method()가 오버라이딩 되어있습니다.
              “오버라이딩 된 메서드는 항상 우선권을 가집니다.”
                
                  따라서 Parent.method()가 아니라 Child.method()가 실행됩니다.
                
              
            
          
        
      
    
  


오버라이딩 된 메서드는 항상 우선권을 가집니다.

  오버라이딩은 부모 타입에서 정의한 기능을 자식 타입에서 재정의하는 것입니다.
    
      만약 자식에서도 오버라이딩하고 손자에서도 메서드를 오버라이딩을 하면 손자의 오버라이딩 메서드가 우선권을 가집니다.
        
          “더 하위 자식의 오버라이딩 된 메서드가 우선권을 가지는 것입니다.”
        
      
    
  


지금까지 다형성을 이루는 핵심 이론인 다형적 참조와 메서드 오버라이딩에 대해 학습했습니다.

  다형적 참조 : 하나의 변수 타입으로 다양한 자식 인스턴스를 참조할 수 있는 기능
  메서드 오버라이딩 : 기존 기능을 하위 타입에서 새로운 기능으로 재정의


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-15-instanceof.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-15-instanceof.html"><h1 class="title_post">☕️[Java] instanceof</h1></a>
                        <a href="/2024/Java/2024-03-15-instanceof.html" class="txt_post">
                            instanceof

다형성에서 참조형 변수는 이름 그대로 다양한 지식을 대상으로 참조할 수 있습니다.
그런데 참조하는 대상이 다양하기 때문에 어떤 인스턴스를 참조하고 있는지 확인하려면 어떻게 해야할까요?

Parent parent1 = new Parent();
Parent parent2 = new Child()



  여기서 Parent는 자신과 같은 Parent의 인스턴스도 참조할 수 있고, 자식 타입인 Child의 인스턴스도 참조할 수 있습니다.
    
      이때 parent1, parent2 변수가 참조하는 인스턴스의 타입을 확인하고 싶다면 instanceof 키워드를 사용하면 됩니다.
    
  


예제를 봅시다.

package poly.basic;

public class CastingMain5 {

  public static void main(String[] args) {
    Parent parent1 = new Parent();
    System.out.println("parent1 호출");
    call(parent1);

    Parent parent2 = new Child();
    System.out.println("parent2 호출");
    call(parent2);
  }

  private static void call(Parent parent) {
    parent.parentMethod();

    if (parent instanceof Child) {
      System.out.println("Child 인스턴스 맞음");
      Child child = (Child) parent;
      child.childMethod();
    }
  }
}


실행 결과
parent1 호출
Parent.parentMethod
parent2 호출
Parent.parentMethod
Child 인스턴스 맞음
Child.childMethod


call(Parent parent) 메서드를 봐봅시다.

  이 메서드는 매개변수로 넘어온 parent가 참조하는 타입에 따라서 다른 명령을 수행합니다.
    
      참고로 지금처럼 다운캐스팅을 수행하기 전에는 먼저 instanceof를 사용해서 원하는 타입으로 변경이 가능한지 확인한 다음에 다운캐스팅을 수행하는 것이 안전합니다.
    
  


해당 메서드를 처음 호출할 때 parent는 Parent의 인스턴스를 참조합니다.
parent instanceof Child // parent는 Parent의 인스턴스
new Parent() instanceof Child // false



  parent는 Parent의 인스턴스를 참조하므로 false를 반환합니다.


해당 메서드를 다음으로 호출할 때 parent는 Child의 인스턴스를 참조합니다.
parent instanceof Child // parent는 Child의 인스턴스
new Child() instanceof Child // true


참고로 instanceof 키워드는 오른쪽 대상의 자식 타입을 왼쪽에서 참조하는 경우에도 true를 반환합니다.
parent instanceof Parent // parent는 Child의 인스턴스

new Parent() instanceof Parent // parent가 Parent의 인스턴스를 참조하는 경우: true
new Child() instanceof Parent // parent가 Child의 인스턴스를 참조하는 경우: true



  쉽게 이야기해서 오른쪽에 있는 타입에 왼쪽에 있는 인스턴스의 타입이 들어갈 수 있는지 대입해보면 됩니다.
    
      대입이 가능하면 true, 불가능하면 false가 됩니다.
    
  


new Parent() instanceof Parent
Parent p = new Parent() // 같은 타입 true

new Child() instancof Parent
Parent p = new Child() // 부모는 자식을 담을 수 있다. true

new Parent() instanceof Child
Child c = new Parent() // 자식은 부모를 담을 수 없다. false

new Child() instanceof Child
Child c = new Child() // 같은 타입 true


자바 16 - Pattern Matching for instanceof

자바 16부터는 instanceof를 사용하면서 동시에 변수를 선언할 수 있습니다.

다음 코드를 참고합시다.

package poly.basic;

public class CastingMain6 {

  public static void main(String[] args) {
    Parent parent1 = new Parent();
    System.out.println("parent1 호출");
    call(parent1);

    Parent parent2 = new Child();
    System.out.println("parent2 호출");
    call(parent2);
  }

  private static void call(Parent parent) {
    parent.parentMethod();
    // Child 인스턴스인 경우 childMethod() 실행
    if (parent instanceof Child child) {
      System.out.println("Child 인스턴스 맞음");
      child.childMethod();
    }
  }
}


실행 결과
parent1 호출
Parent.parentMethod
parent2 호출
Parent.parentMethod
Child 인스턴스 맞음
Child.childMethod



  덕분에 인스턴스가 맞는 경우 직접 다운캐스팅 하는 코드를 생략할 수 있습니다.



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-15-TypesOfCasting.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-15-TypesOfCasting.html"><h1 class="title_post">☕️[Java] 캐스팅의 종류</h1></a>
                        <a href="/2024/Java/2024-03-15-TypesOfCasting.html" class="txt_post">
                            캐스팅의 종류

자식 타입의 기능을 사용하려면 다음과 같이 다운 캐스팅 결과를 변수에 담아두고 이후에 기능을 사용하면 됩니다.
Child child = (Child) poly
child.childMethod();


하지만 다운캐스팅 결과를 변수에 담아두는 과정은 번거롭습니다.
이런 과정 없이 일시적으로 다운캐스팅을 해서 인스턴스에 있는 하위 클래스의 기능을 바로 호출할 수 있습니다.

다음 코드를 봐봅시다.

일시적 다운 캐스팅
package poly.basic;

public class CastingMain2 {

  public static void main(String[] args) {
    // 부모 변수가 자식 인스턴스 참조(다형적 참조)
    Parent poly = new Child();

    // 단 자식의 기능은 호출할 수 없습니다.(컴파일 오류 발생)
    // poly.childMethod();

    // 일시적 다운캐스팅 - 해당 메서드를 호출하는 순간만 다운캐스팅
    ((Child) poly).childMethod();
  }
}


실행 결과
Child.childMethod




((Child) poly).childMethod()



  poly는 Parent 타입입니다. 그런데 이 코드를 실행하면 Parent 타입을 임시로 Child로 변경합니다.
    
      그리고 메서드를 호출할 때 Child 타입에서 찾아서 실행합니다.
    
  


정확히는 poly가 Child 타입으로 바뀌는 것은 아닙니다.
((Child) poly).childMethod(); // 다운캐스팅을 통해 부모타입을 자식 타입으로 변환 후 기능 호출
((Child) x001).childMethod(); // 참조값을 읽은 다음 자식 타입으로 다운캐스팅



  참고로 캐스팅을 한다고 해서 Parent poly의 타입이 변하는 것은 아닙니다.
    
      해당 참조값을 꺼내고 꺼낸 참조값이 Child 타입이 되는 것입니다.
        
          따라서 poly의 타입은 Parent로 그대로 유지됩니다.
        
      
    
  


이렇게 일시적 다운캐스팅을 사용하면 별도의 변수 없이 인스턴스의 자식 타입의 기능을 사용할 수 있습니다.

업캐스팅

다운캐스팅과 반대로 현재 타입을 부모 타입으로 변경하는 것을 업캐스팅이라고 합니다.

다음 코드를 봅시다.

package poly.basic;

public class CastingMain3 {

  public static void main(String[] args) {
    Child child = new Child();
    Parent parent1 = (Parent) child; // 업캐스팅은 생략 가능, 생략 권장.
    Parent parent2 = child;

    parent1.parentMethod();
    parent2.parentMethod();
  }
}


실행 결과
Parent.parentMethod
Parent.parentMethod


다음 코드를 봐봅시다
Parent parent1 = (Parent) child;


  Child 타입을 Parent 타입에 대입해야 합니다.
    
      따라서 타입을 변환하는 캐스팅이 필요합니다.
    
  


그런데 부모 타입으로 변환하는 경우에는 다음과 같이 캐스팅 코드인 (타입)를 생략할 수 있습니다.
Parent parent2 = child
Parent parent2 = new Child()


“업캐스팅은 생략할 수 있습니다. 참고로 업캐스팅은 매우 자주 사용하기 때문에 생략을 권장합니다.”

  자바에서 부모는 자식을 담을 수 있습니다. 하지만 그 반대는 안됩니다.(꼭 필요하다면 다운캐스팅을 해야 합니다.)


업캐스팅을 생략해도 되고, 다운캐스팅은 왜 개발자가 직접 명시적으로 캐스팅을 해야할까요?


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-15-DowncastingAndPrecaution.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-15-DowncastingAndPrecaution.html"><h1 class="title_post">☕️[Java] 다운캐스팅과 주의점</h1></a>
                        <a href="/2024/Java/2024-03-15-DowncastingAndPrecaution.html" class="txt_post">
                            다운캐스팅과 주의점.

다운캐스팅은 잘못하면 심각한 런타임 오류가 발생할 수 있습니다.
다음 코드를 통해 다운캐스팅에서 발생할 수 있는 문제를 확인해봅시다.

package poly.basic;

// 다운캐스팅을 자동으로 하지 않는 이유
public class CastingMain4 {

  public static void main(String[] args) {
    Parent parent1 = new Child();
    Child child1 = (Child) parent1;
    child1.childMethod(); // 문제 없음

    Parent parent2 = new Parent();
    Child child2 = (Child) parent2; // 런타임 오류 - ClassCastException
    child2.childMethod(); // 실행 불가
  }
}


실행 결과
Child.childMethod
Exception in thread "main" java.lang.ClassCastException: class poly.basic.Parent cannot be cast to class poly.basic.Child (poly.basic.Parent and poly.basic.Child are in unnamed module of loader 'app')
	at poly.basic.CastingMain4.main(CastingMain4.java:12)



  실행 결과를 보면 child1.childMethod()는 잘 호출되었지만, child2.childMethod()는 실행되지 못하고, 그 전에 오류가 발생합니다.





  예제의 parent1의 경우 다운캐스팅을 해도 문제가 되지 않습니다.





  예제의 parent2를 다운캐스팅하면 ClassCastException 이라는 심각한 런타임 오류가 발생합니다.


이 코드를 자세히 알아봅시다.
Parent parent2 = new Parent()



  먼저 new Parent()로 부모 타입으로 객체를 생성합니다.
    
      따라서 메모리 상에 자식 타입은 전혀 존재하지 않습니다.
        
          생성 결과를 parent2에 담아둡니다.
            
              이 경우 같은 타입이므로 여기서는 문제가 발생하지 않습니다.
            
          
        
      
    
  


Child child2 = (Child) parent2


  다음으로 parent2를 Child 타입으로 다운캐스팅합니다.
    
      그런데 parent2는 Parent로 생성되었습니다.
        
          따라서 메모리상에 Child 자체가 존재하지 않습니다. Child 자체를 사용할 수 없는 것입니다.
        
      
    
  


자바에서는 이렇게 사용할 수 없는 타입으로 다운캐스팅하는 경우에 ClassCastExecption이라는 예외를 발생시킵니다.

  예외가 발생하면 다음 동작이 실행되지 않고, 프로그램이 종료됩니다.
    
      따라서 child2.childMethod() 코드 자체가 실행되지 않습니다.
    
  


업캐스팅이 안전하고 다운캐스팅이 위험한 이유
업캐스팅의 경우 이런 문제가 절대로 발생하지 않습니다.

  왜냐하면 객체를 생성하면 해당 타입의 상위 부모 타입은 모두 함께 생성되기 때문입니다!
    
      따라서 위로만 타입을 변경하는 업캐스팅은 메모리 상에 인스턴스가 모두 존재하기 때문에 항상 안전합니다.
        
          따라서 캐스팅을 생략할 수 있습니다.
        
      
    
  


반면에 다운캐스팅의 경우 인스턴스에 존재하지 않는 하위 타입으로 캐스팅하는 문제가 발생할 수 있습니다.

  왜냐하면 객체를 생성하면 부모 타입은 모두 함께 생성되지만 자식 타입은 생성되지 않습니다.
    
      따라서 개발자가 이런 문제를 인지하고 사용해야 한다는 의미로 명시적으로 캐스팅을 해주어야 합니다.
    
  




클래스 A, B, C는 상속 관계입니다.

  new C()로 인스턴스를 생성하면 인스턴스 내부에 자신과 부모인 A, B, C가 모두 생성됩니다.
    
      따라서 C의 부모 타입인 A, B, C 모두 C 인스턴스를 참조할 수 있습니다.
    
  


“상위로 올라가는 업캐스팅은 인스턴스 내부에 부모가 모두 생성되기 때문에 문제가 발생하지 않습니다.”

  A a = new C(): A로 업캐스팅
  B b = new C(): B로 업캐스팅
  C c = new C(): 자신과 같은 타입





  new B()로 인스턴스를 생성하면 인스턴스 내부에 자신과 부모인 A, B가 생성됩니다.
    
      따라서 B의 부모 타입인 A, B 모두 B 인스턴스를 참조 할 수 있습니다.
        
          상위로 올라가는 업캐스팅은 인스턴스 내부에 부모가 모두 생성되기 때문에 문제가 발생하지 않습니다.
            
              하지만 객체를 생성할 때 하위 자식은 생성되지 않기 때문에 하위로 내려가는 다운캐스팅은 인스턴스 내부에 없는 부분을 선택하는 문제가 발생할 수 있습니다.
            
          
        
      
    
  
  A a = new B() : A로 업캐스팅
  B b = new B() : 자신과 같은 타입
  C c = new B() : 하위 타입은 대입할 수 없음, 컴파일 오류
  C c = (C) new B() : 하위 타입으로 강제 다운캐스팅, 하지만 B 인스턴스에 C와 관련된 부분이 없으므로 잘못된 캐스팅, ClassCastException 런타임 오류 발생


컴파일 오류 vs 런타임 오류

  컴파일 오류는 변수명 오류, 잘못된 클래스 이름 사용등 자바 프로그램을 실행하기 전에 발생하는 오류입니다.
    
      이런 오류는 IDE에서 즉시 확인할 수 있기 때문에 안전하고 좋은 오류 입니다.
    
  
  반면에 런타임 오류는 이름 그대로 프로그램이 실행되고 있는 시점에 발생하는 오류입니다.
    
      런타임 오류는 매우 안좋은 오류입니다.
        
          왜냐하면 보통 고객이 해당 프로그램을 실행하는 도중에 발생하기 때문입니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-14-polymorphismStart.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-14-polymorphismStart.html"><h1 class="title_post">☕️[Java] 다형성(Polymorphism) 시작</h1></a>
                        <a href="/2024/Java/2024-03-14-polymorphismStart.html" class="txt_post">
                            다형성(Polymorphism) 시작.

“객체지향 프로그래밍의 대표적인 특징으로는 캡슐화, 상속, 다형성이 있습니다.”

  그 중에서 “다형성” 은 객체지향 프로그래밍의 꽃이라고 불립니다.


앞서 학습한 캡슐화나 상속은 직관적으로 이해하기 쉽습니다.

  반면에 “다형성은 제대로 이해하기도 어렵고, 잘 활용하기는 더 어렵습니다.”
    
      하지만 좋은 개발자기 되기 위해서는 “다형성에 대한 이해가 필수” 입니다.
    
  


“다형성(Polymorphism)” 은 이름 그대로 “다양한 형태”, “여러 형태” 를 뜻합니다.

  프로그래밍에서 “다형성은 한 객체가 여러 타입의 객체로 취급될 수 있는 능력을 뜻합니다”


보통 하나의 객체는 하나의 타입으로 고정되어 있습니다.

  그런데 “다형성을 사용하면 하나의 객체가 다른 타입으로 사용될 수 있다는 뜻입니다.”


본격적인 다형성 학습.

다형성을 이해하기 위해서는 크게 “2가지 핵심 이론” 을 알아야 합니다.

  다형적 참조
  메서드 오버라이딩


먼저 “다형적 참조”라 불리는 개념에 대해 알아봅시다.

다형적 참조.

다형적 참조를 이해하기 위해 다음과 같은 간단한 상속 관계를 코드로 만들어보겠습니다.




  부모와 자식이 있고, 각각 다른 메서드를 가집니다.


Parent
package poly.basic;

public class Parent {

  public void parentMethod() {
    System.out.println("Parent.parentMethod");
  }
}


Child
package poly.basic;

public class Child extends Parent {

  public void childMethod() {
    System.out.println("Child.childMethod");
  }
}


PolyMain
/*
 * 다형적 참조: 부모는 자식을 품을 수 있다. 
 */

package poly.basic;

public class PolyMain {

  public static void main(String[] args) {
    // 부모 변수가 부모 인스턴스 참조
    System.out.println("Parent -&gt; Parent");
    Parent parent = new Parent();
    parent.parentMethod();

    // 자식 변수가 자식 인스턴스 참조
    System.out.println("Child -&gt; Child");
    Child child = new Child();
    child.parentMethod();
    child.childMethod();

    // 부모 변수가 자신 인스턴스 참조(다형적 참조)
    System.out.println("Parent -&gt; Child");
    Parent poly = new Child();
    poly.parentMethod();
  }
}


Parent -&gt; Parent
Parent.parentMethod
Child -&gt; Child
Parent.parentMethod
Child.childMethod
Parent -&gt; Child
Parent.parentMethod


그림을 통해 코드를 하나씩 분석해봅시다.

부모 타입의 변수가 부모 인스턴스 참조



  부모 타입의 변수가 부모 인스턴스를 참조합니다.
  Parent parent = new Parent()
  Parent 인스턴스를 만들었습니다. 이 경우 부모 타입인 Parent를 생성했기 때문에 메모리 상에 Parent만 생성됩니다.(자식은 생성되지 않습니다.)
  생성된 참조값을 Parent 타입의 변수인 parent에 담아둡빈다.
  parent.parentMethod()를 호출하면 인스턴스의 Parent 클래스에 있는 parentMethod()가 호출됩니다.


자식 타입의 변수가 자식 인스턴스 참조



  자식 타입의 변수가 자식 인스턴스를 참조합니다.
  Child child = new Child()
  Child 인스턴스를 만들었습니다. 이 경우 자식 타입인 Child를 생성했기 때문에 메모리 상에 Child와 Parent가 모두 생성 됩니다.
  생성된 참조값을 Child 타입의 변수인 child에 답아둡니다.
  child.childMethod()를 호출하면 인스턴스의 Child 클래스에 있는 childMethod()가 호출됩니다.


여기까지는 지금까지 배운 내용이므로 이해하는데 어려움은 없을 것입니다. 이제부터가 중요합니다.




  부모 타입의 변수가 자식 인스턴스를 참조합니다.
  Parent poly = new Child()
  Child 인스턴스를 만들었습니다. 이 경우 자식 타입인 Child를 생성했기 때문에 메모리 상에 Child와 Parent가 모두 생성됩니다.
  생성된 참조값을 Parent 타입의 변수인 poly에 담아둡니다.


부모는 자식을 담을 수 있습니다.

  부모 타입은 자식 타입을 담을 수 있습니다.
  Parent poly는 부모 타입입니다. new Child()를 통해 생성된 결과는 Child 타입입니다. 자바에서 부모 타입은 자식 타입을 담을 수 있습니다.
    
      Parent poly = new Child() : 성공
    
  
  반대로 자식 타입은 부모 타입을 담을 수 없습니다.
    
      Child child1 = new Parent() : 컴파일 오류 발생
    
  


다형적 참조
지금까지 학습한 내용을 떠올려보면 항상 같은 타입에 참조를 대입했습니다.
그래서 보통 한 가지 형태만 참조할 수 있습니다.


  Parent parent = new Parent()
  Child child = new Child()


그런데 Parent 타입의 변수는 다음과 같이 자신인 Parent는 물론이고, 자식 타입까지 참조할 수 있습니다. 만약 손자가 있다면 손자도 그 하위 타입도 참조할 수 있습니다.


  Parent poly = new Parent()
  Parent poly = new Child()
  Parent poly = new Grandson() : Child 하위에 손자가 있다면 가능


자바에서 부모 타입은 물론이고, 자신을 기준으로 모든 자식 타입을 참조할 수 있습니다.
“이것을 바로 다양한 형태를 탐조할수 있다고 해서 다형적 참조하고 합니다.”

다형적 참조와 인스턴스 실행
앞의 그림을 참고합시다.

  poly.parentMethod()를 호출하면 먼저 참조값을 사용해서 인스턴스를 찾습니다.
    
      그리고 다음으로 인스턴스 안에서 실행할 타입도 찾아야 합니다.
    
  
  poly는 Parent 타입입니다.
    
      따라서 Parent 클래스부터 시작해서 필요한 기능을 찾습니다.
    
  
  인스턴스의 Parent 클래스에 parentMethod()가 있습니다.
    
      따라서 해당 메스드가 호출됩니다.
    
  




Parent poly = new Child() 이렇게 자식을 참조한 상황에서 poly가 자식 타입인 Child에 있는 childMethod()를 호출하면 어떻게 될까요?

  poly.childMethod()를 실행하면 먼저 참조값을 통해 인스턴스를 찾습니다.
    
      그리고 다음으로 인스턴스 안에서 실행할 타입을 찾아야 합니다.
        
          호출자인 poly는 Parent타입입니다.
            
              따라서 Parent 클래스부터 시작해서 필요한 기능을 찾습니다.
“그런데 상속 관계는 부코 방향으로 찾아 올라갈 수는 있지만 자식 방향으로 찾아 내려갈 수는 없습니다.”
            
          
        
      
    
  
  Parent는 부모 타입이고 상위에 부모가 없습니다.
    
      따라서 childMethod()를 찾을 수 없으므로 컴파일 오류가 발생합니다.
    
  


이런경우 childMethod()를 호출하고 싶으면 어떻게 해야할까요?

  “바로 캐스팅이 필요합니다.”


다형적 참조의 핵심은 부모는 자식을 품을 수 있다는 것입니다.
그런데 이런 “다형적 참조가 왜 필요하지?” 라는 의문이 들 수 있습니다.

  이 부분은 다형성의 다른 이론들도 함께 알아야 이해할 수 있습니다.
    
      지금은 우선 다형성의 문법과 이론을 익히는데 집중합시다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-14-polymorphismAndCasting.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-14-polymorphismAndCasting.html"><h1 class="title_post">☕️[Java] 다형성과 캐스팅</h1></a>
                        <a href="/2024/Java/2024-03-14-polymorphismAndCasting.html" class="txt_post">
                            다형성과 캐스팅.

Parent poly = new Child()와 같이 부모 타입의 변수를 사용하게 되면 poly.childMethod()와 같이 자식 타입에 있는 기능을 호출할 수 없습니다.

package poly.basic;

public class CastingMain1 {

  public static void main(String[] args) {
    // 부모 변수가 자식 인스턴스 참조(다형적 참조)
    Parent poly = new Child();

    // 단 자식의 기능은 호출할 수 없습니다.(컴파일 오류 발생)
    // poly.childMethod();

    // 다운 캐스팅(부모 타입 -&gt; 자식 타입)
    Child child = (Child) poly; // x001
    child.childMethod();
  }
}


실행 결과
Child.childMethod





  poly.childMethod()를 호출하면 먼저 참조값을 사용해서 인스턴스를 찾습니다.
  인스턴스 안에서 사용할 타입을 찾아야 합니다.
    
      poly는 Parent 타입입니다.
    
  
  Parent는 최상위 부모입니다.
    
      상속 관계는 부모로만 찾아서 올라갈 수 있습니다.
        
          childMethod는 자식 타입에 있으므로 호출할 수 없습니다.
            
              따라서 컴파일 오류가 발생합니다.
            
          
        
      
    
  




이럴때는 어떻게 하면 될까요?

  호출하는 타입을 자식인 Child 타입으로 변경하면 인스턴스의 Child에 있는 childMethod()를 호출할 수 있습니다. 하지만 다음과 같은 문제에 봉착합니다.


부모는 자식을 담을 수 있지만 자식은 부모를 담을 수 없습니다.

  Parent parent = new Child() : 부모는 자식을 담을 수 있습니다.
  Parent parent = child // Child child 변수 : 부모는 자식을 담을 수 있습니다.


반면에 다음과 같이 자식은 부모를 담을 수 없습니다.
Child child = poly // Parent poly 변수



  부모 타입을 사용하는 변수를 자식 타입에 대입하려고 하면 컴파일 오류가 발생합니다. 자식은 부모를 담을 수 없습니다.
    
      이때는 다운캐스팅이라는 기능을 사용해서 부모 타입을 잠깐 자식 타입으로 변경하면 됩니다.
    
  


다음 코드를 분석해봅시다.
Child child = (Child) poly // Parent poly


  (타입) 처럼 괄호와 그 사이에 타입을 지정하면 참조 대상을 특정 타입으로 변경할 수 있습니다.
    
      이렇게 특정 타입으로 변경하는 것을 “캐스팅” 이라고 합니다.
    
  
  오른쪽에 있는 (Child) poly 코드를 먼저 봅시다.
    
      poly는 Parent 타입입니다.
        
          이 타입을 (Child)를 사용해서 일시적으로 자식 타입인 Child 타입으로 변경합니다.
            
              그리고 나서 왼쪽에 있는 Child child에 대입합니다.
            
          
        
      
    
  


실행 순서
Child child = (Child) poly // 다운캐스팅을 통해 부모타입을 자식 타입으로 변환한 다음에 대입 시도
Child child = (Child) x001 // 참조값을 읽은 다음 자식 타입으로 지정
Child child = x001 // 최종 결과



  참고로 캐스팅을 한다고 해서 Parent poly의 타입이 변하는 것은 아닙니다.
해당 참조값을 꺼내고 참조값이 Child 타입이 되는 것입니다.
따라서 poly의 타입은 Parent로 기존과 같이 유지됩니다.


캐스팅

  업캐스팅(upcasting): 부모 타입으로 변경
  다운캐스팅(downcasting): 자식 타입으로 변경



  캐스팅 용어
“캐스팅”은 영어 단어 “cast”에서 유래되었습니다.
“cast”는 금속이나 다른 물질을 녹여서 특정한 형태나 모양으로 만드는 과정을 의미합니다.

  Child child = (Child) poly 경우 Parent poly라는 부모 타입을 Child라는 자식 타입으로 변경했습니다.
부모 타입을 자식 타입으로 변경하는 것을 “다운캐스팅”이라 합니다. (부모 -&gt; 자식)
반대로 부모 타입으로 변경하는 것은 “업캐스팅”이라 합니다. (자식 -&gt; 부모)


다운캐스팅과 실행
// 다운캐스팅(부모 타입 -&gt; 자식 타입)
Child child = (Child) poly;
child.childMethod();


  다운캐스팅 덕분에 child.childMethod()를 호출할 수 있게 되었습니다.
    
      childMethod()를 호출하기 위해 해당 인스턴스를 찾아간 다음 Child 타입을 찾습니다.
        
          Child 타입에는 childMethod()가 있으므로 해당 기능을 호출할 수 있습니다.
            
              앞의 그림을 참고합시다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-03-14-patternMatchingAndExpressionMatching.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-03-14-patternMatchingAndExpressionMatching.html"><h1 class="title_post">💾 [CS] 패턴 매칭(Pattern Matching)과 표현 매칭(Expression Matching)</h1></a>
                        <a href="/2024/CS/2024-03-14-patternMatchingAndExpressionMatching.html" class="txt_post">
                            패턴 매칭(Pattern Matching)과 표현 매칭(Expression Matching).


  패턴 매칭과 표현 매칭은 프로그래밍 언어나 소프트웨어 개발에서 사용되는 두 가지 다른 개념입니다.
    
      둘 다 데이터나 표현식의 구조를 분석하고 일치 여부를 판단하는 방법이지만, 적용되는 맥락과 목적에서 차이가 있습니다.
    
  


패턴 매칭(Pattern Matching).

  데이터의 구조와 그 내용을 기반으로 한 매칭 방식입니다.
  입력된 데이터가 특정 패턴이나 구조와 일치하는지를 검사합니다.
    
      이를 통해 데이터의 타입, 값, 구조 등을 확인하고 , 그에 따른 처리를 분기하는 데 사용됩니다.
    
  


표현 매칭(Expression Matching)

  특정 표현식이나 문자열이 주어진 패턴이나 규칙과 일치하는지를 확인하는 방법입니다.
    
      주로 문자열 처리, 정규 표현식 사용, 텍스트 분석에서 널리 사용됩니다.
    
  
  표현 매칭은 특정 패턴(예: 정규 표현식)을 정의하고, 대상 문자열이 이 패턴과 일치하는지 여부를 판단합니다.
    
      이는 검색, 데이터 검증, 파싱 등 다양한 분야에서 활용됩니다.
    
  


차이점 요약


  적용 분야
    
      패턴 매칭은 주로 데이터의 구조와 타입을 다루는 함수형 프로그래밍에서 사용됩니다.
      반면, 표현 매칭은 문자열이나 텍스트 데이터를 처리할 때 사용되는 패턴(예: 정규 표현식)과의 일치 여부를 확인하는 데 쓰입니다.
    
  
  목적
    
      패턴 매칭은 데이터의 구조를 통해 복잡한 데이터 타입을 효율적으로 분해하고 처리하는 데 중점을 둡니다.
      표현 매칭은 문자열 내에서 특정 패턴의 존재 여부를 검사하고, 데이터를 검증하거나 추출하는 데 주로 사용됩니다.
    
  
  사용 사례
    
      패턴 매칭은 데이터 타입 분해, 조건 분기 처리 등에 사용되며, 함수형 프로그래밍 언어에서 자주 볼 수 있습니다.
      표현 매칭은 로그 분석, 웹 페이지 파싱, 사용자 입력 검증 등 문자열 처리에 널리 사용됩니다.
    
  


두 방법은 각각의 사용 사례와 목적에 맞게 선택하여 사용되며, 프로그래밍에서의 다양한 문제를 해결하는 데 중요한 역할을 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-03-14-WhyYouNeedToKnowComputerArchitecture.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-03-14-WhyYouNeedToKnowComputerArchitecture.html"><h1 class="title_post">💾 [CS] 컴퓨터 구조를 알아야 하는 이유</h1></a>
                        <a href="/2024/CS/2024-03-14-WhyYouNeedToKnowComputerArchitecture.html" class="txt_post">
                            컴퓨터 구조를 알아야 하는 이유.

컴퓨터 구조는 실력 있는 개발자가 되려면 반드시 알아야 할 기본 지식입니다

  why?
    
      문제 해결
        
          컴퓨터 구조를 이해하고 있다면 문제 상황을 빠르게 진단할 수 있고, 문제 해결의 실마리를 다양하게 찾을 수 있습니다.
          컴퓨터 구조 지식은 다양한 문제를 스스로 해결할 줄 아는 개발자로 만들어 줍니다.
        
      
      성능, 용량, 비용
        
          “컴퓨터 구조애서 배우는 내용은 결국 성능, 용량, 비용과 직결됩니다.”
            
              즉, 컴퓨터 구조를 이해하면 입력과 출력에만 집중하는 개발을 넘어 성능, 용량, 비용까지 고려하며 개발하는 개발자가 될 수 있습니다,
            
          
        
      
    
  


문제 해결
컴퓨터 구조를 이해하고 있다면 문제 상황을 빠르게 진단할 수 있고, 문제 해결의 실마리를 다양하게 찾을 수 있습니다.

  컴퓨터 내부를 거리낌 없이 들여다보면 더 좋은 해결책을 고민할 수 있습니다.
    
      이러한 사고가 가능한 이들에게 컴퓨터란 ‘미지의 대상’이 아닌 ‘분석의 대상’이기 때문입니다.
    
  


컴퓨터 구조 지식은 다양한 문제를 스스로 해결할 줄 아는 개발자로 만들어 줍니다.

성능, 용량, 비용

성능, 용량, 비용 문제는 프로그래밍 언어의 문법만 알아서는 해결하기 어렵습니다.

  혼자만 사용하는 프로그램을 만들 떄는 이러한 문제를 생각조차 해 본 적이 없을 수도 있습니다.
  하지만 유튜브, 워드, 포토샵과 같이 사용자가 많은 프로그램은 필연적으로 성능, 용량, 비용이 고려됩니다.
    
      그래서 컴퓨터 구조를 아는 것은 매우 중요합니다.
    
  


“컴퓨터 구조애서 배우는 내용은 결국 성능, 용량, 비용과 직결됩니다.”

  즉, 컴퓨터 구조를 이해하면 입력과 출력에만 집중하는 개발을 넘어 성능, 용량, 비용까지 고려하며 개발하는 개발자가 될 수 있습니다,


핵심 포인트

  컴퓨터 구조를 이해하면 “문제 해결” 능력이 향상 됩니다.
  컴퓨터 구조를 이해하면 문법만으로는 알기 어려운 “성능/용량/비용” 을 고려하며 개발할 수 있습니다.


Q1. iOS 애플리케이션 개발에서 고효율적이고 성능이 우수한 앱을 만들기 위해 컴퓨터 구조에 대한 이해가 왜 중요한지 설명해주세요. 구체적인 예를 들어서 설명해주시기 바랍니다.

답변.
iOS 애플리케이션 개발에서 컴퓨터 구조에 대한 이해는 여러 면에서 중요합니다.

첫째, 성능 최적와레 있어서 핵심적인 역할을 합니다.

예를 들어, CPU의 멀티코어 구조를 이해함으로써, 병렬 처리와 동시성을 통해 애플리케이션의 성능을 효과적으로 향상시킬 수 있습니다.

이는 앱이 사용자의 입력에 빠르게 반응하고, 더 복잡한 작업을 빠른 시간 안에 처리할 수 있게 만들어 줍니다.

둘째, 메모리 관리에 대한 이해를 통해, 애플리케이션의 효율성을 높일 수 있습니다.

예를 들어, RAM과 캐시의 작동 방식을 이해하면, 데이터를 효율적으로 저장하고 접근하는 방법을 개선할 수 있으며, 이는 애플리케이션의 반응 속도와 전반적인 성능에 긍정적인 영향을 미칩니다.

셋째, 하드웨어와 소프트웨어의 상호작용에 대한 이해는 에너지 효율성을 최적화하는 데 도움이 됩니다.

iOS 장치의 배터리 수명은 사용자 경험의 중요한 부분이며, 컴퓨터 구조에 대한 이해는 개발자가 배터리 소모를 최소화하면서 성능을 극대화할 수 있는 애플리케이션을 설계할 수 있게 돕습니다.

마지막으로 컴퓨터 구조에 대한 깊은 이해는 개발자가 효과적인 코드를 작성하고, 시스템 리소스를 효율적으로 관리하며, 최종 사용자에게 더 나은 경험을 제공할 수 있는 애플리케이션을 만들 수 있도록 합니다.

Q2. 서버 개발자가 컴퓨터 구조에 대한 기본적인 지식을 갖추어야 하는 이유에 대해 설명해주시고, 그 지식이 어떻게 서버 애플리케이션의 성능과 안정성에 영향을 미칠 수 있는지 구체적인 예시를 들어 설명해주세요.

답변.
서버 개발자에게 컴퓨터 구조에 대한 이해는 애플리케이션의 성능 최적화와 안정성 보장에 필수적입니다.

첫 번째 이유는 성능 최적화와 관련이 있습니다.

예를 들어, CPU의 멀티코어 아키텍처를 이해함으로써 서버 애플리케이션에서 멀티 스레딩과 병렬 처리를 효율적으로 구현할 수 있습니다.

이는 요청 처리량을 증가시키고 응답 시간을 단축시킬 수 있으며, 고객에게 더 나은 서비스 경험을 제공할 수 있습니다.

두 번째 이유는 자원 관리와 관련이 있습니다.

서버 애플리케이션은 종종 대량의 데이터를 처리하고, 메모리 및 CPU 자원을 집중적으로 사용합니다.
메모리 계층 구조(예: 캐시, 주 메모리)와 이에 대한 이해는 데이터 접근 시간을 최적화하고, 메모리 사용 효율을 극대화하는 방법을 개발자에게 제공합니다.
이를 통해 시스템의 전반적인 효율성을 향상시킬 수 있습니다.

세 번째 이유는 안정성과 가용성에 있습니다.

서버 개발자는 컴퓨터 구조에 대한 이해를 통해 시스템의 잠재적 한계와 병목 현상을 더 잘 파악할 수 있으며, 이를 바탕으로 더 견고하고 오류에 강한 시스템을 설계할 수 있습니다.

예를 들어, 서버 하드웨어의 장애 지점을 이해하고, 이에 대비한 높은 가용성을 보장하는 소프트웨어 설계를 할 수 있습니다.

종합하면, 컴퓨터 구조에 대한 깊은 이해는 서버 개발자가 성능, 자원 관리, 안정성을 고려한 효율적이고 안정적인 서버 애플리케이션을 설계하고 구현하는 데 있어 필수적입니다.
이는 최종적으로 사용자 경험을 개선하고, 비즈니스 목표 달성에 기여합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-13-super2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-13-super2.html"><h1 class="title_post">☕️[Java] super - 생성자</h1></a>
                        <a href="/2024/Java/2024-03-13-super2.html" class="txt_post">
                            super - 생성자.


  상속 관계의 인스턴스를 생성하면 결국 메모리 내부에는 자식과 부모 클래스가 각각 만들어집니다.
    
      Child를 만들면 부모인 Parent까지 함께 만들어지는 것입니다.
        
          따라서 생성자도 모두 호출되어야 합니다.
        
      
    
  


“상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 합니다.(규칙)”

  상속 관계에서 부모의 생성자를 호출할 때는 super(...)를 사용하면 됩니다.


예제를 통해 상속 관계에서 생성자를 어떻게 사용하는지 알아봅시다.

ClassA
package extends1.super2;

public class ClassA {
  public ClassA() {
    System.out.println("ClassA 생성자");
  }
}


  ClaasA는 최상위 부모 클래스입니다.


ClassB
package extends1.super2;

public class ClassB extends ClassA {

  public ClassB(int a) {
    super(); // 기본 생성자 생략 가능.
    System.out.println("ClassB 생성자 a=" + a);
  }

  public ClassB(int a, int b) {
    super(); // 기본 생성자 생략 가능
    System.out.println("ClassB 생성자 a=" + a + " b=" + b);
  }
}


  ClassB는 ClassA를 상속 받았습니다.
    
      상속을 받으면 생성자의 첫 줄에 super(...)를 사용해서 부모 클래스의 생성자를 호출해야 합니다.
        
          예외로 생성자 첫줄에 this(...)를 사용할 수는 있습니다.
            
              하지만 super(...)는 자식의 생성자 안에서 언젠가는 반드시 호출해야 합니다.
            
          
        
      
    
  
  부모 클래스의 생성자가 기본 생성자(파라미터가 없는 생성자)인 경우에는 super()를 생략할 수 있습니다.
    
      상속 관계에서 첫줄에 super(...)를 생략하면 자바는 부모의 기본 생성자를 호출하는 super()를 자동으로 만들어 줍니다.
        
          참고로 기본 생성자를 많이 사용하기 때문에 편의상 이런 기능을 제공합니다.
        
      
    
  


ClassC
package extends1.super2;

public class ClassC extends ClassB {

  public ClassC() {
    super(10, 20);
    System.out.println("ClassC 생성자");
  }
}


  ClassC는 ClassB를 상속 받았습니다.
  ClassB는 다음 두 생성자가 있습니다.
    
      ClassB(int a)
      ClassB(int a, int b)
    
  
  생성자는 하나만 호출할 수 있습니다.
    
      두 생성자 중에 하나를 선택하면 됩니다.
        
          super(10, 20)를 통해 부모 클래스의 ClassB(int a, int b) 생성자를 선택했습니다.
        
      
    
  



  참고로 ClassC의 부모인 ClassB에는 기본 생성자가 없습니다. 따라서 부모의 기본 생성자를 호출하는 super()를 사용하거나 생략할 수 없습니다.


Super2Main
package extends1.super2;

public class Super2Main {

  public static void main(String[] args) {
    ClassC classC = new ClassC();
  }
}


실행 결과
ClassA 생성자
ClassB 생성자 a=10 b=20
ClassC 생성자



  실행해보면 ClassA =&gt; ClassB =&gt; ClassC 순서로 실행됩니다.
    
      생성자의 실행 순서가 결과적으로 최상위 부모부터 실행되어서 하나씩 아래로 내려오는 것 입니다.
        
          따라서 초기화는 최상위 부모부터 이루어 집니다.
            
              왜냐하면 자식 생성자의 첫 줄에서 부모 생성자를 호출해야 하기 때문입니다.
            
          
        
      
    
  




1~3까지의 과정

  new ClassC()를 통해 ClassC 인스턴스를 생성합니다.
    
      이때 ClassC()의 생성자가 먼저 호출되는 것이 맞습니다.
        
          하지만 ClassC()의 생성자는 가장 먼저 super(...)를 통해 ClassB(...)의 생성자를 호출합니다.
            
              ClassB의 생성자도 부모인 ClassA()의 생성자를 가장 먼저 호출합니다.
            
          
        
      
    
  


4~6까지의 과정

  ClassA()의 생성자는 최상위 부모입니다.
    
      생성자 코드를 실행하면서 "ClassA 생성자"를 출력합니다.
        
          ClassA() 생성자 호출이 끝나면 ClassA()를 호출한 ClassB(...) 생성자로 제어권이 돌아갑니다.
        
      
    
  
  ClassB(...) 생성자가 코드를 실행하면서 "ClassB 생성자 a=10 b=20"를 출력합니다.
    
      생성자 호출이 끝나면 ClassB(...)를 호출한 ClassC()의 생성자로 제어권이 돌아갑니다.
    
  
  ClassC()가 마지막으로 생성자 코드를 실행하면서 "ClassC 생성자"를 출력합니다.


정리

  상속 관계의 생성자 호출은 결과적으로 부모에서 자식 순서로 실행됩니다.
    
      따라서 부모의 데이터를 먼저 초기화하고 그 다음에 자식의 데이터를 초기화합니다.
    
  
  상속 관계에서 자식 클래스의 생성자 첫줄에 반드시 super(...)를 호출해야 합니다.
    
      단 기본 생성자(super())인 경우 생략 할 수 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-13-super.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-13-super.html"><h1 class="title_post">☕️[Java] super - 부모 참조</h1></a>
                        <a href="/2024/Java/2024-03-13-super.html" class="txt_post">
                            super - 부모 참조.

“부모와 자식의 필드명이 같거나 메서드가 오버라이딩 되어 있으면, 자식에서 부모의 필드나 메서드를 호출할 수 없습니다.”

  이때 super 키워드를 사용하면 부모를 참조할 수 있습니다.
  super 는 이름 그대로 부모 클래스에 대한 참조를 나타냅니다.


다음 예를 봅시다.

  부모의 필드명과 자식의 필드명 둘 다 value로 똑같습니다.
  메서드도 hello()로 자식에서 오버라이딩 되어 있습니다.
    
      이 때 자식 클래스에서 부모 클래스의 value와 hello()를 호출하고 싶다면 super 키워드를 사용하면 됩니다.
    
  




Parent
package extends1.super1;

public class Parent {

  public String value = "parent";

  public void hello() {
    System.out.println("Parent.hello");
  }
}


Child
package extends1.super1;

public class Child extends Parent {
  public String value = "child";

  @Override
  public void hello() {
    System.out.println("Child.hello");
  }

  public void call() {
    System.out.println("this value = " + this.value); // this 생략 가능
    System.out.println("super value = " + super.value);

    this.hello(); // this 생략 가능
    super.hello();
  }
}


call() 메서드를 봅시다.

  this는 자기 자신의 참조를 뜻합니다. this는 생략할 수 있습니다.
  super는 부모 클래스에 대한 참조를 뜻합니다.
  필드 이름과 메서드 이름이 같지만 super를 사용해서 부모 클래스에 있는 기능을 사용할 수 있습니다.


Super1Main
package extends1.super1;

public class Super1Main {

  public static void main(String[] args) {
    Child child = new Child();
    child.call();
  }
}


실행 결과
this value = child
super value = parent
Child.hello
Parent.hello



  실행 결과를 보면 super를 사용한 경우 부모 클래스의 기능을 사용한 것을 확인할 수 있습니다.


super 메모리 그림


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-13-finalUsedInClassesAndMethods.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-13-finalUsedInClassesAndMethods.html"><h1 class="title_post">☕️[Java] 클래스와 메서드에 사용되는 final</h1></a>
                        <a href="/2024/Java/2024-03-13-finalUsedInClassesAndMethods.html" class="txt_post">
                            클래스와 메서드에 사용되는 final.

클래스에 final

  상속 끝!
  final로 선언된 클래스는 확장될 수 없습니다.
    
      다른 클래스가 final로 선언된 클래스를 상속받을 수 없습니다.
        
          예: public final class MyFinalClass {...}
        
      
    
  


메서드에 final

  오버라이딩 끝!
  final로 선언된 메서드는 오버라이드 될 수 없습니다.
    
      상속받은 서브 클래스에서 이 메서드를 변경할 수 없습니다.
        
          예: public final void myFinalMethod() {...}
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-10-inheritanceAndAccessControl.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-10-inheritanceAndAccessControl.html"><h1 class="title_post">☕️[Java] 상속과 접근 제어</h1></a>
                        <a href="/2024/Java/2024-03-10-inheritanceAndAccessControl.html" class="txt_post">
                            상속과 접근 제어.

상속 관계와 접근 제어에 대해 알아보겠습니다.


  참고로 접근 제어를 자세히 설명하기 위해 부모와 자식의 패키지를 따로 분리하였습니다.





  접근 제어자를 표현하기 위해 UML 표기법을 일부 사용했습니다.
    
      +: public
      #: protected
      ~: default
      -: private
    
  


접근 제어자를 잠시 복습해봅시다.

접근 제어자의 종류

  private: 모든 외부 호출을 막습니다.
  default(package-private): 같은 패키지 안에서 호출은 허용합니다.
  protected: 같은 패키지 안에서 호출은 허용합니다.
    
      패키지가 달라도 상속 관계의 호출은 허용합니다.
    
  
  public: 모든 외부 호출을 허용합니다.


순서대로 private이 가장 많이 차단하고, public이 가장 많이 허용합니다.

  private -&gt; default -&gt; protected -&gt; public


그림과 같이 다양한 접근 제어자를 사용하도록 코드를 작성해보겠습니다.

Parent
package extends1.access.parent;

public class Parent {

  public int publicValue;
  protected int protectedValue;
  int defaultValue;
  private int privateValue;

  public void publicMethod() {
    System.out.println("Parent.publicMethod");
  }

  protected void protectedMethod() {
    System.out.println("Parent.protectedMethod");
  }

  void defaultMethod() {
    System.out.println("Parent.defaultMethod");
  }

  private void privateMethod() {
    System.out.println("Parent.privateMethod");
  }

  public void printParent() {
    System.out.println("==Parent 메서드 안==");
    System.out.println("publicValue = " + publicValue);
    System.out.println("protectedValue = " + protectedValue);
    System.out.println("defaultValue = " + defaultValue);
    System.out.println("privateValue = " + privateValue);


    // 부모 메서드 안에서 모두 접근 가능
    defaultMethod();
    privateMethod();
  }
}


Child
package extends1.access.child;

import extends1.access.parent.Parent;

public class Child extends Parent {

  public void call() {
    publicValue = 1;
    protectedValue = 1; // 상속 관계 or 같은 패키지
//    defaultValue = 1; // 다른 패키지 접근 불가, 컴파일 오류
//    privateValue = 1; // 접근 불가, 컴파일 오류

    publicMethod();
    protectedMethod(); // 상속 관계 or 같은 패키지
//    defaultMethod(); // 다른 패키지 접근 불가, 컴파일 오류
//    privateMethod(); // 접근 불가, 컴파일 오류

    printParent();
  }
}


ExtendsAccessMain
package extends1.access;

import extends1.access.child.Child;

public class ExtendsAccessMain {

  public static void main(String[] args) {
    Child child = new Child();
    child.call();
  }
}


Parent와 Child의 패키지가 다르다는 부분에 유의합시다.

자식 클래스인 Child에서 부모 클래스인 Parent에 얼마나 접근할 수 있는지 확인해봅시다.

  publicValue = 1;: 부모의 public 필드에 접근합니다. public이므로 접근할 수 있습니다.
  protectedValue = 1;: 부모의 protected 필드에 접근합니다. 자식과 부모는 다른 패키지이지만, 상속 관계이므로 접근할 수 있습니다.
  defaultValue = 1;: 부모의 default 필드에 접근합니다. 자식과 부모가 다른 패키지이므로 접근할 수 없습니다.
  privateValue = 1;: 부모의 private 필드에 접근합니다. private은 모두 외부 접근을 막으므로 자식이라도 호출할 수 없습니다.


메서드의 경우도 앞서 설명한 필드와 동일합니다.

Child
package extends1.access.child;

import extends1.access.parent.Parent;

public class Child extends Parent {

  public void call() {
    publicValue = 1;
    protectedValue = 1; // 상속 관계 or 같은 패키지
//    defaultValue = 1; // 다른 패키지 접근 불가, 컴파일 오류
//    privateValue = 1; // 접근 불가, 컴파일 오류

    publicMethod();
    protectedMethod(); // 상속 관계 or 같은 패키지
//    defaultMethod(); // 다른 패키지 접근 불가, 컴파일 오류
//    privateMethod(); // 접근 불가, 컴파일 오류

    printParent();
  }
}



  코드를 실행해보면 Child.call() -&gt; Parent.printParent() 순서로 호출합니다.
  Child는 부모의 public, protexted 필드나 메서드만 접근할 수 있습니다.
    
      반면에 Parent.printParent()의 경우 Parent 안에 있는 메서드이기 때문에 Parent 자신의 모든 필드와 메서드에 얼마든지 접근할 수 있습니다.
    
  


접근 제어와 메모리 구조.




  본인 타입에 없으면 부모 타입에서 기능을 찾는데, 이때 접근 제어자가 영향을 줍니다.
    
      왜냐하면 객체 내부에서는 자식과 부모가 구분되어 있기 때문입니다.
        
          결국 자식 차입에서 부모 타입의 기능을 호출할 때, 부모 입장에서 보면 외부에서 호출한 것과 같습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-09-InheritanceAndMethodOverriding.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-09-InheritanceAndMethodOverriding.html"><h1 class="title_post">☕️[Java] 상속과 메서드 오버라이딩</h1></a>
                        <a href="/2024/Java/2024-03-09-InheritanceAndMethodOverriding.html" class="txt_post">
                            상속과 메서드 오버라이딩.


  부모 타입의 기능을 자식에서는 다르게 재정의 하고 싶을 수 있습니다.
    
      예를 들어서 자동차의 경우 Car.move()라는 기능이 있습니다.
        
          이 기능을 사용하면 단순히 “차를 이동합니다.” 라고 출력합니다.
            
              전기차의 경우 보통 더 빠르기 때문에 전기차가 move()를 호출한 경우에는 “전기차를 빠르게 이동합니다.”라고 출력을 변경하고 싶습니다.
            
          
        
      
    
  


이렇게 부모에게서 상속 받은 기능을 자식이 재정의 하는 것을 “메서드 오버라이딩(Overriding)” 이라고 합니다.

package extends1.overriding - Car

package extends1.overriding;

public class Car {

  public void move() {
    System.out.println("차를 이동합니다.");
  }

  // 추가
  public void openDoor() {
    System.out.println("문을 엽니다.");
  }
}


  기존 코드와 같습니다.


package extends1.overriding - GasCar

package extends1.overriding;

public class GasCar extends Car {

  public void fillUp() {
    System.out.println("기름을 주유합니다.");
  }
}


package extends1.overriding - HydrogenCar

package extends1.overriding;

public class HydrogenCar extends Car {

  public void fillHydrogen() {
    System.out.println("수소를 충전합니다.");
  }
}


package extends1.overriding - ElectricCar

package extends1.overriding;

public class ElectricCar extends Car {

  @Override
  public void move() {
    System.out.println("전기차를 빠르게 이동합니다.");
  }

  public void charge() {
    System.out.println("충전합니다.");
  }
}



  ElectricCar는 부모인 Car의 move() 기능을 그대로 사용하고 싶지 않습니다.
    
      메서드 이름은 같지만 새로운 기능을 사용하고 싶습니다.
        
          그래서 ElectricCar의 move() 메서드를 새로 만들었습니다.
        
      
    
  


이렇게 부모의 기능을 자식이 새로 재정의하는 것을 “매서드 오버라이딩” 이라고 합니다.

  이제 ElectricCar의 move()를 호출하면 Car의 move()가 아니라 ElectricCar의 move()가 호출됩니다.


@Override

  @이 붙은 부분을 애노테이션(어노테이션, annotattion)이라 합니다.
    
      애노테이션은 주석과 비슷한데, 프로그램이 읽을 수 있는 특별한 주석이라 생각하면 됩니다.
    
  
  이 애노테이션은 상위 클래스의 매서드를 오버라이드하는 것임을 나타냅니다.
    
      이름 그대로 오버라이딩한 매서드 위에 이 애노테이션을 붙여야 합니다.
      컴파일러는 이 애노테이션을 보고 매서드가 정확히 오버라이드 되었는지 확인합니다.
      오바라이딩 조건을 만족시키지 않으면 컴파일 에러를 발생시킵니다.
        
          따라서 실수로 오버라이딩을 못하는 경우를 방지해줍니다.
            
              예를 들어서 이 경우에 만약 부모에 move() 메서드가 없다면 컴파일 오류가 발생합니다.
            
          
        
      
    
  



  참고로 이 기능은 필수는 아니지만 코드의 명확성을 위해 붙여주는 것이 좋습니다.


package extends1.overrding - CarMain
package extends1.overriding;

public class CarMain {

  public static void main(String[] args) {
    ElectricCar electricCar = new ElectricCar();
    electricCar.move();

    GasCar gasCar = new GasCar();
    gasCar.move();
  }
}


실행 결과
전기차를 빠르게 이동합니다.
차를 이동합니다.



  실행 결과를 보면 electricCar.move()를 호출했을 때 오버라이딩한 ElectricCar.move() 메서드가 실행된 것을 확인할 수 있습니다.


오버라이딩과 클래스




  Car의 move() 메서드를 ElectricCar에서 오버라이딩 했습니다.


오버라이딩과 메모리 구조




  electricCar.move()를 호출합니다.
  호출한 electricCar의 타입은 ElectricCar입니다. 따라서 인스턴스 내부의 ElectricCar 타입에서 시작합니다.
  ElectricCar 타입에 move() 메서드가 있습니다. 해당 메서드를 실행합니다. 이때 실행할 메서드를 이미 찾았으므로 부모 타입을 찾지 않스빈다.


오버로딩(Overloading)과 오버라이딩(Overriding)

  메서드 오버로딩: 메서드 이름이 같고 매개변수(파라미터)가 다른 메서드를 여러개 정의하는 것을 메서드 오버로딩(Overloading)이라고 합니다.
    
      오버로딩은 번역하면 과적인데, 과하게 물건을 담았다는 뜻입니다.
        
          따라서 같은 이름의 메서드를 여러개 정의했다고 이해하면 됩니다.
        
      
    
  
  메서드 오버라이딩: 메서드 오버라이딩은 하위 클래스에서 상위 클래스의 메서드를 재정의하는 과정을 의미합니다.
    
      따라서 상속 관계에서 사용합니다. 부모의 기능을 자식이 다시 정의하는 것입니다.
        
          오버라이딩을 단순히 해석하면 무언가를 넘어서 타는 것을 말합니다.
            
              자식의 새로운 기능이 부모의 기존 기능을 넘어 타서 기존 기능을 새로운 기능으로 덮어버린다고 이해하면 됩니다.
                
                  오버라이딩을 번역하면 무언가를 다시 정의한다고 해서 재정의라 합니다.
                    
                      상속 관계에서는 기존 기능을 다시 정의한다고 이해하면 됩니다.
                        
                          실무에서는 메서드 오버라이딩, 메서드 재정의 둘 다 사용합니다.
                        
                      
                    
                  
                
              
            
          
        
      
    
  


메서드 오버라이딩 조건

메서드 오버라이딩은 다음과 같은 까다로운 조건을 가지고 있습니다.

  다음 내용은 아직 학습하지 않은 내용들도 있으므로 이해하려고 하기 보다는 참고만 합시다.
    
      지금은 단순히 부모 메서드와 같은 메서드를 오버라이딩 할 수 있다 정도로 이해하면 충분합니다.
    
  


메서드 오버라이딩 조건

  메서드 이름: 메서드 이름이 같아야 합니다.
  메서드 매개변수(파라미터): 매개변수(파라미터) 타입, 순서, 개수가 같아야 합니다.
  반환 타입: 반환 타입이 같아야 합니다. 단, 반환 타입이 하위 클래스 타입일 수 있습니다.
  접근 제어자: 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다 더 제한적이어서는 안됩니다.
    
      예를 들어, 상위 클래스의 메서드가 protected로 선언되어 있으면 하위 클래스에서 이를 public 또는 protected로 오버라이드 할 수 있지만, private 또는 default로 오버라이드 할 수 없습니다.
    
  
  예외: 오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크 예외를 throws로 선언할 수 없습니다.
    
      하지만 더 적거나 같은 수의 예외, 또는 하위 타입의 예외는 선언할 수 있습니다.
    
  
  static, final, private: 키워드가 붙은 메서드는 오버라이딩 될 수 없습니다.
    
      static은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미가 없습니다.
        
          쉽게 이야기해서 그냥 클래스 이름을 통해 필요한 곳에 직접 접근하면 됩니다.
        
      
      final 메서드는 재정의를 금지합니다.
      private 메서드는 해당 클래스에서만 접근 가능하기 때문에 하위 클래스에서 보이지 않습니다.
        
          따라서 오버라이딩 할 수 없습니다.
        
      
    
  
  생성자 오버라이딩: 생성자는 오버라이딩 할 수 없습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-08-extendRelationship.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-08-extendRelationship.html"><h1 class="title_post">☕️[Java] 상속관계</h1></a>
                        <a href="/2024/Java/2024-03-08-extendRelationship.html" class="txt_post">
                            상속관계

  상속은 객체 지향 프로그래밍의 핵심 요소 중 하나로, 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해줍니다.
    
      이름 그대로 기존 클래스의 속성과 기능을 그대로 물려받는 것입니다.
    
  
  상속을 하려면 extends 키워드를 사용하면 됩니다.
    
      그리고 extends 대상은 하나만 선택할 수 있습니다.
    
  


용어 정리

  부모 클래스(슈퍼 클래스): 상속을 통해 자신의 필드와 메서드를 다른 클래스에 제공하는 클래스
  자식 클래스(서브 클래스): 부모 클래스로부터 필드와 메서드를 상속받는 클래스


⛔️주의⛔️
지금부터 코드를 작성할 때 기존 코드를 유지하기 위해, 새로운 패키지에 기존 코드를 옮겨가면서 코드를 작성할 것입니다.
이름이 같기 때문에 패키지 명과 import 사용에 주의해야 합니다.

상속 관계를 사용하도록 코드를 작성해봅시다.

기존 코드를 유지하기 위해 ex2 패키지를 새로 만들겠습니다.
package extends1.ex2;

public class Car {

  public void move() {
    System.out.println("차를 이동합니다.");
  }
}


package extends1.ex2;

public class ElectricCar extends Car {

  public void charge() {
    System.out.println("충전합니다.");
  }
}


package extends1.ex2;

public class GasCar extends Car {

  public void fillUp() {
    System.out.println("기름을 주유합니다.");
  }
}


package extends1.ex2;

public class CarMain {

  public static void main(String[] args) {
    ElectricCar electricCar = new ElectricCar();
    electricCar.move();
    electricCar.charge();

    GasCar gasCar = new GasCar();
    gasCar.move();
    gasCar.fillUp();
  }
}


실행 결과
차를 이동합니다.
충전합니다.
차를 이동합니다.
기름을 주유합니다.



  실행 결과는 기존 예제와 완전히 동일합니다.


상속 구조도



  전기차와 가솔린차가 Car를 상속 받은 덕분에 electricCar.move(),gasCar.move()를 사용할 수 있습니다.



  참고로 당연한 이야기지만 상속은 부모의 기능을 자식이 물려 받는 것입니다.
따라서 자식이 부모의 기능을 물려 받아서 사용할 수 있습니다.
반대로 부모 클래스는 자식 클래스에 접근할 수 없습니다.
자식 클래스는 부모 클래스의 기능을 물려 받기 때문에 접근할 수 있지만, 그 반대는 아닙니다.


부모 코드를 봐봅시다!

  자식에 대한 정보가 하나도 없습니다.
    
      반면에 자식 코드는 extends Parents를 통해서 부모를 알고 있습니다.
    
  


단일 상속

자바는 다중 상속을 지원하지 않습니다.

  그래서 extend 대상은 하나만 선택할 수 있습니다.
    
      부모를 하나만 선택할 수 있다는 뜻입니다.
        
          물론 부모가 또 다른 부모를 하나 가지는 것은 괜찮습니다.
        
      
    
  


다중 상속 그림



만약 비행기와 자동차를 상속 받아서 하늘을 나는 자동차를 만든다고 가정해봅시다.

  만약 그림과 같이 다중 상속을 사용하게 되면 AirplaneCar 입장에서 move()를 호출할 때 어떤 부모의 move()를 사용해야 할지 애매한 문제가 발생합니다.
    
      이것을 다이아몬드 문제라고 합니다.
      그리고 다중 상속을 사용하면 클래스 계층 구조가 매우 복잡해질 수 있습니다.
        
          이런 문제점 때문에 자바는 클래스의 다중 상속을 허용하지 않습니다.
            
              대신에 추후에 공부할 인터페이스의 다중 구현을 허용해서 이러한 문제를 피합니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-08-InheritanceAndMemoryStructure.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-08-InheritanceAndMemoryStructure.html"><h1 class="title_post">☕️[Java] 상속과 메모리 구조</h1></a>
                        <a href="/2024/Java/2024-03-08-InheritanceAndMemoryStructure.html" class="txt_post">
                            상속과 메모리 구조.

이 부분을 제대로 이해하는 것이 앞으로 정말 중요합니다!

상속 관계를 객체로 생성할 때 메모리 구조를 확인해봅시다.

ElectricCar electricCar = new ElectricCar();





  new ElectricCar()를 호출하면 ElectricCar 뿐만 아니라 상속 관계에 있는 Car까지 함께 포함해서 인스턴스를 생성합니다.
  참조값은 x001로 하나이지만 실제로 그 안에서는 Car, ElectricCar라는 두가지 클래스 정보가 공존하는 것입니다.
  상속이라고 해서 단순하게 부모의 필드와 메서드만 물려 받는게 아닙니다.
    
      상속 관계를 사용하면 부모 클래스도 함께 포함해서 생성됩니다.
    
  
  외부에서 볼때는 하나의 인스턴스를 생성하는 것 같지만 내부에서는 부모와 자식이 모두 생성되고 공간도 구분됩니다.


electricCar.charge() 호출




  electricCar.charge()를 호출하면 참조값을 확인해서 x001.charge()을 호출합니다.
    
      따라서 x001을 찾아서 charge()를 호출하면 되는 것입니다.
    
  
  그런데 상속 관계의 경우에는 내부에 부모와 자식이 모두 존재합니다.
    
      이때 부모인 Car를 통해서 charge()를 찾을지 아니면 ElectricCar를 통해서 charge()를 찾을지 선택해야 합니다.
        
          이때는 “호출하는 변수의 타입(클래스)을 기준으로 선택합니다.”
            
              electricCar 변수의 타입이 ElectricCar 이므로 인스턴스 내부에 같은 타입인 ElectricCar를 통해서 charge()를 호출합니다.
            
          
        
      
    
  


electricCar.move() 호출




  electricCar.move()를 호출하면 먼저 x001 참조로 이동합니다.
    
      내부에는 Car, ElectricCar 두가지 타입이 있습니다.
        
          이때 호출하는 변수인 electricCar의 타입이 ElectricCar 이므로 이 타입을 선택합니다.
            
              그런데 ElectricCar에는 move() 메서드가 없습니다.
                
                  상속 관계에서는 자식 타입에 해당 기능이 없으면 부모 타입으로 올라가서 찾습니다.
                
              
            
          
        
      
    
  
  이 경우 ElectricCar의 부모인 Car로 올라가서 move()를 찾습니다.
    
      부모인 Car에 move()가 있으므로 부모에 있는 move() 메서드를 호출합니다.
    
  
  만약 부모에서도 해당 기능을 찾지 못하면 더 상위 부모에서 필요한 기능을 찾아봅니다.
    
      부모에 보무로 계속 올라가면서 필드나 메서드를 찾는 것 입니다.
        
          물론 계속 찾아도 없으면 컴파일 오류가 발생합니다.
        
      
    
  


“지금까지 설명한 상속과 메모리 구조는 반드시 이해해야 합니다!”


  상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성됩니다.
  상속 관계의 객체를 호출할 때, 대상 타입을 정해야 합니다. 이때 호출자의 타입을 통해 대상 타입을 찾습니다.
  현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행합니다. 기능을 찾지 못하면 컴파일 오류가 발생합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-08-InheritanceAndAddingFeatures.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-08-InheritanceAndAddingFeatures.html"><h1 class="title_post">☕️[Java] 상속과 기능 추가</h1></a>
                        <a href="/2024/Java/2024-03-08-InheritanceAndAddingFeatures.html" class="txt_post">
                            상속과 기능 추가.

이번에는 상속 관계의 장점을 알아보기 위해, 상속 관계에 다음 기능을 추가해보겠습니다.

  모든 차량에 문열기(openDoor()) 기능을 추가합니다.
  새로운 수소차(HydrogenCar)를 추가합니다.
    
      수소차는 fillHydrogen() 기능을 통해 수소를 충전할 수 있습니다.
    
  


package ex3 - Car
package extends1.ex3;

public class Car {

  public void move() {
    System.out.println("차를 이동합니다.");
  }

  // 추가
  public void openDoor() {
    System.out.println("문을 엽니다.");
  }
}



  모든 차량에 문열기 기능을 추가할 때는 상위 부모인 Car에 openDoor() 기능을 추가하면 됩니다.
    
      이렇게 하면 Car의 자식들은 해당 기능을 모두 물려받게 됩니다.
        
          만약 상속 관계가 아니었다면 각각의 차량에 해당 기능을 모두 추가해야 합니다.
        
      
    
  


package ex3 - ElectricCar
package extends1.ex3;

public class ElectricCar extends Car {

  public void charge() {
    System.out.println("충전합니다.");
  }
}


  기존 코드와 같습니다.


package ex3 - GasCar
package extends1.ex3;

public class GasCar extends Car {

  public void fillUp() {
    System.out.println("기름을 주유합니다.");
  }
}


  기존 코드와 같습니다.


package ex3 - HydrogenCar
package extends1.ex3;

public class HydrogenCar extends Car {

  public void fillHydrogen() {
    System.out.println("수소를 충전합니다.");
  }
}


  수소차를 추가했습니다.
  Car를 상속받은 덕분에 move(), openDoor()와 같은 기능을 바로 사용할 수 있습니다.
  수소차는 전용 기능인 수소 충전(fillHydrogen()) 기능을 제공합니다.


package ex3 - CarMain
package extends1.ex3;

public class CarMain {

  public static void main(String[] args) {
    ElectricCar electricCar = new ElectricCar();
    electricCar.move();
    electricCar.charge();
    electricCar.openDoor();

    GasCar gasCar = new GasCar();
    gasCar.move();
    gasCar.fillUp();
    gasCar.openDoor();

    HydrogenCar hydrogenCar = new HydrogenCar();
    hydrogenCar.move();
    hydrogenCar.fillHydrogen();
    hydrogenCar.openDoor();
  }
}


실행 결과
차를 이동합니다.
충전합니다.
문을 엽니다.
차를 이동합니다.
기름을 주유합니다.
문을 엽니다.
차를 이동합니다.
수소를 충전합니다.
문을 엽니다.


기능 추가와 클래스 확장




  상속 관계 덕분에 중복은 줄어들고, 새로운 수소차를 편리하게 확장(extend)한 것을 알 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-08-extendStart.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-08-extendStart.html"><h1 class="title_post">☕️[Java] 상속 - 시작</h1></a>
                        <a href="/2024/Java/2024-03-08-extendStart.html" class="txt_post">
                            상속 - 시작.

상속 관계가 왜 필요한지 이해하기 위해 다음 예제 코드를 만들어서 실행해봅시다.

예제 코드

패키지 위치에 주의합시다.

package extends1.ex1;

public class ElectricCar {

  public void move() {
    System.out.println("차를 이동합니다.");
  }

  public void charge() {
    System.out.println("충전합니다.");
  }
}


package extends1.ex1;

public class GasCar {

  public void move() {
    System.out.println("차를 이동합니다.");
  }

  public void fillUp() {
    System.out.println("기름을 주유합니다.");
  }
}


package extends1.ex1;

public class CarMain {

  public static void main(String[] args) {
    ElectricCar electricCar = new ElectricCar();
    electricCar.move();
    electricCar.charge();

    GasCar gasCar = new GasCar();
    gasCar.move();
    gasCar.fillUp();
  }
}


실행 결과
차를 이동합니다.
충전합니다.
차를 이동합니다.
기름을 주유합니다.





  전기차(ElectricCar)와 가솔린차(GasCar)를 만들었습니다.
    
      전기차는 이동(move()), 충전(charge()) 기능이 있습니다.
      가솔린차는 이동(move()), 주유(fillUp()) 기능이 있습니다.
    
  
  전기차와 가솔린차는 자동차(Car)의 좀 더 구체적인 개념입니다.
  반대로 자동차(Car)는 전기차와 가솔린차를 포함하는 추상적인 개념입니다.
    
      그래서인지 잘 보면 둘의 공통 기능이 보입니다.
        
          바로 이동(move())입니다.
            
              전기차든 가솔린차든 주유하는 방식이 다른 것이지 이동하는 것은 똑같습니다.
                
                  이런 경우 상속 관계를 사용하는 것이 효과적입니다.
                
              
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-07-finalVariableAndConstant2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-07-finalVariableAndConstant2.html"><h1 class="title_post">☕️[Java] final 변수와 상수 2</h1></a>
                        <a href="/2024/Java/2024-03-07-finalVariableAndConstant2.html" class="txt_post">
                            final 변수와 상수 2

상수(Constant)

  상수는 변하지 않고, 항상 일정한 값을 갖는 수를 말합니다.
    
      자바에서는 보통 단 하나만 존재하는 변하지 않는 고정된 값을 상수라 합니다.
        
          이런 이유로 상수는 static final 키워드를 사용합니다.
        
      
    
  


자바 상수 특징

  static final 키워드를 사용합니다.
  대문자를 사용하고 구분은 _(언더스코어)로 합니다.(관례)
    
      일반적인 변수와 상수를 구분하기 위해 이렇게 합니다.
    
  
  필드를 직접 접근해서 사용합니다.
    
      상수는 기능이 아니라 고정된 값 자체를 사용하는 것이 목적입니다.
      상수는 값을 변경할 수 없습니다.
        
          따라서 필드에 직접 접근해도 데이터가 변하는 문제가 발생하지 않습니다.
        
      
    
  


package final1;

// 상수
public class Constant {
  // 수학 상수
  public static final double PI = 3.14;
  // 시간 상수
  public static final int HOURS_IN_DAY = 24;
  public static final int MINUTES_IN_HOUR = 60;
  public static final int SECONDS_IN_MINUTE = 60;
  // 애플리케이션 설정 상수
  public static final int MAX_USERS = 1000;
}



  애플리케이션 안에는 다양한 상수가 존재할 수 있습니다.
    
      수학, 시간 등등 실생활에서 사용하는 상수부터, 애플리케이션의 다양한 설정을 위한 상수들도 있습니다.
        
          보통 이런 상수들은 애플리케이션 전반에서 사용되기 때문에 public를 자주 사용합니다.
          물론 특정 위치에서만 사용된다면 다른 접근제어자를 사용하면 됩니다.
        
      
    
  
  상수는 중앙에서 값을 하나로 관리할 수 있다는 장점도 있습니다.
  상수는 런타임에 변경할 수 없습니다.
    
      상수를 변경하려면 프로그램을 종료하고, 코드를 변경한 다음에 프로그램을 다시 실행해야 합니다.
    
  


추가로 상수는 중앙에서 값을 하나로 관리할 수 있다는 장점도 있습니다.
다음 두 예제를 비교해봅시다.

ConstantMain1 - 상수 없음
package final1;

public class ConstantMain2 {

  public static void main(String[] args) {
    System.out.println("프로그램 최대 참여자 수 " + 1000);
    int currentUserCount = 999;
    process(currentUserCount++);
    process(currentUserCount++);
    process(currentUserCount++);
    process(currentUserCount++);
  }

  private static void process(int currentUserCount) {
    System.out.println("참여자 수:" + currentUserCount);
    if (currentUserCount &gt; 1000) {
      System.out.println("대기자로 등록합니다.");
    } else {
      System.out.println("게임에 참여합니다.");
    }
  }
}

이 코드에는 다음과 같은 문제가 있습니다.


  만약 프로그램 최대 참여자 수를 현재 1000명에서 2000명으로 변경해야 하면 2곳의 변경 포인트가 발생합니다.
    
      만약 애플리케이션의 100곳에서 이 숫자를 사용했다면 100곳을 모두 변경해야 합니다.
    
  
  매직 넘버 문제도 있습니다.


ConstatnMain2 - 상수 있음
package final1;

public class ConstantMain2 {

  public static void main(String[] args) {
    System.out.println("프로그램 최대 참여자 수 " + Constant.MAX_USERS);
    int currentUserCount = 999;
    process(currentUserCount++);
    process(currentUserCount++);
    process(currentUserCount++);
    process(currentUserCount++);
  }

  private static void process(int currentUserCount) {
    System.out.println("참여자 수:" + currentUserCount);
    if (currentUserCount &gt; Constant.MAX_USERS) {
      System.out.println("대기자로 등록합니다.");
    } else {
      System.out.println("게임에 참여합니다.");
    }
  }
}


  Constant.MAX_USERS 상수를 사용했습니다.
    
      만약 프로그램 최대 참여자 수를 변경해야 하면 Constant.MAX_USERS의 상수 값만 변경하면 됩니다.
    
  
  매직 넘버 문제를 해결했습니다.
    
      숫자 1000이 아니라 사람이 인지할 수 있게 MAX_USERS라는 변수명으로 코드를 이해할 수 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-07-finalVariableAndConstant1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-07-finalVariableAndConstant1.html"><h1 class="title_post">☕️[Java] final 변수와 상수 1</h1></a>
                        <a href="/2024/Java/2024-03-07-finalVariableAndConstant1.html" class="txt_post">
                            final 변수와 상수 1


  final 키워드는 이름 그대로 끝! 이라는 뜻 입니다.
  변수에 final 키워드가 붙으면 더는 값을 변경할 수 없습니다.



  참고로 final은 class, method를 포함한 여러곳에 붙을 수 있습니다.


final - 지역 변수
package final1;

public class FinalLocalMain {

  public static void main(String[] args) {
    // final 지역 변수1
    final int data1;
    data1 = 10; // 최초 한번만 할당 가능
    // data1 = 20; // 컴파일 오류

    // final 지역 변수2
    final int data2 = 10;
    // data2 = 20; // 컴파일 오류
    method(10);
  }

  static void method(final int parameter) {
    // parameter = 20; // 컴파일 오류
  }
}


  final 을 지역 변수에 설정할 경우 최초 한번만 할당할 수 있습니다.
    
      이후에 변수의 값을 변경하려면 컴파일 오류가 발생합니다.
    
  
  final을 지역 변수 선언시 바로 초기화 한 경우 이미 값이 할당되었기 때문에 값을 할당할 수 없습니다.
  매개변수에 final이 붙으면 메서드 내부에서 매개변수의 값을 변셩할 수 없습니다.
    
      따라서 메서드 호출 시점에 사용된 값이 끝까지 사용됩니다.
    
  


final - 필드(맴버변수)
package final1;

public class ConstructInit {

  final int value;

  public ConstructInit(int value) {
    this.value = value;
  }
}


  final 을 필드에 사용할 경우 해당 필드는 생성자를 통해서 한번만 초기화 될 수 있습니다.


package final1;

public class ConstructInit {

  final int value;

  public ConstructInit(int value) {
    this.value = value;
  }
}


  final 필드를 필드에서 초기화하면 이미 값이 설정되었기 때문에 생성자를 통해서도 초기화 할 수 없습니다.
    
      value 필드를 참고합시다.
    
  
  코드에서 보는 것 처럼 static 변수에도 final을 선언할 수 있습니다.
    
      CONSTANT_VALUE로 변수 작명 방법이 대문자를 사용하였습니다. 이것은 상수입니다.
    
  


package final1;

public class FinalFieldMain {

  public static void main(String[] args) {
    // final 필드 - 생성자 초기화
    System.out.println("생성자 초기화");
    ConstructInit constructInit1 = new ConstructInit(10);
    ConstructInit constructInit2 = new ConstructInit(20);
    System.out.println(constructInit1.value);
    System.out.println(constructInit2.value);

    // final 필드 - 필드 초기화
    System.out.println("필드 초기화");
    FieldInit fieldInit1 = new FieldInit();
    FieldInit fieldInit2 = new FieldInit();
    FieldInit fieldInit3 = new FieldInit();
    System.out.println(fieldInit1.value);
    System.out.println(fieldInit2.value);
    System.out.println(fieldInit3.value);
    
    // 상수
    System.out.println("싱수");
    System.out.println(FieldInit.CONST_VALUE);
  }
}


실행 결과
생성자 초기화
10
20
필드 초기화
10
10
10
싱수
10



  ConstructInit과 같이 생성자를 사용해서 final 필드를 초기화 하는 경우, 각 인스턴스마다 final 필드에 다른 값을 할당할 수 있습니다.
    
      물론 final을 사용했기 때문에 생성 이후에 이 값을 변경하는 것은 불가능합니다.
    
  





  FieldInit과 같이 final 필드를 필드에서 초기화 하는 경우, 모든 인스턴스가 위 그림의 오른쪽과 같이 같은 값을 가집니다.
    
      여기서는 FieldInit 인스턴스의 모든 value 값은 10이 됩니다.
        
          왜냐하면 생성자 초기화와 다르게 필드 초기화는 필드의 코드에 해당 값이 미리 정해져있기 때문입니다.
        
      
    
  
  모든 인스턴스가 같은 값을 사용하기 때문에 결과적으로 메모리를 낭비하게 됩니다.(물론 JVM에 따라서 내부 최적화를 시도할 수 있습니다.)
    
      또 메모리 낭비를 떠나서 같은 값이 계속 생성되는 것은 개발자가 보기에 명확한 중복입니다.
        
          이럴 때 사용하면 좋은 것이 바로 static 영역입니다.
        
      
    
  


static final

  FieldInit.MY_VALUE는 static 영역에 존재합니다.
    
      그리고 final 키워드를 사용해서 초기화 값이 변하지 않습니다
    
  
  static 영역은 단 하나만 존재하는 영역입니다.
    
      MY_VALUE 변수는 JVM 상에서 하나만 존재하므로 앞서 설명한 중복과 메모리 비효율 문제를 모두 해결할 수 있습니다.
    
  


이런 이유로 필드에 final + 필드 초기화를 사용하는 경우 static을 붙여서 사용하는 것이 효과적입니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-07-finalSummary.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-07-finalSummary.html"><h1 class="title_post">☕️[Java] final 정리</h1></a>
                        <a href="/2024/Java/2024-03-07-finalSummary.html" class="txt_post">
                            final 정리.

final은 매우 유용한 제약입니다.
만약 특정 변수의 값을 할당한 이후에 변경하지 않아야 한다면 final을 사용합시다.

  예를 들어서 고객의 id를 변경하면 큰 문제가 발생한다면 final로 선언하고 생성자로 값을 할당합시다.
    
      만약 어디선가 실수로 id 값을 변경한다면 컴파일러가 문제를 찾아줄 것입니다.
    
  


package final1.ex;

public class Member {

  private final String id; // final 키워드 사용
  private String name;

  public Member(String id, String name) {
    this.id = id;
    this.name = name;
  }

  public void changeData(String id, String name) {
//    this.id = id; // 컴파일 오류 발생
    this.name = name;
  }

  public void print() {
    System.out.println("id:" + id + ", name:" + name);
  }
}


  changeData() 메서드에서 final인 id 값 변경을 시도하면 컴파일 오류가 발생합니다.


package final1.ex;

public class MemberMain {

  public static void main(String[] args) {
    Member member = new Member("dev", "kobe");
    member.print();
    member.changeData("dev.skyachieve", "kang");
    member.print();
  }
}


실행 결과
id:dev, name:kobe
id:dev, name:kang


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CPP_DS/2024-03-07-stableAndUnstable.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cpp.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CPP_DS/2024-03-07-stableAndUnstable.html"><h1 class="title_post">🆙[Cpp DataStructure] 안정성(stability) 확인</h1></a>
                        <a href="/2024/CPP_DS/2024-03-07-stableAndUnstable.html" class="txt_post">
                            안정성(stability) 확인.

#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;fstream&gt;

using namespace std;

struct Element
{
	int key;
	char value;
};

void Print(Element* arr, int size)
{
	for (int i = 0; i &lt; size; i++)
		cout &lt;&lt; arr[i].key &lt;&lt; " ";
	cout &lt;&lt; endl;

	for (int i = 0; i &lt; size; i++)
		cout &lt;&lt; arr[i].value &lt;&lt; " ";
	cout &lt;&lt; endl;
}

int main()
{
    	// 안정성 확인(unstable)
	{
		Element arr[] = { {2, 'a'}, {2, 'b'}, {1, 'c' } };
		int size = sizeof(arr) / sizeof(arr[0]);

		Print(arr, size);

		int min_index;
		for(int i = 0; i &lt; (size - 1); i++) 
		{
			min_index = i;
			for (int j = (i + 1); j &lt; size; j++)
			{
				if (arr[j].key &lt; arr[min_index].key) 
				{
					min_index = j;
				}
			}

			swap(arr[i], arr[min_index]);

			Print(arr, size);
		}
	}
	return 0;
}


실행 결과
2 2 1 
a b c 
1 2 2 
c b a 
1 2 2 
c b a


정렬의 안정성(stablity)이라는 개념이 있습니다.

  이 개념은 stable한지 unstable한지로 구분합니다.
    
      즉, 안정적인지 불안정적인지로 구분합니다.
    
  


위 코드에서 보면 Element 배열을 정렬합니다.

이 Èlement를 보면 다음과 같습니다.
struct Element
{
	int key;
	char value;
};


  Element의 key는 정수이고 value는 문자입니다.
    
      그래서 정렬할 때 key를 기준으로 정렬합니다.
        
          그러면 swap시 value(문자)는 함께 따라갑니다. -&gt; 복사를 하니 따라가는 것 입니다.
        
      
    
  


Element arr[] = { {2, 'a'}, {2, 'b'}, {1, 'c' } };


  첫 번째 인덱스의 요소의 key는 2이고 value는 'a' 입니다.
  두 번째 인덱스의 요소의 key는 2이고 value는 'b' 입니다.
  세 번째 인덱스의 요소의 key는 1이고 value는 'c' 입니다.


“정렬시에는 key가 작은 순서대로 정렬되도록 할 것 입니다.”

  즉, key를 기준으로 정렬합니다.


여기서 주목해야 할 점은 “첫 번째 인덱스와 두 번째 인덱스의 요소의 Value”입니다.

  두 인덱스의 요소의 key 값은 같으나 value 값은 다릅니다.


비교 로직을 보면 key값을 가지고 비교를 하지만 swap 시에는 key와 value를 모두 가지고 움직입니다.

실행 결과를 보고 value와 안정성의 상관 관계에 대해 알아봅시다.

실행 결과
2 2 1 
a b c 
1 2 2 
c b a 
1 2 2 
c b a


  실행 결과를 보면 (2 a), (2, b), (1, c)에서 “(1, c), (2, b), (2, a)” 순으로 정렬된 것을 볼 수 있습니다.
    
      처음에는 (2 a), (2, b) 순서였지만 정렬 후에는 “(2, b), (2, a)” 로 순서가 바뀌어 정렬되었습니다.
        
          value가 뒤바뀐 것을 알 수 있습니다.
            
              key가 정렬이 되었으므로 정렬은 잘 되었다고 볼 수 있습니다.
              그러나 “key가 같은 값일 경우에는 value의 순서가 a, b에서 b, a 로 바뀌었습니다.”
                
                  “여기서 stable한 것과 unstable한 것의 차이점이 나타납니다.”
                
              
            
          
        
      
    
  


“키 값이 같아도 정렬시 벨류 값이 처음과 같이 유지가 된다면 그것은 stable하다라고 합니다, 그와 반대로 키 값이 같으나 처음과 달리 벨류의 순서가 바뀔 경우에는 unstable하다 라고 합니다.”

  이것도 정렬 알고리즘을 분류하는 기준 중 하나입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-07-finalVariableAndReference.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-07-finalVariableAndReference.html"><h1 class="title_post">☕️[Java] final 변수와 참조</h1></a>
                        <a href="/2024/Java/2024-03-07-finalVariableAndReference.html" class="txt_post">
                            final 변수와 참조.

final은 변수의 값을 변경하지 못하게 막습니다. 그런데 여기서 변수의 값이라는 것은 무엇일까요?

  변수는 크게 기본형 변수와 참조형 변수가 있습니다.
  기본형 변수는 10, 20 같은 값을 보관하고, 참조형 변수는 객체의 참조값을 보관합니다.
    
      final을 기본형 변수에 사용하면 값을 변경할 수 없습니다.
      final을 참조형 변수에 사용하면 참조값을 변경할 수 없습니다.
    
  


여기까지는 이해하는데 어려움이 없을 것입니다.

이번에는 약간 복잡한 예제를 만들어 봅시다.

package final1;

public class Data {
  public int value;
}


package final1;

public class FinalRefMain {

  public static void main(String[] args) {
   final Data data = new Data();
   //data = new Data(); // final 변경 불가 컴파일 오류

    // 참조 대상의 값은 변경 가능
    data.value = 10;
    System.out.println(data.value);
    data.value = 20;
    System.out.println(data.value);
  }
}


final Data data = new Data();
// data = new Data(); // final 변경 불가 컴파일 오류


  참조형 변수 data에 final이 붙었습니다.
    
      변수 선언 시점에 참조값을 할당했으므로 더는 참조값을 변경할 수 없습니다.
    
  


data.value = 10;
data.value = 20;


  그러나 참조 대상의 객체 값은 변경할 수 있습니다.
    
      참조형 변수 data에 final이 붙었습니다.
        
          이 경우 참조형 변수에 들어있는 참조값을 다른 값으로 변경하지 못합니다.
            
              쉽게 이야기해서 이제 다른 객체를 참조할 수 없습니다.
              그런데 이것의 정확한 뜻을 잘 이해해야 합니다.
                
                  참조값만 변경하지 못한다는 뜻입니다.
                    
                      이 변수 이외에 다른 곳에 영향을 주는 것이 아닙니다.
                    
                  
                
              
            
          
        
      
    
  
  Data.value는 final이 아닙니다.
    
      따라서 값을 변경할 수 있습니다.
    
  





  정리하면 참조형 변수에 final이 붙으면 참조 대상 자체를 다른 대상으로 변경하지 못하는 것이지, 참조하는 대상의 값은 변경할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-06-staticMethod3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-06-staticMethod3.html"><h1 class="title_post">☕️[Java] static 메서드 3</h1></a>
                        <a href="/2024/Java/2024-03-06-staticMethod3.html" class="txt_post">
                            static 메서드 3

용어 정리

멤버 메서드의 종류

  인스턴스 메서드: static이 붙지 않은 멤버 메서드
  클래스 메서드: static이 붙은 멤버 메서드
    
      클래스 메서드, 정적 메서드, static 메서드등으로 부릅니다.
    
  
  static이 붙지 않은 멤버 메서드는 인스턴스를 생성해야 사용할 수 있고, 인스턴스에 소속되어 있습니다.
    
      따라서 인스턴스 메서드라고 합니다.
    
  
  static이 붙은 멤버 메서드는 인스턴스와 무관하게 클래스에 바로 접근해서 사용할 수 있고, 클래스 자체에 소속되어 있습니다.
    
      따라서 클래스 메서드라고 합니다.
    
  



  참고로 방금 설명한 내용은 멤버 변수에도 똑같이 적용됩니다.


정적 메서드 활용

  정적 메서드는 객체 생성이 필요 없이 메서드의 호출만으로 필요한 기능을 수행할 때 주로 사용합니다.
    
      예를 들어 간단한 메서드 하나로 끝나는 유틸리티성 메서드에 자주 사용합니다.
      수학의 여러가지 기능을 담은 클래스를 만들 수 있는데, 이 경우 인스턴스 변수 없이 입력한 값을 계산하고 반환하는 것이 대부분입니다.
        
          이럴 때 정적 메서드를 사용해서 유틸리티성 메서드를 만들면 좋습니다.
        
      
    
  


정적 메서드 접근 법

  static 메서드는 static 변수와 마찬가지로 클래스를 통해 바로 접근할 수 있고, 인스턴스를 통해서도 접근할 수 있습니다.


DataCountMain - 추가
// 추가
// 인스턴스를 통한 접근
DecoData data3 = new DecoData();
data3.staticCall();

// 클래스를 통한 접근
DecoData.staticCall();


실행 결과 - 추가된 부분
staticValue=4
staticValue=5



  둘의 차이는 없습니다. 둘다 결과적으로 정적 메서드에 접근합니다.


인스턴스를 통한 접근 data3.staticCall()

  정적 메서드의 경우 인스턴스를 통한 접근은 추천하지 않습니다.
    
      왜냐하면 코드를 읽을 때 마치 인스턴스 메서드에 접근하는 것 처럼 오해할 수 있기 때문입니다.
    
  


클래스를 통한 접근 DecoData.staticCall()

  정적 메서드는 클래스에서 공용으로 관리하기 때문에 클래스를 통해서 접근하는 것이 더 명확합니다.
    
      따라서 정적 메서드에 접근할 때는 클래스를 통해서 접근합시다.
    
  


static import

  정적 메서드를 사용할 때 해당 메서드를 다음과 같이 자주 호출해야 한다면 static import 기능을 고려합시다.
    DecoData.staticCall();
DecoData.staticCall();
DecoData.staticCall();
    
  
  이 기능을 사용하면 다음과 같이 클래스명을 생략하고 메서드를 호출할 수 있습니다.
    staticCall();
staticCall();
staticCall();
    
  


DecoDataMain - static import 적용
package static2;

// import static static2.DecoData.staticCall;
import static static2.DecoData.*;

public class DecoDataMain {
    
    public static void main(String[] args) {
        System.out.println("1.정적 호출");
        staticCall(); // 클래스 명 생략 가능
        ...
    }
}



  특정 클래스의 정적 메서드 하나만 적용하려면 다음과 같이 생략할 메서드 명을 적어주면 됩니다.
    import static static2.DecoData.staticCall;
    
  
  특정 클래스의 모든 정적 메서드에 적용하려면 다음과 같이 *을 사용하면 됩니다.
    import static static2.DecoData.*;
    
  



  참고로 import static은 정적 메서드 뿐만 아니라 정적 변수에도 사용할 수 있습니다.


main() 메서드는 정적 메서드

  인스턴스 생성 없이 실행하는 가장 대표적인 메서드가 바로 main() 메서드입니다.
    
      main() 메서드는 프로그램을 시작하는 시작점이 되는데, 생각해보면 객체를 생성하지 않아도 main() 메서드가 작동했습니다.
        
          이것은 main() 메서드가 static이기 때문입니다.
        
      
    
  
  정적 메서드는 정적 메서드만 호출할 수 있습니다.
    
      따라서 정적 메서드인 main()이 호출하는 메서드에는 정적 메서드를 사용했습니다.
        
          물론 더 정확히 말하자면 정적 메서드는 같은 클래스 내부에서 정적 메서드만 호출할 수 있습니다.
            
              따라서 정적 메서드인 main() 메서드가 같은 클래스에서 호출하는 메서드도 정적 메서드로 선언해서 사용했습니다.
            
          
        
      
    
  


main() 메서드와 static 메서드 호출 예
public class ValueDataMain {
    
    public static void main(String[] args) {
        ValueData valueData = new ValueData();
        add(valueData);
    }
    
    static void add(ValueData valueData) {
        valueData value++;
        System.out.println("숫자 증가 value=" + valueData.value);
    }
}


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-05-staticMethod1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-05-staticMethod1.html"><h1 class="title_post">☕️[Java] static 메서드 1</h1></a>
                        <a href="/2024/Java/2024-03-05-staticMethod1.html" class="txt_post">
                            static 메서드 1
이번에는 static이 붙은 메서드에 대해 알아보겠습니다.
이해를 돕기 위해 간단한 예제를 만들어보겠습니다.

특정 문자열을 꾸며주는 간단한 기능을 만들어보겠습니다.
예를 들어서 "hello"라는 문자를 꾸미면 앞 뒤에 *을 붙여서 *hello*와 같이 꾸며주는 기능입니다.

인스턴스 메서드

DecoUtil1
package static2;

public class DecoUtil1 {

  public String deco(String str) {
    String result = "*" + str + "*"
    return result;
  }
}


  deco()는 문자열을 꾸미는 기능을 제공합니다.
    
      문자열이 들어오면 앞 뒤에 *을 붙여서 반환합니다.
    
  


DecoMain1
package static2;

public class DecoMain1 {

  public static void main(String[] args) {
    String s = "hello java";
    DecoUtil1 utils = new DecoUtil1();
    String deco = utils.deco(s);

    System.out.println("before: " + s);
    System.out.println("after: " + deco);
  }
}


실행 결과
before: hello java
after: *hello java*



  앞서 개발한 deco() 메서드를 호출하기 위해서는 DecoUtil1의 인스턴스를 먼저 생성해야 합니다.
    
      그런데 deco() 라는 기능은 멤버 변수도 없고, 단순히 기능만 제공할 뿐입니다.
        
          인스턴스가 필요한 이유는 멤버 변수(인스턴스 변수)등을 사용하는 목적이 큰데, 이 메서드는 사용하는 인스턴스 변수도 없고 단순히 기능만 제공합니다.
        
      
    
  


static 메서드
먼저 예제를 만들어서 실행해봅시다.

DecoUtil2
package static2;

public class DecoUtil2 {

  public static String deco(String str) {
    String result = "*" + str + "*";
    return result;
  }
}



  DecoUtil2는 앞선 예제와 비슷합니다.
    
      하지만 메서드 앞에 static이 붙어있습니다. 이 부분에 주의합시다.
        
          이렇게 하면 정적 메서드를 만들 수 있습니다.
            
              그리고 이 정적 메서드는 정적 변수처럼 인스턴스 생성 없이 클래스 명을 통해서 바로 호출할 수 있습니다.
            
          
        
      
    
  


DecoMain2
package static2;

public class DecoMain2 {

  public static void main(String[] args) {
    String s = "hello java";
    String deco = DecoUtil2.deco(s);

    System.out.println("before: " + s);
    System.out.println("after: " + deco);
  }
}


실행 결과
before: hello java
after: *hello java*



  DecoUtil2.deco(s); 코드를 봅시다.
    
      static이 붙은 정적 메서드는 객체 생성 없이 클래스명 + .(dot) + 메서드 명으로 바로 호출할 수 있습니다.
        
          정적 메서드 덕분에 불필요한 객체 생성 없이 편리하게 메서드를 사용했습니다.
        
      
    
  


클래스 메서드

  메서드 앞에서 static을 붙일 수 있습니다.
    
      이것을 정적 메서드 또는 클래스 메서드라 합니다.
        
          정적 메서드라는 용어는 static이 정적이라는 뜻이기 때문입니다.
          클래스 메서드라는 용어는 인스턴스 생성 없이 마치 클래스에 있는 메서드를 바로 호출하는 것 처럼 느껴지기 때문입니다.
        
      
    
  


인스턴스 메서드

  static이 붙지 않은 메서드는 인스턴스를 생성해야 호출할 수 있습니다.
    
      이것을 인스턴스 메서드라 합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-05-staticVariable3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-05-staticVariable3.html"><h1 class="title_post">☕️[Java] static 변수3</h1></a>
                        <a href="/2024/Java/2024-03-05-staticVariable3.html" class="txt_post">
                            static 변수 3

이번에는 static 변수를 정리해보겠습니다.

용어 정리
public class Data3 {
    public String name;
    public static int count; // static
}



  예제 코드에서 name, count는 둘 다 멤버 변수입니다.


멤버 변수(필드)는 static이 붙은 것과 아닌 것에 따라 다음과 같이 분류 할 수 있습니다.

멤버 변수(필드)의 종류.

  인스턴스 변수: static이 붙지 않은 멤버 변수, 예) name
    
      static 이 붙지 않은 멤버 변수는 인스턴스를 생성해야 사용할 수 있고, 인스턴스에 소속되어 있습니다.
        
          따라서 인스턴스 변수라 합니다.
        
      
      인스턴스 변수는 인스턴스를 만들 때 마다 새로 만들어집니다.
    
  
  클래스 변수: static이 붙은 멤버 변수, 예) count
    
      클래스 변수, 정적 변수, static 변수등으로 부릅니다. 용어를 모두 사용하니 주의합시다.
      static이 붙은 멤버 변수는 인스턴스와 무관하게 클래스에 바로 접근해서 사용할 수 있고, 클래스 자체에 소속되어 있습니다.
        
          따라서 클래스 변수라 합니다.
        
      
      클래스 변수는 자바 프로그램을 시작할 때 딱 1개가 만들어집니다.
        
          인스턴스와는 다른게 보통 여러곳에서 공유하는 목적으로 사용됩니다.
        
      
    
  


변수와 생명주기

  지역 변수(매개변수 포함): 지역 변수는 스택 영역에 있는 스택 프레임 안에 보관됩니다. 메서드가 종료되면 스택 프레임도 제거 되는데 이때 해당 스택 프레임에 포함된 지역 변수도 함께 제거됩니다.
    
      따라서 지역 변수는 생존 주기가 짧습니다.
    
  
  인스턴스 변수: 인스턴스에 있는 멤버 변수를 인스턴스 변수라 합니다. 인스턴스 변수는 힙 영역을 사용합니다.
    
      힙 영역은 GC(가비지 컬렉션)가 발생하기 전까지 생존하기 때문에 보통 지역 변수보다 생존 주기가 깁니다.
    
  
  클래스 변수: 클래스 변수는 메서드 영역의 static 영역에 보관 되는 변수입니다.
    
      메서드 영역은 프로그램 전체에서 사용하는 공용 공간입니다.
      클래스 변수는 해당 클래스가 JVM에 로딩 되는 순간 생성됩니다.
        
          그리고 JVM이 종료될 때까지 생명주기가 이어집니다.
            
              따라서 가장 긴 생명주기를 가집니다.
            
          
        
      
    
  


static이 정적이라는 이유는 바로 여기에 있습니다.
힙 역역에 생성되는 인스턴스 변수는 동적으로 생성되고, 제거됩니다.
반면에 static인 정적 변수는 거의 프로그램 실행 시점에 딱 만들어지고, 프로그램 종료 시점에 제거됩니다.
정적 변수는 이름 그대로 정적입니다.

정적 변수 접근 법
static 변수는 클래스를 통해 바로 접근할 수도 있고, 인스턴스를 통해서도 접근할 수 있습니다.
DataCountMain3 마지막 코드에 다음 부분을 추가하고 실행해보겠습니다.

DataCountMain3 - 추가
// 추가
// 인스턴스를 통한 접근
Data3 data4 = new Data3("D");

// 클래스를 통합 접근
System.out.println(Data3.count);


실행 결과 - 추가된 부분
4
4


  둘 다 차이는 없습니다. 둘다 결과적으로 정적 변수에 접근합니다.


인스턴스를 통한 접근 data4.count

  정적 변수의 경우 인스턴스를 통한 접근은 추천하지 않습니다.
    
      왜냐하면 코드를 읽을 때 마치 인스턴스 변수에 접근하는 것 처럼 오해할 수 있기 때문입니다.
    
  


클래스를 통한 접근 Data3.count

  정적 변수는 클래스에서 공용으로 관리하기 때문에 클래스를 통해서 접근하는 것이 더 명확합니다.
    
      따라서 정적 변수에 접근할 때는 클래스를 통해서 접근합시다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-05-staticVariable2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-05-staticVariable2.html"><h1 class="title_post">☕️[Java] static 변수2</h1></a>
                        <a href="/2024/Java/2024-03-05-staticVariable2.html" class="txt_post">
                            static 변수 2

static 변수 사용

특정 클래스에서 공용으로 함께 사용할 수 있는 변수를 만들 수 있다면 편리할 것입니다.

  static 키워드를 사용하면 공용으로 함께 사용하는 변수를 만들 수 있습니다


Data3
package static1;

public class Data3 {
  public String name;
  public static int count; // static

  public Data3(String name) {
    this.name = name;
    count++;
  }
}



  기존 코드를 유지하기 위해 새로운 클래스 Data3을 만들었습니다.
  static int count 부분을 봐봅시다.
    
      변수 타입(int) 앞에 static 키워드가 붙어있습니다.
    
  
  이렇게 멤버 변수에 static을 붙이게 되면 static 변수, 정적 변수 또는 클래스 변수라 합니다.
  객체가 생성되면 생성자에서 정적 변수 count의 값을 하나 증가시킵니다.


DataCountMain3
package static1;

public class DataCountMain3 {

  public static void main(String[] args) {
    Data3 data1 = new Data3("A");
    System.out.println("A coutn=" + Data3.count);

    Data3 data2 = new Data3("B");
    System.out.println("B coutn=" + Data3.count);

    Data3 data3 = new Data3("C");
    System.out.println("C coutn=" + Data3.count);
  }
}



  코드를 보면 count 정적 변수에 접근하는 방법이 조금 특이한데 Data3.count 와 같이 클래스명에 .(dot)을 사용합니다.
    
      마치 클래스에 직접 접근하는 것 처럼 느껴집니다.
    
  


실행 결과
A coutn=1
B coutn=2
C coutn=3



  static 이 붙은 멤버 변수는 메서드 영역에서 관리합니다.
    
      static 이 붙은 멤버 변수 count는 인스턴스 영역에 생성되지 않습니다. 대신 메서드 영역에서 이 변수를 관리합니다.
    
  
  Data3("A") 인스턴스를 생성하면 생성자가 호출됩니다.
  생성자에는 count++ 코드가 있습니다. count는 static이 붙은 정적 변수입니다. 정적 변수는 인스턴스 영역이 아니라 메서드 영역에서 관리합니다. 따라서 이 경우 메서드 영역에 있는 count의 값이 하나 증가됩니다.
  Data3("B") 인스턴스를 생성하면 생성자가 호출됩니다.
  count++ 코드가 있습니다.
    
      count는 static이 붙은 정적 변수입니다
      메서드 영역에 있는 count 변수의 값이 하나 증가됩니다.
    
  
  Data3("C") 인스턴스를 생성하면 생성자가 호출됩니다.
  count++ 코드가 있습니다. count는 static이 붙은 정적 변수입니다.
    
      메서드 영역에 있는 count 변수의 값이 하나 증가됩니다.
    
  


최종적으로 메서드 영역에 있는 count 변수의 값은 3이 됩니다.

  static이 붙은 정적 변수에 접근하려면 Data3.count와 같이 클래스명 + .(dot) + 변수명으로 접근하면 됩니다.



  참고로 Data3의 생성자와 같이 자신의 클래스에 있는 정적 변수라면 클래스 명을 생략할 수 있습니다.


static 변수를 사용한 덕분에 공용 변수를 사용해서 편리하게 문제를 해결할 수 있었습니다.

정리

  static 변수는 쉽게 이야기해서 클래스인 붕어빵 틀이 특별히 관리하는 변수입니다.
  붕어빨 틀은 1개이므로 클래스 변수도 하나만 존재합니다.
  반면에 인스턴스인 붕어빵은 인스턴스의 수 만큼 변수가 존재합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-05-staticMethod2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-05-staticMethod2.html"><h1 class="title_post">☕️[Java] static 메서드 2</h1></a>
                        <a href="/2024/Java/2024-03-05-staticMethod2.html" class="txt_post">
                            static 메서드 2

정적 메서드는 객체 생성없이 클래스에 있는 메서드를 바로 호출할 수 있다는 장점이 있습니다.
하지만 정적 메서드는 언제나 사용할 수 있는 것이 아닙니다.

정적 메서드 사용법

  static 메서드는 static만 사용할 수 있습니다.
    
      클래스 내부의 기능을 사용할 때, 정적 메서드는 static이 붙은 정적 메서드나 정적 변수만 사용할 수 있습니다.
      클래스 내부의 기능을 사용할 때, 정적 메서드는 인스턴스 변수나, 인스턴스 메서드를 사용할 수 없습니다.
    
  
  반대로 모든 곳에서 static을 호출할 수 있습니다.
    
      정적 메서드는 공용 기능입니다.
        
          따라서 접근 제어자만 허락한다면 클래스를 통해 모든 곳에서 static을 호출할 수 있습니다.
        
      
    
  


예제를 통해 정적 메서드의 사용법을 확인해봅시다.

DecoData
package static2;

public class DecoData {

  private int instanceValue;
  private static int staticValue;

  public static void staticCall() {
    //instanceValue++; // 인스턴스 변수 접근, compile error
    //instanceMethod(); // 인스턴스 메서드 접근, compile error

    staticValue++; // 정적 변수 접근
    staticMethod(); // 정적 메서드 접근
  }

  public void instanceCall() {
    instanceValue++; // 인스턴스 변수 접근
    instanceMethod(); // 인스턴스 메서드 접근

    staticValue++; // 정적 변수 접근
    staticMethod(); // 정적 메서드 접근
  }

  private void instanceMethod() {
    System.out.println("instanceValue=" + instanceValue);
  }

  private static void staticMethod() {
    System.out.println("staticValue=" + staticValue);
  }
}


이번 예제에서는 접근 제어자를 적극 활용해서 필드를 포함한 외부에서 직접 필요하지 않은 기능은 모두 막아두었습니다.


  instanceValue는 인스턴스 변수입니다.
  staticValue는 정적 변수(클래스 변수)입니다.
  instanceMethod()는 인스턴스 메서드입니다.
  staticMethod()는 정적 메서드(클래스 메서드)입니다.


staticCall() 메서드를 봐봅시다.

  이 메서드는 정적 메서드입니다.
    
      따라서 static 만 사용할 수 있습니다.
      정적 변수, 정적 메서드에는 접근할 수 있지만, static이 없는 인스턴스 변수나 인스턴스 메서드에 접근하면 컴파일 오류가 발생합니다.
      코드를 보면 staticCall() -&gt; staticMethod()로 static에서 static을 호출하는 것을 확인할 수 있습니다.
    
  


instanceCall() 메서드를 봐봅시다.

  이 메서드는 인스턴스 메서드입니다.
    
      모든 곳에서 공용인 static을 호출할 수 있습니다.
        
          따라서 정적 변수, 정적 메서드에 접근할 수 있습니다.
          물론 인스턴스 변수, 인스턴스 메서드에도 접근할 수 있습니다.
        
      
    
  


DecoDataMain
package static2;

public class DecoDataMain {

  public static void main(String[] args) {
    System.out.println("1. 정적 호출");
    DecoData.staticCall();

    System.out.println("2. 인스턴스 호출1");
    DecoData data1 = new DecoData();
    data1.instanceCall();

    System.out.println("3. 인스턴스 호출2");
    DecoData data2 = new DecoData();
    data2.instanceCall();
  }
}


실행 결과
1. 정적 호출
staticValue=1
2. 인스턴스 호출1
instanceValue=1
staticValue=2
3. 인스턴스 호출2
instanceValue=1
staticValue=3




정적 메서드가 인스턴스의 기능을 사용할 수 없는 이유

  정적 메서드는 클래스의 이름을 통해 바로 호출할 수 있습니다.
    
      그래서 인스턴스처럼 참조값의 개념이 없습니다.
        
          특정 인스턴스의 기능을 사용하려면 참조값을 알아야 하는데, 정적 메서드는 참조값 없이 호출합니다.
            
              따라서 정적 메서드 내부에서 인스턴스 변수나 인스턴스 메서드를 사용할 수 없습니다.
            
          
        
      
    
  


물론 당연한 이야기지만 다음과 같이 객체의 참조값을 직접 매개변수로 전달하면 정적 메서드도 인스턴스의 변수나 메서드를 호출할 수 있습니다.
public static void staticCall(DecoData data) {
    data.instanceValue++;
    data.instanceMethod();
}


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-04-static1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-04-static1.html"><h1 class="title_post">☕️[Java] static 변수1</h1></a>
                        <a href="/2024/Java/2024-03-04-static1.html" class="txt_post">
                            static 변수 1

sttic 키워드는 주로 멤버 변수와 메서드에 사용됩니다.
먼저 멤버 변수에 static 키워드가 왜 필요한지 이해하기 위해 간단한 예제를 만들어봅시다.

특정 클래스를 통해서 생성된 객체의 수를 세는 단순한 프로그램입니다.

인스턴스 내부 변수에 카운트 저장

먼저 생성할 인스턴스 내부에 카운트를 저장하겠습니다.

Data1
package static1;

public class Data1 {
  public String name;
  public int count;

  public Data1(String name) {
    this.name = name;
    count++;
  }
}



  생성된 객체의 수를 세어야 합니다.
    
      따라서 객체가 생성될 때 마다 생성자를 통해 인스턴스의 멤버 변수인 count 값을 증가시킵니다.
    
  



  참고로 예제를 단순하게 만들기 위해 필드에 public을 사용했습니다.


DataCountMain1
package static1;

public class DataCountMain1 {

  public static void main(String[] args) {
    Data1 data1 = new Data1("A");
    System.out.println("A count=" + data1.count);

    Data1 data2 = new Data1("B");
    System.out.println("B count=" + data2.count);

    Data1 data3 = new Data1("C");
    System.out.println("C count=" + data3.count);
  }
}


  객체를 생성하고 카운트 값을 출력합니다.


실행 결과
A count=1
B count=1
C count=1


  이 프로그램은 당연히 기대한 대로 작동하지 않습니다.
    
      객체를 생성할 때 마다 Data1 인스턴스는 새로 만들어집니다.
      그리고 인스턴스에 포함된 count 변수도 새로 만들어지기 때문입니다.
    
  
  처음 Data1("A") 인스턴스를 생성하면 count 값은 0으로 초기화 됩니다.
    
      생성자에서 count++을 호출했으므로 count의 값은 1이 됩니다.
    
  
  다음으로 Data1("B") 인스턴스를 생성하면 완전 새로운 인스턴스를 생성합니다.
    
      이 새로운 인스턴스의 count 값은 0으로 초기화됩니다.
      생성자에서 count++을 호출했으므로 count의 값은 1이 됩니다.
    
  
  다음으로 Data1("C") 인스턴스를 생성하면 이전 인스턴스는 관계없는 새로운 인스턴스를 생성합니다.
    
      이 새로운 인스턴스의 count 값은 0으로 초기화 됩니다.
      생성자에서 count++을 호출했으므로 count의 값은 1이 됩니다.
    
  
  “인스턴스에 사용되는 멤버 변수 count값은 인스턴스끼리 서로 공유되지 않습니다.”
    
      따라서 원하는 답을 구할 수 없습니다.
        
          이 문제를 해결하려면 변수를 서로 공유해야 합니다.
        
      
    
  


외부 인스턴스에 카운트 저장
이번에는 카운트 값을 저장하는 별도의 객체를 만들어보겠습니다.

Counter
package static1;

public class Counter {
  public int count;
}


Data2
package static1;

public class Data2 {
  public String name;

  public Data2(String name, Counter counter) {
    this.name = name;
    counter.count++;
  }
}


DataCountMain2
package static1;

public class DataCountMain2 {

  public static void main(String[] args) {
    Counter counter = new Counter();
    Data2 data1 = new Data2("A", counter);
    System.out.println("A count=" + counter.count);

    Data2 data2 = new Data2("B", counter);
    System.out.println("B count=" + counter.count);

    Data2 data3 = new Data2("C", counter);
    System.out.println("C count=" + counter.count);
  }
}


실행 결과
A count=1
B count=2
C count=3



  Counter 인스턴스를 공용으로 사용한 덕분에 객체를 생성할 때 마다 값을 정확하게 증가시킬 수 있습니다.
  Data2("A") 인스턴스를 생성하면 생성자를 통해 Counter 인스턴스에 있는 count 값을 하나 증가시킵니다.
    
      count 값은 1이 됩니다.
    
  
  Data2("B") 인스턴스를 생성하면 생성자를 통해 Counter 인스턴스에 있는 count 값을 하나 증가시킵니다.
    
      count 값은 2가 됩니다.
    
  
  Data2("C") 인스턴스를 생성하면 생성자를 통해 Counter 인스턴스에 있는 count 값을 하나 증가시킵니다.
    
      count 값은 3이 됩니다.
    
  
  결과적으로 Data2의 인스턴스가 3개 생성되고, count 값도 인스턴스 숫자와 같은 3으로 정확하게 측정됩니다.
    
      그런데 여기에는 약간 불편한 점들이 있습니다.
        
          Data2 클래스와 관련된 일인데, Counter라는 별도의 클래스를 추가로 사용해야 합니다.
          생성자의 매개변수도 추가되고, 생성자가 복잡해집니다. 생성자를 호출하는 부분도 복잡해집니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-04-staticVariable1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-04-staticVariable1.html"><h1 class="title_post">☕️[Java] static 변수1</h1></a>
                        <a href="/2024/Java/2024-03-04-staticVariable1.html" class="txt_post">
                            static 변수 1

sttic 키워드는 주로 멤버 변수와 메서드에 사용됩니다.
먼저 멤버 변수에 static 키워드가 왜 필요한지 이해하기 위해 간단한 예제를 만들어봅시다.

특정 클래스를 통해서 생성된 객체의 수를 세는 단순한 프로그램입니다.

인스턴스 내부 변수에 카운트 저장

먼저 생성할 인스턴스 내부에 카운트를 저장하겠습니다.

Data1
package static1;

public class Data1 {
  public String name;
  public int count;

  public Data1(String name) {
    this.name = name;
    count++;
  }
}



  생성된 객체의 수를 세어야 합니다.
    
      따라서 객체가 생성될 때 마다 생성자를 통해 인스턴스의 멤버 변수인 count 값을 증가시킵니다.
    
  



  참고로 예제를 단순하게 만들기 위해 필드에 public을 사용했습니다.


DataCountMain1
package static1;

public class DataCountMain1 {

  public static void main(String[] args) {
    Data1 data1 = new Data1("A");
    System.out.println("A count=" + data1.count);

    Data1 data2 = new Data1("B");
    System.out.println("B count=" + data2.count);

    Data1 data3 = new Data1("C");
    System.out.println("C count=" + data3.count);
  }
}


  객체를 생성하고 카운트 값을 출력합니다.


실행 결과
A count=1
B count=1
C count=1


  이 프로그램은 당연히 기대한 대로 작동하지 않습니다.
    
      객체를 생성할 때 마다 Data1 인스턴스는 새로 만들어집니다.
      그리고 인스턴스에 포함된 count 변수도 새로 만들어지기 때문입니다.
    
  
  처음 Data1("A") 인스턴스를 생성하면 count 값은 0으로 초기화 됩니다.
    
      생성자에서 count++을 호출했으므로 count의 값은 1이 됩니다.
    
  
  다음으로 Data1("B") 인스턴스를 생성하면 완전 새로운 인스턴스를 생성합니다.
    
      이 새로운 인스턴스의 count 값은 0으로 초기화됩니다.
      생성자에서 count++을 호출했으므로 count의 값은 1이 됩니다.
    
  
  다음으로 Data1("C") 인스턴스를 생성하면 이전 인스턴스는 관계없는 새로운 인스턴스를 생성합니다.
    
      이 새로운 인스턴스의 count 값은 0으로 초기화 됩니다.
      생성자에서 count++을 호출했으므로 count의 값은 1이 됩니다.
    
  
  “인스턴스에 사용되는 멤버 변수 count값은 인스턴스끼리 서로 공유되지 않습니다.”
    
      따라서 원하는 답을 구할 수 없습니다.
        
          이 문제를 해결하려면 변수를 서로 공유해야 합니다.
        
      
    
  


외부 인스턴스에 카운트 저장
이번에는 카운트 값을 저장하는 별도의 객체를 만들어보겠습니다.

Counter
package static1;

public class Counter {
  public int count;
}


Data2
package static1;

public class Data2 {
  public String name;

  public Data2(String name, Counter counter) {
    this.name = name;
    counter.count++;
  }
}


DataCountMain2
package static1;

public class DataCountMain2 {

  public static void main(String[] args) {
    Counter counter = new Counter();
    Data2 data1 = new Data2("A", counter);
    System.out.println("A count=" + counter.count);

    Data2 data2 = new Data2("B", counter);
    System.out.println("B count=" + counter.count);

    Data2 data3 = new Data2("C", counter);
    System.out.println("C count=" + counter.count);
  }
}


실행 결과
A count=1
B count=2
C count=3



  Counter 인스턴스를 공용으로 사용한 덕분에 객체를 생성할 때 마다 값을 정확하게 증가시킬 수 있습니다.
  Data2("A") 인스턴스를 생성하면 생성자를 통해 Counter 인스턴스에 있는 count 값을 하나 증가시킵니다.
    
      count 값은 1이 됩니다.
    
  
  Data2("B") 인스턴스를 생성하면 생성자를 통해 Counter 인스턴스에 있는 count 값을 하나 증가시킵니다.
    
      count 값은 2가 됩니다.
    
  
  Data2("C") 인스턴스를 생성하면 생성자를 통해 Counter 인스턴스에 있는 count 값을 하나 증가시킵니다.
    
      count 값은 3이 됩니다.
    
  
  결과적으로 Data2의 인스턴스가 3개 생성되고, count 값도 인스턴스 숫자와 같은 3으로 정확하게 측정됩니다.
    
      그런데 여기에는 약간 불편한 점들이 있습니다.
        
          Data2 클래스와 관련된 일인데, Counter라는 별도의 클래스를 추가로 사용해야 합니다.
          생성자의 매개변수도 추가되고, 생성자가 복잡해집니다. 생성자를 호출하는 부분도 복잡해집니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-03-StackAndQueue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-03-StackAndQueue.html"><h1 class="title_post">☕️[Java] 스택과 큐 자료구조</h1></a>
                        <a href="/2024/Java/2024-03-03-StackAndQueue.html" class="txt_post">
                            스택과 큐 자료구조.

자바 메모리 구조 중 스택 영역에 대해 알아보기 전에 먼저 스택(Stack)이라는 자료 구조에 대해서 알아봅시다.

스택 구조
다음과 같은 1, 2, 3 이름표가 붙은 블럭이 있다고 가정해봅시다.




  이 블럭을 다음과 같이 생긴 통에 넣는다고 생각해봅시다.
    
      위쪽만 열려있기 때문에 위쪽으로 블럭을 넣고, 위쪽으로 블럭을 빼야 합니다.
        
          쉽게 이야기해서 넣는 곳과 빼는 곳이 같습니다.
        
      
    
  





  블럭은 1 -&gt; 2 -&gt; 3 순서대로 넣을 수 있습니다.


이번에는 넣은 블럭을 빼봅시다.




  블럭을 빼려면 위에서 부터 순서대로 빼야합니다.
    
      블럭은 3 -&gt; 2 -&gt; 1 순서로 뺄 수 있습니다.
    
  


정리하면 다음과 같습니다.

  1(넣기) -&gt; 2(넣기) -&gt; 3(넣기) -&gt; 3(빼기) -&gt; 2(빼기) -&gt; 1(빼기)


후입 선출(LIFO, Last In First Out)
여기서 가장 마지막에 넣은 3번이 가장 먼저 나옵니다.

  이렇게 가장 먼저 나오는 것을 “후입 선출”이라 하고, 이런 자료 구조를 “스택”이라 합니다.


선입 선출(FIFO, First In First Out)

  후입 선출과 반대로 가장 먼저 넣은 것이 가장 먼저 나오는 것을 선입 선출이라고 합니다.
    
      이런 자료 구조를 “큐(Queue)”라 합니다.
    
  


큐(Queue) 자료 구조


정리하면 다음과 같습니다.

  1(넣기) -&gt; 2(넣기) -&gt; 3(넣기) -&gt; 1(빼기) -&gt; 2(빼기) -&gt; 3(빼기)
    
      이런 자료 구조는 각자 필요한 영역이 있습니다.
        
          예를 들어 선착순 이벤트를 하는데 고객이 대기해야 한다면 큐 자료 구조를 사용해야 합니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-03-StackAndHeap.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-03-StackAndHeap.html"><h1 class="title_post">☕️[Java] 스택 영역과 힙 영역</h1></a>
                        <a href="/2024/Java/2024-03-03-StackAndHeap.html" class="txt_post">
                            스택 영역과 힙 영역.
이번에는 스택 영역과 힙 영역이 함께 사용되는 경우를 알아봅시다.

Data
package memory;

public class JavaMemoryMain2 {

  public static void main(String[] args) {
    System.out.println("main start");
    method1();
    System.out.println("main end");
  }

  static void method1() {
    System.out.println("method1 start");
    Data data1 = new Data(10);
    method2(data1);
    System.out.println("method1 end");
  }

  static void method2(Data data2) {
    System.out.println("method2 start");
    System.out.println("data.value=" + data2.getValue());
    System.out.println("method2 end");
  }
}



  main() -&gt; method1() -&gt; method2() 순서로 호출하는 단순한 코드입니다.
  method1()에서 Data 클래스의 인스턴스를 생성합니다.
  method1()에서 method2()를 호출할 때 매개변수에 Data 인스턴스의 참조값을 전달합니다.


실행 결과
main start
method1 start
method2 start
data.value=10
method2 end
method1 end
main end


그림을 통해 순서대로 알아봅시다.




  처음 main() 메서드를 실행합니다.
    
      main() 스택 프레임이 생성됩니다.
    
  





  main()에서 method1()을 실행합니다.
    
      method1() 스택 프레임이 생성됩니다.
    
  
  method1()은 지역 변수로 Data data1을 가지고 있습니다.
    
      이 지역 변수도 스택 프레임에 포함됩니다.
    
  
  method1()은 new Data(10)를 사용해서 힙 영역에 Data 인스턴스를 생성합니다.
    
      그리고 참조값을 data1에 보관합니다.
    
  





  method1()은 method2()를 호출하면서 Data data2 매개변수에 xoo1 참조값을 넘깁니다.
    
      이제 method1()에 있는 data1과 method2()에 있는 data2 지역 변수(매개변수 포함)는 둘다 같은 x001 인스턴스를 참조합니다.
    
  





  method2()가 종료됩니다.
    
      method2()의 스택 프레임이 제거되면서 매개변수 data2도 함께 제거됩니다.
    
  





  method1()1이 종료됩니다.
    
      method1()의 스택 프레임이 제거되면서 지역 변수 data1도 함께 제거됩니다.
    
  





  method1()이 종료된 직후의 상태를 봅시다.
    
      method1()의 스택 프레임이 제거되고 지역 변수 data1도 함께 제거되었습니다.
    
  
  이제 x001 참조값을 가진 Data 인스턴스를 참조하는 곳이 더는 없습니다.
    
      참조하는 곳이 없으므로 사용되는 곳도 없습니다.
        
          결과적으로 프로그램에서 더는 사용하지 않는 객체인 것입니다.
            
              이런 객체는 메모리만 차지하게 됩니다.
                
                  GC(가비지 컬렉션)은 이렇게 참조가 모두 사라진 인스턴스를 찾아서 메모리에서 제거합니다.
                
              
            
          
        
      
    
  



  참고: 힙 영역 외부가 아닌, 힙 영역 안에서만 인스턴스끼리 서로 참조하는 경우에도 GC의 대상이 됩니다.


정리

  지역 변수는 스택 영역에, 객체(인스턴스)는 힙 영역에 관리되는 것을 확인했습니다.
    
      이제 나머지 하나가 남았습니다. 바로 메서드 영역입니다.
        
          메서드 영역이 관리하는 변수도 있습니다.
            
              이것을 이해하기 위해서는 먼저 static 키워드를 알아야합니다.
                
                  static 키워드는 메서드 영역과 밀접한 연관이 있습니다.
                
              
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-03-Stack.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-03-Stack.html"><h1 class="title_post">☕️[Java] 스택 영역</h1></a>
                        <a href="/2024/Java/2024-03-03-Stack.html" class="txt_post">
                            스택 영역.
다음 코드를 실행하면 스택 영역에서 어떤 변화가 있는지 확인해봅시다.

JavaMemoryMain1
package memory;

public class JavaMemoryMain1 {

  public static void main(String[] args) {
    System.out.println("main start");
    method1(10);
    System.out.println("main end");

  }

  static void method1(int m1) {
    System.out.println("method1 start");
    int cal = m1 * 2;
    method2(cal);
    System.out.println("method1 end");
  }

  static void method2(int m2) {
    System.out.println("method2 start");
    System.out.println("method2 end");
  }
}


실행 결과
main start
method1 start
method2 start
method2 end
method1 end
main end


호출 그림


  처음 자바 프로그램을 실행하면 main()을 실행합니다. 이때 main()을 위한 스택 프레임이 하나 생성됩니다.
    
      main() 스택 프레임은 내부에 args라는 매개변수를 가집니다.
    
  
  main()은 method1()을 호출합니다. method1() 스택 프레임이 생성됩니다.
    
      method1()는 m1, cal 지역 변수(매개변수 포함)를 가지므로 해당 지역 변수들이 스택 프레임에 포함됩니다.
    
  
  method1()은 method2()를 호출합니다. method2 스택 프레임이 생성됩니다. method2()는 m2 지역 변수(매개변수 포함)를 가지므로 해당 지역 변수가 스택 프레임에 포함됩니다.


종료 그림


  method2()가 종료됩니다.
    
      이때 method2() 스택 프레임이 제거되고, 매개변수 m2도 제거됩니다.
        
          method2() 스택 프레임이 제거 되었으므로 프로그램은 method1()으로 돌아갑니다.
            
              물론method1()을 처음부터 시작하는 것이 아니라 method1()에서 method2()를 호출한 지점으로 돌아갑니다.
            
          
        
      
    
  
  method1()이 종료됩니다.
    
      이때 method1() 스택 프레임이 제거되고, 지역 변수(매개변수 포함) m1, cal도 제거됩니다.
        
          프로그램은 main()으로 돌아갑니다.
        
      
    
  
  main()이 종료됩니다.
    
      더 이상 호출할 메서드가 없고, 스택 프레임도 완전히 비워졌습니다.
        
          자바는 프로그램을 정리하고 종료합니다.
        
      
    
  


정리

  자바는 스택 영역을 사용해서 메서드 호출과 지역 변수(매개변수 포함)를 관리합니다.
  메서드를 계속 호출하면 스택 프레임이 계속 쌓입니다.
  지역 변수(매개변수 포함)는 스택 영역에서 관리합니다.
  스택 프레임이 종료되면 지역 변수도 함께 제거됩니다.
  스택 프레임이 모두 제거되면 프로그램도 종료됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-03-JavaMemoryStructure.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-03-JavaMemoryStructure.html"><h1 class="title_post">☕️[Java] 자바 메모리 구조</h1></a>
                        <a href="/2024/Java/2024-03-03-JavaMemoryStructure.html" class="txt_post">
                            자바 메모리 구조.

자바 메모리 구조 - 비유

자바의 메모리 구조는 크게 메서드 영역, 스택 영역, 힙 영역, 3개로 나눌 수 있습니다.

  메서드 영역: 클래스 정보를 보관합니다. 이 클래스 정보가 붕어빵 틀입니다.
  스택 영역: 실제 프로그램이 실행되는 영역입니다. 메서드를 실행할 때 마다 하나씩 쌓입니다.
  힙 영역: 객체(인스턴스)가 생성되는 영역입니다. new 명령어를 사용하면 이 영역을 사용합니다. 쉽게 이야기해서 붕어빵 틀로부터 생성된 붕어빵이 존재하는 공간입니다.
    
      참고로 배열도 이 영역에 생성됩니다.
    
  


위 설명한 내용은 쉽게 비유로 한 것이고 실제는 다음과 같습니다.




  메서드 영역(Method Are): 메서드 영역은 프로그램을 실행하는데 필요한 공통 데이터를 관리합니다. 이영역은 프로그램의 모든 영역에서 공유합니다.
    
      클래스 정보: 클래스의 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드등 모든 실행 코드가 존재합니다.
      static영역: static 변수들을 보관합니다.
      런타임 상수 풀: 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관합니다. 예를 들어서 프로그램에 "hello"라는 리터럴 문자가 있으면 이런 문자를 공통으로 묶어서 관리합니다. 이외에도 프로그램을 효율적으로 관리하기 위한 상수들을 관리합니다.
    
  
  스택 영역(Stack Area): 자바 실행 시, 하나의 실행 스택이 생성됩니다. 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함합니다.
    
      스택 프레임: 스택 영역에 쌓이는 네모 박스가 하나의 스택 프레임입니다. 메서드를 호출할 때 마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거됩니다.
    
  
  힙 영역(Heap Area): 객체(인스턴스)와 배열이 생성되는 영역입니다. 가비지 컬렉션(GC)이 이루어지는 주요 영역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거됩니다.



  참고: 스택 영역은 더 정확히는 각 쓰레드별로 하나의 실행 스택이 생성됩니다. 따라서 쓰레드 수 만큼 스택 영역이 생성됩니다. 지금은 쓰레드를 1개만 사용하므로 스택 영역도 하나입니다. 쓰레드에 대한 부분은 멀티 쓰레드를 학습해야 이해할 수 있습니다.


메서드 코드는 메서드 영역에




  자바에서 특정 클래스로 100개의 인스턴스를 생성하면, 힙 메모리에 100개의 인스턴스가 생깁니다.
    
      각각의 인스턴스는 내부에 변수와 메서드를 가집니다.
        
          같은 클래스로 부터 생성된 객체라도, 인스턴스 내부의 변수 값은 서로 다를 수 있지만, 메서드는 공통된 코드를 공유합니다.
            
              따라서 객체가 생성될 때, 인스턴스 변수에는 메모리가 할당되지만, 메서드에 대한 새로운 메모리 할당은 없습니다.
                
                  메서드는 메서드 영역에서 공통으로 관리되고 실행됩니다.
                
              
            
          
        
      
    
  
  정리하면 인스턴스의 메서드를 호출하면 실제로는 메서드 영역에 있는 코드를 불러서 수행합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-03-01-Encapsulation.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-03-01-Encapsulation.html"><h1 class="title_post">☕️[Java] 캡슐화</h1></a>
                        <a href="/2024/Java/2024-03-01-Encapsulation.html" class="txt_post">
                            캡슐화


  캡슐화(Encapsulation)는 객체 지향 프로그래밍의 중요한 개념 중 하나입니다.
  캡슐화는 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶어서 외부에서의 접근을 제한하는 것을 말합니다.
  캡슐화를 통해 데이터의 직접적인 변경을 방지하거나 제한할 수 있습니다.
  캡슐화는 쉽게 이야기해서 속성과 기능을 하나로 묶고, 외부에 꼭 필요한 기능만 노출하고 너머지는 모두 내부로 숨기는 것입니다.


이전에 객체 지향 프로그래밍을 설명하면서 캡슐화에 대해 알아보았습니다.

  이때는 데이터와 데이터를 처리하는 메서드를 하나로 모으는 것에 초점을 맞추었습니다.
    
      여기서 한발짝 더 나아가 캡슐화를 안전하게 완성할 수 있게 해주는 장치가 바로 “접근 제어자” 입니다.
    
  


그럼 어떤 것을 숨기고 어떤 것을 노출해야 할까요?

1. 데이터를 숨겨라.
객체에는 속성(데이터)과 기능(메서드)이 있습니다.

  캡슐화에서 가장 필수로 숨겨야 하는 것은 “속성(데이터)” 입니다.


package access;

public class Speaker {
  private int volume;

  Speaker(int volume) {
    this.volume = volume;
  }

  void volumeUp() {
    if (volume &gt;= 100) {
      System.out.println("음량을 증가할 수 없습니다. 최대 음량입니다.");
    } else {
      volume += 10;
      System.out.println("음량을 증가합니다.");
    }
  }

  void volumeDown() {
    volume -= 10;
    System.out.println("volumeDown 호출");
  }

  void showVolume() {
    System.out.println("현재 음량: " + volume);
  }
}


위 코드에서의 Speaker의 volume을 봐봅시다.

  객체 내부의 데이터를 외부에서 함부로 접근하게 둔다면, 클래스 안에서 데이터를 다루는 모든 로직을 무시하고 데이터를 변경할 수 있습니다.
    
      결국 모든 안전망을 다 빠져나가게 됩니다.
        
          따라서 캡슐화가 깨집니다.
        
      
    
  


우리가 자동자를 운전할 때 자동차 부품을 다 열어서 그 안에 있는 속도계를 직접 조절하지 않습니다.

  단지 자동차가 제공하는 액셀 기능을 사용해서 액셀을 밟으면 자동차가 나머지는 다 알아서 하는 것입니다.


우리가 일상에서 생각할 수 있는 음악 플레이어를 떠올려봅시다.

음악 플레이어를 사용할 때 그 내부에 들어있는 전원부나, 볼륨 상태의 데이터를 직접 수정할 일이 있을까요?

우리는 그냥 음악 플레이어의 켜고, 끄고, 볼륨을 조절하는 버튼을 누를 뿐입니다.

  그 내부에 있는 전원부나, 볼륨의 조절하는 버튼을 누를 뿐입니다.
    
      그 내부에 있는 전원부나, 볼륨의 상태 데이터를 직접 수정하지는 않습니다.
        
          전원 버튼을 눌렀을 때 실제 전원을 받아서 전원을 켜는 것은 음악 플레이어의 일입니다.
          볼륨을 높였을 때 내부에 있는 볼륨 장치들을 움직이고 볼륨 수치를 조절하는 것도 음악 플레이어가 스스로 해야하는 일입니다.
            
              쉽게 이야기해서 우리는 음악 플레이어가 제공하는 기능을 통해서 음악 플레이어를 사용하는 것입니다.
                
                  복잡하게 음악 플레이어의 내부를 까서 그 내부 데이터까지 우리가 직접 사용하는 것은 아닙니다.
                
              
            
          
        
      
    
  


객체의 데이터는 객체가 제공하는 기능인 메서드를 통해서 접근해야 합니다.

2. 기능을 숨겨라.
“객체의 기능 중에서 외부에서 사용하지 않고 내부에서만 사용하는 기능들이 있습니다.”

  이런 기능도 모두 감추는 것이 좋습니다.


우리가 자동차를 운정하기 위해 자동차가 제공하는 복잡한 엔진 조절 기능, 배기 기능까지 우리는 알 필요가 없습니다.

  우리는 단지 렉셀과 핸들 정도의 기능만 알면 됩니다.
    
      만약 사용자에게 이런 기능까지 모두 알려준다면, 사용자가 자동차에 대해 너무 많은 것을 알아야 합니다.
    
  


“사용자 입장에서 꼭 필요한 기능만 외부에 노출합시다. 나머지 기능은 모두 내부로 숨깁시다.”

“정리하면 데이터는 모두 숨기고, 기능은 꼭 필요한 기능만 노출하는 것이 좋은 캡슐화입니다.”

이번에는 잘 캡슐화된 예제를 하나 만들어봅시다.

BankAccount
package access;

public class BankAccount {

  private int balance;

  public BankAccount() {
    balance = 0;
  }

  // public 메서드: deposit
  public void deposit(int amount) {
    if (isAmountValid(amount)) {
      balance += amount;
      System.out.println(amount + "원이 입금되었습니다.");
    } else {
      System.out.println("유효하지 않은 금액입니다.");
    }
  }

  // public 메서드: withdraw
  public void withdraw(int amount) {
    if (isAmountValid(amount) &amp;&amp; (balance - amount &gt;= 0)) {
      balance -= amount;
      System.out.println(amount + "원이 출금되었습니다.");
    } else {
      System.out.println("유효하지 않은 금액이거나 잔액이 부족합니다.");
    }
  }

  // public 메서드: getBalance
  public int getBalance() {
    return balance;
  }

  private boolean isAmountValid(int amount) {
    // 금액이 0보다 커야함.
    return amount &gt; 0;
  }
}


BankAccountMain
package access;

public class BankAccountMain {

  public static void main(String[] args) {
    BankAccount account = new BankAccount();
    account.deposit(10000);
    account.withdraw(3000);
    System.out.println("balance = " + account.getBalance());
  }
}


위 코드는 은행 계좌 기능을 다룹니다.

위 코드는 다음과 같은 기능을 가지고 있습니다.

private

  balance : 데이터 필드는 외부에 직접 노출하지 않습니다. BankAccount가 제공하는 메서드를 통해서만 접근할 수 있슷빈다.
  isAmountValid() : 입력 금액을 검증하는 기능은 내부에서만 필요한 기능입니다. 따라서 private을 사용했습니다.


pulbic

  deposit() : 입금
  withdraw() : 출금
  getBalance() : 잔고


BankAccount를 사용하는 입장에서는 단 3가지 메서드만 알면 됩니다.

  나머지 복잡한 내용은 모두 BankAccount 내부에 숨어있습니다.


“만약 isAmountValid()를 외부에 노출할 경우 어떻게될까요?”

  BankAccount를 사용하는 개발자 입장에서는 사용할 수 있는 메서드가 하나 더 늘었습니다.
    
      여러분이 BankAccount를 사용하는 개발자라면 어떤 생각을 할까요?
        
          아마도 입금과 출금 전에 본인이 먼저 isAmountValid()를 사용해서 검증을 해야 하나? 라고 의문을 가질 것입니다.
        
      
    
  


“만약 balance 필드를 외부에 노출하면 어떻게 될까요?”

  BankAccount를 사용하는 개발자 입장에서는 이 필드를 직접 사용해도 된다고 생각할 수 있습니다.
    
      “왜냐하면 외부에 공개하는 것은 그것을 외부에서 사용해도 된다는 뜻이기 때문입니다.”
        
          “결국 모든 검증과 캡슐화가 깨지고 잔고를 무한정 늘리고 출금하는 심각한 문제가 발생할 수 있습니다.”
        
      
    
  


“접근 제어자와 캡슐화를 통해 데이터를 안전하게 보호하는 것은 물론이고, BankAccount를 사용하는 개발자 입장에서 해당 기능을 사용하는 복잡도도 낮출 수 있습니다.”

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-03-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CS/2024-02-29-cs.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CS/2024-02-29-cs.html"><h1 class="title_post">💾 [CS] 컴퓨터의 구성</h1></a>
                        <a href="/2024/CS/2024-02-29-cs.html" class="txt_post">
                            컴퓨터의 구성.

1. 컴퓨터가 시스템은 크게 어떻게 나누어 지나요?

  컴퓨터 시스템은 크게 하드웨어와 소프트웨어로 나누어집니다.
    
      하드웨어는 컴퓨터를 구성하는 기계적 장치입니다.
        
          중앙처리장치(CPU)
          기억장치: RAM, HDD
          입출력 장치: 마우스, 프린터
        
      
      소프트웨어는 하드웨어의 동작을 지시하고 제어하는 명령어 집합입니다.
        
          시스템 소프트웨어: 운영체제, 컴파일러
          응용 소프트웨어: 워드프로세서, 스프레드시트
        
      
    
  


1.1 명령어란 무엇일까요?

  명령어는 컴퓨터에게 무엇을, 어떻게 해야 하는지를 알려주는 지시사항입니다.
    
      콤퓨터는 이러한 명령어들을 해석하고 실행하여 다양한 작업을 수행합니다.
    
  


명령어 구성 요소

  연산자(Operation Code, Opcode) : 수행해야 할 기본적은 작업의 유형을 나타냅니다. 예를 들어, 데이터를 더하거나 빼거나, 저장하는 등의 작업이 이에 해당합니다.
  피연산자(Operand) : 연산자가 작용할 데이터나, 그 데이터가 위치한 메모리 주소를 가리킵니다. 즉, 연산자가 어떤 데이터에 대한 작업을 수행할지를 지정합니다.
  결과(Result) : 연산의 결과를 저장할 위치입니다. 이는 명령어에 따라 명시적으로 주어지거나, 특정 규칙에 따라 암시적으로 결정될 수 있습니다.


명령어들은 프로그래밍 언어로 작성되며, 고급 프로그래밍 언어에서 작성된 코드는 컴파일러나 인터프리터를 통해 기계어로 번역되어 컴퓨터가 이해할 수 있는 형태로 변환됩니다.

  기계어는 컴퓨터의 프로세서가 직접 실행할 수 있는 매우 기본적이고 낮은 수준의 명령어 집합입니다.


2. 하드웨어란 무엇인가요?

  하드웨어는 중앙처리장치(CPU), 기억장치, 입출력장치로 구성되어 있으며 이들은 시스템 버스로 연결되어 있습니다.
    
      시스템 버스는 데이터와 명령 제어 신호를 각 장치로 실어나르는 역할을 합니다.
    
  


2.2 중앙처리장치(CPU)란 무엇인가요?

  인간으로 따지면 두뇌에 해당하는 부분입니다.
    
      주기억장치에서 프로그램 명령어와 데이터를 읽어와 처리하고 명령어의 수행 순서를 제어합니다.
      중앙처리장치는 비교와 연산을 담당하는 산술논리연산장치(ALU)와 명령어의 해석과 실행을 담당하는 제어장치, 속도가 빠른 데이터 기억장소인 레지스터로 구성되어 있습니다.
    
  
  개인용 컴퓨터와 같은 소형 컴퓨터에서는 CPU를 마이크로프로세서라고도 부릅니다.


2.3 기억장치란 무엇인가요?

  프로그램, 데이터, 연산의 중간 결과를 저장하는 장치입니다.
    
      기억장치는 주기억장치와 보조기억 장치로 나누어집니다.
        
          RAM과 ROM도 이곳에 해당합니다.
          실행중인 프로그램과 같은 프로그램에 필요한 데이터를 일시적으로 저장합니다.
            
              보조기억장치는 하드디스크 등을 말하며, 주기억장치에 비해 속도는 느리지만 많은 자료를 영구적으로 보관할 수 있는 장점이 있습니다.
            
          
        
      
    
  


2.4 입출력장치란 무엇인가요?

  먼저 입출력장치는 입력과 출력 장치로 나뉘어집니다.
    
      입력 장치는 컴퓨터 내부로 자료를 입력하는 장치인 키보드, 마우스등이 이에 속합니다.
      출력 장치는 컴퓨터에서 외부로 표현하는 장치인 프린터, 모니터, 스피커등이 이에 속합니다.
    
  


3. 시스템 버스란 무엇인가요?

  시스템 버스는 하드웨어 구성 요소를 물리적으로 연결하는 선을 말합니다.
    
      시스템 버스는 각 구성요소가 다른 구성요소로 데이터를 보낼 수 있도록 통로가 되어줍니다.
        
          시스템 버스는 용도에 따라 데이터 버스, 주소 버스, 제어 버스로 나뉘어집니다.
        
      
    
  


3.1 데이터 버스란 무엇인가요?

  데이터 버스란 중앙처리장치와 기타 장치 사이에서 데이터를 전달하는 통로를 말합니다.
    
      기억장치와 입출력장치의 명령어와 데이터를 중앙처리장치로 보내거나, 중앙처리장치의 연산 결과를 기억장치와 입출력장치로 보내는 ‘양방향’ 버스입니다.
    
  


3.2 주소 버스란 무엇인가요?

  주소 버스는 중앙처리장치가 주기억장치나 입출력장치로 기억장치 주소를 전달하는 통로입니다.
    
      주소버스는 그렇기 때문에 ‘단방향’ 버스입니다.
        
          데이터를 정확히 실어나르기 위해서는 기억장치’주소’를 정해주어야 합니다.
        
      
    
  


3.3 제어 버스

  제어 버스는 중앙처리장치가 기억장치나 입출력장치에 제어 신호를 전달하는 통로입니다.
    
      제어 신호의 종류에는 기억장치 읽기 및 쓰기, 버스 요청 및 승인, 인터럽트 요청 및 승인, 클락, 리셋 등이 있습니다.
        
          제어 버스는 읽기 동작과 쓰기 동작을 모두 수행하기 때문에 ‘양방향’ 버스입니다.
            
              제어 버스가 필요한 이유는 주소 버스와 데이터 버스는 모든 장치에 공유되는데 이때 이를 제어할 수단이 필요하기 때문입니다.
            
          
        
      
    
  


4. 컴퓨터의 데이터 처리과정

  컴퓨터는 기본적으로 읽고 처리한 뒤 저장하는 과정으로 이루어집니다. (READ -&gt; PROCESS -&gt; WRITE)
    
      이 과정을 진행하면서 끊임없이 주기억장치(RAM)과 소통합니다.
        
          이때 운영체제가 64bit라면, CPU는 RAM으로부터 데이터를 한번에 64bit씩 읽어옵니다.
        
      
    
  




                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-29</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-28-accessModifier-5.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-28-accessModifier-5.html"><h1 class="title_post">☕️[Java] 접근 제어자의 사용 - 클래스 레벨</h1></a>
                        <a href="/2024/Java/2024-02-28-accessModifier-5.html" class="txt_post">
                            접근 제어자의 사용 - 클래스 레벨
클래스 레벨의 접근 제어자 규칙

  클래스 레벨의 접근 제어자는 public, default만 사용할 수 있습니다.
    
      private, protected는 사용할 수 없습니다.
    
  
  public 클래스는 반드시 파일명과 이름이 같아야 합니다.
    
      하나의 자바 파일에 public 클래스는 하나만 등장할 수 있습니다.
      하나의 자바 파일에 default 접근 제어자를 사용하는 클래스는 무한정 만들 수 있습니다.
    
  


PublicClass.java 파일
package access.a;

public class PublicClass {
    pulbic static void main(String[] args) {
        PublicClass publicClass = new PublicClass();
        DefaultClass1 class1 = new DefaultClass1();
        DefaultClass2 class2 = new DefaultClass2();
    }
}

class DefaultClass1 {
}

class DefaultClass2 {
}


  패키지 위치는 package access.a입니다. 패키지 위치를 꼭 맞추어야 합니다. 주의합시다.
  PublicClass라는 이름의 클래스를 만들었습니다. 이 클래스는 public 접근 제어자입니다.
    
      따라서 파일명과 이 클래스의 이름이 반드시 같아야 합니다.
        
          이 클래스는 public이기 때문에 외부에서 접근할 수 있습니다.
        
      
    
  
  DefaultClass1, DefaultClass2는 default 접근 제어자입니다.
    
      이 클래스는 default이기 때문에 같은 패키지 내부에서만 접근할 수 있습니다.
    
  
  PublicClass의 main()을 보면 각각의 클래스를 사용하는 예를 보여줍니다.
    
      PublicClass의 main()을 보면 각각의 클래스를 사용하는 예를 보여줍니다.
        
          PublicClass는 public 접근 제어입니다.
            
              따라서 어디서든 사용할 수 있습니다.
                
                  DefaultClass1, DefaultClass2와는 같은 패키지에 있으므로 사용할 수 있습니다.
                
              
            
          
        
      
    
  


PublicClassInnerMain
package access.a;

public class PublicClassInnerMain {

  public static void main(String[] args) {
    PublicClass publicClass = new PublicClass();
    DefaultClass1 class1 = new DefaultClass1();
    DefaultClass2 class2 = new DefaultClass2();
  }
}


  패키지 위치는 package access.a입니다. 패키지 위치를 꼭 맞춰줘야합니다.
  PublicClass는 public 클래스입니다.
    
      따라서 외부에서 접근할 수 있습니다.
    
  
  PublicClassInnerMain와 DefaultClass1, DefaultClass2는 같은 패키지입니다.
    
      따라서 접근할 수 있습니다.
    
  


PublicClassOuterMain
package access.b;

//import access.a.DefaultClass1;
//import access.a.DefaultClass2;
import access.a.PublicClass;

public class PublicClassOuterMain {

  public static void main(String[] args) {
    PublicClass publicClass = new PublicClass();

    // 다른 패키지 접근 불가.
    //DefaultClass1 class1 = new DefaultClass1();
    //DefaultClass2 class2 = new DefaultClass2();
  }
}


  패키지 위치는 package accesss.b 입니다. 패키지 위치를 꼭 맞춰야합니다.
  PublicClass는 public 클래스입니다.
    
      따라서 외부에서 접근할 수 있습니다.
    
  
  PublicClassOuterMain와 DefaultClass1, DefaultClass2는 다른 패키지입니다.
    
      따라서 접근할 수 없습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-28-accessModifier-3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-28-accessModifier-3.html"><h1 class="title_post">☕️[Java] 접근 제어자의 종류</h1></a>
                        <a href="/2024/Java/2024-02-28-accessModifier-3.html" class="txt_post">
                            접근 제어자의 종류.
자바는 4가지 종류의 접근 제어자를 제공합니다.

접근 제어자의 종류

  private: 모든 외부 호출을 막습니다.
  default(package-private): 같은 패키지안에서 호출은 허용합니다.
  protected: 같은 패키지 안에서 호출은 허용합니다. 패키지가 달라도 상속 관계의 호출은 허용합니다.
  public: 모든 외부 호출을 허용합니다.


순서대로 private이 가장 많이 차단하고, public이 가장 많이 허용합니다.
private -&gt; default -&gt; protected -&gt; public

package-private

  접근제어자를 명시하지 않으면 같은 패키지 안에서 호출을 허용하는 default 접근 제어자가 적용됩니다.
    
      default라는 용어는 해당 접근 제어자가 기본값으로 사용되기 때문에 붙여진 이름이지만, 실제로는 package-private이 더 정확한 표현힙니다.
        
          왜냐하면 해당 접근 제어자를 사용하는 멤버는 동일한 패키지 내의 다른 클래스에서만 접근이 가능하기 때문입니다.
        
      
    
  



  참고로 두 용어를 함께 사용합니다.


접근 제어자 사용 위치

  접근 제어자는 필드와 메서드, 생성자에 사용됩니다.
    
      추가로 클래스 레벨에도 일부 접근 제어자를 사용할 수 있습니다.
    
  


접근 제어자 예시
public class Speacker { // 클래스 레벨
    
    private init volume; //필드
    
    public Speaker(int volume) {} // 생성자
    
    public void volumeUp() {} // 메서드
    public void volumeDown() {}
    public void showVolume() {}
}


접근제어자의 핵심은 속성과 기능을 외부로부터 숨기는 것입니다.

  private은 나의 클래스 안으로 속성과 기능을 숨길 때 사용, 외부 클래스에서 해당 기능을 호출할 수 없습니다.
  default는 나의 패키지 안으로 속성과 기능을 숨길 때 사용, 외부 패키지에서 해당 기능을 호출할 수 없습니다.
  protected는 상속 관계로 속성과 기능을 숨길 때 사용, 상속 관계가 아닌 곳에서 해당 기능을 호출할 수 없습니다.
  public은 기능을 숨기지 않고 어디서든 호출할 수 있게 공개합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-28-accessModifier-4.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-28-accessModifier-4.html"><h1 class="title_post">☕️[Java] 접근 제어자의 사용 - 필드, 메서드</h1></a>
                        <a href="/2024/Java/2024-02-28-accessModifier-4.html" class="txt_post">
                            접근 제어자의 사용 - 필드, 메서드
다양한 상황에 따른 접근 제어자를 확인해봅시다.
“주의! 지금부터는 패키지 위치가 매우 중요합니다. 패키지 위치에 주의하세요.”

필드, 메서드 레벨의 접근 제어자
AccessData
package access.a;

public class AccessData {

  public int publicField;
  int defaultField;
  private int privateField;

  public void publicMethod() {
    System.out.println("publicMethod 호출 " + publicField);
  }

  void defaultMethod() {
    System.out.println("defaultMethod 호출 " + defaultField);
  }

  private void privateMethod() {
    System.out.println("privateMethod 호출 " + privateField);
  }

  public void innerAccess() {
    System.out.println("내부 호출");
    publicField = 100;
    defaultField = 200;
    privateField = 300;
    publicMethod();
    defaultMethod();
    privateMethod();
  }
}



  패키지 위치는 package access.a입니다. 패키지 위치를 꼭 맞추어야 합니다. 주의합시다.
  순서대로 public, default, private을 필드와 메서드에 사용했습니다.
  마지막에 innerAccess()가 있는데, 이 메서드는 내부 호출을 보여줍니다.
    
      내부 호출은 자기 자신에게 접근하는 것입니다.
        
          따라서 private을 포함함 모든 곳에 접근할 수 있습니다.
        
      
    
  


이제 외부에서 이 클래스에 접근해 봅시다.

AccessInnerMain
package access.a;

public class AccessInnerMain {

  public static void main(String[] args) {
    AccessData data = new AccessData();
    // public 호출 가능
    data.publicField = 1;
    data.publicMethod();

    // 같은 패키지 default 호출 가능
    data.defaultField = 2;
    data.defaultMethod();

    // private 호출 불가
    //data.privateField = 3;
    //data.privateMethod();

    data.innerAccess();
  }
}


  패키지 위치는 package access.a입니다. 패키지 위치를 꼭 맞춰야 합니다. 주의합시다.
  public은 모든 접근을 허용하기 때문에 필드, 메서드 모두 접근 가능합니다.
  defaul는 같은 패키지에서 접근할 수 있습니다. AccessInnerMain은 AccessData와 같은 패키지입니다.
    
      따라서 default 접근 제어자에 접근할 수 있습니다.
    
  
  private은 AccessData 내분에서만 접근할 수 있습니다.
    
      따라서 호출 불가입니다.
    
  
  AccessData.innerAccess() 메서드는 public입니다.
    
      따라서 외부에서 호출할 수 있습니다.
        
          innerAccess() 메서드는 외부에서 호출되었지만 innerAccess() 메서드는 AccessData에 포함되어 있습니다.
            
              이 메서드는 자신의 private 필드와 메서드에 모두 접근할 수 있습니다.
            
          
        
      
    
  


실행 결과
publicMethod 호출 1
defaultMethod 호출 2
내부 호출
publicMethod 호출 100
defaultMethod 호출 200
privateMethod 호출 300


AccessOuterMain
package access.b;

import access.a.AccessData;

public class AccessOuterMain {
  public static void main(String[] args) {
    AccessData data = new AccessData();
    // public 호출 가능
    data.publicField = 1;
    data.publicMethod();

    // 다른 패키지 default 호출 가능
    //data.defaultField = 2;
    //data.defaultMethod();

    // private 호출 불가
    //data.privateField = 3;
    //data.privateMethod();

    data.innerAccess();
  }
}


  패키지 위치는 package access.b 입니다. 패키지 위치를 꼭 맞추어야 합니다. 주의합시다.
  public은 모든 접근을 허용하기 때문에 필드, 메서드 모두 접근할 수 있습니다.
  default는 같은 패키지에서 접근할 수 있습니다.
    
      access.b.AccessOuterMain은 access.a.AccessData와 다른 패키지 입니다.
        
          따라서 default 접근 제어자에 접근할 수 없습니다.
        
      
    
  
  private은 AccessData 내부에서만 접근할 수 있습니다. 따라서 호출 불가입니다.
  AccessData.innerAccess() 메서드는 public입니다.
    
      따라서 외부에서 호출할 수 있습니다.
        
          innerAccess() 메서드는 외부에서 호출되었지만 해당 메서드 안에서는 자신의 private 필드와 메서드에 접근할 수 있습니다.
        
      
    
  


실행 결과
publicMethod 호출 1
내부 호출
publicMethod 호출 100
defaultMethod 호출 200
privateMethod 호출 300



  참고로 생성자도 접근 제어자 관점에서 메서드와 같습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-27-accessModifier-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-27-accessModifier-2.html"><h1 class="title_post">☕️[Java] 접근 제어자 이해 2</h1></a>
                        <a href="/2024/Java/2024-02-27-accessModifier-2.html" class="txt_post">
                            접근 제어자 이해 2

  이 문제를 근본적으로 해결하는 방법은 volume 필드를 Speaker 클래스 외부에서는 접근하지 못하게 막는 것 입니다.


Speaker - volume 접근 제어자를 private으로 수정
package access;

public class Speaker {
    
    private int volume; // private 사용
    ...
}



  private 접근 제어자는 모든 외부 호출을 막습니다.
    
      따라서 private이 붙는 경우 해당 클래스 내부에서만 호출할 수 있습니다.
    
  


volume 필드 - private 변경 후

  volume 필드를 private을 사용해서 Speaker 내부에 숨겼습니다.
    
      외부에서 volume 필드에 직접 접근할 수 없게 막은 것입니다.
        
          volume 필드는 이제 Speaker 내부에서만 접근할 수 있습니다.
        
      
    
  


SpeakerMain 코드를 다시 실행해보겠습니다.
// 필드에 직접 접근
System.out.println("volume 필드 직접 접근 수정");
speaker.volume = 200; // private 접근 오류


IDE에서 speaker.volume = 200 부분에 오류가 발생하는 것을 확인할 수 있습니다.

  실행해보면 다음과 같은 컴파일 오류가 발생합니다.


컴파일 오류 메시지
java: volume has private access in access.Speaker


  volume 필드는 private으로 설정되어 있기 때문에 외부에서 접근할 수 없다는 오류입니다.


volume 필드 직접 접근 - 주석 처리
// 필드에 직접 접근
System.out.println("volume 필드에 직접 접근 수정");
//speaker.volume = 200; //private 접근 오류
speaker.showVolume();



  이제 Speaker 외부에서 volume 필드에직접 접근하는 것은 불가능합니다.
    
      이 경우 자바 컴파일러가 컴파일 오류를 발생시킵니다.
        
          프로그램을 실행하기 위해서 volume 필드에 직접 접근하는 코드를 주석 처리합니다.
        
      
    
  


만약 Speaker 클래스를 개발하는 개발자가 처음부터 private을 사용해서 volume 필드의 외부 접근을 막아두었다면 어떠했을까요?

새로운 개발자도 volume 필드에 직접 접근하지 않고, volumeUp() 과 같은 메서드를 통해서 접근했을 것입니다.

  결과적으로 Speaker가 폭발하는 문제는 발생하지 않았을 것입니다.



  참고: 좋은 프로그램은 무한한 자유도가 주어지는 프로그램이 아니라 적절한 제약을 제공하는 프로그램입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/CPP_DS/2024-02-27-SwapAndSort.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cpp.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/CPP_DS/2024-02-27-SwapAndSort.html"><h1 class="title_post">🆙[Cpp DataStructure] 교환(Swap)과 정렬(Sort)</h1></a>
                        <a href="/2024/CPP_DS/2024-02-27-SwapAndSort.html" class="txt_post">
                            Swap(교환)

먼저 아래의 코드를 보고 a와 b를 교환해봅시다.

#include &lt;iostream&gt;

using namespace std;

int main()
{

	// Swap
	{
		int a = 3;
		int b = 2;

		cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;

		// TODO:

		cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;	
	}

	return 0;
}


실행 결과
3 2
3 2


“TODO” 에는 어떤 코드가 들어가야 할까요?

“우리가 양 손에 사과🍎와 레몬🍋을 들고 있다고 생각해봅시다.”

  그럼 왼손에는 사과🍎와 오른손에는 레몬🍋을 들고 있을 때 사과🍎와 레몬🍋을 바꾸려면 어떻게 해야할까요?
    
      저는 하나의 접시를 가져와 그 접시에 사과 또는 레몬을 잠시 올려두고 비어있는 손으로 과일을 옮긴 뒤 접시에 있는 과일을 집을것 입니다.
        
          그럼 코드도 똑같이 만들 수 있지 않을까요?
        
      
    
  


#include &lt;iostream&gt;

using namespace std;

int main()
{

	// Swap
	{
		int a = 3;
		int b = 2;

		cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;

		// TODO:
        // 먼저 a를 사과 b를 레몬이라고 생각하고,
        // temp라는 접시를 만들어보겠습니다.
        // 그 접시에 a라는 사과를 올려보겠습니다.
        int temp = a;
        
        // 그럼 비어있는 손으로 레몬을 옮길 수 있게되었네요.
        // 비어있는 손으로 레몬을 옮겨보겠습니다.
        // a가 있던 손으로 b를 옮깁니다.
        a = b;
        
        // 이번에는 b가 있던 손이 비었네요.
        // b가 있던 손으로 접시(temp)에 있는 a를 들어보겠습니다.
        temp = a;

		cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;	
	}

	return 0;
}

실행 결과
3 2
2 3



  양 손에 있던 사과(3)과 레몬(2)의 자리가 바뀌었습니다
    
      “즉, 교환(Swap)이 이루어졌습니다.”
    
  


하지만 항상 이렇게 3줄의 라인인
int temp = a;
a = b;
b = temp;



  위 코드처럼 코드를 만들어서 사용할 경우에는 매우 많은 교환(Swap)을 해야할 경우 코드의 양도 늘어나고 가독성도 좋지 않은 것 입니다.


“그럼 이번에는 함수를 이용해서 두 숫자를 교환해봅시다.”

먼저, 위 교환 코드를 그대로 가져다가 사용해볼까요?
void MySwap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}



  이 경우에는 리턴 값이 없기 때문에 불가능합니다.
    
      만약 리턴값이 int 형이라고 해도 리턴은 1개만 가능하기 때문에 어렵습니다.
        
          cpp의 다른 기능인 구조체나 여러 기능을 사용해야 할 것입니다.
        
      
    
  


그러면 어떻게 해야할까요?

  “C의 포인터와 CPP의 레퍼런스를 활용하면됩니다.”


1. C의 포인터 활용
#include &lt;iostream&gt;

using namespace std;

void MySwapPtr(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}

int main()
{

	// Swap
	{
		int a = 3;
		int b = 2;

		cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;

		MySwapPtr(&amp;a, &amp;b);

		cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;	
	}

	return 0;
}


실행 결과
3 2
2 3


실행 결과는 올바르게 나왔습니다.

“C 스타일의 포인터 사용은 *(별)을 사용하면 됩니다.”

void MySwapPtr(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}


  temp에 먼저 a의 주소값을 넣어 줍니다.
    
      이후 a의 주소값에 b의 주소값을 넣어 줍니다.
        
          b의 주소값에는 temp(a의 주소값)을 넣어줍니다.
        
      
    
  


“이렇게 되면 각 주소값이 교환이 됩니다.”

C 스타일의 단점은 선언과 호출시에 나타납니다.


  선언시에는 위와 같이 *을 모두 붙여줘야 합니다.
  호출시에는 아래와 같이 &amp;를 붙여줘야 합니다.


MySwapPtr(&amp;a, &amp;b);


“하지만 CPP 스타일의 래퍼런스 교환은 단순합니다.”

// 선언시
void MySwapRef(int&amp; a, int&amp; b) {
	int temp = a;
	a = b;
	b = temp;
}

// 호출시
MySwapRef(a, b);



  내부 구현은 똑같지만 별다른 어노테이션 없이 일반적인 변수 할당과 같이 해주면 래퍼런스 대입되고 교환이 이루어지는 것을 볼 수 있습니다.
  호출시에도 어노테이션을 따로 붙일 필요없이 일반적인 매개변수(parameter)를 넣어주듯이 넣어주면 됩니다.


#include &lt;iostream&gt;

using namespace std;

void MySwapRef(int&amp; a, int&amp; b) {
	int temp = a;
	a = b;
	b = temp;
}

int main()
{

	// Swap
	{
		int a = 3;
		int b = 2;

		cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;

		MySwapRef(a, b);

		cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;	
	}

	return 0;
}


실행 결과
3 2
2 3


“이번에는 교환을 활용해서 정렬을 해보겠습니다.”


  값과 상관 없이 항상 작은 값이 먼저 출력되게 하려면 어떻게 해야할까요?
    
      즉, 두 값이 같을 때는 순서가 상관이 없지만 큰 값이 먼저 출력되지 않게 해야합니다.
    
  


먼저 두 값이 같지 않거나 큰 값이 먼저 출력 되었을 경우에 false를 출력하고 그와는 반대일 경우에는 true를 출력하는 코드를 작성해보겠습니다.

#include &lt;iostream&gt;

using namespace std;

// 정렬(sorting)
int main() {
	int arr[2];

	// TODO:
	for (int j = 0; j &lt; 5; j++) {
		for (int i = 0; i &lt; 5; i++) {
			arr[0] = i;
			arr[1] = j;

			cout &lt;&lt; boolalpha;
			cout &lt;&lt; arr[0] &lt;&lt; " " &lt;&lt; arr[1] &lt;&lt; " "
				&lt;&lt; (arr[0] &lt;= arr[1]) &lt;&lt; endl;
		}
	}
	return 0;
}



  먼저 배열을 선언합니다. 배열은 순서가 있기 때문입니다.
    
      그리고 2중 for문을 사용합니다. 첫 번째 for문이 1번 돌 때 두 번째 for문은 5번 돌게됩니다.
        
          그렇게 각각을 i와 j에 라는 변수의 이름으로 arr 배열 인덱스 0번째와 1번째에 넣어줍니다.
        
      
    
  


실행 결과
0 0 true
1 0 false
2 0 false
3 0 false
4 0 false
0 1 true
1 1 true
2 1 false
3 1 false
4 1 false
0 2 true
1 2 true
2 2 true
3 2 false
4 2 false
0 3 true
1 3 true
2 3 true
3 3 true
4 3 false
0 4 true
1 4 true
2 4 true
3 4 true
4 4 true



  실행 결과 값이 작거나 같은 값이 인덱스 0번 즉 오름차순일 경우에는 true 입니다.
    
      그와는 반대로 큰 값이 인덱스 0번 즉 내림차순일 경우에는 false 입니다.
    
  


“이제 두 값을 비교하여 오름차순으로 정렬되는 것을 확인하는 함수를 만들었으니 이번에는 실제 정렬을 해보도록하겠습니다.”

#include &lt;iostream&gt;

using namespace std;

bool CheckSorted(int a, int b) {
	// TODO: ...
	if (a &lt;= b) {
		return true;
	} else {
		return false;
	}
}

// 정렬(sorting)
int main() {
	int arr[2];

	// TODO:
	for (int j = 0; j &lt; 5; j++) {
		for (int i = 0; i &lt; 5; i++) {
			arr[0] = i;
			arr[1] = j;

			// swap 소개
			if (arr[0] &gt; arr[1]) {
				swap(arr[0], arr[1]);
			}

			cout &lt;&lt; boolalpha;
			cout &lt;&lt; arr[0] &lt;&lt; " " &lt;&lt; arr[1] &lt;&lt; " "
				&lt;&lt; (CheckSorted(arr[0], arr[1])) &lt;&lt; endl;
			
		}
	}
	return 0;
}


실행 결과
0 0 true
0 1 true
0 2 true
0 3 true
0 4 true
0 1 true
1 1 true
1 2 true
1 3 true
1 4 true
0 2 true
1 2 true
2 2 true
2 3 true
2 4 true
0 3 true
1 3 true
2 3 true
3 3 true
3 4 true
0 4 true
1 4 true
2 4 true
3 4 true
4 4 true



  CPP에는 swap이라는 함수가 있습니다 swap을 사용할 경우에는 매개변수로 받은 두 값을 바꿔줍니다.
    
      따라서 위와 같은 실행 결과를 출력합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-27-accessModifier-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-27-accessModifier-1.html"><h1 class="title_post">☕️[Java] 접근 제어자 이해 1</h1></a>
                        <a href="/2024/Java/2024-02-27-accessModifier-1.html" class="txt_post">
                            접근 제어자

접근 제어자 이해 1.


  자바는 public, private 같은 접근 제어자(access modifier)를 제공합니다.
    
      접근 제어자를 사용하면 해당 클래스 외부에서 특정 필드나 메서드에 접근하는 것을 허용하거나 제한할 수 있습니다.
    
  


이런 접근 제어자가 왜 필요할까요?

  예제를 통한 접근 제어자가 필요한 이유를 알아봅시다.


여러분은 스피커에 들어가는 소프트웨어 개발자 입니다.
스피커의 음량은 절대로 100을 넘으면 안된다는 요구사항이 있습니다(100을 넘어가면 스피커의 부품들이 고장납니다.)

스피커 객체를 만들어봅시다.
스피커는 음량을 높이고, 내리고, 현재 음량을 확인할 수 있는 단순한 기능을 제공합니다.
요구사항 대로 스피커의 음량은 100까지만 증가할 수 있습니다.
절대 100을 넘어가면 안됩니다.

Speaker
package access;

public class Speaker {
  int volume;

  Speaker(int volume) {
    this.volume = volume;
  }

  void volumeUp() {
    if (volume &gt;= 100) {
      System.out.println("음량을 증가할 수 없습니다. 최대 음량입니다.");
    } else {
      volume += 10;
      System.out.println("음량을 증가합니다.");
    }
  }

  void volumeDown() {
    volume -= 10;
    System.out.println("volumeDown 호출");
  }

  void showVolume() {
    System.out.println("현재 음량: " + volume);
  }
}


  생성자를 통해 초기 음량 값을 지정할 수 있습니다.
  volumeUp() 메서드를 봅시다. 음량이 한 번에 10씩 증가합니다.
    
      단 음량이 100을 넘게되면 더는 음량을 증가하지 않습니다.
    
  


SpeakerMain
package access;

public class SpeakerMain {

  public static void main(String[] args) {
    Speaker speaker = new Speaker(90);
    speaker.showVolume();

    speaker.volumeUp();
    speaker.showVolume();

    speaker.volumeUp();
    speaker.showVolume();
  }
}


실행 결과
현재 음량: 90
음량을 증가합니다.
현재 음량: 100
음량을 증가할 수 없습니다. 최대 음량입니다.
현재 음량: 100


초기 음량 값을 90으로 지정했습니다.
그리고 음량을 높이는 메서드를 여러번 호출했습니다.
기대한 대로 음량은 100을 넘지 않았습니다.
프로젝트는 성공적으로 끝났습니다.

오랜 시간이 흘러 업그레이드 된 다음 버전의 스피커를 출시하게 되었습니다.
이때 새로운 개발자가 급하게 기존 코드를 이어받아서 개발하게 되었습니다.
참고로 새로운 개발자는 기존 요구사항을 잘 몰랐습니다.
코드를 실행해보니 이상하게 음량이 100이상 올라가지 않았습니다.
소리를 더 올리면 좋겠다고 생각한 개발자는 다양한 방면으로 고민했습니다.
Speaker 클래스를 보니 volume 필드를 직접 사용할 수 있었습니다.
volume 필드의 값을 200으로 설정하고 이 코드를 실행한 순간 스피터의 부풀들이 과부하가 걸리면서 폭발했습니다.

SpeakerMain - 필드 직접 접근 코드 추가
package access;

public class SpeakerMain {

  public static void main(String[] args) {
    Speaker speaker = new Speaker(90);
    speaker.showVolume();

    speaker.volumeUp();
    speaker.showVolume();

    speaker.volumeUp();
    speaker.showVolume();

    // 필드에 직접 접근
    System.out.println("volume 필드에 직접 접근 수정");
    speaker.volume = 200;
    speaker.showVolume();
  }
}


실행 결과
현재 음량: 90
음량을 증가합니다.
현재 음량: 100
음량을 증가할 수 없습니다. 최대 음량입니다.
현재 음량: 100
volume 필드에 직접 접근 수정
현재 음량: 200



  Speaker 객체를 사용하는 사용자는 Speaker의 volume 필드와 메서드에 모두 접근할 수 있습니다.
    
      앞서 volumeUp()과 같은 메서드를 만들어서 음량이 100을 넘지 못하도록 개발했지만 소용이 없습니다.
        
          왜냐하면 Speaker를 사용하는 입장에서는 volume 필드에 직접 접근해서 원하는 값을 설정할 수 있기 때문입니다.
        
      
    
  


“이런 문제를 근본적으로 해결하기 위해서는 volume 필드의 외부 접근을 막을 수 있는 방법이 필요합니다.”

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-26-usesOfPackage.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-26-usesOfPackage.html"><h1 class="title_post">☕️[Java] 패키지 활용</h1></a>
                        <a href="/2024/Java/2024-02-26-usesOfPackage.html" class="txt_post">
                            패키지 활용

실제 패키지가 어떤 식으로 사용되는지 예제를 통해서 알아봅시다.

  실제 동작하는 코드는 아니지만, 큰 애플리케이션은 대략 이런식으로 패키지를 구성한다고 이해하면 됩니다.



  참고로 이것은 정답이 가니고 프로젝트 규모와 아키텍처에 따라서 달라집니다.


전체 구조도

  com.helloshop
    
      user
        
          User
          UserService
        
      
      product
        
          Product
          ProductService
        
      
      order
        
          Order
          OrderService
          OrderHistory
        
      
    
  


com.helloshop.user 패키지
package com.helloshop.user;

public class User {
    String userId;
    String name;
}


package com.helloshop.user;

public class UserService {

}


com.helloshop.product 패키지
package com.helloshop.product;

public class Product {
  String productId;
  int price;
}


package com.helloshop.product;

public class ProductService {

}


com.helloshop.order 패키지
package com.helloshop.order;

import com.helloshop.product.Product;
import com.helloshop.user.User;

public class Order {
  User user;
  Product product;

  public Order(User user, Product product) {
    this.user = user;
    this.product = product;
  }
}


package com.helloshop.order;

import com.helloshop.product.Product;
import com.helloshop.user.User;

public class OrderService {

  public void order() {
    User user = new User();
    Product product = new Product();
    Order order = new Order(user, product);
  }
}


package com.helloshop.order;

public class OrderHistory {

}



  패키지를 구성할 때 서로 관련된 클래스는 하나의 패키지에 모으고, 관련이 적은 클래스는 다른 패키지로 분리하는 것이 좋습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-26-ruleOfpackage.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-26-ruleOfpackage.html"><h1 class="title_post">☕️[Java] 패키지 규칙</h1></a>
                        <a href="/2024/Java/2024-02-26-ruleOfpackage.html" class="txt_post">
                            패키지 규칙.

패키지 규칙.

  “패키지의 이름과 위치는 폴더(디렉토리) 위치와 같아야 합니다.(필수)”
  패키지 이름은 모두 소문자를 사용합니다.(관례)
  패키지의 앞 부분에는 일반적으로 회사의 도메인 이름을 거꾸로 사용합니다.
    
      예를 들어, com.company.myapp과 같이 사용합니다(관례)
        
          이 부분은 필수는 아닙니다. 하지만 수 많은 외부 라이브러리가 함께 사용되면 같은 패키지에 같은 클래스 이름이 존재할 수도 있습니다. 이렇게 도메인 이름을 거꾸로 사용하면 이런 문제를 방지할 수 있습니다.
          내가 오픈소스나 라이브러리를 만들어서 외부에 제공한다면 꼭 지키는 것이 좋습니다.
          내가 만들 애플리케이션을 다른 곳에 공유하지 않고, 직접 배포한다면 보통 문제가 되지 않습니다.
        
      
    
  


패키지와 계층 구조.
패키지는 보통 다음과 같이 계층 구조를 이룹니다.


  a
    
      b
      c
    
  
  이렇게 하면 다음과 같이 총 3개의 패키지가 존재하게 됩니다.
    
      a, a.b, a.c
    
  
  계층 구조상 a 패키지 하위에 a.b 패키지와 a.c 패키지가 있습니다.
    
      그런데 이것은 우리 눈에 보기에 계층 구조를 이룰 뿐입니다.
        
          a 패키지와 a.b,a.c 패키지는 서로 완전히 다른 패키지입니다.
            
              따라서 a 패키지의 클래스에서 a.b 패키지의 클래스가 필요하다면 import 해서 사용해야 합니다. 반대도 물론 마찬가지 입니다.
            
          
        
      
    
  


정리

  패키지가 계층 구조를 이루더라도 모든 패키지는 서로 다른 패키지입니다.
    
      물론 사람이 이해하기 쉽게 계층 구조를 잘 활용해서 패키지를 분류하는 것은 좋습니다.
        
          참고로 카테고리는 보통 큰 분류에서 세세한 분류로 점점 나누어집니다.
            
              패키지도 마찬가지입니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-25-packageImport.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-25-packageImport.html"><h1 class="title_post">☕️[Java] 패키지 - import</h1></a>
                        <a href="/2024/Java/2024-02-25-packageImport.html" class="txt_post">
                            패키지 - import

import

package pack;

public class PackageMain1 {

  public static void main(String[] args) {
   Data data = new Data();
   pack.a.User user = new pack.a.User();
  }
}


  위 코드와 같이 패키지가 다르다고 pack.a.User와 같이 항상 전체 경로를 적어주는 것은 불편합니다.
    
      “이때는 import를 사용하면 됩니다.”
    
  


PackageMain2
package pack;

import pack.a.User;

public class PackageMain2 {

  public static void main(String[] args) {
   Data data = new Data();
   User user = new User();
  }
}


실행 결과
패키지 pack Data 생성
패키지 pack.a 회원 생성



  코드에서 첫줄에는 package를 사용하고, 다음 줄에는 import를 사용할 수 있습니다.
    
      import를 사용하면 다른 패키지에 있는 클래스를 가져와서 사용할 수 있습니다.
        
          import를 사용한 덕분에 코드에서는 패키지 명을 생략하고 클래스 이름만 적을 수 있습니다.
        
      
    
  



  참고로 특정 패키지에 포함된 모든 클래스를 포함해서 사용하고 싶으면 import 시점에 *(별)을 사용하면 됩니다.


패키지 별(*)사용

tree 구조
* pack -&gt; [Package]
├──* Data -&gt; (Class)
├──* PackageMain1 -&gt; (Class)
├──* PackageMain1 -&gt; (Class)
└──* a -&gt; [Package]
   ├──* User -&gt; (Class)
   └──* UserManager -&gt; (Class)


package pack;

import pack.a.*; // pack.a의 모든 클래스 사용

public class PackageMain2 {

  public static void main(String[] args) {
   Data data = new Data();
   User user = new User(); // import 사용으로 패키지 명 생략 가능
   UserManager manager = new UserManager(); // import 사용으로 패키지 명 생략 가능
  }
}


  이렇게 하면 pack.a 패키지에 있는 모든 클래스를 패키지 명을 생략하고 사용할 수 있습니다.


실행 결과
패키지 pack Data 생성
패키지 pack.a 회원 생성
패키지 pack.a 회원 매니저 생성


클래스 이름 중복
패키지 덕분에 클래스 이름이 같아도 패키지 이름으로 구분해서 같은 이름의 클래스를 사용할 수 있습니다.

pack.a.User
pack.b.User


“이런 경우 클래스 이름이 둘다 User이지만 패키지 이름으로 대상을 구분할 수 있습니다.”

  이렇게 이름이 같은 경우 둘다 사용하고 싶으면 어떻게 해야할까요?


pack.b.User
package pack.b;

public class User {
  public  User() {
    System.out.println("패키지 pack.b 회원 생성");
  }
}


PackageMain3
package pack;

import pack.a.User;

public class PackageMain3 {

  public static void main(String[] args) {
    User userA = new User();
    pack.b.User userB = new pack.b.User();
  }
}



  같은 이름의 클래스가 있다면 import는 둘중 하나만 선택할 수 있습니다.
    
      이때는 자주 사용하는 클래스를 import하고 나머지를 패키지를 포함한 전체 경로를 적어주면 됩니다.
        
          물론 둘다 전체 경로를 적어준다면 import를 사용하지 않아도 됩니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-25-init(3).html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-25-init(3).html"><h1 class="title_post">☕️[Java] 기본 생성자</h1></a>
                        <a href="/2024/Java/2024-02-25-init(3).html" class="txt_post">
                            기본 생성자

아래의 코드를 봐봅시다.
생각해보면 아래의 코드는 생성자를 만들지 않았는데, 생성자를 호출한 적이 있습니다.
확인해 봅시다.
public class MemberInit {
    String name;
    int age;
    int grade;
}


public class MethodInitMain1 {
    public static void main(String[] args) {
        MemberInit member1 = new MemberInit();
        ...
    }
}


여기서 new MemberInit() 이 부분은 분명히 매개변수가 없는 다음과 같은 생성자가 필요할 것입니다.

public class MemberInit {
    String name;
    int age;
    int grade;
    
    MemberInit() { // 생성자 필요
    }
}


기본 생성자

  매개변수가 없는 생성자를 기본 생성자라 합니다.
  클래스에 생성자가 하나도 없으면 자바 컴파일러는 매개변수가 없고, 작동하는 코드가 없는 기본 생성자를 자동으로 만들어줍니다.
  생성자가 하나라도 있으면 자바는 기본 생성자를 만들지 않습니다.


MemberInt 클래스의 경우 생성자를 만들지 않았으므로 자바가 자동으로 기본 생성자를 만들어준 것입니다.

예제를 통해 기본 생성자를 확인해봅시다.

MemberDefault
package construct;

public class MemberDefault {
  String name;

  public MemberDefault() {
    System.out.println("생성자 호출");
  }
}



  참고: 자바가 자동으로 생성해주는 기본 생성자는 클래스와 같은 접근 제어자를 같습니다.


물론 다음과 같이 기본 생성자를 직접 정의해도 됩니다.
package construct;

public class MemberDefault {
  String name;

  MemberDefault() {
    System.out.println("생성자 호출");
  }
}


실행 경과
생성자 호출


기본 생성자를 왜 자동으로 만들어줄까?

  만약 가바에서 기본 생성자를 만들어주지 않는다면 생성자 기능이 필요하지 않은 경우에도 모든 클래스에 개발자가 직접 기본 생성자를 정의해야 합니다.
    
      생성자 기능을 사용하지 않는 경우도 많기 때문에 이런 편의 기능을 제공합니다.
    
  


정리

  생성자는 반드시 호출되어야 합니다.
  생성자가 없으면 기본 생성자가 제공됩니다.
  생성자가 하나라도 있으면 기본 생성자가 제공되지 않습니다. 이 경우 개발자가 정의한 생성자를 직접 호출해야합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-25-initOverloadingAndThis.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-25-initOverloadingAndThis.html"><h1 class="title_post">☕️[Java] 생성자 - 오버로딩 this()</h1></a>
                        <a href="/2024/Java/2024-02-25-initOverloadingAndThis.html" class="txt_post">
                            생성자 - 오버로딩 this()
생성자도 메서드 오버로딩처럼 매개변수만 다르게 해서 여러 생성자를 제공할 수 있습니다.

MemberConstruct - 생성자 추가
package construct;

public class MemberConstruct {
  String name;
  int age;
  int grade;

  // 추가
  MemberConstruct(String name, int age) {
    this.name = name;
    this.age = age;
    this.grade = 50;
  }

  MemberConstruct(String name, int age, int grade) {
    System.out.println("생성자 호출 name=" + name + ",age=" + age + ",grade=" + grade);
    this.name = name;
    this.age = age;
    this.grade = grade;
  }
}


기존 MemberConstruct에 생성자를 하나 추가해서 생성자가 2개가 되었습니다.
MemberConstruct(String name, int age)
MemberConstruct(String name, int age, int grade)


새로 추가한 생성자는 grade를 받지 않습니다. 대신에 grade는 50점이 됩니다.

package construct;

public class ConstructMain2 {

  public static void main(String[] args) {
    MemberConstruct member1 = new MemberConstruct("user1", 15, 90);
    MemberConstruct member2 = new MemberConstruct("user2", 16);

    MemberConstruct[] members = { member1, member2 };

    for (MemberConstruct member : members) {
      System.out.println("이름:" + member.name + " 나이:" + member.age + "성적:" + member.grade);
    }
  }
}


실행 결과
생성자 호출 name=user1,age=15,grade=90
이름:user1 나이:15성적:90
이름:user2 나이:16성적:50



  생성자를 오버로딩 한 덕분에 성적 입력이 꼭 필요한 경우에는 grade가 있는 생성자를 호출하면 되고, 그렇지 않은 경우에는 grade가 없는 생성자를 호출하면 됩니다.
    
      grade가 없는 생성자를 호출하면 성적은 50점이 됩니다.
    
  


this()
두 생성자를 비교해 보면 코드가 중복되는 부분이 있습니다.
public MemberConstruct(String name, int age) {
    this.name = name;
    this.age = age;
    this.grade = 50;
}

public MemberConstruct(String name, int age, int grade) {
    this.name = name; 
    this.age = age;
    this.grade = grade;
}


바로 다음 부분입니다.
this.name = name;
this.age = age;


이때 this()라는 기능을 사용하면 생성자 내부에서 자신의 생성자를 호출할 수 있습니다.


  참고로 this는 인스턴스 자신의 참조값을 가리킵니다. 그래서 자신의 생성자를 호출한다고 생각하면됩니다.


MemberConstruct - this() 사용
package construct;

public class MemberConstruct {
  String name;
  int age;
  int grade;

  // 추가
  MemberConstruct(String name, int age) {
    this(name, age, 50);
  }

  MemberConstruct(String name, int age, int grade) {
    System.out.println("생성자 호출 name=" + name + ",age=" + age + ",grade=" + grade);
    this.name = name;
    this.age = age;
    this.grade = grade;
  }
}



  이 코드는 첫번째 생성자 내부에서 두번째 생성자를 호출합니다.
    MemberConstruct(String name, int age) -&gt; MemberConstruct(String name, int age, int grade)
    
  
  this()를 사용하면 생성자 내부에서 다른 생성자를 호출할 수 있습니다.
    
      이 부분을 잘 활용하면 지금과 같이 중복을 제거할 수 있습니다.
        
          물론 실행 결과는 기존과 같습니다.
        
      
    
  


this() 규칙

  this()는 생성자 코드의 첫줄에만 작성할 수 있습니다.


다음은 규칙 위반입니다.
이 경우 컴파일 오류가 발생합니다.
public MemberConstruct(String name, int age) {
    Sytem.out.println("go");
    this(name, age, 50);
}


  this()가 생성자 코드의 첫줄에 사용되지 않았습니다.



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-25-packageStart.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-25-packageStart.html"><h1 class="title_post">☕️[Java] 패키지 - 시작</h1></a>
                        <a href="/2024/Java/2024-02-25-packageStart.html" class="txt_post">
                            패키지 - 시작.

쇼핑몰 시스템을 개발한다고 가정해봅시다.
다음과 같이 프로그램이 매우 작고 단순해서 클래스가 몇개 없다면 크게 고민할 거리가 없겠지만, 기능이 점점 추가되어서 프로그램이 아주 커지게 된다면 어떻게 될까요?

아주 작은 프로그램
Order
User
Product


큰 프로그램
User
UserManager
UserHistory
Product
ProductCatalog
ProductImage
Order
OrderService
OrderHistory
ShoppingCart
CartItem
Payment
PaymentHistory
Shipment
ShipmentTracker



  매우 많은 클래스가 등장하면서 관련 있는 기능들을 분류해서 관리하고 싶을 것입니다.
    
      컴퓨터는 보통 파일을 분류하기 위해 폴더, 디렉토리라는 개념을 제공합니다.
        
          자바도 이런 개념을 제공하는데, 이것이 바로 패키지입니다.
        
      
    
  


다음과 같이 카테고리를 만들고 분류해봅시다.

* user
    * User
    * UserManager
    * UserHistory
* product    
    * Product
    * ProductCatalog
    * ProductImage
* order
    * Order
    * OrderService
    * OrderHistory
* cart    
    * ShoppingCart
    * CartItem
* payment    
    * Payment
    * PaymentHistory
* shipping    
    * Shipment    
    * ShipmentTracker



  여기서 user, product 등이 바로 패키지입니다.
    
      그리고 해당 패키지 안에 관련된 자바 클래스들을 넣으면 됩니다.
    
  
  패키지(package)는 이름 그대로 물건을 운송하기 위한 포장 용기나 그 포장 묶음을 뜻합니다.


패키지 사용
패키지 사용법을 코드로 확인해봅시다.
패키지를 먼저 만들고 그 다음에 클래스를 만들어야 합니다.
패키지 위치에 주의해야합니다.

pcak.Data
package pack;

public class Data {
    public Data() {
        System.out.println("패키지 pack Data 생성")
    }
}


  패키지를 사용하는 경우 항상 코드 첫 줄에 package pack과 같이 패키지 이름을 적어주어야 합니다.
  여기서는 pack 패키지에 Data 클래스를 만들었습니다.
  이후에 Data 인스턴스가 생성되면 생성자를 통해 정보를 출력합니다.


pack.a.User
package pack.a;

public class User {

  public User() {
    System.out.println("패키지 pack.a 회원 생성");
  }
}


  pack 하위에 a라는 패키지를 먼저 만듭니다.
  pack.a 패키지에 User 클래스를 만들었습니다.
  이후에 User 인스턴스가 생성되면 생성자를 통해 정보를 출력합니다.



  참고: 생성자에 public을 사용했습니다. 다른 패키지에서 이 클래스의 생성자를 호출하려면 public을 사용해야합니다.


pack.PackageMain1

package pack;

public class PackageMain1 {

  public static void main(String[] args) {
   Data data = new Data();
   pack.a.User user = new pack.a.User();
  }
}


  pack 패키지 위치에 PackageMain1 클래스를 만들었습니다.


실행 결과
패키지 pack Data 생성
패키지 pack.a 회원 생성



  사용자와 같은 위치: PackageMain1과 Data는 같은 pack이라는 패키지에 소속되어 있습니다. 이렇게 같은 패키지에 있는 경우에는 패키지 경로를 생략해도 됩니다.
  사용자와 다른 위치: PackageMain1과 User는 서로 다른 패키지입니다. 이렇게 패키지가 다르면 pack.a.User와 같이 패키지 전체 경로를 포함해서 클래스를 적어주어야 합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-24-init(2).html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-24-init(2).html"><h1 class="title_post">☕️[Java] 생성자 - 도입</h1></a>
                        <a href="/2024/Java/2024-02-24-init(2).html" class="txt_post">
                            생성자 - 도입

  프로그래밍을 하다보면 객체를 생성하고 이후에 바로 초기값을 할당해야 하는 경우가 많습니다.
    
      따라서 앞서 initMember(...)와 같은 메서드를 매번 만들어야 합니다.
        
          “그래서 대부분의 객체 지향 언어는 객체를 생성하자마자 즉시 필요한 기능을 좀 더 편리하게 수행할 수 있도록 생성자라는 기능을 제공합니다.”
            
              생성자를 사용하면 객체를 생성하는 시점에 즉시 필요한 기능을 수행할 수 있습니다.
            
          
        
      
    
  


생성자는 앞서 살펴본 initMember(...)와 같이 메서드와 유사하지만 몇가지 다른 특징이 있습니다.

아래 코드를 보면서 이해해봅시다.

MemberConstruct
package construct;

public class MemberConstruct {
  String name;
  int age;
  int grade;

  MemberConstruct(String name, int age, int grade) {
    System.out.println("생성자 호출 name=" + name + ",age=" + age + ",grade=" + grade);
    this.name = name;
    this.age = age;
    this.grade = grade;
  }
}


“다음 부분이 바로 생성자입니다.”
MemberConstruct(String name, int age, int grade) {
    System.out.println("생성자 호출 name=" + name + ",age=" + age + ",grade=" + grade);
    this.name = name;
    this.age = age;
    this.grade = grade;
}

“생성자는 메서드와 비슷하지만 다음과 같은 차이가 있습니다.”

  생성자의 이름은 클래스 이름과 같아야 합니다. 따라서 첫 글자도 대문자로 시작합니다.
  생성자는 반환 타입이 없습니다. 비워두워야 합니다.
  나머지는 메서드와 같습니다.


ConstructMain1
package construct;

public class ConstructMain1 {

  public static void main(String[] args) {
    MemberConstruct member1 = new MemberConstruct("user1", 15, 90);
    MemberConstruct member2 = new MemberConstruct("user2", 16, 80);

    MemberConstruct[] members = { member1, member2 };

    for (MemberConstruct member : members) {
      System.out.println("이름:" + member.name + " 나이:" + member.age + "성적:" + member.grade);
    }
  }
}


실행 결과
생성자 호출 name=user1,age=15,grade=90
생성자 호출 name=user2,age=16,grade=80
이름:user1 나이:15성적:90
이름:user2 나이:16성적:80


생성자 호출

  생성자는 인스턴스를 생성하고 나서 즉시 호출됩니다.
    
      생성자를 호출하는 방법은 다음 코드와 같이 new 명령어 다음에 생성자 이름과 매개변수에 맞추어 인수를 전달하면 됩니다.
        new 생성자이름(생성자에 맞는 인수 목록)
new 클래스이름(생성자에 맞는 인수 목록)
        
      
    
  



  참고로 생성자 이름이 클래스 이름이기 때문에 둘다 맞는 표현입니다.


new MemberConstruct("user1", 15, 90)


  이렇게 하면 인스턴스를 생성하고 즉시 해당 생성자를 호출합니다.
    
      여기서는 Memeber 인스턴스를 생성하고 바로 MemberConstruct(String name, int age, int grade) 생성자를 호출합니다.
    
  



  참고로 new 키워드를 사용해서 객체를 생성할 때 마지막에 괄호()도 포함해야 하는 이유가 바로 생성자 때문입니다. 객체를 생성하면서 동시에 생성자를 호출한다는 의미를 포함합니다.


생성자 장점
중복 호출 제거
생성자가 없던 시절에는 생성 직후에 어떤 작업을 수행하기 위해 다음과 같이 메서드를 직접 한번 더 호출해야 했습니다.
“생성자 덕분에 객체를 생성하면서 동시에 생성 직후에 필요한 작업을 한번에 처리할 수 있게 되었습니다.”
// 생성자 등장 전
MemberInit member = new MemberInit();
member.initMember("user1", 15, 90);

// 생성자 등장 후
MemberConstruct member = new MemberConstruct("user1", 15, 90);


제약 - 생성자 호출 필수
위 코드에서 생성자 등장 전 코드를 보며 이해해봅시다.
“이 경우 initMember(...)를 실수로 호출하지 않으면 어떻게 될까요?”

  이 메서드를 실수로 호출하지 않아도 프로그램은 작동합니다.
    
      하지만 학생의 이름과 나이, 성적 데이터가 없는 상태로 프로그램이 작동하게 됩니다.
    
  


“만약에 이 값들을 필수로 반드시 입력해야 한다면, 시스템에 큰 문제가 발생할 수 있습니다.”

  결국 아무 정보가 없는 유령 학생이 시스템 내부에 등장하게 됩니다.


생성자의 진짜 장점은 객체를 생성할 때 직접 정의한 생성자가 있다면 “직접 정의한 생성자를 반드시 호출” 해야 한다는 점입니다.


  참고로 생성자를 메서드 오버로딩 처럼 여러개 정의할 수 있는데, 이 경우에는 하나만 호출하면 됩니다.


“MemberConstruct 클래스의 경우 다음 생성자를 직접 정의했기 때문에 직접 정의한 생성자를 반드시 호출해야 합니다.”

MemberConstruct(String name, int age, int grade) { ... }


다음과 같이 직접 정의한 생성자를 호출하지 않으면 컴파일 오류가 발생합니다.
MemberConstruct member3 = new MemberConstruct(); // 컴파일 오류 발생
member3.name = "user1";


컴파일 오류 메시지
java: constructor MemberConstruct in class construct.MemberConstruct cannot be applied to given types;
  required: java.lang.String,int,int
  found:    no arguments
  reason: actual and formal argument lists differ in length


컴파일 오류는 IDE에서 즉시 확인할 수 있는 좋은 오류입니다.

  이 경우 개발자는 객체를 생성할 때, 직접 정의한 생성자를 필수로 호출해야 한다는 것을 바로 알 수 있습니다.
    
      그래서 필요한 생성자를 찾아서 다음과 같이 호출할 것입니다.
        MemberConstruct member = new MemberConstruct("user1", 15, 90);
        
      
    
  


“생성자 덕분에 학생의 이름, 나이, 성적은 항상 필수로 입력하게 됩니다.”

  따라서 아무 정보가 없는 유령 회원이 시스템 내부에 등장할 가능성을 원천 차단합니다.


“생성자를 사용하면 필수값 입력을 보장할 수 있습니다.”


  참고: 좋은 프로그램은 무한한 자유도가 주어지는 프로그램이 아니라 적절한 제약이 있는 프로그램입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-24-this.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-24-this.html"><h1 class="title_post">☕️[Java] this</h1></a>
                        <a href="/2024/Java/2024-02-24-this.html" class="txt_post">
                            this

Member - initMember() 추가
package construct;

public class Member {
  String name;
  int age;
  int grade;

  // 추가
  void initMember( String name, int age, int grade) {
    this.name = name;
    this.age = age;
    this.grade = grade;
  }
}


MethodInitMain3
package construct;

public class MethodInitMain3 {

  public static void main(String[] args) {
    Member member1 = new Member();
    member1.initMember("user1", 15, 90);

    Member member2 = new Member();
    member2.initMember("user2", 16, 80);

    Member[] members = { member1, member2 };

    for (Member member : members) {
      System.out.println("아름:" + member.name + " 나이:" + member.age + " 성적:" + member.grade);
    }
  }
}



  initMember(...)는 Member에 초기값 설정 기능을 제공하는 메서드입니다.


다음과 같이 메서드를 호출하면 객체의 멤버 변수에 인자로 넘어온 값을 채웁니다.

  member1.initMember("user1", 15, 90)


this
Member의 코드를 다시 봐봅시다.

  initMember(String name...)의 코드를 보면 메서드의 매개변수에 정의한 String name과 Member의 멤버 변수의 이름이 String name으로 둘다 똑같습니다.
    
      나머지 변수 이름도 name, age, grade로 모두 같습니다.
    
  


“멤버 변수와 메스더의 매개변수의 이름이 같으면 둘을 어떨게 구분해야 할까요?”

  이 경우 멤버 변수보다 매개변수가 코드 블럭의 안쪽에 있기 때문에 “매개변수가 우선 순위를” 가집니다.
    
      따라서 initMember(String name, ...) 메서드 안에서 name이라고 적으면 매개변수에 접근하게 됩니다.
    
  
  멤버 변수에 접근하려면 앞에 this.이라고 해주면 됩니다.
    
      여기서 this는 인스턴스 자신의 참조값을 가리킵니다.
    
  


진행 과정
this.name = name; // 1. 오른쪽의 name은 매개변수에 접근
this.name = "user"; // 2. name 매개변수의 값 사용
x001.name = "user"; // 3. this.은 인스턴스 자신의 참조값을 뜻함. 따라서 인스턴스의 멤버 변수에 접근.


this 제거
만약 이 예제에서 this를 제거하면 어떻게 될까요?
this.name = name


다음과 같이 수정하면 name은 둘다 매개변수를 뜻하게 됩니다.
따라서 멤버변수의 값이 변경되지 않습니다.
name = name;


정리

  매개변수의 이름과 멤버 변수의 이름이 같은 경우 this를 사용해서 둘을 명확하게 구분해야 합니다.
  this는 인스턴스 자신을 가리킵니다.


this의 생략

  this는 생략할 수 있습니다.
    
      이 경우 변수를 찾을 때 가까운 지역변수(매개변수도 지역변수입니다.)를 먼저 찾고 없으면 그 다음으로 멤버 변수를 찾습니다.
        
          멤버 변수도 없으면 오루가 발생합니다.
        
      
    
  


다음 예제는 필드 이름과 매개변수의 이름이 서로 다릅니다.

MemberThis
package construct;

public class MemberThis {
  String nameField;

  void initMember(String nameParameter) {
    nameField = nameParameter;
  }
}

“예를 들어서 nameField는 앞에 this가 없어도 멤버 변수에 접근합니다.”

  nameField는 먼저 지역변수(매개변수)에서 같은 이름이 있는지 찾습니다.
    
      이 경우 없으므로 멤버 변수에서 찾습니다.
    
  
  nameParametr는 먼저 지역변수(매개변수)에서 같은 이름이 있는지 찾습니다.
    
      이 경우 매개변수가 있으므로 매개변수를 사용합니다.
    
  


this와 코딩 스타일
“다음과 같이 멤버 변수에 접근하는 경우에 항상 this를 사용하는 코딩 스타일도 있습니다.”
MemberThis
package construct;

public class MemberThis {
  String nameField;

  void initMember(String nameParameter) {
    this.nameField = nameParameter;
  }
}


  this.nameField를 보면 this를 생략할 수 있지만, 생략하지 않고 사용해도 됩니다.
    
      이렇게 this를 사용하면 이 코드가 멤버 변수를 사용한다는 것을 눈으로 쉽게 확인할 수 있습니다.
        
          그래서 과거에 이런 스타일을 많이 사용하기도 했습니다.
            
              쉽게 이야기해서 this를 강제로 사용해서, 지역 변수(매개변수)와 멤버 변수를 눈에 보이도록 구분하는 것입니다.
            
          
        
      
    
  


“하지만 최근에는 IDE가 발전하면서 IDE가 멤버 변수와 지역 변수를 색상으로 구분해줍니다.”

  이런 점 때문에 this는 꼭 필요한 경우에만 사용해도 충분하다 생각한다.
    
      예를 들어 이런 경우 this.name = name -&gt; name이 중복되는 것.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-24-init(1).html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-24-init(1).html"><h1 class="title_post">☕️[Java] 생성자 - 필요한 이유</h1></a>
                        <a href="/2024/Java/2024-02-24-init(1).html" class="txt_post">
                            생성자 - 필요한 이유.
객체를 생성하는 시점에 어떤 작업을 하고 싶다면 “생성자(Construct)” 을 이용하면 됩니다.

생성자를 알아보기 전에 먼저 생성자가 왜 필요한지 코드로 간단히 알아봅시다.

MemberInit
package construct;

public class MemberInit {
  String name;
  int age;
  int grade;
}


MethodInitMain1
package construct;

public class MethodInitMain1 {

  public static void main(String[] args) {
    MemberInit member1 = new MemberInit();
    member1.name = "user1";
    member1.age = 15;
    member1.grade = 90;

    MemberInit member2 = new MemberInit();
    member2.name = "user2";
    member2.age = 16;
    member2.grade = 80;

    MemberInit[] members = { member1, member2 };

    for (MemberInit member : members) {
      System.out.println("아름:" + member.name + " 나이:" + member.age + " 성적:" + member.grade);
    }
  }
}


실행 결과
아름:user1 나이:15 성적:90
아름:user2 나이:16 성적:80


회원 객체를 생성하고 나면 name, age, grade 같은 변수에 초기값을 설정합니다.
아마도 회원 객체를 제대로 사용하기 위해서는 객체를 생성하자 마자 이런 초기값을 설정해야 할 것입니다.
이 코드에는 회원의 초기값을 설정하는 부분이 계속 반복됩니다.
메서드를 사용해서 반복을 제거해봅시다.

MethodInitMain2
package construct;

public class MethodInitMain2 {

  public static void main(String[] args) {
    MemberInit member1 = new MemberInit();
    initMember(member1, "user1", 15, 90);

    MemberInit member2 = new MemberInit();
    initMember(member2, "user2", 16, 80);

    MemberInit[] members = { member1, member2 };

    for (MemberInit member : members) {
      System.out.println("아름:" + member.name + " 나이:" + member.age + " 성적:" + member.grade);
    }
  }

  static void initMember(MemberInit member, String name, int age, int grade) {
    member.name = name;
    member.age = age;
    member.grade = grade;
  }
}


  initMember(...) 메서드를 사용해서 반복을 제거했습니다.
    
      그런데 이 메서드는 대부분 MemberInit 객체의 멤버 변수를 사용합니다.
    
  


우리는 앞서 객체 지향에 대해서 학습했습니다.

  이런 경우 속성과 기능을 한 곳에 두는 것이 더 나은 방법입니다.
    
      쉽게 이야기해서 MemberInit이 자기 자신의 데이터를 변경하는 기능(메서드)을 제공하는 것이 좋습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-23-procedure-oriented-programming(3).html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-23-procedure-oriented-programming(3).html"><h1 class="title_post">☕️[Java] 절차 지향 프로그래밍(3)</h1></a>
                        <a href="/2024/Java/2024-02-23-procedure-oriented-programming(3).html" class="txt_post">
                            절차 지향 프로그래밍(3) - 메서드 추출

코드를 보면 다음과 같이 중복되는 부분들이 있습니다.
// 볼륨 증가
data.volume++;
System.out.println("음악 플레이어 볼륨:" + data.volume);

// 볼륨 증가
data.volume++;
System.out.println("음악 플레이어 볼륨:" + data.volume);


그리고 각각의 기능들은 이후에 재사용 될 가능성이 높습니다.

  음악 플레이어 켜기, 끄기
  볼륨 증가, 감소
  음악 플레이어 상태 출력


“메서드를 사용해서 각각의 기능을 구분해봅시다.”

MusicPlayerMain3
package oop1;

public class MusicPlayerMain3 {

  public static void main(String[] args) {
    MusicPlayerData data = new MusicPlayerData();
    // 음악 플레이어 켜기
    on(data);
    // 볼륨 증가
    volumeUp(data);
    // 볼륨 증가
    volumeUp(data);
    // 볼륨 감소
    volumeDown(data);
    // 음악 플레이어 상태
    showStatus(data);
    // 음악 플레이어 끄기
    off(data);
  }

  static void on(MusicPlayerData data) {
    data.isOn = true;
    System.out.println("음악 플레이어를 시작합니다.");
  }

  static void off(MusicPlayerData data) {
    data.isOn = false;
    System.out.println("음악 플레이어를 종료합니다.");
  }

  static void volumeUp(MusicPlayerData data) {
    data.volume++;
    System.out.println("음악 플레이어 볼륨:" + data.volume);
  }

  static void volumeDown(MusicPlayerData data) {
    data.volume--;
    System.out.println("음악 플레이어 볼륨:" + data.volume);
  }

  static void showStatus(MusicPlayerData data) {
    System.out.println("음악 플레이어 상태 확인");
    if (data.isOn) {
      System.out.println("음악 플레이어 ON, 볼륨:" + data.volume);
    } else {
      System.out.println("음악 플레이어 OFF");
    }
  }
}


각각의 기능을 메서도로 만든 덕분에 각각의 기능이 모듈화 되었습니다.
덕분에 다음과 같은 장점이 생겼습니다.

  중복 제거: 로직 중복이 제거되었습니다. 같은 로직이 필요하면 해당 메서드를 여러번 호출하면 됩니다.
  변경 영향 범위: 기능을 수정할 때 해당 메서드 내부만 변경하면 됩니다.
  메서드 이름 추가: 메서드 이름을 통해 코드를 더 쉽게 이해할 수 있습니다.



  모듈화: 쉽게 이야기해서 레고 블럭을 생각하면 됩니다. 필요한 블럭을 가져다 꼽아서 사용할 수 있습니다. 여기서는 음악 플레이어의 기능이 필요하면 해당 기능을 메서드 호출 만으로 손쉽게 사용할 수 있습니다. 이제 음악 플레이어와 관련된 메서드를 조립해서 프로그램을 작성할 수 있습니다.


절차 지향 프로그래밍의 한계
지금까지 클래스를 사용해서 관련된 데이터를 하나로 묶고, 또 메서드를 사용해서 각각의 기능을 모듈화했습니다.
덕분에 상당히 깔끔하고 읽기 좋고, 유지보수 하기 좋은 코드를 작성할 수 있었습니다.
하지만 여기서 더 개선할 수는 없을까요?

작성한 코드의 한계는 바로 데이터와 기능이 분리되어 있다는 점입니다.
음악 플레이어의 데이터는 MusicPlayerData에 있는데, 그 데이터를 사용하는 기능은 MusicPlayerMain3에 있는 각각의 메서드에 분리되어 있습니다.
그래서 음악 플레이어와 관련된 데이터는 MusicPlayerData를 사용해야 하고, 음악 플레이어와 관련된 기능은 MusicPlayerMain3의 각 메서드를 사용해야 합니다.

데이터와 그 데이터를 사용하는 기능은 매우 밀접하게 연관되어 있습니다.
각각의 메서드를 보면 대부분 MusicPlayerData의 데이터를 사용합니다.
따라서 이후에 관련 데이터가 변경되면 MusicPlayerMain3 부분의 메서드들도 함께 변경해야 합니다.
그리고 이렇게 데이터와 기능이 분리되어 있으면 유지보수 관점에서도 관리 포인트가 2곳으로 늘어납니다.

“객체 지향 프로그래밍이 나오기 전까지는 지금과 같이 데이터와 기능이 분리되어 있었습니다.”

  따라서 지금과 같은 코드가 최선이였습니다.
    
      하지만 객체 지향 프로그래밍이 나오면서 데이터와 기능을 온전히 하나로 묶어서 사용할 수 있게 되었습니다.
    
  


“데이터와 기능을 하나로 온전히 묶는다는 것이 어떤 의미인지 이해하기 위해 간단한 예시 코드를 만들어봅시다”

  이 예시 코드는 다음 포스팅에 이어집니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-23-object-oriented-programming.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-23-object-oriented-programming.html"><h1 class="title_post">☕️[Java] 객체 지향 프로그래밍</h1></a>
                        <a href="/2024/Java/2024-02-23-object-oriented-programming.html" class="txt_post">
                            객체 지향 프로그래밍.
지금까지 개발한 음악 플레이어는 데이터와 기능이 분리되어 있습니다.
이제 데이터와 기능을 하나로 묶어서 음악 플레이어라는 개념을 온전히 하나의 클래스에 담아보도록 하겠습니다.
프로그램을 작성하는 절차도 중요하지만 “지금은 음악 플레이어라는 개념을 객체로 온전히 만드는 것이 더 중요합니다.”
음악 플레이어라는 객체를 지향해봅시다!
그러기 위해서는 프로그램의 실행 순서 보다는 “음악 플레이어 클래스를 만드는 것 자체에 집중해야 합니다.”
“음악 플레이어가 어떤 속성(데이터)을 가지고 어떤 기능(메서드)을 제공하는지 이 부분에 초점을 맞추어야 합니다.”
지금부터 우리는 음악 플레이어를 개발하는 개발자가 될 것입니다.
이것을 어떨게 사용할지는 분리해서 생각해봅시다.
쉽게 이야기해서 음악 플레이어를 만들어서 제공하는 개발자와 음악 플레이어를 사용하는 개발자가 분리되어 있다고 생각하면 됩니다.

음악 플레이어

  속성: volume, isOn
  기능: on(), off(), volumeUp(), volumeDown(), showStatus()


이것을 가지고 음악 플레이어를 만들어봅시다.

객체 지향 음악 플레이어.

MusicPlayer

package oop1;

public class MusicPlayer {

  int volume = 0;
  boolean isOn = false;

  void on() {
    isOn = true;
    System.out.println("음악 플레이어를 시작합니다.");
  }

  void off() {
    isOn = false;
    System.out.println("음악 플레이어를 종료합니다.");
  }

  void volumeUp() {
    volume++;
    System.out.println("음악 플레이어 볼륨:" + volume);
  }

  void volumeDown() {
    volume--;
    System.out.println("음악 플레이어 볼륨:" + volume);
  }

  void showStatus() {
    System.out.println("음악 플레이어 상태 확인");
    if (isOn) {
      System.out.println("음악 플레이어 ON, 볼륨:" + volume);
    } else {
      System.out.println("음악 플레이어 OFF");
    }
  }
}



  MusicPlayer 클래스에 음악 플레이어에 필요한 속성과 기능을 모두 정의했습니다.
    
      이제 음악 플레이어가 필요한 곳에서 이 클래스만 있으면 온전한 음악 플레이어를 생성해서 사용할 수 있습니다.
      음악 플레이어를 사용하는데 필요한 모든 속성과 기능이 하나의 클래스에 포함되어 있습니다.
    
  


MusicPlayerMain4
package oop1;

public class MusicPlayerMain4 {

  public static void main(String[] args) {
    MusicPlayer player = new MusicPlayer();
    // 음악 플레이어 켜기
    player.on();
    // 볼륨 증가
    player.volumeUp();
    // 볼륨 증가
    player.volumeUp();
    // 볼륨 감소
    player.volumeDown();
    // 음악 플레이어 상태
    player.showStatus();
    // 음악 플레이어 끄기
    player.off();
  }
}


실행 결과
음악 플레이어를 시작합니다.
음악 플레이어 볼륨:1
음악 플레이어 볼륨:2
음악 플레이어 볼륨:1
음악 플레이어 상태 확인
음악 플레이어 ON, 볼륨:1
음악 플레이어를 종료합니다.


“MusicPlayer를 사용하는 코드를 봅시다.”
MusicPlayer 객체를 생성하고 필요한 기능(메서드)을 호출하기만 하면 됩니다. 
필요한 모든 것은 MusicPlayer 안에 들어있습니다.


  MusicPlayer를 사용하는 입장에서는 MusicPlayer의 데이터인 volumn, isOn 같은 데이터는 전혀 사용하지 않습니다.
  MusicPlayer를 사용하는 입장에서는 이제 MusicPlayer 내부에 어떤 속성(데이터)이 있는지 전혀 몰라도 됩니다.
    
      MusicPlayer를 사용하는 입장에서는 단순하게 MusicPlayer가 제공하는 기능 중에 필요한 기능을 호출해서 사용하기만 하면 됩니다.
    
  


캡슐화
MusicPlayer를 보면 음악 플레이어를 구성하기 위한 속성과 기능이 마치 하나의 캡슐에 쌓여있는 것 같습니다.
“이렇게 속성과 기능을 하나로 묶어서 필요한 기능을 메서드를 통해 외부에 제공하는 것을 캡슐화라 합니다.”

“객체 지향 프로그래밍” 덕분에 음악 플레이어 객체를 사용하는 입장에서 진짜 음악 플레이어를 만들고 사용하는 것 처럼 친숙하게 느껴집니다.

  그래서 코드가 더 읽기 쉬운 것은 물론이고, 속성과 기능이 한 곳에 있기 때문에 변경도 더 쉬워집니다.
    
      예를 들어서 MusicPlayer 내부 코드가 변하는 경우에 다른 코드는 변경하지 않아도 됩니다.
        
          MusicPlayer의 volume이라는 필드 이름이 다른 이름으로 변한다고 할 때 MusicPlayer 내부만 변경하면 됩니다.
          또 음악 플레이어가 내부에서 출력하는 메시지를 변경할 때도 MusicPlayer 내부만 변경하면 됩니다.
            
              이 경우 MusicPlayer를 사용하는 개발자는 코드를 전혀 변경하지 않아도 됩니다.
                
                  물론 외부에서 호출하는 MusicPlayer의 메서드 이름을 변경한다면 MusicPlayer를 사용하는 곳의 코드도 변경해야 합니다.
                
              
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-23-classAndMethod.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-23-classAndMethod.html"><h1 class="title_post">☕️[Java] 클래스와 메서드</h1></a>
                        <a href="/2024/Java/2024-02-23-classAndMethod.html" class="txt_post">
                            클래스와 메서드.

클래스는 데이터인 멤버 변수 뿐 아니라 기능 역할을 하는 메서드도 포함할 수 있습니다.

먼저 멤버 변수만 존재하는 클래스로 간단한 코드를 작성해봅시다.

ValueData
package oop1;

public class ValueData {
  int value;
}


ValueDataMain
package oop1;

public class ValueDataMain {

  public static void main(String[] args) {
    ValueData valueData = new ValueData();
    add(valueData);
    add(valueData);
    add(valueData);
    System.out.println("최종 숫자=" + valueData.value);
  }

  static void add(ValueData valueData) {
    valueData.value++;
    System.out.println("숫자 증가 value=" + valueData.value);
  }
}


실행 결과
숫자 증가 value=1
숫자 증가 value=2
숫자 증가 value=3
최종 숫자=3


  ValueData 라는 인스턴스를 생성하고 외부에서 ValueData.value에 접근해 숫자를 하나씩 증가시키는 단순한 코드입니다.
    
      코드를 보면 데이터인 value와 value의 값을 증가시키는 기능은 add() 메서드가 서로 분리되어 있습니다.
    
  
  자바 같은 객체 지향 언어는 클래스 내부에 속성(데이터)과 기능(메서드)을 함께 포함할 수 있습니다.
    
      클래스 내부에 멤버 변수 뿐만 아니라 메서드도 함께 포함할 수 있다는 뜻 입니다.
    
  


“이번에는 숫자를 증가시키는 기능도 클래스에 함께 포함해서 새로운 클래스를 정의해봅시다.”

package oop1;

public class ValueData {
  int value;

  void add() {
    value++;
    System.out.println("숫자 증가 value=" + value);
  }
}


  이 클래스에는 데이터인 value와 해당 데이터를 사용하는 기능인 add() 메서드를 함께 정의했습니다.


이제 이 클래스가 어떻게 사용되는지 확인해봅시다.


  참고: 여기서 만드는 add() 메서드에는 static 키워드를 사용하지 않습니다.
메서드는 객체를 생성해야 호출할 수 있습니다. 그런데 static이 붙으면 객체를 생성하지 않고도 메서드를 호출할 수 있습니다.
static에 대한 자세한 내용은 추후에 포스팅하겠습니다.


ValueObjectMain

package oop1;

public class ValueObjectMain {

  public static void main(String[] args) {
    ValueData valueData = new ValueData();
    valueData.add();
    valueData.add();
    valueData.add();
    System.out.println("최종 숫자=" + valueData.value);
  }
}


실행 결과
숫자 증가 value=1
숫자 증가 value=2
숫자 증가 value=3
최종 숫자=3


인스턴스 생성
ValueData valueData = new ValueData();


  valueData라는 객체를 생성했습니다. 이 객체는 멤버 변수 뿐만 아니라 내분에 기능을 수행하는 add() 메서드도 함께 존재합니다.


인스턴스의 메서드 호출

  인스턴스의 메서드를 호출하는 방법은 멤버 변수를 사용하는 방법과 동일합니다.
    
      .(dot)을 찍어서 객체 접근한 다음에 원하는 메서드를 호출하면 됩니다.
        valueData.add(); // 1
x002.add(); // 2 x002 ValueData 인스턴스에 있는 add() 메서드를 호출합니다.
        
      
    
  
  3: add() 메서드를 호출하면 메서드 내부에서 value++을 호출하게 됩니다.
    
      이때 value에 접근해야 하는데, 기본으로 본인 인스턴스에 있는 멤버 변수에 접근합니다.
        
          본인 인스턴스가 x002 참조값을 사용하므로 자기 자신인 x002.value에 접근하게 됩니다.
        
      
    
  
  4: ++ 연산으로 value의 값을 하나 증가시킵니다.


정리

  클래스는 속성(데이터, 멤버 변수)과 기능(메서드)을 정의할 수 있습니다.
  객체는 자신의 메서드를 통해 자신의 멤버 변수에 접근할 수 있습니다.
    
      객체의 메서드 내부에서 접근하는 멤버 변수는 객체 자신의 멤버 변수입니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-23-OOPvsPOPsummary.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-23-OOPvsPOPsummary.html"><h1 class="title_post">☕️[Java] 객체 지향 프로그래밍 vs 절차 지향 프로그래밍</h1></a>
                        <a href="/2024/Java/2024-02-23-OOPvsPOPsummary.html" class="txt_post">
                            객체 지향 프로그래밍 vs 절차 지향 프로그래밍

  객체 지향 프로그래밍과 절차 지향 프로그래밍은 서로 대치되는 개념이 아닙니다.
    
      객체 지향이라도 프로그램의 작동 순서는 중요합니다.
        
          다만 어디에 더 초점을 맞추는가에 둘의 차이가 있습니다.
        
      
    
  
  객체 지향의 경우 객체의 설계와 관계를 중시합니다.
    
      반면 절차 지향의 경우 데이터와 기능이 분리되어 있고, 프로그램이 어떻게 작동하는지 그 순서에 초점을 맞춥니다.
    
  


절차 지향 프로그래밍

  절차 지향 프로그래밍은 이름 그대로 절차를 지향합니다.
    
      쉽게 이야기해서 실행 순서를 중요하게 생각하는 방식입니다.
    
  
  절차 지향 프로그래밍은 프로그램의 흐름을 순차적으로 따르며 처리하는 방식입니다.
    
      즉, “어떻게”를 중심으로 프로그래밍 합니다.
    
  


객체 지향 프로그래밍

  객체 지향 프로그래밍은 이름 그대로 객체를 지향합니다.
    
      쉽게 이야기해서 객체를 중요하게 생각하는 방식입니다.
    
  
  객체 지향 프로그래밍은 실제 세계의 사물이나 사건을 객체로 보고, 이러한 객제들 간의 상호작용을 중심으로 프로그래밍하는 방식입니다.
    
      즉 “무엇을” 중심으로 프로그래밍 합니다.
    
  


둘의 중요한 차이

  절차 지향은 데이터와 해당 데이터에 대한 처리 방식이 분리되어 있습니다.
    
      반면 객체 지향에서는 데이터와 그 데이터에 대한 행동(메서드)이 하나의 ‘객체’ 안에 함께 포함되어 있습니다.
    
  


객체란?

  세상의 모든 사물을 단순하게 추상화해보면 속성(데이터)과 기능(메서드) 딱 2가지로 설명할 수 있습니다.


자동차

  속성: 색상, 속도
  기능: 엑셀, 브레이크, 문 열기, 문 닫기


동물

  속성: 색상, 키, 온도
  기능: 먹는다, 걷는다


게임 캐릭터

  속성: 레벨, 경험치, 소유한 아이템들
  기능: 이동, 공격, 아이템 획득


“객체 지향 프로그래밍은 모든 사물을 속성과 기능을 가진 객체로 생각하는 것 입니다.”

  객체에는 속성과 기능만 존재합니다.
    
      이렇게 단순화하면 세상에 있는 객체들을 컴퓨터 프로그램으로 쉽게 설계할 수 있습니다.
        
          이런 장점들 덕분에 지금은 객체 지향 프로그래밍이 가장 많이 사용됩니다.
            
              참고로 실세계와 객체가 항상 1:1로 매칭되는 것은 아닙니다.
            
          
        
      
    
  


객체 지향의 특징은 속성과 기능을 하나로 묶는 것 뿐만 아니라 캡슐화, 상속, 다형성, 추상화, 메시지 전달 같은 다양한 특징들이 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-23-procedure-oriented-programming(2).html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-23-procedure-oriented-programming(2).html"><h1 class="title_post">☕️[Java] 절차 지향 프로그래밍(2)</h1></a>
                        <a href="/2024/Java/2024-02-23-procedure-oriented-programming(2).html" class="txt_post">
                            절차 지향 프로그래밍(2) - 데이터 묶음
“절차 지향 프로그래밍(1)에 작성한 코드에 클래스를 도입합시다.”

MusicPlayerData라는 클래스를 만들고, 음악 플레이어에 사용되는 클래스를 만들고, 음악 플레이어에 사용되는 데이터들을 여기에 묶어서 멤버 변수로 사용해봅시다.

MusicPlayerData
package oop1;

public class MusicPlayerData {
  int volume = 0;
  boolean isOn = false;
}


  음악 플레이어에 사용되는 volume, isOn 속성을 MusicPlayerData의 멤버 변수에 포함했습니다.


MusicPlayerMain2
package oop1;

public class MusicPlayerMain2 {

  public static void main(String[] args) {
    MusicPlayerData data = new MusicPlayerData();

    // 음악 플레이어 켜기
    data.isOn = true;
    System.out.println("음악 플레이어를 시작합니다.");

    // 볼륨 증가
    data.volume++;
    System.out.println("음악 플레이어 볼륨:" + data.volume);
    // 볼륨 증가
    data.volume++;
    System.out.println("음악 플레이어 볼륨:" + data.volume);
    // 볼륨 감소
    data.volume--;
    System.out.println("음악 플레이어 볼륨:" + data.volume);
    // 음악 플레이어 상태
    System.out.println("음악 플레이어 상태 확인");
    if (data.isOn) {
      System.out.println("음악 플레이어 ON, 볼륨:" + data.volume);
    } else {
      System.out.println("음악 플레이어 OFF");
    }
    // 음악 플레이어 끄기
    data.isOn = false;
    System.out.println("음악 플레이어를 종료합니다.");
  }
}


  음악 플레이어와 관련된 데이터는 MusicPlayerData 클래스에 존재합니다.
    
      이 클래스를 사용하도록 기존 로직을 변경했습니다.
        
          이후에 프로그램 로직이 더 복잡해져서 다양한 변수들이 추가되더라도 음악 플레이어와 관련된 변수들은 MusicPlayerData data 객체에 속해있으므로 쉽게 구분할 수 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-22-procedure-oriented-programming(1).html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-22-procedure-oriented-programming(1).html"><h1 class="title_post">☕️[Java] 절차 지향 프로그래밍(1)</h1></a>
                        <a href="/2024/Java/2024-02-22-procedure-oriented-programming(1).html" class="txt_post">
                            객체지향 프로그래밍(1)

절차 지향 프로그래밍 vs 객체 지향 프로그래밍

  프로그래밍 방식은 크게 절차 지향 프로그래밍과 객체 지향 프로그래밍으로 나눌 수 있습니다.


절차 지향 프로그래밍

  절차 지향 프로그래밍은 이름 그대로 절차를 지향합니다.
    
      쉽게 이야기해서 실행 순서를 중요하게 생각하는 방식입니다.
    
  
  절차 지향 프로그래밍은 프로그램의 흐름을 순차적으로 따르며 처리하는 방식입니다.
    
      즉, “어떻게”를 중심으로 프로그래밍 합니다.
    
  


객체 지향 프로그래밍

  객체 지향 프로그래밍은 이름 그대로 객체를 지향합니다.
    
      쉽게 이야기해서 객체를 중요하게 생각하는 방식입니다.
    
  
  객체 지향 프로그래밍은 실제 세계의 사물이나 사건을 객체로 보고, 이러한 객체들 간의 상호작용을 중심으로 프로그래밍하는 방식입니다.
    
      즉, “무엇을” 중심으로 프로그래밍 합니다.
    
  


둘의 중요한 차이

  절차 지향은 데이터와 해당 데이터에 대한 처리 방식이 분리되어 있습니다.
  반변 객체 지향에서는 데이터와 그 데이터에 대한 행동(메서드)이 하나의 ‘객체’안에 함께 포함되어 있습니다.


절차 지향에서 객체 지향으로 점진적으로 코드를 변경해보면서 객체 지향 프로그래밍을 이해해봅시다.

“음악 플레이어를 만들어보고 그것을 보면서 이해해봅시다.”

요구 사항:

  음악 플레이어를 켜고 끌 수 있어야 합니다.
  음악 플레이어의 볼륨을 증가, 감소할 수 있어야 합니다.
  음악 플레이어의 상태를 확인할 수 있어야 합니다.


예시 출력:
음악 플레이어를 시작합니다.
음악 플레이어 볼륨:1
음악 플레이어 볼륨:2
음악 플레이어 볼륨:1
음악 플레이어 상태 확인
음악 플레이어 ON, 볼륨:1
음악 플레이어를 종료합니다.


절차 지향 음악 플레이어1
package oop1;

public class MusicPlayerMain1 {

  public static void main(String[] args) {
    int volume = 0;
    boolean isOn = false;

    // 음악 플레이어 켜기
    isOn = true;
    System.out.println("음악 플레이어를 시작합니다.");

    // 볼륨 증가
    volume++;
    System.out.println("음악 플레이어 볼륨:" + volume);
    // 볼륨 증가
    volume++;
    System.out.println("음악 플레이어 볼륨:" + volume);
    // 볼륨 감소
    volume--;
    System.out.println("음악 플레이어 볼륨:" + volume);
    // 음악 플레이어 상태
    System.out.println("음악 플레이어 상태 확인");
    if (isOn) {
      System.out.println("음악 플레이어 ON, 볼륨:" + volume);
    } else {
      System.out.println("음악 플레이어 OFF");
    }
    // 음악 플레이어 끄기
    isOn = false;
    System.out.println("음악 플레이어를 종료합니다.");
  }
}


실행 결과
음악 플레이어를 시작합니다.
음악 플레이어 볼륨:1
음악 플레이어 볼륨:2
음악 플레이어 볼륨:1
음악 플레이어 상태 확인
음악 플레이어 ON, 볼륨:1
음악 플레이어를 종료합니다.


“순서대로 프로그램이 작동하도록 단순하게 작성했습니다. 이 코드를 점진적으로 변경해봅시다.”


  다음 포스트인 “절차 지향 프로그래밍(2)”에서 이어서 포스팅하겠습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-22-NullPointerException.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-22-NullPointerException.html"><h1 class="title_post">☕️[Java] NullPointerException</h1></a>
                        <a href="/2024/Java/2024-02-22-NullPointerException.html" class="txt_post">
                            NullPointerException
택배를 보낼 때 주소지 없이 택배를 발송하려면 어떤 문제가 발생할까요?
만약 참조값 없이 객체를 찾아가면 어떤 문제가 발생할까요?

  이 경우 NullPointerExecption이라는 예외가 발생하는데, 개발자를 가장 많이 괴롭히는 예외입니다.
  NullPointerExecption은 이름 그대로 null을 가리리키다(Pointer)인데, 이때 발생하는 예외(Exception)입니다.
  
    null은 없다는 뜻이므로 결국 주소가 없는 곳을 찾아갈 때 발생하는 예외입니다.
  
  객체를 참조할 때는 .(dot)을 사용합니다.
    
      이렇게 하면 참조값을 사용해서 해당 객체를 찾아갈 수 있습니다.
      그런데 참조값이 null이라면 값이 없다는 뜻이므로, 찾아갈 수 있는 객체(인스턴스)가 없습니다.
        
          NullPointerExecption은 이처럼 null에 .(dot)을 찍었을 때 발생합니다.
        
      
    
  


예제를 통해서 확인해봅시다.
package ref;

public class NullMain2 {

  public static void main(String[] args) {
    Data data = null;
    data.value = 10; // NullPointerException 예외 발생
    System.out.println("data = " + data.value);
  }
}


  data 참조형 변수에는 null 값이 들어가 있습니다.
    
      그런데 data.value = 10 이라고 하면 어떻게 될까요?
    
  


data.value = 10;
null.value = 10 // data에는 null 값이 들어있습니다.


  결과적으로 null 값은 참조할 주소가 존재하지 않는다는 뜻입니다.
    
      따라서 참조할 객체 인스턴스가 존재하지 않으므로 다음과 같이 java.lang.NullPointerExecption이 발생하고, 프로그램이 종료됩니다.
        
          참고로 예외가 발생했기 때문에 그 다음 로직은 수행되지 않습니다.
        
      
    
  


실행 결과
Exception in thread "main" java.lang.NullPointerException: Cannot assign field "value" because "data" is null at ref.NullMain2.main(NullMain2.java:7)


멤버 변수와 null
앞선 예제와 같이 지역 변수의 경우에는 null 문제를 파악하는 것이 어렵지 않습니다.

  다음과 같이 멤버 변수가 null인 경우에는 주의가 필요합니다.


Data
package ref;

public class Data {
  int value;
}


BigData
package ref;

public class BigData {
  Data data;
  int count;
}


  BigData 클래스는 Data data, int count 두 변수를 가집니다.


NullMain3
package ref;

public class NullMain3 {

  public static void main(String[] args) {
    BigData bigData = new BigData();
    System.out.println("bigData.count=" + bigData.count);
    System.out.println("bigData.data=" + bigData.data);

    // NullPointerException
    System.out.println("bigData.data.value=" + bigData.data.value);
  }
}


실행 결과
bigData.count=0
bigData.data=null
Exception in thread "main" java.lang.NullPointerException: Cannot read field "value" because "bigData.data" is null at ref.NullMain3.main(NullMain3.java:11)


BigData를 생성하면 BigData의 인스턴스가 생성됩니다.
이때 BigData 인스턴스의 멤버 변수에 초기화가 일어나는데, BigData의 data 멤버 변수는 참조형이므로 null로 초기화 됩니다.
count 멤버 변수는 숫자이므로 0으로 초기화가 됩니다.

  bigData.count를 출력하면 0이 출력됩니다.
  bigData.data를 출력하면 참조값인 null이 출력됩니다. 이 변수는 아직 아무것도 참조하고 있지 않습니다.
  bigData.data.value를 출력하면 data의 값이 null이므로 null에 .(dot)을 찍게 되고, 따라서 참조할 곳이 없으므로 NullPointerException 예외가 발생하게 됩니다.


예외 발생 과정
bigData.data.value
x001.data.value // bigData는 x001 참조값을 가집니다.
null.value // x001.data는 null 값을 가집니다.
NullPointerExecption // null 값에 .(dot)을 찍으면 예외가 발생합니다.


“이 문제를 해결하려면 Data 인스턴스를 만들고 BigData.data 멤버 변수에 참조값을 할당하면 됩니다.”

NullMain4
package ref;

public class NullMain4 {

  public static void main(String[] args) {
    BigData bigData = new BigData();
    bigData.data = new Data();
    
    System.out.println("bigData.count=" + bigData.count);
    System.out.println("bigData.data=" + bigData.data);

    System.out.println("bigData.data.value=" + bigData.data.value);
  }
}


실행 결과
bigData.count=0
bigData.data=ref.Data@3a71f4dd
bigData.data.value=0


실행 과정
bigData.data.value
x001.data.value // bigData는 x001 참조값을 가집니다.
x002.value // x001.data는 x002 값을 가집니다.
0 // 최종 결과



  참고: xoo1과 x002 는 sudo code입니다.


정리

  “NullPointerException이 발생하면 null값에 .(dot)을 찍었다고 생각하면 문제를 쉽게 찾을 수 있습니다.”


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-21-buildSystem.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-21-buildSystem.html"><h1 class="title_post">🍃[Spring] Gradle과 Maven</h1></a>
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-21-buildSystem.html" class="txt_post">
                            Gradle.

  Gradle은 오픈 소스 빌드 자동화 시스템으로, 다양한 프로그래밍 언어와 프로젝트에 대해 유연한 빌드 스크립트를 제공합니다.
  Groovy나 Kotlin DSL을 사용하여 빌드 스크립트를 작성하며, 이는 개발자가 읽기 쉽고, 강력하며, 사용자 정의가 가능한 빌드를 구성할 수 있게 합니다.
  Gradle은 의존성 관리와 멀티 프로젝트 빌드를 지원하며, 이전에 실행된 작업의 출력을 캐시하여 빌드 시간을 단축시키는 증분 빌드 기능도 제공합니다.
  Android 개발을 위한 공식 빌드 시스템으로도 널리 사용됩니다.


Maven.

  Maven은 Java 프로젝트의 빌드, 문서화, 보고, 의존성 관리 등을 자동화하기 위한 또 다른 오픈 소스 빌드 도구입니다.
  XML 형식의 pom.xml 파일을 사용하여 프로젝트 구성과 의존성을 관리합니다.
  Maven은 중앙 저장소에서 필요한 라이브러리와 플러그인을 자동으로 다운로드하고, 프로젝트의 라이프사이클(컴파일, 테스트, 패키징 등)을 관리하는 표준화된 방법을 제공합니다.
    
      이는 프로젝트의 일관성을 유지하고, 빌드 과정을 간소화하는 데 도움이 됩니다.
    
  


Gradle과 Maven의 차이점.

  빌드 스크립트 구문 : Gradle은 Groovy나 Kotlin으로 작성된 빌드 스크립트를 사용하는 반면, Maven은 XML 기반의 pom.xml 파일을 사용합니다. Gradle의 DSL은 Maven의 XML보다 간결하고, 읽기 쉽습니다.
  성능 : Gradle은 증분 빌드와 빌드 캐시 기능을 통해 Maven보다 빌드 시간을 단축시킬 수 있습니다. Maven은 Gradle에 비해 이러한 최적화 기능이 부족합니다.
  유연성 : Gradle은 빌드 스크립트에 로직을 추가하여 빌드 프로세스를 매우 세밀하게 제어할 수 있습니다. Maven은 더 엄격한 라이프사이클과 구조를 따르며, 커스터마이징이 제한적입니다.
  플러그인 생태계 : Maven은 오랜 기간 동안 사용되어 왔기 때문에 방대한 양의 플러그인이 있지만, Gradle도 활발히 성장하고 있는 플러그인 생태계를 갖추고 있습니다.
  프로젝트 구조 : Maven은 규약을 중시하는 구조로, 프로젝트의 디렉토리 구조가 일정합니다. Gradle은 더 많은 구성 가능성을 제공하지만, 이는 동시에 프로젝트 설정이 복잡해질 수 있음을 의미합니다.


결론적으로, Gradler과 Maven은 각각의 장단점을 가지고 있으며, 프로젝트의 요구사항과 개발 팀의 선호도에 따라 적합한 도구를 선택하는 것이 중요합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-02-21-systemClassification.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-02-21-systemClassification.html"><h1 class="title_post">🌐[Network] 시스템의 구분</h1></a>
                        <a href="/2024/Network/2024-02-21-systemClassification.html" class="txt_post">
                            시스템의 구분

네트워크를 구성하는 시스템이 반드시 일반 컴퓨터처럼 복잡한 기능을 수행해야 하는 것은 아니지만, 데이터 전송 기능을 포함하여 일정 정도의 컴퓨팅 기능을 보유합니다.

네트워크 시스템은 수행 기능에 따라 다음과 같이 다양한 명칭으로 부를 수 있습니다.


  노드
    
      노드(Node)는 컴퓨터 이론 분야에서 특정 시스템을 가리키는 가장 일반적인 용어로 사용됩니다.
      인터넷에서도 상호 연결된 시스템을 표현할 수 있는 가장 포괄적 의미로 사용되므로 데이터를 주고 받을 수 있는 모든 시스템을 통칭합니다.
      노드는 인터넷 내부를 구성하는 라우터와 인터넷 바깥쪽에 연결되어 데이터를 주고받는 호스트로 구분됩니다.
    
  
  라우터
    
      라우터(Router)는 인터넷 내부를 구성하며, 기본으로 데이터 전송 기능을 포함합니다.
      라우터의 주요 역할은 데이터 중개 기능이며, 인터넷 바깥쪽에 연결된 호스트들 사이의 데이터 전송이 인터넷 내부에서 최적의 경로를 통하여 이루어지도록 합니다.
    
  
  호스트
    
      호스트(Host)는 인터넷 바깥쪽에 연결되어 일반 사용자들의 네트워크 접속 창구 역할을 합니다.
      일반적인 컴퓨팅 기능을 갖춘 호스트는 네트워크 응용 프로그램을 실행할 수 있고, 사용자는 이 프로그램을 이용하여 다양한 인터넷 서비스를 제공받습니다.
      호스트는 호스트 사이에 제공되는 서비스를 기준으로 클라이언트와 서버로 나눌 수 있습니다.
    
  
  클라이언트와 서버
    
      클라이언트(Client)는 임의의 인터넷 서비스를 이용하는 응용 프로그램이고, 서버(Server)는 서비스를 제공하는 응용 프로그램입니다.
      클라이언트와 서버의 개념은 서비스 단위로 이루어지므로 임의의 호스트가 클라이언트나 서버로 고정되지는 않습니다.
        
          이용하는 서비느싀 종류에 따라 클라이언트가 될 수도 있고, 서버가 될 수도 있습니다.
            
              그러므로 특정 서비스틑 기준으로 상태적인 관점에서 클라이언트와 서버라는 용어를 사용합니다.
            
          
        
      
    
  
  일반적으로 응용 프로그램 혹은 서비스 단위가 아닌 호스트 단위로도 클라이언트와 서버를 사용하기도 합니다.
    
      즉, 다양한 서비스를 제공하는 목적으로 특화된 호스트의 경우 호스트 자체를 서버라 부르기도 합니다.
    
  
  서버는 클라이언트보다 먼저 실행 상태가 되어 클라이언트의 요청에 대기해야 합니다.
    
      그리고 영원히 종료하지 않으면서 클라이언트의 요청이 있을 때마다 서비스를 반복해서 제공합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-21-referenceTypesAndMethodCalls.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-21-referenceTypesAndMethodCalls.html"><h1 class="title_post">☕️[Java] 참조형과 메서드 호출 - 활용</h1></a>
                        <a href="/2024/Java/2024-02-21-referenceTypesAndMethodCalls.html" class="txt_post">
                            참조형과 메서드 호출 - 활용

아래의 코드 class1.ClassStart3 코드에는 중복되는 부분이 2가지가 있습니다.

  name, age, grade에 값을 할당하는 부분.
  학생 정보를 출력하는 부분.


package class1;

public class ClassStart3 {

  public static void main(String[] args) {
    Student student1;
    student1 = new Student();
    student1.name = "학생1";
    student1.age = 15;
    student1.grade = 90;

    Student student2 = new Student();
    student2.name = "학생2";
    student2.age = 16;
    student2.grade = 80;

    System.out.println("이름:" + student1.name + " 나이:" + student1.age + " 성적:" + student1.grade);
    System.out.println("이름:" + student2.name + " 나이:" + student2.age + " 성적:" + student2.grade);
  }
}


“이러한 중복은 메서드를 통해 손쉽게 제거할 수 있습니다.”

메서드에 객체 전달
다음과 같이 코드를 작성해봅시다.

Student
package ref;

public class Student {
  String name;
  int age;
  int grade;
}


  ref 패키지에도 Student 클래스를 만듭니다.


Method1
package ref;

public class Method1 {

  public static void main(String[] args) {
    Student student1 = new Student();
    initStudent(student1, "학생1", 15, 90);

    Student student2 = new Student();
    initStudent(student2, "학생2", 16, 80);

    printStudent(student1);
    printStudent(student2);

  }

  static void initStudent(Student student, String name, int age, int grade) {
    student.name = name;
    student.age = age;
    student.grade = grade;
  }

  static void printStudent(Student student) {
    System.out.println("이름:" + student.name + " 나이:" + student.age + " 성적:" + student.grade);
  }
}


참조형은 메서드를 호출할 때 참조값을 전달합니다.
따라서 메서드 내부에서 전달된 참조값을 통해 객체의 값을 변경하거나, 값을 읽어서 사용할 수 있습니다.

  initStudent(Student student, ...) : 전달한 학생 객체의 필드에 값을 설정합니다.
  printStudent(Student student, ...) : 전달한 학생 객체의 필드 값을 읽어서 출력합니다.


initStudent() 메서드 호출 분석

initStudent(Student student, String name, int age, int grade) {
    student.name = name;
    student.age = age;
    student.grade = grade;
}



  student1이 참조하는 Student 인스턴스에 값을 편리하게 할당하고 싶어서 initStudent() 메서드를 만들었습니다.
    
      이 메서드를 호출하면서 student1을 전달합니다.
        
          그러면 student1의 참조값(30f39991)이 매개변수 student에 전달됩니다.
            
              이 참조값을 통해 initStudent() 메서드 안에서 student1이 참조하는 것과 동일한 30f39991 Student 인스턴스에 접근하고 값을 변경할 수 있습니다.
            
          
        
      
    
  



  참고: 30f39991은 실제 student1의 참조값입니다.
System.out.println("student1 참조값 : " + student1); 의 결과가 student1 참조값 : ref.Student@30f39991 이였습니다.


주의!

package ref;

import class1 Student;

public class Method1 {
    ...
}


  import class1.Student;이 선언되어 있으면 안됩니다.
    
      이렇게 되면 class1 패키지에서 선언한 Student를 사용하게 됩니다.
        
          이 경우에는 접근 제어자 때문에 컴파일 오류가 발생합니다.
            
              만약 선언되어 있다면 삭제해야 합니다. 삭제하면 같은 패키지에 있는 ref.Student를 사용합니다.
            
          
        
      
    
  


메서드에서 객체 반환
조금 더 코드를 리팩토링 시켜봅시다. 다음 코드에도 중복이 있습니다.

Student student1 = new Student();
initStudent(student1, "학생1", 15, 90);
    
Student student2 = new Student();
initStudent(student2, "학생2", 16, 80);


바로 객체를 생성하고, 초기값을 설정하는 부분입니다.

  이렇게 2번 반복되는 부분을 하나로 합져봅시다.


“다음과 같이 기존 코드를 변경해봅시다.”

Method2
package ref;

public class Method2 {

  public static void main(String[] args) {
    Student student1 = createStudent("학생1", 15, 90);
    Student student2 = createStudent("학생2", 16, 80);

    printStudent(student1);
    printStudent(student2);
  }

  static Student createStudent(String name, int age, int grade) {
    Student student = new Student();
    student.name = name;
    student.age = age;
    student.grade = grade;
    return student;
  }

  static void printStudent(Student student) {
    System.out.println("이름:" + student.name + " 나이:" + student.age + " 성적:" + student.grade);
  }
}


createStudent() 라는 메서드를 만들고 객체를 생성하는 부분도 이 메서드안에 함께 포함했습니다.
“이제 이 메서드 하나로 객체의 생성과 초기값 설정을 모두 처리합니다.”

  그런데 메서드 안에서 객체를 생성했기 때문에 만들어진 객체를 메서드 밖에서 사용할 수 있게 돌려주어야 합니다.
    
      그래야 메서드 밖에서 이 객체를 사용할 수 있습니다.
        
          메서드는 호출 결과를 반환(return)을 할 수 있습니다.
            
              메서드의 반환 기능을 사용해서 만들어진 객체의 참조값을 메서드 밖으로 반환하면 됩니다.
            
          
        
      
    
  


createStudent() 메서드 호출 분석
createStudent(String name, int age, int grade) {
    Student student = new Student();
    student.name = name;
    student.age = age;
    student.grade = grade;
    return student;
}


  메서드 내부에서 인스턴스를 생성한 후에 참조값을 메서드 외부로 반환했습니다.
    
      이 참조값만 있으면 해당 인스턴스에 접근할 수 있습니다.
        
          여기서는 student1에 참조값을 보관하고 사용합니다.
        
      
    
  


진행 과정
Student student1 = createStudent("학생1", 15, 90); // 메서드 호출후 결과 반환
Student student1 = student(30f39991); // 참조형인 student를 반환
Student student1 = 30f39991; // student의 참조값 대입
student1 = 30f39991;



  createStudent() 는 생성한 Student 인스턴스의 참조값을 반환합니다.
    
      이렇게 반환된 참조값을 student1 변수에 저장합니다.
        
          앞으로는 student1을 통해 Student 인스턴스를 사용할 수 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-21-null.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-21-null.html"><h1 class="title_post">☕️[Java] null</h1></a>
                        <a href="/2024/Java/2024-02-21-null.html" class="txt_post">
                            null
친구에게 책을 보내려고 합니다.
우체국 택배를 보내려고 할 때 책은 준비가 되었지만, 깜빡하고 친구에게 주소를 물어보지 못했습니다.
즉, 보낼 주소지가 아직 결정되지 않았습니다.
이 때, 보낼 주소지가 결정될 때 까지는 주소지를 비워두어야 할 것 입니다.


  참조형 변수에는 항상 객체가 있는 위치를 가리키는 참조값이 들어갑니다.
    
      그런데 아직 가리키는 대상이 없거나, 가리키는 대상을 나중에 입력하고 싶을 경우에는 어떻게 해야할까요?
    
  
  참조형 변수에서 아직 가리키는 대상이 없다면 null이라는 특별한 값을 넣어둘 수 있습니다.
    
      null은 값이 존재하지 않는, 없다는 뜻 입니다.
    
  


“코드를 통해서 null 값에 대해 알아봅시다.”

Data
package ref;

public class Data {
  int value;
}


NullMain1
package ref;

public class NullMain1 {

  public static void main(String[] args) {
    Data data = null;
    System.out.println("1. data = " + data);
    data = new Data();
    System.out.println("2. data = " + data);
    data = null;
    System.out.println("3. data = " + data);
  }
}


실행 결과
1. data = null
2. data = ref.Data@30f39991
3. data = null


Data data = null;


  Data 타입을 받을 수 있는 참조형 변수 data를 만들었습니다.
    
      그리고 여기에 null 값을 할당했습니다.
        
          따라서 data 변수에는 아직 가리키는 객체가 없다는 뜻입니다.
        
      
    
  


data = new Data();



  이후에 새로운 Data 객체를 생성해서 그 참조값을 data 변수에 할당했습니다.
    
      이제 data 변수가 참조할 객체가 존재합니다.
        
          여기서 Data 인스턴스의 value 값은 0으로 초기화 되어있습니다.
        
      
    
  


data = null;



  마지막에는 data에 다시 null 값을 할당했습니다.
    
      이렇게 하면 data 변수는 앞서 만든 Data 인스턴스를 더는 참조하지 않습니다.
    
  


“GC(Garbage Collection) - 아무도 참조하지 않는 인스턴스의 최후”

마지막에 data에 null을 할당했습니다.
따라서 앞서 생성한 x001(sudo 참조값) Data 인스턴스를 더는 아무도 참조하지 않습니다.
이렇게 아무도 참조하지 않게 되면 x001이라는 참조값을 다시 구할 방법이 없습니다.
따라서 해당 인스턴스에 다시 접근할 방법이 없습니다.

  이렇게 아무도 참조하지 않는 인스턴스는 사용되지 않고 메모리 용량만 차지할 뿐입니다.


C와 같은 과거 프로그래밍 언어는 개발자가 직접 명령어를 사용해서 인스턴스를 메모리에서 제거해야 했습니다.
만약 실수로 인스턴스 삭제를 누락할 경우, 메모리에 사용하지 않는 객체가 가득해져서 메모리 부족 오류가 발생하게 됩니다.

“자바는 이런 과정을 자동으로 처리해줍니다.”

  아무도 참조하지 않는 인스턴스가 있으면 JVM의 GC(가비지 컬렉션)가 더 이상 사용하지 않는 인스턴스라 판단하고 해당 인스턴스를 자동으로 메모리에서 제거해줍니다.


“객체는 해당 객체를 참조하는 곳이 있으면, JVM이 종료할 때 까지 계속 생존합니다.”

  그런데 중간에 해당 객체를 참조하는 곳이 모두 사라지면 그때 JVM은 필요 없는 객체로 판단하고 GC(가비지 컬렉션)를 사용해서 제거합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-21-variableAndInit.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-21-variableAndInit.html"><h1 class="title_post">☕️[Java] 변수와 초기화</h1></a>
                        <a href="/2024/Java/2024-02-21-variableAndInit.html" class="txt_post">
                            변수와 초기화

변수의 종류

  멤버 변수(필드): 클래스에 선언.
  지역 변수: 메서드에 선언, 매개변수도 지역 변수의 한 종류입니다.


멤버 변수, 필드 예시
public class Student {
    String name;
    int age;
    int grade;
}


  name, age, grade 는 멤버 변수입니다.


지역 변수 예시
public class ClassStart3 {
    public static void main(String[] args) {
        Student student1;
        student1 = new Student();
        Student student2 = new Student();
    }
}


  student1, student2는 지역 변수입니다.


public class MethodChange1 {

  public static void main(String[] args) {
    int a = 10;
    System.out.println("메서드 호출 전: a = " + a);
    changePrimitive(a);
    System.out.println("메서드 호출 후: a = " + a);
  }

  static void changePrimitive(int x) {
   x = 20;
  }
}



  a, x(매개변수, Parameter)는 지역변수입니다.
  지역 변수는 이름 그대로 “특정 지역에서만 사용되는 변수라는 뜻입니다.”
    
      예를 들어서 변수 x는 changePrimitive() 메서드의 블록에서만 사용됩니다.
        
          changePrimitive() 메서드가 끝나면 제거됩니다.
          a 변수도 마찬가지입니다. main() 메서드가 끝나면 제거됩니다.
        
      
    
  


변수의 값 초기화

  멤버 변수: 자동 초기화.
    
      인스턴스의 멤버 변수는 인스턴스를 생성할 때 자동으로 초기화됩니다.
      숫자(int) = 0, boolean = false, 참조형 = null(null 값은 참조할 대상이 없다는 뜻으로 사용됩니다.)
      개발자가 초기값을 직접 지정할 수 있습니다.
    
  
  지역 변수: 수동 초기화.
    
      지역 변수는 항상 직접 초기화해야 합니다.
    
  


“멤버 변수의 초기화를 살펴봅시다”
InitData
package ref;

public class InitData {
    int value1; // 초기화 하지 않음
    int value2 = 10; // 10으로 초기화
}



  value1은 초기값을 지정하지 않았고, value2는 초기값을 10으로 지정했습니다.


InitMain
package ref;

public class initMain {

  public static void main(String[] args) {
    InitData data = new InitData();
    System.out.println("value1 = " + data.value1);
    System.out.println("value2 = " + data.value2);
  }
}


실행 결과
value1 = 0
value2 = 10



  value1은 초기값을 지정하지 않았지만 멤버 변수는 자동으로 초기화 됩니다.
    
      숫자는 0으로 초기화됩니다.
    
  
  value2는 10으로 초기값을 지정해두었기 때문에 객체를 생성할 때 10으로 초기화됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-21-referenceAndPrimitive3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-21-referenceAndPrimitive3.html"><h1 class="title_post">☕️[Java] 기본형과 참조형(3) - 메서드 호출</h1></a>
                        <a href="/2024/Java/2024-02-21-referenceAndPrimitive3.html" class="txt_post">
                            기본형과 참조형(3) - 메서드 호출

대원칙: 자바는 항상 변수의 값을 복사해서 대입합니다.

  자바에서 변수에 값을 대입하는 것은 변수에 들어 있는 값을 복사해서 대입하는 것입니다.
  기본형, 참조형 모두 항상 변수에 있는 값을 복사해서 대입합니다.
    
      기본형이면 변수에 들어 있는 실제 사용하는 값을 복사해서 대입합니다.
      참조형이면 변수에 들어 있는 참조값을 복사해서 대입합니다.
    
  


메서드 호출도 마찬가지입니다. 메서드를 호출할 때 사용하는 매개변수(parameter)도 결국 변수일 뿐 입니다.

  따라서 메서드를 호출할 때 매개변수(parameter)에 값을 전달하는 것도 앞서 설명한 내용과 같이 값을 복사해서 전달합니다.


다음 예시 코드를 봐봅시다.

기본형과 메서드 호출
package ref;

public class MethodChange1 {

  public static void main(String[] args) {
    int a = 10;
    System.out.println("메서드 호출 전: a = " + a);
    changePrimitive(a);
    System.out.println("메서드 호출 후: a = " + a);
  }

  static void changePrimitive(int x) {
   x = 20;
  }
}


실행 결과
메서드 호출 전: a = 10
메서드 호출 후: a = 10


1. 메서드 호출

  메서드를 호출할 때 매개변수 x에 변수 a의 값을 전달합니다.
    int x = a
    
  
  이 코드는 다음과 같이 해석할 수 있습니다.
    
      자바에서 변수에 값을 대입하는 것은 항상 값을 복사해서 대입합니다 따라서 변수 a,x 각각 숫자 10을 가지고 있습니다.
    
  


2. 메서드 안에서 값을 변경
int a = 10;
changePrimitive(a);


  메서드 안에서 x = 20으로 새로운 값을 대입합니다.
    
      결과적으로 x의 값만 20으로 변경되고, a의 값은 10으로 유지됩니다.
    
  


3. 메서드 종료
int a = 10;
changePrimitive(a);


  메서드 종료후 값을 확인해보면 a는 10이 출력되는 것을 확인할 수 있습니다.
    
      참고로 메서드가 종료되면 매개변수 x는 제거됩니다.
    
  


참조형과 메서드 호출
package ref;

public class MethodChange2 {

  public static void main(String[] args) {
    Data dataA = new Data();
    dataA.value = 10;
    System.out.println("메서드 호출 전: dataA.value = " + dataA.value);
    changeReference(dataA);
    System.out.println("메서드 호출 전: dataA.value = " + dataA.value);
  }

  static void changeReference(Data dataX) {
    dataX.value = 20;
  }
}


실행 결과
메서드 호출 전: dataA.value = 10
메서드 호출 전: dataA.value = 20


1. 메서드 호출


  메서드를 호출할 때 매개변수 dataX에 변수 dataA의 값을 전달합니다.
    
      이 코드는 다음과 같이 해석할 수 있습니다.
        int dataX = dataA;
        
      
    
  
  자바에서 변수에 값을 대입하는 것은 항상 값을 복사해서 대입합니다.
    
      변수 dataA는 참조값 x001을 가지고 있다는 가정하에 dataA는 참조값을 복사해서 전달합니다.
        
          따라서 변수 dataA, dataX 둘 다 같은 참조값인 x001을 가지게 됩니다.
            
              이제 dataX를 통해서도 x001에 있는 Data 인스턴스에 접근할 수 있습니다.
            
          
        
      
    
  


2. 메서드 안에서 값을 변경
static void changeReference(Data dataX) {
    dataX.value = 20;
}


  메서드 안에서 dataX.value = 20으로 새로운 값을 대입합니다.
    
      참조값을 통해 x001 인스턴스에 접근하고 그 안에 있는 value의 값을 20으로 변경했습니다.
        
          dataA, dataX 모두 같은 x001 인스턴스를 참조하기 때문에 dataA.value와 dataX.value는 둘다 20이라는 값을 가집니다.
        
      
    
  


3. 메서드 종료

  메서드 종료후 dataA.value의 값을 확인해보면 다음과 같이 20으로 변경된 것을 확인할 수 있습니다.
    메서드 호출 전: dataA.value = 10
메서드 호출 전: dataA.value = 20
    
  


기본형과 참조형의 메서드 호출

자바에서 메서드의 매개변서(Parameter)는 항상 값에 의해 전달됩니다.
그러나 이 값이 실제 값이냐, 참조(메모리 주소)값이냐에 따라 동작이 달라집니다.

  기본형: 메서드로 기본형 데이터를 전달하면, 해당 값이 복사되어 전달됩니다. 이 경우, 메서드 내부에서 매개변수(Parameter)의 값을 변경해도, 호출자의 변수 값에는 영향이 없습니다.
  참조형: 메서드로 참조형 데이터를 전달하면, 참조값이 복사되어 전달됩니다. 이 경우, 메서드 내부에서 매개변수(Parameter)로 전달된 객체의 멤버 변수를 변경하면, 호출자의 객체도 변경됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-20-referenceAndPrimitive2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-20-referenceAndPrimitive2.html"><h1 class="title_post">☕️[Java] 기본형과 참조형(2) - 변수 대입</h1></a>
                        <a href="/2024/Java/2024-02-20-referenceAndPrimitive2.html" class="txt_post">
                            기본형과 참조형(2) - 변수 대입
“대원칙: 자바는 항상 변수의 값을 복사해서 대입합니다.”

  자바에서 변수에 값을 대입하는 것은 변수에 들어 있는 값을 복사해서 대입하는 것입니다.
    
      기본형, 참조형 모두 항상 변수에 있는 값을 복사해서 대입합니다.
      “기본형” 이면 변수에 들어 있는 “실제 사용하는 값”을 복사해서 대입하고, “참조형” 이면 변수에 들어 있는 “참조값”을 복사해서 대입합니다.
    
  


이 대원칙을 이해하면 복잡한 상황에도 코드를 단순하게 이해할 수 있습니다.

기본형 대입
int a = 10;
int b = a;


참조형 대입
Student s1 = new Student();
Student s2 = s1;


기본형은 변수에 값을 대입하더라도 실제 사용하는 값이 변수에 바로 들어 있기 때문에 값만 복사해서 대입한다고 생각하면 쉽게 이해할 수 있습니다.

그러나 참조형의 경우 실제 사용하는 객체가 아니라 객체의 위치를 가르키는 참조값만 복사가 됩니다.

  쉽게 이야기해서 실제 건물이 복사가 되는 것이 아니라 건물의 위치인 주소만 복사되는 것입니다.
    
      따라서 같은 건물을 찾아갈 수 있는 방법이 하나 늘어날 뿐입니다.
    
  


“구체적인 예시를 통해서 변수 대입시 기본형과 참조형의 차이를 알아봅시다.”

VarChange1
package ref;

public class VarChange1 {

  public static void main(String[] args) {
    int a = 10;
    int b = a;
    System.out.println("a = " + a);
    System.out.println("b = " + b);

    // a 변경
    a = 20;
    System.out.println("변경 a = 20");
    System.out.println("a = " + a);
    System.out.println("b = " + b);

    // b 변경
    b = 30;
    System.out.println("변경 b = 30");
    System.out.println("a = " + a);
    System.out.println("b = " + b);
  }
}


실행 결과
a = 10
b = 10
변경 a = 20
a = 20
b = 10
변경 b = 30
a = 20
b = 30


“코드를 순서대로 알아봅시다.”

int a = 10;
int b = a;


실행 결과
a = 10
b = 10



  “변수의 대입은 변수에 들어있는 값을 복사해서 대입합니다.”
    
      여기에서 변수 a에 들어있는 값 10을 복사해서 변수 b에 대입합니다.
        
          변수 a 자체를 b에 대입하는 것이 아닙니다.
        
      
    
  


a = 20;


실행 결과
a = 10
b = 20



  변수 a에 값 20을 대입했습니다.
    
      따라서 변수 a의 값이 10에서 20으로 변경되었습니다.
        
          “당연한 이야기지만 변수 b에는 아무런 영향을 주지 않습니다.”
        
      
    
  


b = 30;


실행 결과
a = 20
b = 30



  변수 b에 값 30을 대입했습니다.
    
      변수 b의 값이 10에서 30으로 변경되었습니다.
        
          “당연한 이야기지만 변수 a에는 아무런 영향을 주지 않습니다.”
        
      
    
  


여기서 핵심은 int b = a라고 했을 때 변수에 들어있는 값을 복사해서 전달한다는 점입니다.

  따라서 a = 20, b = 30이라고 했을 때 각각 본인의 값만 변경되는 것을 확인할 수 있습니다.


참조형과 변수 대입

아래의 예시 코드를 보고 참조형과 변수 대입에 대하여 알아봅시다.

Data
package ref;

public class Data {
  int value;
}


VarChange2
package ref;

public class VarChange2 {

  public static void main(String[] args) {
    Data dataA = new Data();
    dataA.value = 10;
    Data dataB = dataA;

    System.out.println("dataA 참조값 = " + dataA);
    System.out.println("dataB 참조값 = " + dataB);
    System.out.println("dataA.value = " + dataA.value);
    System.out.println("dataB.value = " + dataB.value);

    // dataA 변경.
    dataA.value = 20;
    System.out.println("변경 dataA.value = 20");
    System.out.println("dataA.value = " + dataA.value);
    System.out.println("dataB.value = " + dataB.value);

    // dataB 변경.
    dataB.value = 30;
    System.out.println("변경 dataA.value = 30");
    System.out.println("dataA.value = " + dataA.value);
    System.out.println("dataB.value = " + dataB.value);
  }
}


실행 결과
dataA 참조값 = ref.Data@30f39991
dataB 참조값 = ref.Data@30f39991
dataA.value = 10
dataB.value = 10
변경 dataA.value = 20
dataA.value = 20
dataB.value = 20
변경 dataA.value = 30
dataA.value = 30
dataB.value = 30


“코드를 한 줄씩 읽어가며 이해 해봅시다.”
Data dataA = new Data();
dataA.value = 10;



  dataA 변수는 Data 클래스를 통해서 만들었기 때문에 “참조형”입니다.
    
      이 변수는 “Data 형 객체의 참조값을 저장” 합니다.
    
  
  Data 객체를 생성하고, 참조값을 dataA에 저장합니다.
    
      그리고 객체의 value 변수에 값 10을 저장했습니다.
    
  


Data dataB = dataA;


실행 코드
Data dataA = new Data();
dataA.value = 10;
Data dataB = dataA;

System.out.println("dataA 참조값 = " + dataA);
System.out.println("dataB 참조값 = " + dataB);
System.out.println("dataA.value = " + dataA.value);
System.out.println("dataB.value = " + dataB.value);


출력 결과
dataA 참조값 = ref.Data@30f39991
dataB 참조값 = ref.Data@30f39991
dataA.value = 10
dataB.value = 10



  변수의 대입은 변수에 들어있는 “값을 복사해서 대입” 합니다.
    
      변수 dataA에는 참조값 30f39991이 들어있습니다.
        
          여기서는 변수 dataA에 들어있는 참조값 30f39991을 복사해서 변수 dataB에 대입합니다.
            
              이제 dataA와 dataB에 들어있는 참조값은 같습니다.
                
                  따라서 둘 다 같은 30f39991 인스턴스를 가리킵니다.
                
              
            
          
        
      
    
  



  참고로 변수 dataA가 가르키는 인스턴스를 복사하는 것이 아닙니다!
“변수에 들어있는 참조값만 복사해서 전달하는 것 입니다.”


dataA.value = 20;


실행 코드
dataA.value = 20;
System.out.println("dataA.value = " + dataA.value);
System.out.println("dataB.value = " + dataB.value);


출력 결과
dataA.value = 20
dataB.value = 20



  dataA.value = 20 코드를 실행하면 dataA가 가르키는 30f39991 인스턴스의 value 값을 10에서 20으로 변경합니다.
    
      그러나 dataA와 dataB는 같은 30f39991 인스턴스를 참조하기 때문에 dataA.value와 dataB.value는 둘 다 같은 값인 20을 출력합니다.
    
  


dataB.value = 30;


실행 코드
dataB.value = 30;
System.out.println("dataA.value = " + dataA.value);
System.out.println("dataB.value = " + dataB.value);


출력 결과
dataA.value = 30
dataB.value = 30


  dataB.value = 30 코드를 실행하면 dataB가 가르키는 30f39991 인스턴스의 value 값을 20에서 30으로 변경합니다.
    
      그러나 dataA와 dataB는 같은 30f39991 인스턴스를 참조하기 때문에 dataA.value와 dataB.value는 같은 값인 30을 출력합니다.
    
  


“여기서 핵심은 Data dataB = dataA 라고 했을 때 변수에 들어있는 값을 복사해서 사용한다는 점입니다.”

  그런데 그 값이 참조값입니다.
    
      따라서 dataA와 dataB는 같은 참조값을 가지게 되고, 두 변수는 같은 객체 인스턴스를 참조하게 됩니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-20</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-20-referenceAndPrimitive.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-20-referenceAndPrimitive.html"><h1 class="title_post">☕️[Java] 기본형과 참조형(1)</h1></a>
                        <a href="/2024/Java/2024-02-20-referenceAndPrimitive.html" class="txt_post">
                            기본형과 참조형(1)
자바에서 참조형을 제대호 이해하는 것은 정말 중요합니다.

변수의 데이터 타입을 가장 크게 보면 기본형과 참조형으로 분류할 수 있습니다.

  사용하는 값을 변수에 직접 넣을 수 있는 기본형
  
    이전 포스팅의 예시 코드에서 본 Student student1 과 같이 객체가 저장된 메모리의 위치를 가르키는 참조값을 넣을 수 있는 참조형으로 분류할 수 있습니다.
  
  기본형(Primitive Type)
    
      Int, long, double, boolean 처럼 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입을 “기본형” 이라고 합니다.
    
  
  참조형(Reference Type)
    
      Student student1, int[] students와 같이 데이터에 접근하기 위한 참조(주소)를 저장하는 데이터 타입을 “참조형” 이라고 합니다.
        
          참조형은 객체 또는 배열에 사용됩니다.
        
      
    
  


쉽게 이야기해서 기본형 변수에는 직접 사용할 수 있는 값이 들어있지만 참조형 변수에는 위치(참조값)이 들어가 있습니다.

참조형 변수를 통해서 뭔가 하려면 결국 참조값을 통해 위치로 이동해야 합니다.

기본형 vs 참조형 - 기본

  “기본형” 은 숫자 10, 20과 같이 실제 사용하는 값을 변수에 담을 수 있습니다.
    
      때문에 해당 값을 바로 사용할 수 있습니다.
    
  
  “참조형” 은 실제 사용하는 값을 변수에 담는 것이 아닙니다.
    
      이름 그대로 실제 객체의 위치(참조, 주소)를 저장합니다.
        
          참조형에는 객체와 배열이 있습니다.
            
              “객체” 는 .(dot)을 통해서 메모리 상에 생성된 객체를 찾아가야 사용할 수 있습니다.
              “배열” 은 []를 통해서 메모리 상에 생성된 배열을 찾아야가 사용할 수 있습니다.
            
          
        
      
    
  


기본형 vs 참조형 - 계산

  기본형은 들어있는 값을 그대로 계산에 사용할 수 있습니다.
    
      예) 더하고 빼고, 사용하고 등등,(숫자 같은 것들은 바로 계산할 수 있습니다.)
    
  
  참조형은 들어있는 참조값을 그대로 사용할 수 없습니다.
    
      주소지만 가지고는 할 수 있는게 없습니다.
      주소지에 가야 실체가 있기 때문입니다.
        
          예) 더하고 빼고 사용하고를 못합니다. 참조값만 가지고는 계산할 수 있는 것이 없습니다.
        
      
    
  


“기본형은 연산이 가능하지만 참조형은 연산이 불가능합니다.”
int a = 10, b = 20;
int sum = a + b;


  기본형은 변수에 실제 사용하는 값이 담겨있습니다.
    
      따라서 +, -와 같은 연산이 가능합니다.
    
  


Student s1 = new Student();
Student s2 = new Student();
s1 + s2 // 오류 발생.


  참초형은 변수에 객체의 위치인 참조값이 들어있습니다.
    
      참조값은 계산에 사용할 수 없습니다. 따라서 오류가 발생합니다.
    
  


“물론 다음과 같이 .(dot)을 통해 객체의 기본형 멤버 변수에 접근한 경우에는 연산을 할 수 있습니다.”

Student s1 = new Student();
s1.grade = 100;
Student s2 = new Student();
s2 grade 90;
int sum = s1.grade + s2.grade // 연산 가능


쉽게 이해하는 팁
“기본형을 제외한 나머지는 모두 참조형입니다.”

  기본형은 소문자로 시작합니다.
    
      int, long, double, boolean 모두 소문자로 시작합니다.
        
          기본형은 자바가 기본으로 제공하는 데이터 타입입니다.
          이러한 기본형은 개발자가 새로 정의할 수 없습니다.
          개발자는 참조형인 클래스만 직접 정의할 수 있습니다.
        
      
    
  
  클래스는 대문자로 시작합니다.
    
      Student, String, 등…
        
          클래스는 모두 참조형입니다.
        
      
    
  



  “참고 - String”
자바에서 String은 특별합니다. 
String은 사실 클래스입니다. 즉, 참조형입니다.
그런데 기본형처럼 문자 값을 바로 대입할 수 있습니다.
문자는 매우 자주 다루기 때문에 자바에서 특별하게 편의 기능을 제공합니다.
String에 대한 자세한 내용은 추후에 설명하겠습니다.



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-20</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-19-arrayIntro-refactoring.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-19-arrayIntro-refactoring.html"><h1 class="title_post">☕️[Java] 배열 도입 - 리팩토링</h1></a>
                        <a href="/2024/Java/2024-02-19-arrayIntro-refactoring.html" class="txt_post">
                            배열 도입 - 리팩토링

아래 코드를 보면 배열을 사용한 덕분에 출력에서 for문을 “도입할 수 있게 되었습니다.”

ClassStart5
package class1;

public class ClassStart5 {

  public static void main(String[] args) {

    Student student1 = new Student();
    student1.name = "학생1";
    student1.age = 15;
    student1.grade = 90;

    Student student2 = new Student();
    student2.name = "학생2";
    student2.age = 16;
    student2.grade = 80;
    
    // 배열 선언
    Student[] students = new Student[]{student1, student2};
      
    // for문 적용
    for (int i = 0; i &lt; students.length; i++) {
      System.out.println("이름:" + students[i].name + " 나이:" + students[i].age + " 성적:" + students[i].grade);
    }
}


배열 선언 최적화.

  개발자가 직접 정의한 ‘Student‘ 타입도 일반적인 변수와 동일하게 배열을 생성할 때 포함할 수 있습니다.
    Student[] students = new Student[]{student1, student2};
    
  
  생성과 선언을 동시에 하는 경우 다음과 같이 더 최적화 할 수 있습니다.
    Student[] students = {student1, student2};
    
  


for문 최적화.

  배열을 사용한 덕분에 for문을 사용해서 반복 작업을 깔끔하게 처리할 수 있습니다.


for문 도입
for (int i = 0; i &lt; students.length; i++) {
      System.out.println("이름:" + students[i].name + " 나이:" + students[i].age + " 성적:" + students[i].grade);
    }


for문 - 반복 요소를 변수에 담아서 처리하기
for (int i = 0; i &lt; students.length; i++) {
      Student s = students[i];
      System.out.println("이름:" + s.name + " 나이:" + s.age + " 성적:" + s.grade);
}



  
    students[i].name, students[i].age 처럼 students[i]를 자주 접근하는 것이 번거롭다면 반복해서 사용하는 객체를 Students s와 같은 변수에 담아두고 사용해도 됩니다.
  
  
    물론 이런 경우에는 다음과 같이 향상된 for문을 사용하는 것이 가장 깔끔합니다.
향상된 for문(Enhanced For Loop)
    for (int i = 0; i &lt; students.length; i++) {
  Student s = students[i];
  System.out.println("이름:" + s.name + " 나이:" + s.age + " 성적:" + s.grade);
}
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-18-apiSummary.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-18-apiSummary.html"><h1 class="title_post">🍃[Spring] API</h1></a>
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-18-apiSummary.html" class="txt_post">
                            API

@ResponseBody 문자 반환
@Controller
public class HelloController {
    
    @GetMapping("hello-string")
    @ResponseBody
    public String helloString(@RequestParam("name") String name) {
        return "hello " + name;
    }
}


  @ResponseBody를 사용하면 뷰 리졸버('viewResolver')를 사용하지 않습니다
    
      대신 HTTP의 BODY에 문자 내용을 직접 반환합니다(HTML BODY TAG를 말하는 것이 아닙니다.)
    
  


실행
http://localhost:8080/hello-string?name=spring

@ResponseBody 객체 반환
@Controller
public class HelloController {
    
    @GetMapping("hello-api")
    @ResponseBody
    public Hello helloApi(@RequestParam("name") String name) {
        Hello hello = new Hello();
        hello.setName(name);
        return hello;
    }
    
    static class Hello {
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
}


  @ResponseBody를 사용하요, 객체를 반환하면 객체가 JSON으로 변환됩니다.


실행

  http://localhost:8080/hello-api?name=spring


@ResponseBody 사용 원리




  웹 브라우저에서 localhost:8080/hello-api 로 접속을 시도합니다.
  톰켓 내장 서버에서 “hello-api 가 왔어” 하고 스프링에 던집니다.
  스프링은 “hello-api 가 있네?! 어? 근데 @RespinseBody 어노테이션이 붙어있다!!” 하고 인식합니다.
    
      이런 어노테이션이 붙어있지 않았다면 viewResolver에게 던집니다. -&gt; “나에게 맞는 템플릿을 찾아 돌려줘”
      @ResponsBody가 있다면 HTTP 응답에 그대로 넘겨야겠다 하고 동작합니다.
        
          여기서 문자가 오면 바로 문자를 돌려줍니다.
          하지만 객체가 오면 기본 디폴트인 JSON 방식으로 데이터를 만들어서 HTTP 응답에 반환합니다. -&gt; 기본 정책
        
      
    
  
  @ResponseBody return: hello(name: spring)은 객체를 넘겨줍니다. 그러면 “HttpMessageConverter“ 가 동작합니다.
  만약 반환하는 아이가 단순 문자일 경우 “StringConverter“ 가 동작합니다.
  그게 아니고 반환하는 아이가 객체일 경우 “JsonConverter“ 가 동작합니다.
  결국 JSON 형식으로 변환한 것을 요청한 웹 브라우저에게 보내줍니다.


정리

  @ResponseBody를 사용
    
      HTTP의 BODY에 문자 내용을 직접 반환
      viewResolver 대신에 httpMessageConverter가 동작
      기본 문자처리: StringHttpMessageConverter
      기본 객체처리: MappingJackson2HttpMessageConverter
      byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있음
    
  



  참고: 클라이언트 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보 들을 조합해서 HttpMessageConverter가 선택됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/MySQL/2024-02-19-drop.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/mysql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/MySQL/2024-02-19-drop.html"><h1 class="title_post">🐋[MySQL] 테이블 삭제하기</h1></a>
                        <a href="/2024/MySQL/2024-02-19-drop.html" class="txt_post">
                            테이블 삭제

DROP TABLE 테이블이름; 구문을 사용합니다.

DROP TABLE 테이블이름;


MySQL은 IF EXISTS 구문을 지원하므로 아래와 같이 테이블이 존재할 경우 삭제하도록 하면 에러를 방지할 수 있습니다.
DROP TABLE if exists 테이블이름;


외래 키(Forgign Key)가 테이블에 있을 경우

만약 다른 테이블에서 foreign key로 삭제하려는 테이블을 참조하는 등 constraint가 있을 경우 삭제되지 않습니다.

이 경우에는 2가지 방법이 있습니다.


  참조하는 테이블을 먼저 삭제하는 방법.


DROP TABLE if exists 참조하는테이블이름;
DROP TABLE if exists 삭제하려는테이블이름;



  참조 테이블을 계속 사용해야 할 경우 참조 테이블 내부에 외래 키를 삭제한 뒤 삭제하려는 테이블을 DROP 해주면 됩니다.


ALTER TABLE 참조테이블이름 DROP FOREIGN KEY 외래키이름;
DROP TABLE 삭제할테이블이름;


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/MySQL/2024-02-18-selectAndLimit.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/mysql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/MySQL/2024-02-18-selectAndLimit.html"><h1 class="title_post">🐋[MySQL] SELECT 조회 결과 LIMIT 1000 ROW 해제하기.</h1></a>
                        <a href="/2024/MySQL/2024-02-18-selectAndLimit.html" class="txt_post">
                            MySQL에서 SELECT의 조회 결과가 1000개만 출력이 되는 이유.

처음에는 MySQL로 for 문을 만들 수 있는지 호기심에서 시작했습니다.(for문에 대한 포스팅은 따로 올리겠습니다.)

그래서 다음과 같이 코드를 만들고 실행했습니다.

delimiter $$ 
create procedure loopInsert()
begin
	declare i int;
	set i = 1;

	while (i &lt;= 2000) do
		insert into test_table (id) values(i);
    
		set i = i + 1;
	end while;
end $$

call loopInsert(); --2000개의 id가 만들어짐.


저의 예상은 2000개의 row(필드)가 만들어져 id가 1~2000이 되어 Result 값에 보여질 줄 알았으나 id의 갯수를 세어주는 SQL 문을 만들어 실행 시켜보니 1000 이라는 결과값이 나왔습니다.

SELECT COUNT(id) FROM test_table; -- 결과값 count(id) 1000


그래서 확인을 해보려 다음과 같은 쿼리문을 만들어 실행해봤습니다.

SELECT * FROM test_table; 
-- Action select * from test_table LIMIT 0, 1000
-- 결과값 1~999, Response 1000 row(s) returned


  여기서 주목할 점은 “Action select * from test_table LIMIT 0, 1000” 입니다.
    
      저는 LIMIT 키워드를 발견했고 이 LIMIT을 해제하는 방법을 찾아보았습니다.
    
  


LIMIT 해제 방법1 : 직접 LIMIT 제한 범위 걸어주기

직접적인 해결 방법은 아니지만,
쿼리 자체가 ‘LIMIT 1000’으로 고정되기 때문에 쿼리에 LIMIT를 넣어 LIMIT 제한을 늘려주는 방법입니다.

  이 방식은 권장하는 방식은 아니라고 합니다. 이런 방식으로 조회할 수 있다는 방법 중 하나를 제시한 것 뿐이라는 블로그의 글을 보았습니다.
    
      아래와 같이 LIMIT 키워드를 쿼리 내에 직접 명시하여 범위를 제공해주는 방법입니다.
        select * from table_test LIMIT 99999999;
        
      
    
  


LIMIT 해제 방법2 : Workbench 설정 Limit Rows 옵션 해제하기

MySQL에서의 Workbench에는 SELECT 쿼리 조회 결과를 자체적으로 행을 제한해서 보여주는 옵션이 있습니다 이게 기본 값 1000행으로 되있는데, 이 옵션을 변경 또는 해제하면 됩니다.


  settings &gt; SQL Execution &gt; SELECT Query Results &gt; Limit Rows 해제
    
      혹은 Limit Rows Count 행 수 변경.
    
  


Limit Rows 옵션의 장.단점.


  장점
    
      테이블에 속해 있는 데이터의 수를 정확하게 확인할 수 있습니다.
    
  
  단점
    
      무분별한 전체 조회는 데이터베이스의 과부하에 영향을 미칠 수 있습니다.
    
  


결론적으로 쿼리를 작성하고 실행하는 개발자가 상황에 맞게 잘 사용해야 합니다.

즉, 최적화와 DB 성능에 영향에 대해 잘 고민해보고 쿼리를 사용해야 합니다.


  예시 1) 테이블 구조 및 데이터 확인 용도.
    SELECT * FROM 테이블이름 LIMIT 5;
    
  
  예시 2) 조건에 맞는 특정 데이터 확인 용도.
    SELECT 컬럼명 FROM 테이블명 WHERE 조건입력 LIMIT 5;
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/MySQL/2024-02-18-nullColumn.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/mysql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/MySQL/2024-02-18-nullColumn.html"><h1 class="title_post">🐋[MySQL] null 컬럼 변경하기.</h1></a>
                        <a href="/2024/MySQL/2024-02-18-nullColumn.html" class="txt_post">
                            테이블 null 컬럼 -&gt; not null 으로 변경하기.

alter table 테이블이름 mofify column 컬럼이름 컬럼타입 not null;



  컬럼에 null 값 허용


테이블 null 컬럼 -&gt; null 으로 변경하기.

alter table 테이블이름 mofify column 컬럼이름 컬럼타입 null;



  컬럼에 null 값 비허용


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/MySQL/2024-02-18-InsertInto.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/mysql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/MySQL/2024-02-18-InsertInto.html"><h1 class="title_post">🐋[MySQL] 테이블에 데이터 입력 INSERT INTO</h1></a>
                        <a href="/2024/MySQL/2024-02-18-InsertInto.html" class="txt_post">
                            INSERT INTO

memberTBL이라는 테이블이 있습니다.

그 테이블에는 아무런 데이터가 입력되지 않은 상태입니다.

열(Column, 필드)은 총 3개입니다.

  memberID
    
      char(8)
    
  
  memberName
    
      char(5)
    
  
  memberAddress
    
      char(20)
    
  


데이터를 한 행(row)을 삽입하려고 할 경우에는 다음과 같이하면 됩니다.
INSERT INTO 테이블이름 VALUES (데이터1, 데이터2, 데이터3...);


만약 memberTBL에 한 행(row)을 삽입하려 할 경우는 다음과 같이하면 됩니다.
INSERT INTO memberTBL VALUES ('Thomas', '토마스', '경기 부천시 중동');


만약 특정 필드에만 값을 입력하고 싶을 경우에는 VALUES 앞에 “입력할 필드를 선언해 줍니다.”
INSERT INTO memberTBL (memberID, memberAddress) VALUES ('Thomas', '경기 부천시 중동');


만약 여러 개의 행(row)을 동시에 입력하고 싶을 경우에는 아래와 같이 여러 개의 행을 동시에 입력이 가능합니다.
INSERT INTO memberTBL (memberID, memberName, memberAddress) VALUES  ('Thomas', '토마스', '경기 부천시 중동'), ('Edward', '에드워드', '서울 은평구 증산동'), ('Henrv', '헨리', '인천 남구 주안동'), ('Gorden', '고든', '경기 성남시 분당구');


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-17-staticContent.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-17-staticContent.html"><h1 class="title_post">🍃[Spring] 정적 컨텐츠</h1></a>
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-17-staticContent.html" class="txt_post">
                            정적 컨텐츠.

웹을 개발한다는 것은 크게 3가지 방법으로 나뉩니다.


  정적 컨텐츠: 서버에서의 별다른 작업 없이 파일을 웹 브라우저에 그대로 내려주는 것 입니다.
  MVC와 템플릿 엔진: JSP, PHP 등 활용하여 HTML을 그냥 주는 것이 아니라 서버에서 프로그래밍을 해서 HTML을 동적으로 바꿔서 내려주는 것을 템플릿 엔진이라고 말하며, 그것을 하기 위하여 Model-View(템플릿 엔진 화면)-Controller 이 세가지를 MVC라고 합니다.
  API: JSON이라는 데이터구조 포맷으로 클라이언트에게 데이터를 전달하는 것이 보통 API 방식이라고 합니다.


“스프링 부트는 자동으로 정적 컨텐츠 기능을 제공합니다.”

&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" conten="text/html"; charset="UTF-8" /&gt;
  &lt;title&gt;Static Content&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
정적 컨텐츠 입니다.
&lt;/body&gt;
&lt;/html&gt;





  Spring Boot Docs에 다음과 같이 명시되어 있습니다. “기본적으로 Spring Boot는 \static 이라는 디렉터리에서 정적 콘텐츠를 제공합니다.”



  Spring Boot Docs - Static Content 참고해주세요.




“위 그림은 큰 개념을 잡기 위하여 이해하기 쉽게 그린 그림입니다.”
Spring MVC를 본격적으로 학습하면서 깊이있게 들어가게 되면 이 내부에 여러가지가 많이 나오게 됩니다.
지금 이 포스팅의 목적 자체는 “디테일” 보다는 “크게 어떻게 돌아가는지를 이해하는데 목적이 있습니다.”
즉, ‘큰 그림을 보는 것’이라고 이해하면 됩니다.


  먼저 “localhost:8080/hello-static.html”을 접속했습니다.
    
      제일 처음에 내장 톰켓 서버가 요청을 받습니다.
        
          그러면 내장 톰켓 서버가 “hello-static.html이 왔데요~”하고 “Spring”에게 넘깁니다.
        
      
      이때, Spring은 Controller에서 hello-static이 있는지 찾아봅니다.
        
          “즉, Controller가 먼저 우선순위를 가진다는 뜻 입니다.”
        
      
    
  





  컨트롤러 내부를 보니 “hello-static” 관련 컨트롤러가 없음을 확인할 수 있습니다.
    
      따라서 이후에 스프링 부트는 “resources: static/hello-static.html”을 찾습니다.
        
          그래서 “오 있다!!” 하고 찾으면 바로 “hello-static.html”을 반환해주는 것 입니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-17-mvcAndTemplateEngine.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-17-mvcAndTemplateEngine.html"><h1 class="title_post">🍃[Spring] MVC와 템플릿 엔진</h1></a>
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-17-mvcAndTemplateEngine.html" class="txt_post">
                            MVC와 템플릿 엔진


  MVC: Model, View, Controller


Controller

package com.devkobe.hellospring.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class HelloController {
    @GetMapping("hello-mvc")
    public String helloMvc(@RequestParam("name") String name, Model model) {
        model.addAttribute("name", name);
        return "hello-template";
    }
}


View
&lt;html xmlns:th="http://www.thymeleaf.org"&gt;
&lt;body&gt;
&lt;p th:text="'hello ' + ${name}"&gt;hello! empty&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;


실행

  http://localhost:8080/hello-mvc?name=spring


MVC, 템플릿 엔진 이미지.



  웹 브라우저에서 localhost:8080/hello-mvc를 넘깁니다.
  스프링 부트를 띄울 때 함깨 띄우는 “내장 톰켓 서버를 localhost:8080/hello-mvc 가 거칩니다”.
  내장 톰켓 서버가 ‘localhost:8080/hello-mvc가 왔어~’ 하고는 스프링에게 던집니다.
  그러면 스프링은 ‘아! localhost:8080/hello-mvc가 helloController 내부 메서드에 매핑이 되어있네?!’하고는 “그 메서드를 호출해줍니다.”
  호출한 메서드가 리턴시 이름을 “hello-temple”이라고 하고, “model에 키는 name이고, 값은 spring으로 넣은것”을 스프링에게 넘겨줍니다.
  그러면 스프링이 “viewResolver” (화면과 관련된 해결자 - 뷰를 찾아주고 템플릿 엔진을 연결 시켜주는 것입니다.)가 동작합니다.
  viewResolver가 “templates” 의 “hello-template” 이라는 “리턴의 String name과 똑같은 아이를 찾아서 Thymeleaf 템플릿 엔진에게 처리해달라고 넘깁니다.”
  그러면 “템플릿 엔진이 랜더링“을 하여 “변환을 한 HTML” 을 “웹 브라우저에 반환합니다.”



  정적일 때는 “변환을 하지 않았습니다.” 즉, 그대로 반환을 해줬습니다.
    
      이런 “템플릿 엔진에서는 변환을해서 웹 브라우저에 넘겨줍니다.”
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-17-arrayIntroduction.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-17-arrayIntroduction.html"><h1 class="title_post">☕️[Java] 배열 도입</h1></a>
                        <a href="/2024/Java/2024-02-17-arrayIntroduction.html" class="txt_post">
                            배열 도입


  “배열” 을 사용하면 특정 타입을 연속한 데이터 구조로 묶어서 편리하게 관리할 수 있습니다.
  Student 클래스를 사용한 변수들도 Student 타입이기 때문에 학생도 “배열” 을 사용해서 “하나의 데이터 구조로 묶어서 관리” 할 수 있습니다.
    
      클래스의 도입 포스팅 예시 코드 참고 -&gt; 학생 클래스.
    
  


Student 타입을 사용하는 “배열” 을 도입해봅시다.

package class1;

public class ClassStart4 {

  public static void main(String[] args) {

    Student student1 = new Student();
    student1.name = "학생1";
    student1.age = 15;
    student1.grade = 90;

    Student student2 = new Student();
    student2.name = "학생2";
    student2.age = 16;
    student2.grade = 80;

    Student[] students = new Student[2];
    students[0] = student1;
    students[1] = student2;

    for (int i = 0; i &lt; students.length; i++) {
      System.out.println("이름:" + students[i].name + " 나이:" + students[i].age + " 성적:" + students[i].grade);
    }
  }
}


코드를 분석해 봅시다.
Student student1 = new Student();
student1.name = "학생1";
student1.age = 15;
student1.grade = 90;

Student student2 = new Student();
student2.name = "학생2";
student2.age = 16;
student2.grade = 80;



  Student 클래스를 기반으로 student1, student2 인스턴스를 생성합니다. 그리고 필요한 값을 채워둡니다.


배열에 참조값 대입

이번에는 Student를 담을 수 있는 배열을 생성하고, 해당 배열에 student1, student2 인스턴스를 보관해봅시다.

Student[] students = new Student[2];



  Student 변수를 2개 보관할 수 있는 사이즈 2의 배열을 만듭니다.
  Student 타입의 변수는 Student 인스턴스의 “참조값을 보관” 합니다.
    
      Student 배열의 각각의 항목도 “Student 타입의 변수일 뿐” 입니다. 따라서 “Student 타입의 참조값을 보관” 합니다.
        
          student1, student2 변수를 생각해보면 Student 타입의 참조값을 보관합니다.
        
      
    
  
  배열에는 아직 참조값을 대입하지 않았기 때문에 참조값이 없다는 의미의 null 값으로 초기화 됩니다.


이제 배열에 객체를 보관해보겠습니다.

students[0] = student1;
students[1] = student2;

// 자바에서 대입은 항상 변수에 들어 있는 값을 복사합니다.
students[0] = x001;
students[1] = x002;



  잊지 말자 자바의 대원칙: “자바에서 대입은 항상 변수에 들어 있는 값을 복사한다.”



  student1, student2에는 참조값이 보관되어 있습니다.
    
      따라서 이 참조값이 배열에 저정됩니다.
      또는 student1, student2에 보관된 참조값을 읽고 복사해서 배열에 대입한다고 표현합니다.
    
  


이제 배열은 x001, x002의 참조값을 가집니다.
참조값을 가지고 있기 때문에 x001(학생1), x002(학생), Student 인스턴스에 모두 접근할 수 있습니다.


  너무 중요해서 한 번더 강조합니다 잊지 말자 자바의 대원칙: “자바에서 대입은 항상 변수에 들어 있는 값을 복사한다.”


students[0] = student1;
students[1] = student2;

// 자바에서 대입은 항상 변수에 들어 있는 값을 복사합니다.
students[0] = x001;
students[1] = x002;



  자바에서 변수의 대입(=)은 모두 변수에 들어있는 값을 복사해서 전달하는 것입니다.
    
      이 경우 오른쪽 변수인 student1, student2에는 참조값이 들어있습니다.
        
          그래서 이 값을 복사해서 왼쪽에 있는 배열에 전달합니다.
            
              따라서 기존 student1, student2에 들어있던 참조값은 당연히 그대로 유지됩니다.
            
          
        
      
    
  


주의!!

  변수에는 인스턴스 자체가 들어있는 것이 아닙니다!
    
      “인스턴스의 위치를 가리키는 참조값이 들어있을 뿐입니다!!”
        
          따라서 대입(=)시에 인스턴스가 복사되는 것이 아니라 참조값만 복사됩니다.
        
      
    
  


배열에 들어있는 객체 사용
배열에 들어있는 객체를 사용하려면 먼저 배열에 접근하고, 그 다음에 객체에 접근하면 됩니다.
이전에 설명한 그림과 코드를 함께 보면 쉽게 이해가 될 것입니다.

학생1 예제
System.out.println(students[0].name); // 배열 접근 시작
System.out.println(x005[0].name); // [0]를 사용해서 x005 배열의 0번 요소에 접근
System.out.println(x001.name); // .(dot)을 사용해서 참조값으로 객체에 접근
System.out.println("학생1");


학생2 예제
System.out.println(students[1].name); // 배열 접근 시작
System.out.println(x005[1].name); // [0]를 사용해서 x005 배열의 1번 요소에 접근
System.out.println(x002.name); // .(dot)을 사용해서 참조값으로 객체에 접근
System.out.println("학생2");


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/MySQL/2024-02-16-trobleshootingMysql1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/mysql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/MySQL/2024-02-16-trobleshootingMysql1.html"><h1 class="title_post">🐋[MySQL] MySQL Server Start/Stop</h1></a>
                        <a href="/2024/MySQL/2024-02-16-trobleshootingMysql1.html" class="txt_post">
                            MySQL Server Start/Stop

초기 세팅
처음 MySQL을 설치시 MySQL 웹 사이트에 접속하여 DMG File을 받아서 설치하는 방법과 Homebrew를 활용하여 설치하는 방법 두 가지가 있습니다.

  저는 MySQL을 Homebrew를 이용해서 설치하지 않고 MySQL 웹 사이트에 접속하여 DMG File을 받아 설치하였습니다.
    
      (요것이 약간의 패착?😵‍💫)
    
  


정상 설치 이후에 mysql.server start 명령어를 terminal에 입력하면 아래 그림과 같은 에러가 발생했습니다.




  homebrew로 설치했다면 .zshrc 파일에 아마 PATH 환경변수가 잘 추가가 되어 이런 에러가 나지 않았을 것입니다.
    
      만약 이런 에러가 그래도 발생했다면 간단하게 PATH 환경변수를 .zshrc 파일 내부에 export PATH=$PATH:/usr/local/mysql/bin 이런식으로 넣어 준 뒤 터미널을 재시작해주면 됩니다.
    
  


저는 homebrew로 설치하지 않았으므로 저 명령어가 일단은 안되는게 정상이여서 homebrew로 설치하지 않았을 경우 어떻게 서버를 동작시키는지 알아봤습니다.


  먼저 /usr/local/mysql/data/ 로 이동합니다.
  sudo 명령어를 활용하여 sudo /usr/local/mysql/support-files/mysql.server start 명령어를 입력해줍니다.


이와 같이 간단하게 서버를 동작 시킬 수 있었습니다.

반대로 서버를 닫을 땐 sudo /usr/local/mysql/support-files/mysql.server stop를 사용하면 됩니다.



참고 문서


  How to fix [Errno 13] Permission denied error on MySQL
  윤카일의 개발공간


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-16-useObject.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-16-useObject.html"><h1 class="title_post">☕️[Java] 객체 사용</h1></a>
                        <a href="/2024/Java/2024-02-16-useObject.html" class="txt_post">
                            객체 사용

“클래스를 통해 생성한 객체를 사용하려면 먼저 메모리에 존재하는 객체에 접근해야 합니다.”

  객체에 접근하려면 .(점, dot)을 사용하면 됩니다.


// 객체 값 대입
student1.name = "학생1";
student1.age = 15;
student1.grade = 90;

// 객체 값 사용
System.out.println("이름:" + student1.name + " 나이:" + student1.age + " 성적:" + student1.grade);


객체에 값 대입

  객체가 가지고 있는 멤버 변수(name, age, grade)에 값을 대입하려면 먼저 객체에 접근해야 합니다.
    
      객체에 접근하려면 .(점, dot) 키워드를 사용하면 됩니다.
        
          이 키워드는 변수(student1)에 들어있는 참조값(x001)을 읽어서 메모리에 존재하는 객체에 접근합니다.
        
      
    
  


순서를 간단히 풀어보겠습니다.
student1.name = "학생1" // 1. student1 객체의 name 멤버 변수에 값 대입
x001.name = "학생1" // 2. 변수에 있는 참조값을 통해 실제 객체에 접근, 해당 객체의 name 멤버 변수에 값 대입



  student1.(dot)이라고 하면 student1 변수가 가지고 있는 참조값을 통해 실제 객체에 접근합니다.
  student1은 x001이라는 참조값을 가지고 있으므로 x001 위치에 있는 Student 객체에 접근합니다.


객체 값 읽기
객체의 값을 읽는 것도 앞서 설명한 내용과 같습니다.

  .(점, dot) 키워드를 통해 참조값을 사용해서 객체에 접근한 다음에 원하는 작업을 하면 됩니다.


아래 예시 코드를 봅시다.
// 1. 객체 값 읽기.
System.out.println("이름:" + student1.name);
// 2. 변수에 있는 참조값을 통해 실제 객체에 접근하고, name 멤버 변수에 접근합니다.
System.out.println("이름:" + x001.name);
// 3. 객체의 멤버 변수의 값을 읽어옵니다.
System.out.println("이름:" + "학생1");


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-16-termSummary.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-16-termSummary.html"><h1 class="title_post">☕️[Java] 클래스, 객체, 인스턴스 정리</h1></a>
                        <a href="/2024/Java/2024-02-16-termSummary.html" class="txt_post">
                            클래스, 객체, 인스턴스 정리.

클래스 - Class

  클래스는 객체를 생성하기 위한 “틀” 또는 “설계도” 입니다.
  클래스는 객체가 가져야 할 “속성(변수)” 와 “기능(메서드)” 를 정의합니다.
    
      예를 들어 학생이라는 클래스는 속성(변수)으로 name, age, grade를 가집니다.
    
  



  참고로 기능(메서드)은 추후에 설명합니다. 지금은 속성(변수)에 집중합시다.



  “틀” : 붕어빵 틀을 생각해봅시다.
    
      붕어빵 틀은 붕어빵이 아닙니다! 이렇게 생긴 붕어빵이 나왔으면 좋겠다고 만드는 틀일 뿐입니다.
        
          실제 먹을 수 있는 것이 아닙니다. 실제 먹을 수 있는 팥 붕어빵을 객체 또는 인스턴스라고 합니다.
        
      
    
  
  “설계도” : 자동차 설계도를 생각해봅시다.
    
      자동차 설계도는 자동차가 아닙니다! 설계도는 실제 존재하는 것이 아니라 개념으로만 있는 것입니다.
        
          설계도를 통한 생산한 실제 존재하는 흰색 테슬라 모델 Y 자동차를 객체 또는 인스턴스라고 합니다.
        
      
    
  


객체 - Object

  객체는 클래스에서 정의한 속성과 기능을 가진 실체입니다.
  객체는 서로 독립적인 상태를 가집니다.
    
      예를 들어 위 코드에서 student1은 학생1의 속성을 가지는 객체이고, student2는 학생2의 속성을 가지는 객체입니다.
        
          student1 과 student2는 같은 클래스에서 만들어졌지만, 서로 다른 객체입니다.
        
      
    
  


인스턴스 - Instance

  인스턴스는 특정 클래스로부터 생성된 객체를 의미합니다.
    
      그래서 객체와 인스턴스라는 용어는 자주 혼용됩니다.
    
  
  인스턴스는 주로 객체가 어떤 클래스에 속해 있는지 강조할 때 사용합니다.
    
      예를 들어서 “student1 객체는 Student 클래스의 인스턴스다.” 라고 표현합니다.
    
  


객체 vs 인스턴스

  둘 다 클래스에서 나온 실체라는 의미에서 비슷하게 사용되지만, 용어상 인스턴스는 “객체보다 좀 더 관계에 초점을 맞춘 단어입니다.”
  보통 “student1은 Student의 객체이다.” 라고 말하는 대신 “student1은 Student의 인스턴스이다.” 라고 특정 클래스와의 “관계를 명확히 할 때 인스턴스” 라는 용어를 주로 사용합니다.
  좀 더 쉽게 풀어보자면, 모든 인스턴스는 객체이지만, 우리가 “인스턴스” 라고 부르는 순간 “특정 클래스로부터 그 객체가 생성되었음을 강조하고 싶을 때입니다.”
    
      예를 들어, student1은 객체이지만, 이 객체가 Student 클래스로부터 생성된다는 점을 명확히 하기 위해 student1을 Student의 인스턴스라고 부릅니다.
    
  


하지만 둘 다 클래스에서 나온 실체라는 핵심 의미는 같기 때문에 보통 둘을 구분하지 않고 사용합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-16-classIntroduction.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-16-classIntroduction.html"><h1 class="title_post">☕️[Java] 클래스 도입</h1></a>
                        <a href="/2024/Java/2024-02-16-classIntroduction.html" class="txt_post">
                            클래스 도입

클래스를 사용해서 “학생”이라는 개념을 만들고, 각 학생 별로 본인의 이름, 나이, 성적을 관리해봅시다.

우선 코드를 봐봅시다.

package class1;

public class Student {
  String name;
  int age;
  int grade;
}



  class 키워드를 사용해서 학생 클래스(Student)를 정의합니다.
    
      학생 클래스는 내부에 이름(name), 나이(age), 성적(grade) 변수를 가집니다.
    
  


이렇게 “클래스에 정의한 변수들을 멤버 변수, 또는 필드” 라 합니다.

  멤버 변수(Member Variable) : 이 변수들은 특정 클래스에 소속된 멤버이기 때문에 이렇게 부릅니다.
  필드(Field) : 데이터 항목을 가르키는 전통적인 용어입니다. 데이터베이스, 엑셀 등에서 데이터 각각의 항목을 필드라고 합니다.
  자바에서 멤버 변수, 필드는 같은 뜻입니다.
    
      클래스에 소속된 변수를 뜻합니다.
    
  


클래스는 관례상 대문자로 시작하고 낙타 표기법을 사용합니다.

  예) Student, User, MemberService


package class1;

public class ClassStart3 {

  public static void main(String[] args) {
    Student student1;
    student1 = new Student();
    student1.name = "학생1";
    student1.age = 15;
    student1.grade = 90;

    Student student2 = new Student();
    student2.name = "학생2";
    student2.age = 16;
    student2.grade = 80;

    System.out.println("이름:" + student1.name + " 나이:" + student1.age + " 성적:" + student1.grade);
    System.out.println("이름:" + student2.name + " 나이:" + student2.age + " 성적:" + student2.grade);
  }
}


실행 결과
이름:학생1 나이:15 성적:90
이름:학생2 나이:16 성적:80


클래스와 사용자 정의 타입

  “타입” 은 데이터의 종류나 형태를 나타냅니다.
    
      int라고 하면 정수 타입, String이라고 하면 문자 타입입니다.
      그러면 학생(Student)이라는 타입을 만들면 되지 않을까요?
    
  
  클래스를 사용하면 int, String과 같은 타입을 직접 만들 수 있습니다.
    
      사용자가 직접 정의하는 “사용자 정의 타입” 을 만들려면 설계도가 필요합니다.
        
          이 “이 설계도가 바로 클래스” 입니다.
        
      
    
  
  “설계도”인 “클래스”를 사용해서 “실제 메모리에 만들어진 실체를 객체 또는 인스턴스” 라 합니다.
  “클래스”를 통해서 사용자가 원하는 종류의 데이터 타입을 마음껏 정의할 수 있습니다.


용어: 클래스, 객체, 인스턴스

  클래스는 설계도이고, 이 설계도를 기반으로 실제 메모리에 만들어진 실체를 “객체 또는 인스턴스” 라 합니다.
    
      둘다 같은 의미로 사용됩니다.
        
          여기서는 학생(Student) 클래스를 기반으로 학생1(student1), 학생2(student2) 객체 또는 인스턴스를 만들었습니다.
        
      
    
  


코드 분석

1. 변수 선언.
Student student1 // Student 변수 선언


  Student student1
    
      Student “타입” 을 받을 수 있는 변수를 선언합니다.
      int는 정수를, String은 문자를 담을 수 있듯이 “Student는 Student 타입의 객체(인스턴스)를 받을 수 있습니다.”
    
  


2. 객체 생셩.
student1 = new Student() // Student 인스턴스 생성


student1 = new Student() 코드를 나누어 분석해봅시다.

  객체를 사용하려면 먼저 설계도인 클래스를 기반으로 객체(인스턴스)를 생성해야 합니다.
  new Student()에서의 new는 새로 생성한다는 뜻 입니다.
    
      new Student()는 Student 클래스 정보를 기반으로 새로운 객체를 생성하라는 뜻입니다.
      이렇게 하면 메모리에 실제 Student 객체(인스턴스)를 생성합니다.
    
  
  객체를 생성할 때는 new 클래스명()을 사용하면 됩니다. 마지막에 ()도 추가해야합니다.
  Student 클래스는 String name, int age, int grade 멤버 변수를 가지고 있습니다.
    
      이 변수를 사용하는데 필요한 메모리 공간도 함께 확보합니다.
    
  


3. 참조값 보관
student1 = x001l // Student 인스턴스 참조값 보관


  객체를 생성시 자바는 메모리 어딘가에 있는 이 객체에 접근할 수 있는 참조값(주소)(x001)을 반환합니다.
    
      여기셔 x001이라고 표현한 것이 참조값입니다.(실제로 x001처럼 표현되는 것은 아니고 이해를 돕기 위한 예시입니다.)
    
  
  new 키워드를 통해 객체가 생성되고 나면 참조값을 반환합니다.
    
      앞서 선언한 변수인 Student student1에 생성된 객체의 참조값(x001)을 보관합니다.
    
  
  Student student1 변수는 이제 메모리에 존재하는 실제 Student 객체(인스턴스)의 참조값을 가지고 있습니다.
    
      student1 변수는 방금 만든 객체에 접근할 수 있는 참조값을 가지고 있습니다.
        
          따라서 이 변수를 통해서 객체를 접근(참조)할 수 있습니다. 쉽게 이야기해서 student1 변수를 통해 메모리에 있는 실제 객체를 접근하고 사용할 수 있습니다.
        
      
    
  


참조값을 변수에 보관해야 하는 이유

  객체를 생성하는 new Student() 코드 자체에는 아무런 이름이 없습니다.
    
      “이 코드는 단순히 Student 클래스를 기반으로 메모리에 실제 객체를 만드는 것 입니다.”
        
          따라서 생성한 객체에 접근할 수 있는 방법이 필요합니다.
            
              이런 이유로 객체를 생성할 때 반환되는 참조값을 어딘가에 보관해두어야 합니다.
            
          
        
      
    
  
  앞서 Student student1 변수에 참조값(x001)을 저장해두었으므로 저장한 참조값(x001)을 통해서 실제 메모리에 존재하는 객체에 접근할 수 있습니다.


지금까지 설명한 내용을 간단히 풀어보면 다음과 같습니다.
Student student1 = new Student(); // 1. Student 객체 생성
Student student1 = x001; // 2. new Student()의 결과로 x001 참조값 변환
student1 = x001; // 3. 최종 결과


이후에 학생2(student2)까지 생성하면 다음과 같이 Student 객체(인스턴스)가 메모리에 2개 생성됩니다.

  “각각의 참조값이 다르므로 서로 구분할 수 있습니다.”


참조값을 확인하고 싶다면 다음과 같이 객체를 담고 있는 변수를 출력해보면 됩니다.
System.out.println(student1);
System.out.println(student2);


출력 결과
class1.Student@30f39991
class1.Student@452b3a41


  @ 앞은 패키지 + 클래스 정보를 뜻합니다. @ 뒤에 16진수는 참조값을 뜻합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Database/2024-02-16-IntroSQL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Database/2024-02-16-IntroSQL.html"><h1 class="title_post">💾[Database] SQL의 개요</h1></a>
                        <a href="/2024/Database/2024-02-16-IntroSQL.html" class="txt_post">
                            SQL의 개요

SQL은 관계형 DB에서 사용되는 언어로 ‘에스큐엘’ 또는 ‘시퀄’이라고 읽습니다.
관계형 DBMS(그중에서도 MySQL)를 배우려면 SQL을 익히는 것은 필수입니다.


  SQL은 DB를 조작하는 ‘언어’로, 일반적인 프로그래밍 언어(C, C++, Java, C# 등)와 다른 특성을 가지고 있습니다.
  SQL은 국제 표준화기관에서 표준화된 내용을 계속 발표했습니다.


SQL의 특징


  “DBMS 제작 회사와 독립적이다.”
    
      모든 DBMS 제작 회사에서 표준 SQL이 공개되어 각 회사는 이 표준 SQL에 맞춰 DBMS를 개발합니다.
        
          따라서 SQL은 대부분의 DBMS 제품에서 공통적으로 호환됩니다.
        
      
    
  
  “다른 시스템으로의 이식성이 좋다.”
    
      SQL은 서버용, 개인용, 휴대용 장비 등 운영되는 DBMS마다 상호 호환성이 뛰어납니다.
        
          한 시스템에서 사용하던 SQL을 다른 시스템으로 이식하는 데 큰 문제가 없습니다.
        
      
    
  
  “표준이 계속 발전합니다.”
    
      SQL은 SQL-86, 89, 92, 1999, 2003, 2008, 2011 등으로 개선된 표준안이 계속 발표되었으며, 지금도 개선된 안이 꾸준히 연구되고 있습니다.
    
  
  “대화식 언어입니다.”
    
      기존 프로그래밍 언어는 프로그램 작성, 컴파일 및 디버깅, 실행 과정을 거쳐야만 그 결과를 확인할 수 있지만 SQL은 바로 질의하고 결과를 얻는 대화식 언어입니다.
    
  
  “클라이언트/서버 구조를 지원합니다.”
    
      SQL은 분산형 구조인 클라이언트/서버 구조를 지원합니다.
        
          클라이언트에서 질의를 하면 서버에서 그 질의를 받아 처리하여 클라이언트에 전달하는 구조입니다.
        
      
    
  


SQL을 사용시 주의할 점은, 모든 DBMS 제품의 SQL 문이 완벽하게 동일하지는 않다는 것입니다.

  많은 회사가 되도록 표준 SQL을 준수하려고 노력하지만 각 회사의 DBMS마다 특징이 있기 때문에 현실적으로 완전히 통일되기는 어렵습니다.
    
      각 회사는 가급적 표준 SQL을 지키면서도 자신의 제품에 특화된 SQL을 사용합니다.
        
          이를 오라클에서는 PL/SQL, SQL Server에서는 T-SQL이라 부르고 MySQL에서는 그냥 SQL이라 일컫습니다.
        
      
    
  


아래 그림과 같이 각회사의 제품은 모두 표준 SQL을 공통으로 사용하면서 자기 제품의 특성에 맞춘 호환되지 않는 SQL 문도 사용합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/AWS/post-05.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/AWS/post-05.html"><h1 class="title_post">☁️[AWS] Route 53에 등록된 서브도메인 github page에 연결하기</h1></a>
                        <a href="/2024/AWS/post-05.html" class="txt_post">
                            AWS Route 53에 등록된 서브도메인 github page에 연결.

고통의 시작.

블로그를 처음 만들고 잘 운영하던 중 jekyll과 Gem Dependency와 Ruby 버전 그리고 Bundle까지 뭔가 엉키고 꼬여서 풀리지 않고 어느새 블로그는 엉망이 되어버렸습니다.

  진심으로 복구 시도를 열심해 했으나 내 부족한 지식으로 인하여 밀어버릴 수 밖에…


그리하여 깔끔하게 데이터 백업 후 밀어버리고 더 이쁜 블로그 테마를 찾아버렸습니다(오히려 좋아👍)

그렇게 아주 기분 좋게 블로그를 옮기고 잘 운영되나 싶었는데 ‘얼씨구?’ AWS Route 53에서 등록한 서브도메인을 github page와 연결해 놓았었는데 이 친구가 아주 먹통이 되어버렸습니다.

“DNS가 깃헙 서버와 맞지 않는다는 경고를 내보내주었습니다.”

  이상하게 찝찝하게도 그런데 접속은 정상적으로 동작했습니다…


아….. 찝찝한게 제일 싫은 나는 결국 오전 4시 기상해서 하나씩 알아보기 시작했습니다.

DNS

  Domain Name System(이후 DNS)은 인터넷의 전화번호부 같은 역할을 합니다.
    
      사람들이 웹사이트에 접속시, 일반적으로 기억하기 쉬운 도메인 이름(예: www.devkobe24.com)을 사용합니다.
      그러나 인터넷 자체는 IP 주소(예:192.0.2.1)라는 숫자 주소 체계를 사용하여 컴퓨터들 사이의 통신을 가능하게 합니다.
        
          “DNS는 사용자가 웹 브라우저에 입력한 도메인 이름을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 시스템입니다.”
            
              이를 통해 사용자는 복잡한 IP 주소를 기억하지 않고도 웹사이트에 쉽게 접근할 수 있습니다.
            
          
        
      
    
  


DNS의 주요 기능과 구성요소

  도메인 이름 해석 : 사용자가 웹 브라우저에 URL을 입력하면, DNS 서버는 해당 URL의 도메인 이름을 IP 주소로 변환합니다. 이 과정을 “이름 해석” 또는 “도메인 이름 해석”이라고 합니다.
  계층적 구조 : DNS 시스템은 계층적 구조로 되어 있습니다. 맨 위에는 루트 DNS 서버가 있으며, 그 아래에는 최상위 도메인(TLD)서버(예: .com, .net, .org등), 그리고 더 아래에는 권한 있는 이름 서버가 위치합니다. 권한 있는 이름 서버는 특정 도메인(예: devkobe24.com)에 대한 정보를 관리합니다.
  캐싱 : DNS 쿼리의 효율성을 높이기 위해, DNS 서버는 해석된 주소 정보를 일정 시간 동안 저장(캐싱)합니다. 이렇게 하면 같은 요청에 대해 반복적으로 최상위 서버에 접근할 칠요가 없어집니다.
  재귀적 및 반복 쿼리 : 사용자의 DNS 쿼리는 먼저 로컬 DNS 서버로 전송됩니다. 로컬 DNS 서버는 요청된 도메인의 IP 주소를 알고 있으면 바로 응답합니다. 모르는 경우, 다른 DNS 서버에 요청을 전달하여 답을 찾습니다. 이 과정에서 재귀적 쿼리(사용자를 대신해 답을 찾는 과정)와 반복적 쿼리(요청을 다른 서버로 전달하는 과정)가 사용됩니다.


DNS는 인터넷 사용의 핵심요소로, 사용자가 웹사이트에 접근하고, 이메일을 보내고 받으며, 다양한 온라인 서비스를 이용할 수 있게 해줍니다.

이렇게 DNS에 대하여 알아보고나서 이전에 연결을 어떻게 했었는지 이전에 블로그를 찾아봤습니다.

먼저 연결 전 사전 준비물(?)이 필요합니다.


  도메인
  Route 53 DNS 호스팅 설정
  Github Pages 설정된 Repository


이렇게 준비 한 뒤 Route 53 콘솔을 세팅합니다.

Route 53 콘솔 설정.


  Route 53 콘솔로 갑니다 &gt; 호스팅 영역을 클릭 &gt; 보유 도메인을 설정합니다.
  레코드 생성
    
      레코드 이름 : 서브(2차) 도메인 명 &gt; www
      레코드 유형 : CNAME
      값 : (자신의 깃헙 레포 이름) &gt; ex) devKobe24.github.io

    
  


Github Repository 설정.

레포지토리 &gt; 셋팅 &gt; 페이지 &gt; 커스텀 도메인


  그 안에 Route 53에서 내가 등록한 커스텀 도메인 명을 입력합니다. (예 : www.devkobe24.com)



  위와 같이 등록해주고 초록색 글자로 “DNS check successful”이 나오면 성공입니다.


하지만 저는 나오지 않았습니다.

그래서!! 더 알아 본 결과!!

A레코드 추가.

Route 53에서 A레코드를 추가해주었어야 했습니다.

Route 53 &gt; 호스팅 영역 &gt; 등록할 호스팅 영역의 이름 클릭 &gt; 레코드 생성




  레코드 이름은 비워둡니다.
  레코드 유형은 A
  값은 다음 IP 중 하나를 골라 사용합니다.
    
      185.199.108.153
      185.199.109.153
      185.199.110.153
      185.199.111.153
    
  
  나머지 옵션은 건들지 않습니다.
  이후 레코드 생성을 눌러 생성합니다.


이후 깃헙 레포로 돌아갑니다.




  위 그림과 같이 다시 도메인을 넣고 체크해보면 성공적으로 도메인이 적용됩니다, 저는 이렇게 도메인을 성공적으로 적용했습니다!!




참고자료


  AWS Route 53에 등록된 서브도메인을 GitHub Pages에 연결하기


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-02-15-standardization.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-02-15-standardization.html"><h1 class="title_post">🌐[Network] 표준화</h1></a>
                        <a href="/2024/Network/2024-02-15-standardization.html" class="txt_post">
                            서로 다른 시스템이 상호 연동해 동작하려면 “표준화(Standardization)” 라는 “연동 형식 통일”이 필요합니다.

  예를 들어, 프린트 용지를 생각해봅시다.
    
      일반적으로 프린터와 프린트 용지를 만드는 회사는 다릅니다. 하지만 사전에 A4 규격이라는 통일된 틀을 만들어두었기 때문에 서로 다른 회사에서 생산한 프린터와 프린트 용지를 자유롭게 사용할 수 있습니다.
    
  


현대 산업사회가 눈부시게 성장한 배경에는 증기기관의 개발에 따른 에너지 동력원의 발전이 있었습니다.
지금은 인간의 노동력이라는 한계를 넘어 인공지능으로 대표되는 새로운 차원의 사회 발전 단계인 4차 산업혁명이 진행되고 있습니다.

  그러나 이와 다른 관점에서 더 근원적인 발전 배경을 살펴보면, 표준화 원리를 바탕으로 한 레고의 산업 전반에 존재해왔기 때문임을 알 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-02-15-internet.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-02-15-internet.html"><h1 class="title_post">🌐[Network] 인터넷</h1></a>
                        <a href="/2024/Network/2024-02-15-internet.html" class="txt_post">
                            인터넷


  “인터넷(Internet)” 은 전세계의 모든 네트워크가 유기적으로 연결되어 동작하는 통합 네트워크입니다.
  인터넷에서 사용되는 시스템, 인터페이스, 전송 매체, 프로토콜들은 그 종류가 매우 복잡하고 다양하지만, 데이터 전달 기능에 한해서 공통으로 IP(Internet Protocol) 프로토콜을 사용합니다.
    
      즉, ISO의 OSI 7계층 모델에서 계층 3인 네트워크 계층의 기능을 IP 프로토콜이 수행하며 “인터넷” 이라는 용어는 “IP” 의 첫 단어인 “Internet” 에서 유래했습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-15-whyWeNeedClass.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-15-whyWeNeedClass.html"><h1 class="title_post">☕️[Java] 클래스가 필요한 이유.</h1></a>
                        <a href="/2024/Java/2024-02-15-whyWeNeedClass.html" class="txt_post">
                            클래스가 필요한 이유.

먼저 아래의 학생 정보 출력 프로그램을 만들어 봅시다.

이 프로그램은 두 명의 학생 정보를 출력하는 프로그램입니다.
각 학생은 이름, 나이, 성적을 가지고 있습니다.

요구사항

  첫 번째 학생의 이름은 “학생1”, 나이는 15, 성적은 90 입니다.
  두 번째 학생의 이름은 “학생2”, 나이는 16, 성적은 80 입니다.
  각 학생의 정보를 다음과 같은 형식으로 출력해야 합니다: "이름: [이름] 나이: [나이] 성적: [성적]"
  변수를 사용해서 학생 정보를 저장하고 변수를 사용해서 학생 정보를 출력해야 합니다.


예시 출력
이름: 학생1 나이: 15 성적: 90
이름: 학생2 나이: 16 성적: 80


변수를 사용해서 이 문제를 풀어보면 다음과 같이 프로그램을 만들어볼 수 있습니다.

package class1;

public class ClassStart1 {

  public static void main(String[] args) {
    String firstStudentName = "학생1";
    String secondStudentName = "학생2";

    int firstStudentAge = 15;
    int secondStudentAge = 16;

    int firstStudentGrade = 90;
    int secondStudentGrade = 80;

    System.out.println("이름: " + firstStudentName + " 나이: " + firstStudentAge + " 성적: " + firstStudentGrade);
    System.out.println("이름: " + secondStudentName + " 나이: " + secondStudentAge + " 성적: " + secondStudentGrade);
  }
}



  위 코드에서는 학생 2명을 다루어야 하기 때문에 각각 다른 변수를 사용했습니다.
  이 코드의 문제는 학생이 늘어날 때 마다 변수를 추가로 선언해야 하고, 또 출력하는 코드도 추가해야 합니다.


이런 문제를 어떻게 해결할 수 있을까요?

이번에는 위 코드를 “배열을 사용하여 리펙토링” 해봅시다.

아래의 코드는 “배열을 활용한 코드” 입니다.

package class1;

public class ClassStart2 {

  public static void main(String[] args) {
    String[] studentNames = { "학생1", "학생2" };
    int [] studentAges = { 15, 16 };
    int [] studentGrades = { 90, 80 };

    for (int i = 0; i &lt; studentNames.length; i++) {
      System.out.println("이름: " + studentNames[i] + " 나이: " + studentAges[i] + " 성적: " + studentGrades[i]);
    }
  }
}


이전 코드보다 훨씬 깔끔해졌으며, 위 코드에서 문제가 됐었던 학생이 늘어날 때 마다 변수를 새롭게 추가할 필요도 없어졌습니다.

배열 사용의 한계.

하지만 배열을 사용해서 코드를 최소화하는데 성공했지만 “한 한생의 데이터가 studentNames[], studentAges[], studentGrades라는 3개의 배열에 나누어져 있습니다.”

  따라서 “데이터를 변경할 때 매우 조심해서 작업해야 합니다.”
    
      예를 들어서 학생 2의 데이터를 제거하려면 각각의 배열마다 학생2의 요소를 정확하게 찾아서 제거해주어야 합니다.
    
  


학생2 제거
String[] studentNames = { "학생1", "학생3", "학생4", "학생5" };
int [] studentAges = { 15, 17, 10, 16 };
int [] studentGrades = { 90, 100, 80, 50 };



  한 학생의 데이터가 3개의 배열에 나누어져 있기 때문에 3개의 배열을 각각 변경해야 합니다!!
    
      그리고 한 학생의 데이터를 관리하기 위해 3개의 배열의 인덱스 순서를 항상 정확하게 맞추어야 합니다.(조금이라도 실수하면 😱)
        
          이렇게 하면 특정 학생의 데이터를 변경시 실수할 가능성이 매우 높습니다.
        
      
    
  


이 코드는 컴퓨터가 볼 때는 아무 문제가 없지만, 사람이 관리하기에는 좋은 코드가 아닙니다. 😵‍💫

정리


  지금처럼 이름, 나이, 성적을 각각 따로 나누어서 관리하는 것은 사람이 관리하기 좋은 방식이 아닙니다.
  사람이 관리하기 좋은 방식은 학생이라는 개념을 하나로 묶는 것입니다.
    
      그리고 각각의 학생 별로 본인의 이름, 나이, 성적을 관리하는 것 입니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-15-methodSummary.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-15-methodSummary.html"><h1 class="title_post">☕️[Java] 메서드 파트 정리.</h1></a>
                        <a href="/2024/Java/2024-02-15-methodSummary.html" class="txt_post">
                            정리

변수명 vs 메서드명
변수 이름은 일반적으로 명사를 사용합니다.
한편 메서드는 무언가 동작하는데 사용하기 때문에 일반적으로 동사로 시작합니다.
이런 차이점 외에는 변수 이름과 메서드 이름에 대한 규칙은 둘다 같습니다.


  변수명 예): customerName, totalSum, employeeCount, isAvailable
  메서드명 예): printReport(), calculateSum(), addCustomer(), getEmployeeCount(), setEmployeeName()


메서드 사용의 장점

  코드 재사용 : 메서드는 특정 기능을 캡슐화하므로, 필요할 때마다 그 기능을 다시 작성할 필요 없이 해당 메서드를 호출함으로써 코드를 재사용할 수 있습니다.
  코드의 가독성 : 이름이 부여된 메서드는 코드가 수행하는 작업을 명확하게 나타내므로, 코드를 읽는 사람에게 추가적인 문맥을 제공합니다.
  모듈성 : 큰 프로그램을 작은, 관리 가능한 부분으로 나눌 수 있습니다. 이는 코드의 가독성을 향상시키고 디버깅을 쉽게 만듭니다.
  코드 유지 관리 : 메서드를 사용하면, 코드의 특정 부분에서 문제가 발생하거나 업데이트가 필요한 경우 해당 메서드만 수정하면 됩니다. 이렇게 하면 전체 코드 베이스에 영향을 주지 않고 변경 사항을 적용할 수 있습니다.
  재사용성과 확장성 : 잘 설계된 메서드는 다른 프로그램이나 프로젝트에서도 재사용할 수 있으며, 새로운 기능을 추가하거나 기존 기능을 확장하는 데 유용합니다.
  추상화 : 메서드를 사용하는 곳에서는 메서드의 구현을 몰라도 됩니다. 프로그램의 다른 부분에서는 복잡한 내부 작업에 대해 알 필요 없이 메서드를 사용할 수 있습니다.
  테스트와 디버깅 용이성 : 개별 메서드는 독립적으로 테스트하고 디버그할 수 있습니다. 이는 코드의 문제를 신속하게 찾고 수정하는데 도움이 됩니다.


따라서, 메서드는 효율적이고 유지 보수가 가능한 코드를 작성하는 데 매우 중요한 도구입니다.

자바에서의 대원칙.

“자바는 항상 변수의 값을 복사해서 대입합니다.”

  이 대원칙은 반드시 이해해야 합니다. 그러면 아무리 복잡한 상황에서도 코드를 단순하게 이해할 수 있습니다.


package method;

public class MethodValue0 {
    
    public static void main(String[] args) {
        int num1 = 5;
        int num2 = num1;
        num2 = 10;
        System.out.println("num1=" + num1);
        System.out.println("num2=" + num2);
    }
}


실행 결과
num1 = 5
num2 = 10


용어: 메서드 시그니처(method signature)
메서드 시그니처 = 메서드 이름 + 매개변수 타입(순서)


  메서드 시그니처는 자바에서 메서드를 구분할 수 있는 고유한 식별자나 서명을 뜻합니다.
  메서드 시그니처는 메서드의 이름과 매개변수 타입(순서 포함)으로 구성되어 있습니다.
    
      쉽게 이야기해서 메서드를 구분할 수 있는 기준입니다.
    
  
  자바 입장에서는 각각의 메서드를 고유하게 구분할 수 있어야 합니다. 그래야 어떤 메서드를 호출 할 지 결정할 . 수있습니다.
    
      따라서 메서드 오버로딩과 같이 메서드 이름이 같아도 메서드 시그니처가 다르면 다른 메서드로 간주합니다.
    
  
  반환 타입은 시그니처에 포함되지 않습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Database/2024-02-15-databaseDefinition.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Database/2024-02-15-databaseDefinition.html"><h1 class="title_post">💾[Database] 데이터베이스의 정의와 특징</h1></a>
                        <a href="/2024/Database/2024-02-15-databaseDefinition.html" class="txt_post">
                            데이터베이스의 정의와 특징.

“데이터베이스” 는 여러 사용자나 응용 프로그램이 공유하고 동시에 접근 가능한 “데이터의 집합” 이라 정의할 수 있습니다.
“DBMS(Database Management System)” 는 이러한 데이터베이스를 관리﹒운영하는 소프트웨어입니다.

일반적으로 사용하는 마이크로소프트의 엑셀 같은 프로그램은 테이터의 집합을 다루기 때문에 DBMS와 비슷해 보이지만, 대용량 데이터를 관리하거나 여러 명의 사용자가 공유하는 것은 아니므로 DBMS라고 부르지 않습니다.

데이터베이스는 “데이터의 저장 공간” 자체를 의미하기도 합니다.

  DBMS 중 하나인 MySQL에서는 데이터베이스를 자료가 저장되는 디스크 공간(주로 파일로 구성됨)으로 취급합니다.
    
      아래 그림은 데이터베이스, DBMS, 사용자, 응용 프로그램의 관계를 보여줍니다.

    
  


위 그림에서 보듯이 “DBMS” 는 데이터베이스를 관리하는 역할을 하는 소프트웨어 입니다.

  여러 사용자나 응용 프로그램은 “DBMS” 가 관리하는 데이터에 동시에 접속하여 데이터를 공유합니다.
    
      즉, “DBMS” 에서는 “데이터베이스에서 사용되는 데이터가 집중 관리됩니다.”
    
  


DBMS에는 MySQL 외에도 많은 종류가 있습니다.


DBMS 또는 데이터베이스는 다음과 같은 몇 가지 중요한 특징을 가지고 있습니다.


  데이터의 무결성
    
      데이터베이스 안의 데이터는 어떤 경로를 통해 들어왔든 오류가 있어서는 안 되는데 이를 무결성(Integrity)이라고 합니다.
      무결성을 지키기 위해 데이터베이스는 제약 조건(Constraint)을 따릅니다.
        
          예를 들어 학생 데이터에서 모든 학생은 학번이 반드시 있어야 하고 학번이 중복되면 안 된다는 제약 조건을 생각해봅시다.
            
              이 제약 조건을 충실히 지킨다면 학번으로도 학생 데이터에서 학생을 정확히 찾을 수 있습니다.
              즉 학번은 무결한 데이터를 보장하는 요소이며, 자동 발급기로 성적 증명서나 재학 증명서를 뗄 때 학번만 조회해도 정확한 자료를 출력할 수 있습니다.
            
          
        
      
    
  
  데이터의 독립성
    
      데이터베이스의 크기를 변경하거나 데이터 파일의 저장소를 변경하더라도 기존에 작성된 응용 프로그램은 전혀 영향을 받지 않습니다.
        
          즉 데이터베이스와 응용 프로그램은 서로 의존적인 관계가 아니라 독립적인 관계입니다.
            
              예를 들어 데이터베이스가 저장된 디스크가 새것으로 변경되어도 기존에 사용하던 응용 프로그램은 아무런 변경 없이 계속 사용할 수 있습니다.
            
          
        
      
    
  
  보안
    
      데이터베이스 안의 데이터는 아무나 접근할 수 있는 것이 아니라 데이터를 소유한 사람이나 데이터에 접근이 허가된 사람만 접근할 수 있습니다.
      또한 같은 데이터에 접근할 때도 사용자의 계정에 따라서 각각 다른 권한을 갖습니다.
        
          최근 들어 고객 정보 유출사고가 빈번하여 보안(security)은 데이터베이스에서 더욱 중요한 이슈가 되고 있습니다.
        
      
    
  
  데이터 중복 최소화
    
      데이터베이스에서는 동일한 데이터가 여러 군데 중복 저장되는 것을 방지합니다.
        
          학교를 예로 들면, 학생 정보를 이용하는 교직원들(학생처, 교무처, 과사무실 등)이 각 직원마다 별도의 엑셀 파일로 학생 정보를 관리하면 한 명의 학생 정보가 각각의 엑셀 파일에 중복 저장됩니다.
          그러나 데이터베이스에 통합하여 관리하면 하나의 테이블에 데이터를 저장한 후 응용 프로그램마다 이를 공유하여 사용할 수 있어 데이터의 중복을 최소화할 수 있습니다.
        
      
    
  
  응용 프로그램 제작 및 수정 용이
    
      기존 파일 시스템에서는 각각의 파일 포맷에 맞춰 응용 프로그램을 개발했습니다.
        
          그러나 데이터베이스를 이용하면 통일된 방식으로 응용 프로그램을 작성할 수 있고 유지﹒보수 또한 쉽습니다.
        
      
    
  
  데이터의 안전성 향상
    
      대부분의 DBMS는 데이터 백업/복원 기능을 제공합니다.
        
          따라서 데이터가 손상되는 문제가 발생하더라도 원래의 상태로 복원 또는 복구할 수 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Database/2024-02-15-classificationOfDBMS.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Database/2024-02-15-classificationOfDBMS.html"><h1 class="title_post">💾[Database] DBMS의 분류</h1></a>
                        <a href="/2024/Database/2024-02-15-classificationOfDBMS.html" class="txt_post">
                            DBMS의 분류.

“DBMS” 는 크게 계층형(hierarchical), 망형(network), 관계형(relational), 객체지향형(object-oriented), 객체관계형(object-relational) 으로 분류됩니다.


  “계층형(Hierachical) DBMS”
    
      1960년대에 처음 등장한 DBMS 개념입니다.
      아래 그림에서 보듯이 각 계층이 트리 형태를 띠고 1:N 관계를 갖습니다.
        
          예를 들어 사장 1명에 부서 3개가 연결되어 있는 구조가 계층형 구조입니다.
        
      
      계층형 DBMS는 구축한 후 구조를 변경하기가 상당히 까다롭습니다.
      주어진 상태에서 검색은 빠르나 접근의 유연성이 부족하여 임의 검색 시 어려움이 있는 것이 단점입니다.
    
  





  “망형(network) DBMS”
    
      계층형(Hierachical) DBMS의 문제점을 개선하기 위해 1970년대에 시작되었습니다.
      1:1, 1:N, N:M(다대다) 관계가 지원되어 효과적이고 빠른 데이터 추출이 가능합니다.
      그러나 매우 복잡한 내부 포인터를 사용하고 프로그래머가 모든 구조를 이해해야만 프로그램을 작성할 수 있다는 단점이 여전히 존재합니다.
    
  





  관계형(Relational) DBMS
    
      1969년 에드거 F.코드(Edgar F. Codd)가 수학 모델에 근거하여 고안했습니다.
      관계형(Relational) DBMS의 핵심 개념은 ‘데이터베이스는 테이블(table)’이라는 최소 단위로 구성되어 있으며, 이 테이블은 하나 이상의 열로 구성되어 있다는 것입니다.
      관계형 DBMS에서는 모든 데이터가 테이블에 저장됩니다.
        
          테이블이라는 구조는 관계형 DBMS의 가장 기본적이고 중요한 구성으로, 테이블을 잘 이해하면 관계형 DBMS의 기본적인 것을 이해했다고 말할 수 있습니다.
        
      
    
  





  테이블은 데이터를 효율적으로 저장하기 위한 구조입니다.
    
      관계형 DBMS에서는 데이터를 하나가 아닌 여러 개의 테이블에 나누어 저장하므로 불필요한 공간의 낭비를 줄이고 데이터 저장의 효율성을 보장합니다.
        
          이렇게 나뉜 테이블의 관계를 “기본키(Primary Key, PK)” 와 “외래키(Foreign Key, FK)” 를 사용하여 맺음으로써 두 테이블을 부모와 자식 관계로 묶습니다.
          그리고 부모와 자식 관계로 연결된 테이블을 서로 조합하여 원하는 결과를 얻을 수 있습니다.
            
              이 때 “SQL(Structured Query Language, 구조화된 질의 언어)” 의 조인(join) 기능을 이용합니다.
            
          
        
      
    
  



  테이블은 릴레이션(relation), 엔티티(entity) 등으로도 불립니다.



  관계형 DBMS는 다른 DBMS에 비해 업무 변화에 따라 바로 순응할 수 있고 유지﹒보수 측면에서도 편리하다는 특징이 있습니다.
    
      또한 대용량 데이터를 체계적으로 관리할 수 있고 데이터의 무결성도 잘 보장됩니다.
      따라서 동시에 데이터에 접근하는 여러 응용 프로그래밍을 사용할 때 관계형 DBMS는 적절한 선택이 될 수 있습니다.
    
  
  관계형 DBMS의 단점으로는 시스템 자원을 많이 차지하여 시스템이 전반적으로 느려진다는 것을 꼽을 수 있습니다.
    
      그러나 최근에는 하드웨어의 급속한 발전으로 이러한 단점이 많이 보완되고 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-02-14-aboutNetwork.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-02-14-aboutNetwork.html"><h1 class="title_post">🌐[Network] 네트워크</h1></a>
                        <a href="/2024/Network/2024-02-14-aboutNetwork.html" class="txt_post">
                            네트워크

통신용 전송 매체로 연결된 여러 시스템이 프로토콜을 사용하여 데이터를 주고받을 때, 이들을 하나의 단위로 통칭하여 “네트워크(Network)” 라 부릅니다.

일반적인 “컴퓨터 네트워크” 에서는 물리적인 전송 매체로 연결된 컴퓨터들이 동일한 프로토콜을 이용해 서로 데이터를 주고받습니다.

“소규모 네트워크” 가 모여 “더 큰 네트워크” 를 구성할 수 있는데, “네트워크” 끼리는 “라우터(Router)”라는 중개 장비를 사용해서 연결합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-14-JavaRefAccount1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-14-JavaRefAccount1.html"><h1 class="title_post">☕️[Java] 메서드 리펙토링 - 입.출금</h1></a>
                        <a href="/2024/Java/2024-02-14-JavaRefAccount1.html" class="txt_post">
                            MethodEx3
package method.ex;

public class MethodEx3 {

  public static void main(String[] args) {
    int balance = 10000;

    // 입금
    int depositAmount = 1000;
    balance += depositAmount;
    System.out.println(depositAmount + "원을 입급하였습니다. 현재 잔액: " + balance + "원");

    // 출금
    int withdrawAmount = 2000;
    if (balance &gt;= withdrawAmount) {
      balance -= withdrawAmount;
      System.out.println(withdrawAmount + "원을 출금하였습니다. 현재 잔액: " + balance + "원");
    } else {
      System.out.println(withdrawAmount + "원을 출금하려 했으나 잔액이 부족합니다.");
    }
    System.out.println("최종 잔액: " + balance + "원");
  }
}


위 코드는 입금, 출금을 나타내는 코드입니다.
“입금(deposit)” 과 “출금(withdraw)” 을 메서드로 만들어서 리펙토링 해보겠습니다.

MethodEx3Ref
package method.ex;

public class MethodEx3Ref {

  public static void main(String[] args) {
    int balance = 10000;
    
    balance = deposit(10000, 1000);
    balance = withdraw(balance, 2000);
    
    System.out.println("최종 잔액: " + balance + "원");
  }

  public static int deposit(int balance, int amount) {
    balance += amount;
    System.out.println(amount + "원을 입급하였습니다. 현재 잔액: " + balance + "원");
    return balance;
  }

  public static int withdraw(int balance, int amount) {
    if (balance &gt;= amount) {
      balance -= amount;
      System.out.println(amount + "원을 출금하였습니다. 현재 잔액: " + balance + "원");
    } else {
      System.out.println(amount + "원을 출금하려 했으나 잔액이 부족합니다.");
    }
    return balance;
  }
}


위 코드는 리펙토링을 한 코드입니다.


  리펙토링 결과를 보면 main()은 세세한 코드가 아니라 전체 구조를 한눈에 볼 수 있게 되었습니다.
    
      “쉽게 이야기해서 책의 목자를 보는 것 같습니다.”
        
          더 자세히 알고 싶으면 해당 메서드를 찾아서 들어가면 됩니다.
          그리고 입금과 출금 부분이 메서드로 명확하게 분리되었기 때문에 이후에 변경 사항이 발생하면 관련된 메서드만 수정하면 됩니다.
          특정 메서드로 수정 범위가 한정되기 때문에 더 유지보수 하기 좋습니다.
        
      
    
  
  “이런 리펙토링을 메서드 추출(Extract Method)이라 합니다.”
    
      메서드를 재사용하는 목적이 아니어도 괜찮습니다. “메서드를 적절하게 사용해서 분류하면 구조적으로 읽기 쉽고 유지보수 하기 좋은 코드를 만들 수 있습니다.”
        
          그리고 “메서드의 이름 덕분에 프로그램을 더 읽기 좋게 만들 수 있습니다.”
        
      
    
  


// MethodEx3 내부코드에서의

// &lt;=== 입금로직 
int depositAmount = 1000;
balance += depositAmount;
System.out.println(depositAmount + "원을 입급하였습니다. 현재 잔액: " + balance + "원");
// ===&gt;

// &lt;=== 출금로직
    int withdrawAmount = 2000;
    if (balance &gt;= withdrawAmount) {
      balance -= withdrawAmount;
      System.out.println(withdrawAmount + "원을 출금하였습니다. 현재 잔액: " + balance + "원");
    } else {
      System.out.println(withdrawAmount + "원을 출금하려 했으나 잔액이 부족합니다.");
    }
// ===&gt;

위 코드 조각에서 볼 수 있듯 입금로직 부분과 출금로직 부분을 뽑아내어

// MethodEx3Ref 내부 메소드
    // 입금 메서드
  public static int deposit(int balance, int amount) {
    balance += amount;
    System.out.println(amount + "원을 입급하였습니다. 현재 잔액: " + balance + "원");
    return balance;
  }
    // 출금 메서드
  public static int withdraw(int balance, int amount) {
    if (balance &gt;= amount) {
      balance -= amount;
      System.out.println(amount + "원을 출금하였습니다. 현재 잔액: " + balance + "원");
    } else {
      System.out.println(amount + "원을 출금하려 했으나 잔액이 부족합니다.");
    }
    return balance;
  }


위의 두 deposit(입금) 메서드와 withdraw(출금) 메서드를 만들었습니다.


  이런 리펙토링을 메서드 추출(Extract Method) 이라 합니다.


메서드가 단순하게 코드를 재사용하고 여러 곳에서 같이 사용한다는 것을 떠나서, 구조적으로 우선 비슷한 것을 그룹화하거나 카테고리화하면 이미 그것만으로도 큰 효용가치가 있습니다.

  그래서 관련된 코드를 모아서 하나로 딱 묶어두는 것 입니다.
    
      그러면 읽기도 좋고, 유지보수에도 좋습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-13-methodStart.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-13-methodStart.html"><h1 class="title_post">☕️[Java] 메서드.</h1></a>
                        <a href="/2024/Java/2024-02-13-methodStart.html" class="txt_post">
                            메서드의 필요성을 알기위해서 아래의 코드를 보고 실제로 느껴보겠습니다.

아래의 코드는 두 숫자를 입력 받아서 더하고 출력하는 단순한 기능을하는 프로그램입니다.

먼저 1+2를 수행하고, 그 다음으로 10 + 20을 수행합니다.

package method;

public class Method1 {

  public static void main(String[] args) {
    // 계산1
    int a = 1;
    int b = 2;
    System.out.println(a + "+" + b + " 연산 수행");
    int sum1 = a + b;
    System.out.println("결과1 출력: " + sum1);

    // 계산2
    int x = 10;
    int y = 20;
    System.out.println(x + "+" + y + " 연산 수행");
    int sum2 = x + y;
    System.out.println("결과2 출력:" + sum2);
  }
}


위 코드는 다음과 같은 특징이 있습니다.


  같은 연산을 두 번 수행합니다.
  코드를 잘보면 계산 1 부분과, 계산 2 부분이 거의 같습니다.


계산 1

int a = 1;
int b = 2;
System.out.println(a + "+" + b + " 연산 수행");
int sum1 = a + b;


계산 2

int x = 10;
int y = 20;
System.out.println(x + "+" + y + " 연산 수행");
int sum2 = x + y;


계산 1과 2 둘 다 변수를 두 개 선언하고, 어떤 연산을 수행하는지 출력하고, 두 변수를 더해서 결과를 구합니다.
만약 프로그램의 여러 곳에서 이와 같은 계산을 반복해야 할 경우에는 같은 코드를 여러번 반복해서 작성해야 할 것입니다.
더 나아가서 어떤 연산을 수행하는지 출력하는 부분을 변경하거나 또는 제거하고 싶다면 해당 코드를 다 찾아다니면서 모두 수정해야 할 것 입니다.

함수(Function)



함수 정의

add(a, b) = a + b


  이름이 add이고, a,b라는 두 값을 받는 함수입니다. 그리고 이 함수는 a + b 연산을 수행합니다.


함수 사용

add(1,2) -&gt; 결과: 3
add(5,6) -&gt; 결과: 11
add(3,5) -&gt; 결과: 8



  함수에 값을 입력하면, 함수가 가진 연산을 처리한 다음 결과를 출력합니다. 여기서는 단순히 a + b라는 연산을 수행합니다.
  여러번 같은 계산을 해야 한다면 지금처럼 함수를 만들어두고(정의), 필요한 입력 값을 넣어서 해당 함수를 호출하면 됩니다. 그러면 계산된 결과가 나옵니다.
  함수는 마치 마술상자와 같습니다. 함수를 호출할 때는 외부에서는 필요한 값만 입력하면 됩니다. 그러면 계산된 결과가 출력됩니다.
    
      내부 구조는 어떻게 되어있는지 알 필요가 없습니다.
    
  
  같은 함수를 다른 입력 값으로 여러번 호출할 수 있습니다.
  여기서 핵심은 함수를 한 번 정의해두면 계속해서 재사용할 수 있다는 점입니다!


평균 함수



만약 두 수의 평균을 구해야 한다면 매번 (a + b) / 2라는 공식을 사용해야 할 것입니다.
이것을 함수로 만들어두면 다음과 같이 사용할 수 있습니다.

함수 정의
avg(a, b) = (a + b) / 2


함수 사용

avg(4, 6) -&gt; 결과: 5
avg(10, 20) -&gt; 결과: 15
avg(100, 200) -&gt; 결과: 150


수하의 함수의 개념을 프로그래밍에 가지고 온다면 어떨까요?
필요한 기능을 미리 정의해두고 필요할 때 마다 호출해서 사용할 수 있기 때문에 앞서 고민한 문제들을 해결할 수 있을 것 같습니다.
프로그램 언어들은 오래 전 부터 이런 문제를 해결하기 위해 수학의 함수라는 개념을 차용해서 사용합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-13-methodReturnType.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-13-methodReturnType.html"><h1 class="title_post">☕️[Java] 반환타입.</h1></a>
                        <a href="/2024/Java/2024-02-13-methodReturnType.html" class="txt_post">
                            반환 타입.

반환 타입이 있으면 반드시 값을 반환해야 합니다.
반환 타입이 있는 메서드는 반드시 return을 사용해서 값을 반환해야 합니다.
이 부분은 특히 조건문과 함께 사용할 때 주의해야 합니다.

MethodReturn1
package method;

public class MethodReturn1 {

  public static void main(String[] args) {
    boolean result = odd(2);
    System.out.println(result);
  }

  public static boolean odd(int i) {
    if (i % 2 == 1) {
      return true;
    }
  }
}


위 코드에서 if 조건이 만족할 때는 true가 반환됩니다.
하지만 조건을 만족하지 않는 경우에는 return문이 실행되지 않습니다.
따라서 위 코드를 실행하면 return 문을 누락했다는 컴파일 오류가 발생합니다.

컴파일 오류
java: missing return statement

MethodReturn1 - 수정코드
package method;

public class MethodReturn1 {

  public static void main(String[] args) {
    boolean result = odd(2);
    System.out.println(result);
  }

  public static boolean odd(int i) {
    if (i % 2 == 1) {
      return true;
    } else {
      return false;
    }
  }
}


위와 같이 수정하면 ìf 조건을 만족하지 않아도 else를 통해 return문이 실행됩니다.

return 문을 만나면 그 즉시 메서드를 빠져나갑니다.
return 문을 만나면 그 즉시 해당 메서드를 빠져나갑니다.

다음 로직을 수행하는 메서드를 만들어보겠습니다.

  18세 미만의 경우: 미성년자는 출입이 불가합니다.
  18세 이상의 경우: 입장하세요.


MethodReturn2
package method;

public class MethodReturn2 {

  public static void main(String[] args) {
//    checkAge(10);
    checkAge(18);
  }

  public static void checkAge(int age) {
    if (age &lt; 18) {
      System.out.println(age + "세, 미성년자는 출입이 불가합니다.");
      return;
    }
    System.out.println(age + "세, 입장하세요.");
  }
}


  18세 미만의 경우, “미성년자는 출입이 불가능합니다.”를 출력하고 바로 return문이 수행됩니다.
    
      따라서 다음 로직을 수행하지 않고, 해당 메서드를 빠져나옵니다.
    
  
  18세 이상의 경우, “입장하세요.”를 출력하고, 메서드가 종료됩니다.
    
      참고로 반환 타입이 없는 void형이기 때문에 마지막 줄의 return은 생략할 수 있습니다.
    
  


반환 값 무시.
반환 타입이 있는 메서드를 호출했는데 만약 반환 값이 필요없다면 사용하지 않아도 됩니다.


  예시 1) int sum = add(1,2)
    
      반환된 값을 받아서 ‘sum’에 저장했습니다.
    
  
  예시 2) add(1,2)
    
      반환된 값을 사용하지 않고 버립니다.
        
          여기서는 ‘예시 1’과 같이 호출 결과를 변수에 담지 않았습니다. 단순히 메서드만 호출했습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-13-method3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-13-method3.html"><h1 class="title_post">☕️[Java] 메서드정의</h1></a>
                        <a href="/2024/Java/2024-02-13-method3.html" class="txt_post">
                            메서드 정의

메서드는 다음과 같이 정의합니다.

public static int add(int a, int b) {
    // 메서드 본문, 실행 코드
}

제어자 반환타입 메서드이름(매개변수 목록) {
    메서드 본문
}



  제어자(Modifier) : public, static 과 같은 부분입니다.
    
      제어자는 추후에 학습 후 정리하겠습니다.
    
  
  반환 타입(Return Type) : 메서드가 실행 된 후 반환하는 데이터의 타입을 지정합니다.
    
      메서드가 값을 반환하지 않는 경우, 없다는 뜻의 void를 사용해야 합니다.
        
          예) void print(String str)
        
      
    
  
  메서드 이름(Method Name) : 메서드의 이름입니다.
    
      이 이름은 메서드를 호출하는 데 사용됩니다.
    
  
  매개변수(Parameter) : 입력 값으로, 메서드 내부에서 사용할 수 있는 변수입니다.
    
      매개변수(Parameter)는 옵션입니다. 입력값이 필요 없는 메서드는 매개변수(Parameter)를 지정하지 않아도 됩니다.
        
          예) add()
        
      
    
  
  메서드 본문(Method Body) : 실제 메서드의 코드가 위치합니다.
    
      중괄호 {} 사이에 코드를 작성합니다.
    
  


매개변수가 없거나 반환 타입이 없는 경우
매개변수가 없고, 반환 타입도 없는 메서드를 확인해봅시다.

package method;

public class Method2 {

  public static void main(String[] args) {
    // 매개변수가 없기 때문에 전달하는 인수,인자도 없다.
    printHeader();
    System.out.println("프로그램이 동작합니다.");
    printFooter();
  }
  // 반환타입과 매개변수가 없는 함수
  public static void printHeader() {
    System.out.println("= 프로그램을 시작합니다 =");
    return; // void의 경우 생략 가능
  }
  
  public static void printFooter() {
    System.out.println("= 프로그램을 종료합니다 =");
  }
}


실행 결과
= 프로그램을 시작합니다 =
프로그램이 동작합니다.
= 프로그램을 종료합니다 =


printHeader(), printFooter() 메서드는 매개변수가 없고, 반환 타입도 없습니다.


  매개변수가 없는 경우
    
      선언 : public static void printHeader()와 같이 매개변수를 비워두고 정의하면 됩니다.
      호출 : printHeader();와 같이 인수를 비워두고 호출하면 됩니다.
    
  
  반환 타입이 없는 경우
    
      선언 : public static void printHeader()와 같이 반환 타입을 void로 정의하면 됩니다.
      호출 : printHeader(); 와 같이 반환 타입이 없으므로 메서드만 호출하고 반환 값을 받지 않으면 됩니다.
        
          String str = printHeader(); 반환 타입이 void이기 때문에 이렇게 반환 값을 받으면 컴파일 오류가 발생합니다.
        
      
    
  


void와 return 생략
모든 메서드는 항상 return을 호출해야 합니다.
그런데 반환 타입 void의 경우에는 예외로 printFooter()와 같이 생략해도 됩니다.
자바 컴파일러가 반환 타입이 없는 경우에는 return을 마지막줄에 넣어줍니다.
참고로 return을 만나면 해당 메서드는 종료됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-13-method2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-13-method2.html"><h1 class="title_post">☕️[Java] 메서드(2)</h1></a>
                        <a href="/2024/Java/2024-02-13-method2.html" class="txt_post">
                            메서드 정의

public static int add(int a, int b) {
    System.out.println(a + "+" + b + " 연산 수행");
    int sum = a + b;
    return sum;
}


위 코드가 바로 메서드입니다.
이것을 함수를 정의하는 것과 같이, 메서드를 정의한다고 표현합니다.
메서드는 수학의 함수와 유사하게 생겼습니다.
함수에 값을 입력하면, 어떤 연산을 처리한 다음에 결과를 반환합니다.


  수학에 너무 집중하지 않아도 됩니다, 단순히 무언가 정의해두고 필요할 때 불러서 사용한다는 개념으로 이해하면 충분합니다.


메서드는 크게 “메서드 선언” 과 “매서드 본문” 으로 나눌 수 있습니다.

메서드 선언(Method Declaration)

public static int add(int a, int b)


  메서드의 선언 부분으로, 메서드 이름, 반환 타입, 파라미터(매개변수) 목록을 포함합니다.
    
      이름 그대로 이런 메서드가 있다고 선언하는 것입니다.
      메서드 선언 정보를 통해 다른 곳에서 해당 메서드를 호출할 수 있습니다.
    
  
  public static
    
      public: 다른 클래스에서 호출할 수 있는 메서드라는 뜻입니다. (접근 제어에서 학습할 예정)
      static: 객체를 생성하지 않고 호출할 수 있는 정적 메서드라는 뜻입니다. (자세한 내용은 추후에 정리)
    
  
  int add(int a, int b)
    
      int: 반환 타입을 정의합니다. 메서드의 실행 결과를 반환할 때 사용할 반환 타입을 지정합니다.
      add: 메서드의 이름입니다. 이 이름으로 메서드를 호출할 수 있습니다.
      (int a, int b): 메서드를 호출할 때 전달하는 입력 값을 정의합니다. 이 변수들은 해당 메서드 안에서만 사용됩니다. 이렇게 메서드 선언에 사용되는 변수를 영어로 파라미터(parameter), 한글로 매개변수라 합니다.
    
  


메서드 본문(Method Body)

{
    System.out.println(a + "+" + b + " 연산 수행");
    int sum = a + b;
    return sum;
}



  메서드가 수행해야 하는 코드 블록입니다.
  메서드를 호출하면 메서드 본문이 순서대로 실행됩니다.
  메서드 본문은 마술상자입니다. 메서드를 호출하는 곳에서는 메서드 선언은 알지만 메서드 본문은 모르기 때문입니다.
  메서드의 실행 결과를 반환하려면 return문을 사용해야 합니다. return문은 다음에 반환할 결과를 적어주면 됩니다.
    
      return sum: sum 변수에 들어있는 값을 반환합니다.
    
  


메서드 호출

앞서 정의한 메서드를 호출해서 실행하려면 메서드 이름에 입력 값을 전달하면 됩니다. 보통 메서드를 호출한다고 표현합니다.

int sum1 = add(5, 10);
int sum2 = add(15, 20);


메서드를 호출하면 어떻게 실행되는지 순서대로 확인해봅시다.

int sum1 = add(5, 10); // add라는 메서드를 숫자 5, 10을 전달하면서 호출합니다.
int sum1 = 15; // add(5, 10)이 실행됩니다. 실행 결과 반환 값은 15입니다.


메서드를 호출하면 메서드는 계산을 끝내고 결과를 반환합니다.
쉽게 이야기하자면, 메서드 호출이 끝나면 해당 메서드가 반환한 결과 값으로 치환됩니다.

메서드 호출이 끝나면 더 이상 해당 메서드가 사용한 메모리를 낭비할 이유가 없습니다.
메서드 호출이 끝나면 메서드 정의에 사용한 파라미터 변수인 int a, int b는 물론이고, 그 안에서 정의한 int sum도 모두 제거 되기 때문입니다.

메서드 호출과 용어정리
메서드를 호출할 때는 다음과 같이 메서드에 넘기는 값과 매개변수(파라미터)의 타입이 맞아야 합니다.
물론 넘기는 값과 매개변수(파라미터)의 순서와 갯수도 맞아야 합니다.

호출: call("hello", 20)
메서드 정의: int call(String str, int age)


인수(Argument)
여기서 hello,20 처럼 넘기는 값을 영어로 Argument(아큐먼트), 한글로 인수 또는 인자라 합니다.
실무에서는 아규먼트, 인수, 인자라는 용어를 모두 사용합니다.

매개변수(Parameter)
메서드를 정의할 때 선언한 변수인 String str, int age를 매개변수, 파라미터라 합니다.
메서드를 호출할 때 인수를 넘기면, 그 인수가 매개변수에 대입됩니다.
실무에서는 매개변수, 파라미터 용어를 모두 사용합니다.

용어정리

  인수라는 용어는 ‘인’과 ‘수’의 합성어로, ‘들어가는 수’라는 의미를 가집니다. 즉, 메서드 내부로 들어가는 값을 의미합니다. 인자도 같은 의미입니다.
  매개변수, parameter는 ‘매개’와 ‘변수’의 합성어로 ‘중간에서 전달하는 변수’라는 의미를 가집니다. 즉, 메서드 호출부와 메서드 내부 사이에서 값을 전달하는 역할을 하는 변수라는 뜻입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-13-Spring.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-13-Spring.html"><h1 class="title_post">🍃[Spring Boot] 스프링?</h1></a>
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-13-Spring.html" class="txt_post">
                            Intro.


  스프링 프레임워크(Spring Framework) 는 자바(Java) 가반의 애플리케이션 프레임워크로 엔터프라이즈급 애플리케이션을 개발하기 위한 다양한 기능을 제공합니다.
  스프링은 목적에 따라 다양한 프로젝트를 제공하는데, 그중 하나가 스프링 부트(Spring Boot) 입니다.


이번 포스팅에서는 먼저 스프링 부트의 기반인 스프링 프레임워크를 알아보고, 스프링이 제공하는 다양한 프로젝트 중 하나인 스프링 부트의 특징을 설명하겠습니다.

스프링 프레임워크.

스프링 프레임워크(이후 스프링) 는 자바에서 가장 많이 사용하는 프레임워크입니다.
스프링은 자바 언어를 이용해 엔터프라이즈급 개발을 편리하게 만들어주는 ‘오픈소스 경량급 애플리케이션 프레임워크’로 불리고 있습니다.
쉽게 말해서 자바로 애플리케이션을 개발하는 데 필요한 기능을 제공하고 쉽게 사용하도록 돕는 도구입니다.


  TIP: ‘엔터프라이즈급 개발?’

  ‘엔터프라이즈급 개발’은 기업 환경을 대상으로 하는 개발을 뜻합니다.
네이버나 카카오톡 같은 대규모 데이터를 처리하는 환경을 엔터프라이즈 환경이라고 부릅니다.
스프링은 이 환경에 알맞게 설계되어 있어 개발자는 애플리케이션을 개발할 때 많은 요소를 프레임워크에 위임하고 비즈니스 로직을 구현하는 데 집중할 수 있습니다.


스프링의 핵심 가치는 “애플리케이션 개발에 필요한 기반을 제공해서 개발자가 비즈니스 로직 구현에만 집중할 수 있게끔 하는 것” 입니다.

제어 역적(IoC)

일반적인 자바 개발의 경우 객체를 사용하기 위해 아래의 예제 코드와 같은 코드를 사용합니다.

@RestController
public class NoDIController {
    
    private MyService service = new MyServiceImpl();
    
    @GetMapping("/no-di/hello")
    public String getHello() {
        return service.getHello();
    }
}


즉, 사용하려는 객체를 선언하고 해당 객체의 의존성을 생성한 후 객체에서 제공하는 기능을 사용합니다.
객체를 생성하고 사용하는 일련의 작업을 개발자가 직접 제어하는 구조입니다.

하지만 제어 역전(IoC: Inversion of Controller) 을 특징으로 하는 스프링은 기존 자바 개발 방식과 다르게 동작합니다.
IoC를 적용한 환경에서는 사용할 객체를 직접 생성하지 않고 객체의 생명주기 관리를 외부에 위임합니다.
여기서 ‘외부’ 는 스프링 컨테이너(Spring Container) 또는 IoC 컨테이너(IoC Container) 를 의미합니다.

“객체의 관리를 컨테이너에 맡겨 제어권이 넘어간 것”을 제어 역전이라고 부르며, 제어 역전을 통해 의존성 주입(DI: Dependency Injection), 관점 지향 프로그래밍(AOP: Aspect-Oriented Programming) 등이 가능해집니다.

스프링 을 사용하면 객체의 제어권을 컨테이너로 넘기기 때문에 “개발자는 비즈니스 로직을 작성하는 데 더 집중” 할 수 있습니다.

의존성 주입(DI)

의존성 주입(DI: Dependency Injection)이란 “제어 역전의 방법 중 하나”로, 사용할 객체를 직접 생성하지 않고 외부 컨테이너가 생성한 객체를 주입받아 사용하는 방식을 의미합니다.

스프링에서 의존성을 주입받는 방법은 3가지가 있습니다.


  생성자를 통한 의존성 주입
  필드 객체 선언을 통한 의존성 주입
  setter 메서드를 통한 의존성 주입


스프링에서는 @Autowired라는 어노테이션(annotation)을 통해 의존성을 주입할 수 있습니다.
스프링 4.3 이후 버전은 생성자를 통해 의존성을 주입할 때 @Autowired 어노테이션을 생략할 수도 있습니다.
하지만 스프링을 처음 다룰 때는 가독성을 위해 어노테이션을 명시하기를 권장합니다.

스프링에서 의존성을 주입받는 각 방법에 대한 예시 코드는 아래와 같습니다.

// 생성자를 통한 의존성 주입
@RestController
public class DIController {
    
    // &lt;-- 의존성을 주입 받는 주요부분 
    MyService myService;
    @Autowired
    public DIController(MyService myService) {
        this.myService = myServicel
    }
    // --&gt;
    
    @GetMapping("di/hello")
    public String getHello() {
        return myService.getHello();
    }
}


// 필드 객체 선언을 통한 의존성 주입
@RestController
public class FieldInjectionController {
    // &lt;-- 의존성을 주입 받는 주요부분
    @Autowired
    private MyService myService;
    // --&gt;
}


// setter 메서드를 통한 의존성 주입
@RestController
public class SetterInjectionController {
    // &lt;-- 의존성을 주입 받는 주요부분
    MyService myService;
    
    @Autowired
    public void setMyService(MyService myService) {
        this.myService = myService;
    }
    // --&gt;
}


스프링 공식 문서에서 권장하는 의존성 주입 방법은 “생성자를 통해 의존성을 주입받는 방식” 입니다.
다른 방식과는 다르게 생성자를 통해 의존성을 주입받는 방식은 “레퍼런스 객체 없이는 객체를 초기화할 수 없게 설계할 수 있기 때문입니다.”

관점 지향 프로그래밍(AOP)

관점 지향 프로그래밍(이후 AOP: Aspect-Oriented Programming) 은 스프링의 아주 중요한 특징입니다.
AOP는 OOP를 더욱 잘 사용하도록 돕는 개념으로 보는 것이 좋습니다.


  스터디 가이드

  OOP를 요약하자면 각 기능을 재사용 가능한 개별 객체로 구성해 프로그래밍하는 것을 뜻합니다.

  다음과 같은 OOP의 핵심키워드를 이해한다면 더 나은 객체지행 프로그래밍이 가능합니다.

  
    추상화(abstraction)
    캡슐화(encapsulation)
    상속(inheritance)
    다형성(polymorphism)
  


“AOP는 관점을 기준으로 묶어 개발하는 방식을 의미합니다.”
여기서 “관점(aspect)” 이란 “어떤 기능을 구현할 때 그 기능을 ‘핵심 기능’과 ‘부가 기능’으로 구분해 각각을 하나의 관점으로 보는 것을 의미” 합니다.


  “핵심기능”
    
      비즈니스로직을 구현하는 과정에서 비즈니스 로직이 처리하려는 목적 기능을 말합니다.
        
          예를 들면, 클라이언트로부터 상품 정보 등록 요청을 받아 데이터베이스에 저장하고, 그 상품 정보를 조회하는 비즈니스 로직을 구현한다면
            
              (1) 상품 정보를 데이터베이스에 저장하고,
              (2) 저장된 상품 정보 데이터를 보여주는 코드가 핵심 기능입니다.
            
          
        
      
    
  


그런데 실제 애플리케이션을 개발할 때는 핵심 기능에 부가 기능을 추가할 상황이 생깁니다.
“핵심 기능인 비즈니스 로직 사이에 로깅 처리를 하거나 트랜잭션을 처리하는 코드를 예로 들 수 있습니다.”

일반적인 OOP 형식으로 비즈니스 로직을 작성하면 아래 그림과 같이 비즈니스 동작 흐름이 발생합니다.



OOP 방식의 애플리케이션 로직에서는 위 그림과 같이 객채마다 핵심 기능을 수행하기 위한 “로직” 과 함께 부가 기능인 “로깅”, “트랜잭션” 등의 코드를 작성합니다.
위 그림의 상품정보 등록 기능과 상품정보 조회 기능은 엄연히 다른 기능으로, 각자 로직이 구현돼 있습니다.

하지만 유지보수 목적이나 데이터베이스 접근을 위해 작성된 “로깅” 과 “트랜잭션” 영역은 상품정보를 등록할 때나 상품정보를 조회할 때 동일한 기능을 수행할 확률이 높습니다.

즉, 핵심 기능을 구현한 두 로직에 동일한 코드가 포함된다는 것을 의미합니다.

AOP의 관점에서는 부가 기능은 핵심 기능이 어떤 기능인지에 구관하게 로직이 수행되기 전 또는 후에 수행되기만 하면 됩니다.
그래서 아래 그림과 같은 구성으로 만들 수 있습니다.



이처럼 여러 비즈니스 로직에서 반복되는 부가 기능을 하나의 “공통 로직으로 처리하도록 모듈화해 삽입하는 방식” 을 “AOP” 라고 합니다.

이러한 AOP를 구현하는 방법은 크게 세 가지가 있습니다.


  컴파일 과정에 삽입하는 방식
  바이트코드를 메모리에 로드하는 과정에 삽입하는 방식
  프락시 패턴을 이용한 방식


이 가운데 스프링은 디자인 패턴 중 하나인 “프락시 패턴” 을 통해 “AOP” 기능을 제공하고 있습니다.

스프링 AOP의 목적은 OOP와 마찬가지로 모듈화해서 재사용 가능한 구성을 만드는 것이고, 모듈화된 객체를 편하게 적용할 수 있게 함으로써 개발자가 비즈니스 로직을 구현하는 데만 집중할 수 있게 도와주는 것입니다.

스프링 프레임워크의 다양한 모듈

스프링 프레임워크는 기능별로 구분된 약 20여 개의 모듈로 구성돼 있습니다.

아래 그림은 스프링 공식 문서에서 제공하는 다이어그램입니다.



스프링 프레임워크 공식 문서에서는 스프링 버전별로 다른 다이어그램을 제시하고 있지만 큰 틀은 유사합니다.
그리고 스프링 프레임워크를 사용한다고 해서 모든 모듈을 사용할 필요는 없습니다.
애플리케이션 개발에 필요한 모듈만 선택해서 사용하게끔 설계돼 있으며, 이를 “경량 컨테이너 설계”라고 부릅니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-11-foreach.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/forloop.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-11-foreach.html"><h1 class="title_post">☕️[Java] 향상된 for문</h1></a>
                        <a href="/2024/Java/2024-02-11-foreach.html" class="txt_post">
                            ☕️[Java] 향상된 for문


  향상된 for문(Enhanced For Loop)을 이해하려면 배열을 먼저 알아야 합니다.
    
      각각의 요소를 탐색한다는 의미로 for-each문이라고도 많이 불립니다.
    
  
  향상될 for문은 배열을 사용할 때 기존 for문 보다 더 편리하게 사용할 수 있습니다.


향상된 for문 정의
for (변수 : 배열 또는 컬렉션) {
    // 배열 또는 컬렉션의 요소를 순회하면서 수행할 작업
}


일반 for문
for(int i = 0; i &lt; numbers.length, i++) {
    int number = numbers[i];
    System.out.println(number);
}


일반 for문은 배열에 있는 값을 순서대로 읽어서 number 변수에 넣고 출력합니다.
배열은 처음부터 끝까지 순서대로 읽어서 사용하는 경우가 많습니다.
그런데 배열의 값을 읽으려면 int i와 같은 인덱스를 탐색할 수 있는 변수를 선언해야 합니다.
그리고 i &lt; numbers.length와 같이 배열의 끝 조건을 지정해주어야 합니다.
마지막으로 배열의 값을 하나 읽을 때 마다 인덱스를 하나씩 증가해야 합니다

개발자 입장에서는 그냥 배열을 순서대로 처음부터 끝까지 탐색하고 싶은데, 너무 번잡한 일을 해주어야 합니다.
그래서 향상된 for문이 등장했습니다.

향상된 for문
// 향상된 for문 for-each문
for (int number : numbers) {
    System.out.println(number);
}


  앞서 일반 for문과 동일하게 작동합니다.
  향상된 for문은 배열의 인덱스를 사용하지 않고, 종료 조건을 주지 않아도 됩니다. 단순히 해당 배열을 처음부터 끝까지 탐색합니다.
  : 의 오른쪽에 numbers와 같이 탐색할 배열을 선택하고, :의 왼쪽에 int number와 같이 반복할 때 마다 찾은 값을 저장할 변수를 선언합니다. 그러면 배열의 값을 하나씩 꺼내서 왼쪽에 있는 number에 담과 for문을 수행합니다. for문의 끝에 가면 다음 값을 꺼내서 number에 담고 for문을 반복 수행합니다. numbers 배열의 끝에 도달해서 더 값이 없으면 for문이 완전히 종료 됩니다.
  향상된 for문은 배열의 인덱스를 사용하지 않고도 배열의 요소를 순회할 수 있기 때문에 코드가 간결하고 가독성이 좋습니다.


향상된 for문을 사용하지 못하는 경우
향상된 for문을 사용하지 못하는 경우가 있습니다.
향상된 for문에는 증가하는 인덱스 값이 감추어져 있습니다.
따라서 int i와 같은 증가하는 인덱스 값을 직접 사용해야 하는 경우에는 향샹된 for문을 사용할 수 없습니다.
// for-each문을 사용할 수 없는 경우, 증가하는 index 값이 필요할 때.
for (int i = 0; i &lt; numbers.length; i++) {
    System.out.println("numbers " + i + "번의 결과는: " + numbers[i]);
}

이 예제에서는 증가하는 i 값을 출력해야 하므로 향상된 for문 대신에 일반 for문을 사용해야 합니다.

물론 다음과 같이 억지스럽게 향상된 for문을 사용하는 것이 가능하지만, 이런 경우 일반 for문을 사용하는 것이 더 좋다.
int i = 0;
for (int number : numbers) {
    System.out.println("number" + i +"번의 결과는: " + number);
    i++;
}


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-02-10-protocol.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-02-10-protocol.html"><h1 class="title_post">🌐[Network] 프로토콜.</h1></a>
                        <a href="/2024/Network/2024-02-10-protocol.html" class="txt_post">
                            🌐[Network] 프로토콜.

논리적으로 상호 연동되는 시스템이 전송 매체를 통해 데이터를 교환할 때는 표준화된 대화 규칙을 따르는데, 이 규칙을 프로토콜(Protocol) 이라고 합니다.

일반적으로 프로토콜은 상하 관계가 아닌 동등한 위치에 있는 시스템 사이의 규칙이라는 측면이 강조되어 인터페이스와 구분됩니다.



인터페이스는 아래 그림과 같이 두 시스템이 연동하기 위한 특정한 접촉 지점(Access Point) 을 의미하는 경우가 많지만, 프로토콜과 비교하여 인용될 때는 상하 개념이 적용됩니다.


  즉, 나중에 배우게 될 네트워크의 계층 모델 구조에서 인터페이스는 상하 계층 사이의 관계를 다루고, 프로토콜은 동등 계층 사이의 관계를 다룹니다.


일반적으로 프로토콜은 주고받는 데이터 형식과 그 과정에서 발생하는 일련의 절차적 순서에 무게를 둡니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-09-springFramework1.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-09-springFramework1.html"><h1 class="title_post">🍃[Spring] 라이브러리 살펴보기</h1></a>
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/2024-02-09-springFramework1.html" class="txt_post">
                            🍃[Spring] 라이브러리 살펴보기.

    Gradle은 의존관계가 있는 라이브러리를 함께 다운로드 합니다.


    스프링 부트 라이브러리
    
    spring-boot-start-web
    
        spring-boot-start-tomcat: 톰캣(웹서버)
        spring-webmvc: 스프링 웹 MVC
    
    spring-boot-starter-thymeleaf: 타임리프 템플릿 엔진(View)
    spring-boot-starter(공통): 스프링 부트 + 스프링 코어 + 로깅
    
        spring-boot
        
            spring-core
        
        spring-boot-starter-logging
        
            logback, slf4j
        
    



    테스트 라이브러리
    
    spring-boot-starter-test
    
        junit: 테스트 프레임워크
        mockito: 목 라이브러리
        assertj: 테스트 코드를 좀 더 편하게 작성하게 도와주는 라이브러리
        spring-test: 스프링 통합 테스트 지원
    



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-09-typecasting.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-09-typecasting.html"><h1 class="title_post">☕️[Java] 형변환 정리.</h1></a>
                        <a href="/2024/Java/2024-02-09-typecasting.html" class="txt_post">
                            ☕️[Java] 형변환 정리.

    형변환


    int =&gt; long =&gt; double
    
        작은 범위에서 큰 범위로는 대입할 수 있습니다.
        
            이것을 묵시적 형변환 또는 자동 형변환이라 합니다.
        



    
        큰 범위에서 작은 범위의 대입은 다음과 같은 문제가 방생할 수 있습니다. 이때는 명식적 형변환을 사용해야 합니다.
        
            소수점 버림
            오버플로우
        



    
        연산과 형변환
        
            같은 타입은 같은 결과를 냅니다.
            서로 다른 타입의 계산은 큰 범위로 자동 형변환이 일어납니다.
        



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-02-08-TransmissionMedia.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-02-08-TransmissionMedia.html"><h1 class="title_post">🌐[Network] 전송매체.</h1></a>
                        <a href="/2024/Network/2024-02-08-TransmissionMedia.html" class="txt_post">
                            🌐[Network] 전송매체

    시스템끼리 정해진 인터페이스를 연동해 데이터를 전달하려면 물리적인 전송 수단인 전송 매체(Transmission Media)가 반드시 있어야 합니다.


    전송 매체는 사람의 눈으로 볼 수 있는 동축케이블을 포함하여 소리를 전파하는 공기, 무선 신호 등 다양하게 존재합니다.


    인터페이스는 시스템 간의 물리적인 연동을 위한 논리적인 규격이고 인터페이스로 정해진 규격은 전송 매체를 통해 물리적으로 구현되며, 시스템끼리 데이터 정송을 가능하게 합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-07-scope1.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-07-scope1.html"><h1 class="title_post">☕️[Java] 스코프 존재 이유 1</h1></a>
                        <a href="/2024/Java/2024-02-07-scope1.html" class="txt_post">
                            ☕️[Java] 스코프 존재 이유 1

    
        
        package scope;

        public class Scope3_1 {

            public static void main(String[] args) {
                int m = 10;
                int temp = 0;
                if (m &gt; 0) {
                    temp = m * 2;
                    System.out.println("temp = " + temp);
                }
                System.out.println("m = " + m);
            }
        }



    조건이 맞으면 변수 m의 값을 2배 증가해서 출력하는 코드입니다.
    여기서 2배 증가한 값을 저장해두기 위해 임시 변수 temp를 사용했습니다.
    그런데 이 코드는 좋은 코드라고 보기는 어렵습니다.
    그 이유는 임시 변수 temp는 if 조건이 만족할 때 임시로 잠깐 사용하는 변수입니다
    그런데 임시 변수 temp가 main()코드 블록에 선언되어 있습니다.
    이렇게 되면 다음과 같은 문제가 발생합니다.


    비효율적인 메모리 사용:
    
    temp는 if코드 블록에서만 필요하지만, main() 코드 블록이 종료될 때 까지 메모리에 유지됩니다. 만약 if 코드 블록 안에 temp를 선언했다면 자바를 구현하는 곳에서 if 코드 블록의 종료 시점에 이 변수를 메모리에서 제거해서 더 효율적으로 메모리응 사용할 수 있습니다.



        
        
        package scope;

        public class Scope3_1 {

            public static void main(String[] args) {
                int m = 10;
                
                if (m &gt; 0) {
                    int temp = m * 2;// temp의 생존 시작
                    System.out.println("temp = " + temp);
                } // temp의 생존 종료
                System.out.println("m = " + m);
            }
        }



    코드 복잡성 증가:
    
    좋은 코드는 군더더기 없는 단순한 코드입니다.temp는 if코드 블록에서만 필요하지만, main() 코드 블록이 종료될 때 까지 메모리에 유지됩니다.따라서 불필요한 메모리가 낭비됩니다.만약 if 코드 블록 안에 temp를 선언했다면 if가 끝나고 나면 temp를 전혀 생각하지 않아도 됩니다.즉, 머리속에서 생각할 변수를 하나 줄일 수 있다는 말입니다.그런데 지금 작성한 코드는 if 코드 블록이 끝나도 main() 어디서나 temp를 여전히 접근할 수 있습니다.누군가 이 코드를 유지보수 할 때 m은 물론이고 temp까지 계속 신경써야 합니다.스코프가 불필요하게 넓은 것입니다.지금은 코드가 매우 단순해서 이해하는데 어려움이 없겠지만 실무에서는 코드가 매우 복잡한 경우가 많습니다.



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-07-loop.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-07-loop.html"><h1 class="title_post">☕️[JAVA] while문과 for문.</h1></a>
                        <a href="/2024/Java/2024-02-07-loop.html" class="txt_post">
                            ☕️[JAVA] while문과 for문.


    for문


    장점:
    
    초기화, 조건 체크, 반복 후의 작업을 한 줄에서 처리할 수 있어 편리하다.
    정해진 횟수만큼의 반복을 수행하는 경우에 사용하기 적합하다.
    루프 변수의 범위가 for 루프 블록에 제한되므로, 다른 곳에서 이 변수를 실수로 변경할 가능성이 적다.



    단점:
    
    루프의 조건이 루프 내부에서 변경되는 경우, for 루프는 관리하기 어렵다.
    복잡한 조건을 가진 반복물을 작성하기에는 while문이 더 적합할 수 있다.



    while문


    장점:
    
    루프의 조건이 루프 내부에서 변경되는 경우, while 루프는 이를 관리하기 쉽다.
    for 루프보다 더 복잡한 조건과 시나리오에 적합하다.
    조건이 충족되는 동안 계속해서 루프를 실행하며, 종료 시점을 명확하게 알 수 없는 경우에 유용하다.



    단점:
    
    초기화, 조건 체크, 반복 후의 작업이 분산되어 있어 코드를 이해하거나 작성하기 어려울 수 있다.
    루프 변수가 while 블록 바깥에서도 접근 가능하므로, 이 변수를 실수로 변경하는 상황이 발생할 수 있다.



    한줄로 정의하자면 정해진 횟수만큼 반복을 수행해야 하면 for문을 사용하고 그렇지 않으면 while문을 사용하면 된다. 물론 이것이 항상 정답은 아니니 기준으로 삼는 정도로 이해하자.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-06-JavaFormat.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-06-JavaFormat.html"><h1 class="title_post">☕️[JAVA] Packaing 옵션.</h1></a>
                        <a href="/2024/Java/2024-02-06-JavaFormat.html" class="txt_post">
                            ☕️[JAVA] Packaing 옵션.

    Spring Initializr에서 "Packaing" 옵션을 선택할 때 'Jar'와 'War' 중에 선택해야 합니다.


    어떤 것을 선택해야 할지는 개발하려는 어플리케이션의 유형과 배포 환경에 따라 달라집니다.


    각 포맷에 대한 설명.


    1️⃣ Jar (Java Archive)


    
        Jar 파일은 Java 클래스 파일, 메타데이터, 리소스 파일을 하나의 파일로 압축한 포맷입니다.
        스탠드얼론(Spring Boot 어플리케이션 권장 포맷):  Jar 포맷은 내장된 서버(예: Tomcat, Jetty)를 사용하여 스프링 부트 어플리케이션을 스탠드얼론 어플리케이션으로 실행할 수 있게 합니다. 이는 별도의 웹 서버 설치 없이도 실행 가능하며, 마이크로서비스, 클라우드 어플리케이션 개발에 적합합니다.
        간편한 배포와 실행: Jar 파일은 'java -jar' 명령어로 쉽게 실행할 수 있으며, 도커 컨테이너와 같은 환경에 배포하기도 용이합니다.



    2️⃣ War (Web Application Archive)


    
        War 파일은 웹 어플리케이션에 필요한 Java 클래스 파일, JSP(JavaServer Pages), 서블릿, 리소스 파일, 메타데이터 등을 포함한 포맷입니다.
        전통적인 웹 어플리케이션: War 포맷은 서블릿 컨테이너나 어플리케이션 서버(예: Tomcat, Jetty, WebLogic, WildFly)에 배포될 전통적인 웹 어플리케이션 개발에 사용됩니다. 이 경우, 어플리게이션 서버가 웹 어플리케이션을 실행하는데 필요한 환경을 제공합니다.
        엔터프라이즈 환경: 복잡한 엔터프라이즈 환경에서는 여러 어플리케이션을 하나의 서버에 배포해야 할 필요가 있을 수 있으며, War 포맷이 이러한 요구 사항을 충족시킬 수 있습니다.



    🙌 선택 기준


    
        스탠드얼론 어플리케이션 개발 및 마이크로 아키텍처를 선호한다면 'Jar'를 선택하세요.
        기존의 엔터프라이즈 환경에서 어플리케이션 서버를 사용해야 한다면 'War'를 선택하세요.



    Spring Boot는 두 가지 포맷 모두를 지원하므로, 프로젝트 요구 사항과 배포 환경에 맞게 최적의 옵션을 선택할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Read%20English%20Book/2024-02-06-TheOldMadAndTheSea7.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Read%20English%20Book/2024-02-06-TheOldMadAndTheSea7.html"><h1 class="title_post">📚[Book] The old man and the sea (7).</h1></a>
                        <a href="/2024/Read%20English%20Book/2024-02-06-TheOldMadAndTheSea7.html" class="txt_post">
                            📚[Book] The old man and the sea (7).


    
        sardines: 정어리
        
            *"So I can get the cast net and go after the sardines"
        *"그래서 나는 투망을 가져다가 정어리를 잡으러 갈 수 있어요"
        



    
        hard: 단단한,견고한
        barided: 땋아진, 삼줄로 엮어진
        hard-barided line: 단단하게 땋아진
        harpoon: (고래나 큰 물고기를 잡는데 사용되는) 창
        
            *The old man carried mast on his shoulder and the boy carried the wooden box with the coiled, hard-barided lines, the gaff and the harpoon with the its shaft.
            *노인은 돛대를 어깨에 메고, 소년은 감겨 있고 단단하게 엮인 갈색 줄, 갈고리대, 그리고 창과 그 손잡이가 담긴 나무 상자를 들고 갔다.
        



    stern: 선미
    subdue: 제압하다, 통제하다
    
        *The box with the baits was under the stern of the skiff along with the club that was used to subdue the big fish when they wew brought alongside
        *미끼 상자는 보트의 선미 아래에 있었고, 큰 물고기를 옆으로 끌어당겼을 때 그것들을 제압하기 위해 사용된 몽둥이도 함께 있었다.



    dew: 이슬
    through: ~을 통하여, ~동안, 끝까지
    temptation: 유혹
    
        *No one would steal from the old man but it was better to take the sail and the heavy lines home as the dew was bad for them and, though he was quite sure no local people would steal from him, the old man thouhjt that a gaff and a harpoon were needless temptations
        아무도 그 노인에게서 훔치지 않겠지만, 이슬이 돛과 무거운 줄들에게 해로웠기 때문에 그것들을 집에 가져가는 것이 나았고, 비록 현지 사람들이 자신에게서 훔치지 않을 것이라고 확신하고 있었지만, 노인은 갈고리대와 창은 불필요한 유혹이라고 생각했다.



    nearly: 거의, 대략
    
        *The mast was nearly as long as the one room of the shack.
        *돛대는 오두막의 한 방만큼이나 거의 길었다.



    budshields: 봉오리 껍질
    royal plam: (야자수의 한 종류) 로열 팜
    
        *The shack was made of the tough budshields of the royal palm which are called guano and in it there was a bed, a table, one chair, and a place on the dirt floor to cook with charcoal.
        오두막은 로열 팜의 튼튼한 봉오리 껍질로 만들어졌으며, 이것을 구아노라고 부릅니다. 그안에는 침대, 탁자, 의자 하나 그리고 숯으로 요리할 수 있는 흙바닥 위의 공간이 있습니다.



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-02-05-interface.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-02-05-interface.html"><h1 class="title_post">🌐[Network] 인터페이스(Interface).</h1></a>
                        <a href="/2024/Network/2024-02-05-interface.html" class="txt_post">
                            🌐[Network] 인터페이스(Interface).

    인터페이스(Interface)는 시스템과 시스템을 연결하기 위한 표준화된 접촉 지점을 의미하며 하드웨어적인 관점과 소프트웨어적인 관점이 모두 존재합니다.


    하드웨어적인 관점에서의 인터페이스(Interface).
    
    컴퓨터 본체와 키보드를 연결하여 제대로 동작하게 하려면 키보드의 잭을 본체의 정해진 위치에 꽂아야 합니다.
    
        이렇게 하려면 상호간의 데이터 교환을 위한 RS-232C, USB 등과 같은 논리적인 규격뿐만 아니라, 잭의 크기와 모양 같은 물리적인 규격도 표준화되어야 합니다.
    



    소프트웨어적인 관점에서의 인터페이스(Interface)
    
        프로그래밍 언어에서 함수 설계자는 함수 이름과 매개변수를 표준화하여 정의해야 합니다.
    
        함수 사용자는 이 정의에 맞게 함수 이름과 인수를 지정하여 사용할 수 있습니다.
    



    인터페이스 구조.
    
    인터페이스를 논리적인 상하 구조의 개념으로 이해할 필요는 없습니다.
    인터페이스를 양방향으로 데이터를 주고받는 경우와 한쪽에서 다른 쪽의 단방향으로 데이터를 보내는 경우로 나눌 수 있습니다.



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-02-05-system.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-02-05-system.html"><h1 class="title_post">🌐[Network] 시스템(System).</h1></a>
                        <a href="/2024/Network/2024-02-05-system.html" class="txt_post">
                            🌐[Network] 시스템(System).

    일반적으로 말하는 시스템(System)
    
        내부 규칙에 따라 자율적으로 동작하는 대상을 가리킵니다.
        자동차, 커피 자판기, 컴퓨터, 마이크로프로세서, 하드디스크 등과 같은 물리적인 대상도 시스템.
    신호등으로 교통을 제어하는 운영 시스템, MS 윈도우즈 등의 운영체제, 프로그램의 실행 상태를 의미하는 프로세스와 같은 소프트웨어적인 대상들도 시스템.
    


    
        TIP: 네트워크 환경에서 동작하는 임의의 시스템은 다른 시스템과 데이터를 교환하는 기능이 필수적입니다.
    


   시스템의 동작에 필요한 외부 입력이 있을 수 있으며, 내부 정보와 외부 입력의 조합에 따른 출력(시스템 실행의 결과물)이 있을 수 있습니다. 


    작은 시스템이 여러 개 모여 더 큰 시스템을 구성할 수 있으므로 크기를 기준으로 시스템을 나누지는 않습니다.


    우리가 알고 있는 인터넷은 수많은 소규모 네트워크들이 서로 연동되는 반복적인 과정을 거쳐서 형성된 거대 연합체의 네트워크를 의미합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/MySQL/2024-02-05-COLUMN1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/mysql.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/MySQL/2024-02-05-COLUMN1.html"><h1 class="title_post">🐋[MySQL] 컬럼명 변경, 순서변경, 타입변경, 추가.</h1></a>
                        <a href="/2024/MySQL/2024-02-05-COLUMN1.html" class="txt_post">
                            💾[MySQL] 컬럼명 변경, 순서변경, 타입변경, 추가.


    컬럼명 변경
    
        ALTER TABLE ${테이블명} CHANGE ${기존컬럼명} ${변경할컬럼명} ${컬럼타입};
    


    mysql&gt; ALTER TABLE user CHANGE user_id user_name varchar(30);



    컬럼 순서변경
    
        ALTER TABLE ${테이블명} MODIFY ${순서변경할컬럼명} ${컬럼타임} AFTER ${앞에오는컬럼명};
    


    ALTER TABLE usr MODIFY nickname varchar(64) AFTER user_id;


    컬럼 디폴트값 변경
    
        ALTER TABLE ${테이블명} ALTER COLUMN ${변경할컬럼명} SET DEFAULT ${디폴트값};
    


    ALTER TABLE user ALTER COLUMN time SET DEFAULT 24;


    컬럼 타입변경
    
        ALTER TABLE ${테이블명} MODIFY ${컬럼명} ${변경할컬럼타입};
    


    mysql&gt; ALTER TABLE user MODIFY user_id INT(10);


    컬럼 추가
    
        ALTER TABLE ${테이블명} ADD ${추가할컬럼명} ${컬럼타입} DEFAULT ${디폴트값};
        ALTER TABLE ${테이블명} ADD COLUMN ${추가할컬럼명} ${컬럼타입} DEFAULT ${디폴트값} ${컬럼위치};
    


    mysql&gt; ALTER TABLE user ADD level int DEFAULT 1;
    mysql&gt; ALTER TABLE 'rank' ADD COLUMN 'ranking' INT(10) DEFAULT 0 AFTER 'user_id'; // user_id 뒤에 추가
    mysql&gt; ALTER TABLE 'rank' ADD COLUMN 'test' INT(10) DEFAULT 1 FIRST; // 테이블 맨 앞에 추가


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-02-03-networkBasicTerm1.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-02-03-networkBasicTerm1.html"><h1 class="title_post">🌐[Network] 네트워크 기초 용어.</h1></a>
                        <a href="/2024/Network/2024-02-03-networkBasicTerm1.html" class="txt_post">
                            🌐[Network] 네트워크 기초 용어.

    네트워크를 이해하려면 시스템, 인터페이스, 전송 매체, 프로토콜, 인터넷과 같은 용어를 먼저 이해해야 합니다.


    네트워크(Network)
    
        하드웨어적인 전송 매체(Transmisson Media)를 매개로 서로 연결되어 데이터를 교환하는 시스템(System)의 모음.
    


    인터페이스(Interface)
    
        시스템과 전송 매체의 연결 지점에 대한 규격.
    


    프로토콜(Protocol)
    
        소프트웨어적으로 동작하는 통신 규칙.    
    


    표준화(Standardization)
    
        인터페이스와 프로토콜은 서로 다른 시스템을 상호 연동해 동작시키기 위함이니 반드시 연동 형식의 통일이 필요하고 이를 표준화라고 합니다.
    



    위 그림은 여러 시스템이 전송 매체로 연결되어 네트워크를 구성한 예입니다.


    시스템은 반드시 일반 컴퓨터일 필요는 없으며, 보통 컴퓨팅 기능을 보유한 네트워크 장비들을 의미합니다.


    그림과 같은 네트워크의 가장 바깥쪽에 스마트폰을 포함한 일반 사용자들의 컴퓨터가 연결되어 데이터 교환 작업을 수행합니다.


    시스템들은 물리적으로 공유하는 전송 매체에 의하여 서로 연결되지만, 시스템이 전송 매체를 통해 데이터를 교환하려면 반드시 표준화된 프로토콜을 사용해야 합니다.


    우리가 알고 있는 인터넷은 IP(Internet Protocol)라는 네트워크 프로토콜이 핵심적인 역할을 하는 네트워크 집합체입니다.


    여기서 IP는 프로토콜의 의미가 포함된 약자이지만 보통 IP 프로토콜이라고 부릅니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Read%20English%20Book/2024-02-03-TheOldManAndTheSea6.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Read%20English%20Book/2024-02-03-TheOldManAndTheSea6.html"><h1 class="title_post">📚[Book] The old man and the sea (6).</h1></a>
                        <a href="/2024/Read%20English%20Book/2024-02-03-TheOldManAndTheSea6.html" class="txt_post">
                            📚[Book] The old man and the sea (6).


    
        attained: 달성하다, 이루다, 얻다
        
            *But he knew he had attained it and he knew it was not disgraceful and it carried no loss of trur pride.
            *그러나 그는 그것을 얻었다는 것을 알았고, 그것이 불명예스럽지 않으며 진정한 자부심을 잃지 않는다는 것을 알았다.
        
    



    
        turtle-ing: 거북이 잡이
        
            *"He never went turtle-ing. That is what kills the eyes."
            *"그는 결코 거북이 잡이를 하지 않았다. 그것이 바로 눈을 망치는 것이다."
        
    


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/AWS/post-02.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/AWS/post-02.html"><h1 class="title_post">🌐 [Network, AWS] Routing Table이란?</h1></a>
                        <a href="/2024/AWS/post-02.html" class="txt_post">
                            🌐 [Network, AWS] Routing Table이란?


    라우팅 테이블(Routing table)은 네트워크 라우터나 컴퓨터에서 사용하는 데이터 테이블로, 데이터 패킷이 목적지까지 가장 효율적으로 도달할 수 있는 경로를 결정하기 위한 정보를 포함하고 있습니다.
    라우팅 테이블은 네트워크 상의 다른 장치들로 데이터를 전송하는 데 필요한 지시사항을 제공합니다.


    라우팅 테이블의 주요 구성 요소.
    
        목적지 네트워크 주소: 데이터 패킷이 도달해야 하는 최종 네트워크 또는 호스트의 주소입니다.
    서브넷 마스크: 목적지 주소의 네트워크 부분과 호스트 부분을 구분하는데 사용됩니다. 이는 주로 CIDR(클래스 없는 도메인 간 라우팅)주소 지정 방식에서 중요합니다.
    게이트웨이: 패킷이 목적지에 도달하기 위해 다음으로 전달되어야 하는 중간 네트워크 장치(보통 라우터)의 주소입니다. 직접 연결된 네트워크에 대해서는 "0.0.0.0" 또는 "자신"으로 표시될 수 있습니다.
    인터페이스: 데이터 패킷이 네트워크를 통해 전송되기 위해 사용되는 물리적 또는 논리적 네트워크 인터페이스 입니다.
    매트릭: 여러 경로가 가능할 때 어떤 경로를 선호할지 결정하기 위한 비용 또는 거리를 나타내는 값입니다. 낮은 메트릭 값이 더 선호되는 경로를 의미합니다.
    


    라우팅 테이블은 정적 라우팅과 동적 라우팅 방식을 모두 지원합니다.
    
        정적 라우팅: 관리자가 수동으로 라우팅 경로를 설정합니다. 네트워크 구성이 변하지 않는 소규모 네트워크에 적합합니다.
        동적 라우팅: 라우터가 라우팅 프로토콜을 사용하여 네트워크 변경 사항을 자동으로 감지하고 라우팅 테이블을 동적으로 업데이트합니다. 이는 네트워크 구성이 자주 변경되거나 크기가 큰 네트워크에 적합합니다.
    


    라우팅 테이블은 네트워크의 효율성과 성능을 최적화하는 데 중요한 역할을 하며, 네트워크 관리자는 이를 통해 네트워크 트래픽을 효과적으로 관리할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/AWS/post-03.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/AWS/post-03.html"><h1 class="title_post">🌐 [Network, AWS] Subnet이란?</h1></a>
                        <a href="/2024/AWS/post-03.html" class="txt_post">
                            🌐 [Network, AWS] Subnet이란?

    서브넷(Subnet 또는 Subnetwork)은 IP 네트워크를 더 작은, 관리 가능한 부분으로 나누는 방법입니다.
    서브네팅은 효율적인 IP 주소 관리, 네트워크 트래픽의 분리 및 제어, 보안 강화를 위해 널리 사용됩니다.
    네트워크를 서브넷으로 분할하면 네트워크의 복잡성을 줄이고, 네트워크 성능을 최적화하며, 보안을 강화할 수 있습니다.


    서브넷의 주요 개념
    
        IP 주소 할당: 네트워크를 서브넷으로 나누면 각 서브넷에 고유한 IP 주소 범위가 할당됩니다. 이를 통해 네트워크 내에서 트래픽을 효과적으로 라우팅할 수 있습니다.
        네트워크 마스크: 서브넷을 식별하기 위해 IP 주소와 함꼐 사용되는 네트워크 마스크(또는 서브넷 마스크)가 있습니다. 네트워크 마스크는 IP 주소의 어느 부분이 네트워크 주소에 해당하고 어느 부분이 호스트 주소에 해당하는지를 정의합니다.
        브로드캐스트 도메인 분할: 서브네팅을 사용하면 네트워크의 브로드캐스트 도메인을 분할하여 네트워크 트래픽을 줄이고 성능을 향상시킬 수 있습니다. 각 서브넷은 독립된 브로드캐스트 도메인을 형성합니다.
        보안과 관리: 서브넷은 네트워크 리소스에 대한 접근을 제어하는 데 사용될 수 있으며, 네트워크 내의 세그먼트를 보다 쉽게 관리하고 모니터링할 수 있게합니다.
    


    서브넷 사용 예시
    
        기업 네트워크: 기업은 다양한 부서나 기능별로 서브넷을 구성하여 네트워크 리소스를 효율적으로 관리하고 보안을 강화할 수 있습니다.
        공용 및 프라이빗 클라우드 환경: 클라우드 환경에서는 VPC 내에서 여러 서브넷을 구성하여 고용 서비스와 프라이빗 리소스를 분리할 수 있습니다.
        IoT 네트워크: IoT(Internet Of Things) 환경에서는 서브넷을 사용하여 다양한 유형의 장치를 분리하고, 네트워크 트래픽을 관리하며, 보안을 강화할 수 있습니다.
    


    서브넷 구성은 네트워크 설계의 중요한 부분이며, 네트워크의 규모와 복잡성에 따라 다양한 방식으로 구현될 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/AWS/post-04.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/AWS/post-04.html"><h1 class="title_post">🌐 [AWS] VPC?</h1></a>
                        <a href="/2024/AWS/post-04.html" class="txt_post">
                            🌐 [AWS] VPC?


    VPC(Virtual Private Clould)는 공용 클라우드 인프라 내에서 사용자가 정의할 수 있는 분리된 가상 네트워크 세그먼트입니다.
    VPC를 사용하면 기업이 공용 클라우드의 리소스를 사용하면서도 개인 클라우드와 유사한 보안 수준과 네트워크 제어를 유지할 수 있습니다.
    사용자는 VPC 내에서 자신의 가상 네트워크를 구성하고, IP 주소 범위를 정의하며, 서브넷을 생성하고, 라우팅 테이블과 네트워크 게이트웨이를 설절할 수 있습니다.


    VPC의 주요 기능
    
        격리 및 보안: VPC는 다른 사용자의 클라우드 리소스와 분리된 환경을 제공하여 데이터와 애플리케이션의 보안을 강화합니다.
        사용자 정의 네트워킹: 사용자는 자신의 IP 주소 범위를 선택하고, 서브넷을 생성하며, 라우팅 테이블과 네트워크 게이트웨이를 구성할 수 있습니다.
        연결 옵션: VPC는 온프레미스 데이터 센터와의 VPN 연결이나 AWS Direct Connect와 같은 전용 연결 옵션을 통해 확장될 수 있습니다.
        보안 그룹과 네트워크 ACL: 이러한 기능을 통해 인바운드 및 아웃바운드 트래픽을 세밀하게 제어할 수 있습니다.
    


    AWS(Amazon Web Services), GCP(Google Clould Platform), Microsoft Azure와 같은 주요 클라우드 제공 업체들은 모두 VPC 서비스를 제공하며, 각각의 VPC 서비스는 사용자에게 가상 네트워킹 환경을 자유롭게 구성할 수 있는 능력을 제공합니다.
    VPC는 클라우드 컴퓨팅에서 데이터의 보안과 네트워크 구성의 유연성을 필요로 하는 기업에게 중요한 기능입니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/AWS/post-01.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/AWS/post-01.html"><h1 class="title_post">🌐 [AWS] IAM이란?</h1></a>
                        <a href="/2024/AWS/post-01.html" class="txt_post">
                            🌐 [AWS] IAM이란?


    IAM(Identity and Access Management)은 누가, 어떤 리소스나 서비스를 사용할 수 있는지 접근 레벨이나 권한(permission) 관리 기능을 제공합니다.
    대부분의 AWS 리소스는 지역(region)에 따라 제공되는 서비스와 기능이 다르지만, IAM은 유니버셜(Universal)합니다.
    따라서 IAM 사용 시 따로 지역을 설정해줄 필요가 없습니다.
    IAM에서 일어나는 모든 것은 전 지역에 적용되기 때문입니다.


    IAM은 유저 X에 대한 엑세스 키(access key)와 비밀 키(secret key)를 부여합니다.
    두 가지 키를 가지고 유저 X는 AWS 내의 다양한 서비스를 사용할 수 있습니다.
    AWS 메인 페이지에서 로그인할 때 제공하는 유저 아이디 및 비밀번호와는 다른 개념입니다.
    엑세스 키와 비밀 키는 사람이 이해할 수 없는 긴 문자열로 이루어져 있고, API 혹은 콘솔에서 이 키를 가지고 AWS 리소스를 사용합니다.


    IAM은 세밀한 접근 권한 관리를 가능하게 합니다.
    데이터베이스를 생각해봅시다.
    테이블을 생성하고 데이터를 삽입하거나 읽어올 수 있고, 수정하고, 삭제하는 등 다양한 액션을 취할 수도 있습니다.
    앞서 언급한 유저 X에게 모든 권한을 부여할 수 있고, 데이터만 읽을 수 있는 읽기 전용(view only) 권한도 부여할 수도 있습니다.
    IAM은 리소스에 대한 권한만 관리하는 것이 아니라 리소스 안에서 이루어지는 다양한 행동에 대한 세밀한 접근 원한 관리도 할 수 있습니다.


    루트 유저, 혹은 루트 유저가 만들어낸 유저는 AWS에 접속할 때 아이디와 비밀번호를 입력하면 로그인할 수 있습니다.
    아마존에서는 다요소 인증(multi-factor authentication, MFA)을 활성화시킬 것을 적극 권장하고 있습니다.
    MFA는 사용자의 다른 계정(Facebook, Google 등)을 통한 2차 인증을 거치는 추가적인 과정입니다.



                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Java/2024-02-01-VariableDeclaration.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Java/2024-02-01-VariableDeclaration.html"><h1 class="title_post">☕️[Java] 변수 선언.</h1></a>
                        <a href="/2024/Java/2024-02-01-VariableDeclaration.html" class="txt_post">
                            ☕️[Java] 변수 선언.

package variable;

public class Var2 {
    public static void main(String[] args) {
        int number; // 변수 선언
        number = 20;
    }
}


    자바의 변수 선언은 먼저 어떤 형(type)인지를 명시하고 그 뒤에 변수명을 명시합니다.
    위 코드 조각에서는 int형 임을 명시하고, 그 뒤에 변수명 으로 number 을 명시했습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-02-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Read%20English%20Book/2024-01-28-TheOldManAndTheSea4.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Read%20English%20Book/2024-01-28-TheOldManAndTheSea4.html"><h1 class="title_post">📚[Book] The old man and the sea (4).</h1></a>
                        <a href="/2024/Read%20English%20Book/2024-01-28-TheOldManAndTheSea4.html" class="txt_post">
                            📚[Book] The old man and the sea (4).


    
        faint: 희미한
        odour: 냄새
        
            *but today was only faint edge of the odour because the wind had backed into the north and then dropped off and it was pleasant and sunny on the Terrace.
            *하지만 오늘은 바람이 북쪽으로 돌아간 뒤 잦아들어 테라스에서는 기분 좋은 햇볕이 비추었고 냄새도 거의 나지 않았다.
        
    



    
        sardines: 정어리
        
            *"Can I go out to get sardines for you for tomorrow?"
            *"내일 정어리를 사러 나가도 될까요?"
        
    



    
        tore: 찢어졌다
        
            *"Five and your nearly were killed when I brought the fish in to green and he nearly tore the boat to pieces."
            *"내가 물고기를 풀밭 쪽으로 끌어들였을 때 당신은 거의 죽을 뻔 했고, 그 물고기는 배를 거의 부숴버릴 뻔 했어요"
        
    



    
        slapping: 큼직한
        
            *"I can remember the tail slapping and banging and the thwart breaking and the noise of the clubbing."
            *"나는 꼬리가 휘갈기며 부닺치는 노리, 좌석이 부저지는 소리, 그리고 몽둥이질하는 소리를 기억할 수 있어요."
            
                "*the tail slapping"은 "꼬리를 휘뒤르는 것"정도로 표현할 수 있습니다.
                이는 어떤 동물이나 생물이 꼬리를 강하게 움직여 물체에 부딪치는 행위를 나타냅니다.
            
        
    



    
        shiver: 떨다
        
            *"I can remember you throwing me into the bow where the wet coiled lines were and feeling the whole boat shiver and the noise of you clubbing him like chopping a tree down and the sweet blood smell all over me."
            *"당신이 젖은 밧줄이 감겨 있는 선수 쪽으로 나를 던져 넣는 것을 기억할 수 있어요. 전체 배가 떨리는 것과 나무를 찍는 것처럼 당신이 그를 때리는 소리, 그리고 내 주변에 퍼지는 달콤한 피 냄새가 나요."
        
    


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Read%20English%20Book/2024-01-29-TheOldManAndTheSea5.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Read%20English%20Book/2024-01-29-TheOldManAndTheSea5.html"><h1 class="title_post">📚[Book] The old man and the sea (5).</h1></a>
                        <a href="/2024/Read%20English%20Book/2024-01-29-TheOldManAndTheSea5.html" class="txt_post">
                            📚[Book] The old man and the sea (5).


    
        confident: 자신감
        
            *The old man looked at him with his sun-burned, confident loving eyes.
            *그 노인은 그를 햇볕에 그을린 자신감 있고 애정 어린 눈으로 바라보았다.
        
    



    
        sardines: 정어리
        baits: 미끼
        
            *"May I get the sardine? I know where I can get four baits too."
            *"정어리를 가져가도 될까요? 미끼 네 개도 어디서 구할 수 있는지 알아요"
        
    



    
        breeze: 미풍    
        rises: 상승
        
            *But now they were freshening as when the breeze rises.
            *하지만 지금 그들은 바람이 불기 시작할 때처럼 신선해지고 있었다.
        
    



    
        attained: 달성
        humility: 겸손
        
            *"Thank you," the old man said. He was too simple to wonder when he had attained humility.
            *"고맙습니다", 노인이 말했다. 그는 겸손함을 언제 얻었는지 궁금해할 만큼 복잡한 사람이 아니었다.
        
    


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Read%20English%20Book/2024-01-27-TheOldManAndTheSea3.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Read%20English%20Book/2024-01-27-TheOldManAndTheSea3.html"><h1 class="title_post">📚[Book] The old man and the sea (3).</h1></a>
                        <a href="/2024/Read%20English%20Book/2024-01-27-TheOldManAndTheSea3.html" class="txt_post">
                            📚[Book] The old man and the sea (3).


    
        stuff: 물건
        
            *"Can I offer you a beer on the Terrace and then we'll take the stuff home."
            *"테라스에서 맥주 한 잔 사 드릴까요? 그럼 그 뒤에 물건들을 집으로 가져갈게요."
        
    



    
        butcherd: 정육점
        marlin: 청새치
        planks: 널빤치
        staggering: 엄청난
        
            *"The successful fishermen of that day were already in and had butchered their marlin out and carried them laid full length across two planks, with two men staggering at the end of each plank, of the fish house where they waited for the ice truck to carru them to the market in Havana"
            *그 날 성공한 어부들은 이미 들어와 있었고, 그들은 이미 자신들의 청새치를 도려내어 두 개의 널빤지 위에 가로로 펴놓고, 각 널빤지 끝에서 두 명의 사나이가 비틀거리며 서 있었다. 그들은 얼음 트럭이 그들을 하바나 시장으로 실어 나르기를 기다리는 어선 창고 앞에 섰다.
        
    



    
        hoisted: 계양하다
        flesh: 육체
        
            *Those who had caught sharks had taken them to the shark factory on the other side of the cove where they were hoisted on a block and tackle, their livers removed, their fins cut off and their hides skinned out and their flesh cut into strips for salting
            *상어를 잡은 어부들은 그것들을 만리만 반대편에 위치한 상어 공장으로 가져갔습니다. 거기서는 그들이 블록과 택률에 걸려 올려지고 간이 제거되며 지느러미가 잘려내어 가죽이 벗겨지고 고기는 소금에 절이기 위해 채로 잘려갔습니다.
        
    



    
        harbour: 항구
        
            *When the wind was in the east a smell came across the harbour from the shark factory
            *바람이 동쪽에서 불 때, 상어 공장에서 바다로 향하는 냄새가 항구를 향해 퍼져왔다.
        
    


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Read%20English%20Book/2024-01-26-TheOldManAndTheSea2.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Read%20English%20Book/2024-01-26-TheOldManAndTheSea2.html"><h1 class="title_post">📚[Book] The old man and the sea (2).</h1></a>
                        <a href="/2024/Read%20English%20Book/2024-01-26-TheOldManAndTheSea2.html" class="txt_post">
                            📚[Book] The old man and the sea (2).


    
        deep-creased: 깊은 주름
        cords: 굴레
        
            *The blotches ran well down the sides of his face and his hands had the deep-creased scars from handling heavy fish on the cords.
            *얼룩은 얼굴 옆으로 줄지어 늘어져 있었고, 손에는 밧줄에 걸린 무거운 물고기를 다루느라 깊게 주름진 상처가 있었습니다..
            위 문장에서 *cords가 "밧줄"로 해석.
        
    



    
        erosions: 침식
        
            *They were as old as erosions in fishless desert.
            *그들은 물고기가 없는 사막의 침식만큼 오래되었습니다.
        
    



    
        undefeated: 무패    
        
            *Everything about him was old except his eyes and they were the same color as the sea and were cheerful and undefeated.
            *그의 모든 것은 낡았지만 그의 눈은 예외였고, 그것들은 바다와 같은 색이었으며 쾌활하고 불굴의 정신을 가지고 있었다.
            위 문장에서 *undefeated는 "불굴의 정신"으로 해석.
        
    



    
        climbed: 올라갔다
        
            *"Santiago," the boy said to him as they climbed the bank from where the skiff was hauled up.
            "산티아고," 작은 배를 끌어 올린 곳에서 강둑으로 올라가면서 소년이 그에게 말했다.
        
    



    
        doubted: 의심스럽다    
        
            *I know you did not leave me because you doubted."
            *"당신이 의심했기 때문에 나를 떠난 게 아니라는 걸 알아요."
        
    



    
        obey: 순종하다, ~에 복종하다    
        
            *"It was papa made me leave. I am a boy and I must obey him"
            *"떠나게 한 건 아빠였어요, 저는 아들이니까 아빠 말을 들어야 해요."
        
    



    
        faith: 믿음
        
            *"He hasn't much faith."
            *"그는 별로 믿음이 없어요."
        
    


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Read%20English%20Book/2024-01-25-TheOldManAndTheSea.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Read%20English%20Book/2024-01-25-TheOldManAndTheSea.html"><h1 class="title_post">📚[Book] The old man and the sea.</h1></a>
                        <a href="/2024/Read%20English%20Book/2024-01-25-TheOldManAndTheSea.html" class="txt_post">
                            📚[Book] The old man and the sea.


    
        skiff: 작은 보트
        Gulf Stream: 맥시코 만류
        *He was an old man who fished alone in a skiff in the Gulf Stream and he had gone eighty-four days now without taking a fish.
        *그는 맥시코 만류에서 작은 보트를 타고 혼자 낚시를 하는 노인이었는데, 지금까지 84일 동안 물고기를 한 마리도 잡지 못한 채 지내고 있었습니다.
    



    
        salao: 최악의 불운한 상태를 뜻하는 스페인어
        gaff: 갈고릿대
        harpoon: 작살
        mast: 돛대
        furled: 감다, 감겨 오르다, 펄럭이는
        permanent: 영구적인
        
            *It made the boy sad to see the old man come in each day with his skiff empty and he always went down to help him carry either the coled lines or the gaff and harpoon and the sail that was furled around the mast.
            *노인이 매일 빈 배를 들고 들어오는 것을 보고 소년은 슬펏고, 그는 항상 내려가서 낚싯줄이나 작살, 돛대 주위에 휘감긴 돛을 나르는 것을 도왔습니다.
        
    



    
        sail: 돛
        sacks: 자루, 마대
        
            *The sail was patched with flour sacks and, furled, it looked like the flag of permanent defeat.
            돛에는 밀가루 자루가 덧대어져 있었고, 펼쳐져 있으면 마치 영원한 패배를 알리는 깃발처럼 보였습니다.
            이 문장에서 'fruled'는 '휘감긴, 감다'가 아닌 '펄럭이는, 펼펴져 있는'으로 해석되었습니니다.    
        
    



    
        gaunt: 쓸쓸한, 수척한.
        
            *The old man was thin and gaunt woth deep wrinkles in the back of his neck.
            *그 노인은 목덜미에 깊은 주름이 있고 마르고 여위었습니다.
        
        benevolent: 자애로운
        blotches: 얼룩
        
            *The brown blotches of the benevolent skin cancer the sun brings from its reflection on the tropic sea were on his cheeks.
            *열대 바다의 반사로 태양이 가져다주는 자비로운 피부암의 갈색 얼룩들이 그의 볼에 있었다.
        
    


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-01-23-Packet.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-01-23-Packet.html"><h1 class="title_post">🌐[Network] 패킷(Packet)</h1></a>
                        <a href="/2024/Network/2024-01-23-Packet.html" class="txt_post">
                            🌐[Network] 패킷(Packet)이란?

패킷(Packet)이란 네트워크를 통해 전송되는 데이터의 작은 단위입니다.
정보 통신에서 데이터는 큰 파일이나 메시지로부터 분할되어 패킷 형태로 변환되며, 각 패킷은 전송을 위해 필요한 정보를 포함합니다.
이 정보에는 목적지 주소, 출발지 주소, 데이터 자체, 오류 검출 등이 포함될 수 있습니다.

패킷 기반 전송 방식은 데이터를 더 효율적으로 전송할 수 있게 해줍니다.
각 패킷은 네트워크를 통해 독립적으로 이동하며, 최종 목적지에서 다시 원래의 데이터로 조립됩니다.
이 과정은 데이터 전송의 신뢰성을 높이고, 네트워크 혼잡을 줄이는 데 도움이 됩니다.
패킷 기반 통신은 인터넷을 포함한 다양한 디지털 네트워크에서 널리 사용됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-01-23-HTTP.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-01-23-HTTP.html"><h1 class="title_post">🌐[Network] HTTP 통신.</h1></a>
                        <a href="/2024/Network/2024-01-23-HTTP.html" class="txt_post">
                            🌐[Network] HTTP 통신이란?

HTTP(HyperText Transfer Protocol) 통신은 월드 와이드 웹(World Wide Web)에서 데이터를 주고받는 데 사용되는 주요 프로토콜입니다.
이 프로토콜은 웹 서버와 클라이언트(대게 웹 브라우저)간의 통신을 위해 설계되었습니다.

🌐 HTTP 통신의 주요 특징.

1. 클라이언트-서버 모델 : HTTP는 클라이언트-서버 모델을 따릅니다.
클라이언트(예: 웹 브라우저)는 서버에 요청(Request)을 보내고, 서버는 이에 대한 응답(Response)을 반환합니다.


2. 무상태성(Stateless) : HTTP는 무상태 프로토콜입니다.
즉, 각 요청은 독립적이며, 서버는 이전 요청에 대한 정보를 저장하지 않습니다.
이는 통신을 단순화하지만, 세션 관리를 위해 쿠기와 같은 메커니즘을 사용해야 합니다


3. HTTP 메소드 : HTTP는 다양한 메소드(GET, POST, PUT, DELETE 등)를 사용하여 리소드(웹 페이지, 이미지, 파일 등)에 대한 다양한 작업을 수행할 수 있습니다.


4. 확장 가능 : HTTP 헤더를 통해 프로토콜을 확장할 수 있습니다.이를 통해 메타데이터, 캐싱 정책, 인증 정보 등을 전송할 수 있습니다.


🌐 HTTP 작동 원리.

1. 요청 시작 : 사용자가 웹 브라우저에서 URL을 입력하거나 링크를 클릭하면 HTTP 요청이 시작됩니다.


2. 서버로의 요청 전송 : 웹 브라우저는 해당 서버의 주소를 찾고(도메인 이름 시스템을 통해 IP 주소를 확인)해당 서버에 연결하여 HTTP 요청을 전송합니다.


3. 서버 처리 및 응답 : 웹 서버는 요청을 받고 처리한 뒤, 요청된 리소스(HTML 페이지, 이미지, 파일 등) 또는 오류 메시지, 리디렉션 정보 등을 포함하는 HTTP 응답을 보냅니다.


4. 콘텐츠 렌더링 : 클라이언트(웹 브라우저)는 응답을 받고, 그 내용을 해석하여 사용자에게 표시합니다. 예를 들어, HTML 문서가 반환되면 브라우저는 이를 파싱하여 화면에 웹 페이지로 렌더링합니다.


5. 연결 종료 : 통신이 완료되면 TCP 연결이 종료됩니다.
HTTP/1.1에서는 지속 연결(keep-alive)을 통해 여러 요청과 응답을 같은 연결로 처리할 수 있습니다.


🌐 HTTP 버전.

HTTP/1.x : 가장 널리 사용되는 버전으로, 각 요청/응답마다 별도의 연결을 맺습니다(HTTP/1.0) 또는 지속 연결을 사용합니다(HTTP/1.1)


HTTP/2 : 성능 향상을 위해 도입된 버전으로, 여러 요청을 동시에 하나의 연결로 처리할 수 있는 멀티플렉싱, 헤더 압축 등의 기능을 제공합니다.


HTTP/3 : 최신 버전으로, UDP 기반의 QUIC 프로토콜을 사용하여 연결의 설정 시간을 단축하고, 패킷 손실에 더 강한 성능을 보입니다


HTTP 통신은 웹의 기본적인 동작 방식을 정의하며, 현대 인터넷에서 가장 중요한 프로토콜 중 하나입니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Network/2024-01-22-webSocket.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Network/2024-01-22-webSocket.html"><h1 class="title_post">🌐[Network] 웹소켓(WebSocket)</h1></a>
                        <a href="/2024/Network/2024-01-22-webSocket.html" class="txt_post">
                            🌐[Network] 웹소켓(WebSocket)?

웹소켓(WebSocket)은 웹 브라우저와 서버 간에 양방향 통신을 가능하게 하는 고급 기술입니다.
이는 HTTP 프로토콜에 비해 지속적이고 실시간의 통신을 가능하게 합니다.

🌐 웹소켓의 주요 특징.

1. 양방향 통신 : 웹소켓은 서버와 클라이언트 간의 양방향 통신 채널을 제공합니다.
이는 클라이언트와 서버가 서로에게 데이터를 동시에 보낼 수 있음을 의미합니다.


2. 실시간 통신 : 웹소켓은 실시간 통신을 위해 설계되었습니다.
이는 온라인 게임, 채팅 애플리케이션, 실시간 데이터 스트리밍 등에 매우 유용합니다.


3. 지속적인 연결 : 웹소켓 연결은 한 번 수립되면 지속적으로 유지됩니다.
이는 브라우저가 서버에 연결을 맺은 후 해당 연결을 지속적으로 유지하며 데이터를 교환한다는 것을 의미합니다.


4. 효율적인 데이터 전송 : 웹소켓은 HTTP의 오버헤드를 줄여 효율적인 데이터 전송을 가능하게 합니다.
데이터 패킷이 작고, 연결 수립 후에는 추가적인 헤더 없이 데이터를 전송할 수 있습니다.


🌐 작동 원리.

1. 핸드셰이크 : 웹소켓 연결은 HTTP 요청을 통해 시작됩니다.
이 요청은 서버에 웹소켓 연결을 요청하는 “업그레이드 요청(Upgrade Request)”을 포함합니다.
서버가 이를 수락하면, HTTP 연결은 웹소켓 연결로 “업그레이드”됩니다.


2. 연결 수립 : 핸드셰이크 과정이 성공적으로 완료되면, 웹소켓 연결이 수립됩니다.
이 시점부터 클라이언트와 서버 간에 양방향 데이터 전송이 가능해집니다.


3. 데이터 프레임 교환 : 데이터는 프레임 단위로 교환됩니다.
각 프레임은 텍스트 또는 바이너리 데이터를 포함할 수 있으며, 웹소켓 프로토콜은 이를 신속하게 전송합니다.


4. 연결 종료 : 클라이언트 또는 서버 어느 한 쪽이 연결을 종료하기를 요청할 수 있으며, 연결이 종료되면 더 이상 데이터를 교환할 수 없습니다.


🌐 사용 사례.

* 채팅 애플리케이션 : 실시간으로 메시지를 주고받는데 사용됩니다.


* 온라인 게임 : 실시간 상호작용과 게임 상태의 빠른 업데이트를 위해 사용됩니다.


* 금융 애플리케이션 : 주식 시작의 실시간 가격 업데이트 등에 사용됩니다.


* 라이브 스트리밍 : 실시간 비디오 또는 오디오 스트리밍에 사용될 수 있습니다.


웹소켓은 웹의 실시간, 대화형 애플리케이션을 위한 강력한 도구로, 기존의 HTTP 기반 통신보다 더 다이나믹하고 효율적인 방식을 제공합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/HackTheSwift/2024-01-22-DoubleAndBool.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/HackTheSwift/2024-01-22-DoubleAndBool.html"><h1 class="title_post">👾[Day 3] Doubles and Booleans</h1></a>
                        <a href="/2024/HackTheSwift/2024-01-22-DoubleAndBool.html" class="txt_post">
                            👾 Day 3 [Doubles and Booleans]

스위프트에서 또 다른 기본적인 데이터 유형에는 Double과 Bool이 있으며, 이들을 자주 사용하게 될 것입니다.


“Double”은 “이중 정밀도 부동 소수점 숫자(double-precision floating-point number)”의 줄임말이며, 38.1이나 3.141592654와 같은 소수점을 가진 값을 저장한다는 복잡한 방식의 표현힙니다.


소수점이 있는 숫자로 변수를 만들 때, Swift는 자동으로 그 변수에 Double 타입을 할당합니다.


예를 들어:


var pi = 3.141


Double은 정수(Integers)와 다르며, 실수로(by accident) 섞이지 않습니다.


Boolean의 경우 훨씬 간단합니다.
참(true) 또는 거짓(false)만을 담고, Swift는 참(true)또는 거짓(false)값을 할당받은 모든 변수에 자동으로 Bool 타입을 할당합니다.


예를 들어:


var awesome = true


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Leet-Code/2024-01-22-MergeSortedArray.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Leet-Code/2024-01-22-MergeSortedArray.html"><h1 class="title_post">🆙 [LeetCode] 88.Merge Sorted Array.</h1></a>
                        <a href="/2024/Leet-Code/2024-01-22-MergeSortedArray.html" class="txt_post">
                            🆙 [LeetCode] 88.Merge Sorted Array.


  Difficulty: Easy
  Topic: Array, Two Pointer, Sorting




Approach 1: Merge and sort

Intuition(직관)

순진한 접근 방식은 nums2의 값을 그저 nums1의 끝에 쓰고, 그다음 nums1을 정렬하는 것입니다.
우리는 값을 반환할 필요가 없으며, nums1을 직접 수정해야 합니다.
이 방법은 코딩하기는 쉽지만, 이미 정렬된 상태를 활용하지 않기 때문에 높은 시간 복잡도를 가집니다.

Implementation(구현)

class Solution {
    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        for i in 0..&lt;n {
            nums1[i + m] = nums2[i]
        }
        nums1.sort()
    }
}



  Time complexity(시간 복잡도): O((n + m) log(n+m))
    
      내장된 정렬 알고리즘을 사용하여 길이가 x인 리스트를 정렬하는 비용은 O(xlogx)입니다. 이 경우에는 길이가 m+n인 리스트를 정렬하므로 총 시간 복잡도는 O((n + m) log(n + m))가 됩니다.
    
  
  Space complexity(공간 복잡도): O(n), 하지만 상황에 따라 다를 수 있습니다.
    
      대부분의 프로그래밍 언어는 O(n) 공간을 사용하는 내장 정렬 알고리즘을 가지고 있습니다.
    
  




Approach 2: Three Pointers (Start From the Beginning)

Intuition(직관)

각 배열이 이미 정렬되어 있기 때문에, Two pointer 기법을 활용하면 O(n+m)의 시간 복잡도를 달성할 수 있습니다.

Algorithm

nums1의 값을 복사하여 nums1Copy라는 새 배열을 만드는 것이 가장 간단한 구현 방법입니다.
그런 다음 두 개의 읽기(read) 포인터와 하나의 쓰기(write) 포인터를 사용하여 nums1Copy와 nums2에서 값을 읽고 nums1에 씁니다.


  nums1Copy를 nums1의 처음 m 값이 포함된 새 배열로 초기화합니다.
  읽기 포인터 p1을 nums1Copy의 시작 부분에 초기화합니다.
  읽기 포인터 p2를 nums2의 시작 부분에 초기화합니다.
  쓰기 포인터 p를 nums1의 시작 부분에 초기화합니다.
  p가 여전히 nums1 내에 있는 동안:
    
      nums1Copy[p1]이 존재하고 nums2[p2] 보다 작거나 같으면:
        
          nums1Copy[p1]을 nums1[p]에 쓰고 p1을 1 증가시킵니다.
        
      
      그렇지 않으면
        
          nums2[p2]를 nums1[p]에 쓰고 p2를 1 증가시킵니다.
        
      
      p를 1 증가시킵니다.
    
  





class Solution {
    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        // nums1의 처음 m개 원소의 복사본을 만듭니다.
        let nums1Copy = Array(nums1[0..&lt;m])

        // nums1Copy와 nums2에 대한 읽기 포인터입니다.
        var p1 = 0
        var p2 = 0

        // nums1Copy와 nums2에서 원소를 비교하여 더 작은 것을 nums1에 씁니다.
        for p in 0..&lt;(m + n) {
            // p1과 p2가 각각의 배열 범위를 벗어나지 않도록 확인합니다.
            if p2 &gt;= n || (p1 &lt; m &amp;&amp; nums1Copy[p1] &lt; nums2[p2]) {
                nums1[p] = nums1Copy[p1]
                p1 += 1
            } else {
                nums1[p] = nums2[p2]
                p2 += 1
            }
        }
    }
}


Complexity Analysis


  Time complexity(시간 복잡도) : O(n+m)
    
      우리는 n+2*m 번의 읽기와 n+2*m 번의 쓰기를 수행하고 있습니다. Big O 표기법에서 상수는 무시되므로, 이는 O(n+m)의 시간 복잡도를 의미합니다.
    
  
  Space complexity(공간 복잡도) : O(m)
    
      우리는 추가적으로 길이가 m인 배열을 할당하고 있습니다.
    
  




Approach 3: Three Pointers (Start From the End)

Intuition


    
        인터뷰 팁: 이것은 쉬운 문제에 대한 중간 수준의 솔루션입니다.
        쉬운 수준의 문제 중 상당수는 더 어려운 해결책을 갖고 있으며,
        좋은 지원자는 이를 찾을것으로 예상됩니다.
    




Approach 2는 이미 최상의 시간 복잡도인 O(n+m)을 보여주지만, 여전히 추가 공간을 사용합니다.
이는 nums1 배열의 요소들을 어딘가에 저장해야 하기 때문에, 그것들이 덮어쓰여지지 않도록 해야하기 때문입니다

그렇다면 대신 nums1의 끝부터 덮어쓰기 시작하면 어떨까요? 거기에는 아직 정보가 없으니까요.

알고리즘은 이전과 유사하지만, 이번에는 p1을 nums1의 m - 1 인덱스에, p2를 nums2의 n - 1 인덱스에, 그리고 p를 nums1의 m + n - 1 인덱스에 두는 방식입니다.
이 방식으로, nums1의 처음 m 값들을 덮어쓰기 시작할 때, 이미 각각을 새 위치에 써 놓았을 것이라는 것이 보장됩니다.
이런 방식으로, 추가 공간을 없앨 수 있습니다.



    
        인터뷰 팁: 베열 문제를 제자리에서 해결하려고 할 때는 항상 배열을 앞에서 뒤로 순회하는 대신 뒤에서 앞으로 순회하는 가능성을 고려해보세요
        이것은 문제를 완전히 바꾸어 놓고, 훨씩 쉽게 만들 수 있습니다.
    







Implementation

1️⃣
2️⃣
3️⃣
4️⃣
5️⃣
6️⃣

class Solution {
    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        // 각 배열의 끝을 가리키는 p1과 p2를 설정합니다.
        var p1 = m - 1
        var p2 = n - 1

        // p를 배열을 통해 뒤로 이동하면서, 매번 p1 또는 p2가 가리키는 더 작은 값을 작성합니다.
        for p in stride(from: m + n - 1, through: 0, by: -1) {
            if p2 &lt; 0 {
                break
            }
            if p1 &gt;= 0 &amp;&amp; nums1[p1] &gt; nums2[p2] {
                nums1[p] = nums1[p1]
                p1 -= 1
            } else {
                nums1[p] = nums2[p2]
                p2 -= 1
            }
        }
    }
}


Complexity Analysis


  Time complexity: O(n + m)
    
      Same as Approach 2.
    
  
  Space complexity: O(1)
    
      Unlike Approach 2, we’re not using an extra array.
    
  


Proof(optional)

이 주장에 대해 조금 회의적일 수도 있습니다.
정말 모든 경우에 작동하나요?
이렇게 대담한 주장을 하는 것이 안전한가요?



    
        이 방식으로, `nums1`의 처음 `m`개 값을 덮어쓰기 시작하면, 각각을 이미 새 위치에 써 놓았을 것입니다
        이런 방식으로 우리는 추가 공간을 없앨 수 있습니다.
    




훌륭한 질문입니다!
그렇다면 왜 이 방법이 작동할까요?
이를 증명하기 위해, p가 nums1에서 p1이 아직 읽지 않은 값을 덮어쓰지 않는 것을 확실히 해야 합니다.



    
        조언 :증명에 겁을 먹고 있나요?
        많은 소프트웨어 엔지니어들이 그렇습니다.
        좋은 증명은 간단히 각각의 논리적 주장들이 다음 주장 위에 구축되는 것입니다.
        이런 방식으로, 우리는 "명백한" 진술로부터 시작하여 증명하고자 하는 것에 이룰 수 있습니다.
        각 진술을 하나씩 읽으며, 다음으로 넘어가기 전에 각각을 이해하는 것이 중요합니다.
    



  초기화 시 p는 p1보다 n만큼 앞서 있다는 것을 알 수 있습니다.(다른 말로, p1 + n = p 입니다.)
  또한, 이 알고리즘이 수행하는 p의 반복 동안, p는 항상 1 만큼 감소하고, p1 또는 p2 중 하나가 1 만큼 감소한다는 것도 알고 있습니다.
  p1이 감소할 때, p와 p1 사이의 간격은 동일하게 유지되므로, 그 경우에 “추월(overtake)”이 발생할 수 없다는 것을 추론할 수 있습니다.
  하지만 p2가 감소할 때는, p는 움직이지만 p1은 그렇지 않으므로, p와 p1 사이의 간격이 1만큼 줄어든가는 것을 추론할 수 있습니다.
  그리고 이로부터, p2가 감소할 수 있는 최대 횟수는 n번임을 추론할 수 있습니다. 다시 말해, p와 p1 사이의 간격은 최대 n 만큼 1 씩 줄어들 수 있습니다.
  결론적으로, 그들이 처음에 n만큼 떨어져 있었기 때문에 추월이 일어날 수 없습니다. 그리고 p = p1일 때, 간격은 n 번 줄어들어야 합니다. 이는 nums2의 모든 것이 병합되었으므로 더 이상 할 일이 없음을 의미합니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Leet-Code/2024-01-20-DuplicateZeros.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Leet-Code/2024-01-20-DuplicateZeros.html"><h1 class="title_post">🆙 [LeetCode] 1089.Duplicate Zeros.</h1></a>
                        <a href="/2024/Leet-Code/2024-01-20-DuplicateZeros.html" class="txt_post">
                            🆙 [LeetCode] 1089.Duplicate Zeros


  Difficulty: Easy
  Topic: Array, Two Pointers




문제는 배열을 제자리에서 수정하도록 요구합니다.
제자리 수정이 제약 조건이 아니라면, 원본 배열에서 대상 배열로 요소를 복사하는 방법을 사용했을 것입니다.



0을 두 번 복사한 것을 주목하세요.
var s = 0
var d = 0

let N = source.count // 여기서 'source'는 Int 타입의 배열이라고 가정합니다.
var destination = [Int]()

// 목적지 배열이 가득 찰 때까지 복사가 수행됩니다.
while s &lt; N {
    if source[s] == 0 {
        // 0을 두 번 복사합니다.
        destination.append(0)
        d += 1
        destination.append(0)
    } else {
        destination.append(source[s])
    }
    
    d += 1
    s += 1
}


문제 설명에는 새 배열을 확장하지 않고 원래 배열의 길이로만 자른다고도 언급되어 있습니다.
이는 배열의 끝에서 몇몇 요소를 버려야 함을 의미합니다.
이러한 요소들은 새로운 인덱스가 원래 배열의 길이를 넘어서는 요소들입니다.



우리에게 주어진 문제 제약 사항에 대해 다시 생각해 봅시다.
추가 공간을 사용할 수 없기 때문에, 우리의 원본 배열과 대상 배열은 본질적으로 동일합니다.
우리는 단순히 원본을 대상 배열로 그대로 복사할 수 없습니다.
그렇게 하면 몇몇 요소를 잃어버릴 것입니다.
왜냐하면, 우리는 배열을 덮어쓰게 될 것이기 때문입니다.


이를 염두에 두고 아래 겁근 방식에서는 배열의 끝 부분에 복사를 시작합니다.

Approach 1: Two pass, O(1) space

Intuition(직관)

만약 우리가 배열의 끝에서 버려질 요소의 수를 안다면, 나머지는 복사할 수 있습니다.
우리는 어떻게 배열의 끝에서 버려질 요소의 수를 알아낼 수 있을까요?
그 수는 배열에 추가될 여분의 0의 수와 같을 것입니다.
여분의 0은 배열의 끝에서 요소 하나를 밀어내면서 자신을 위한 공간을 만듭니다.

일단 우리가 원래 배열에서 최종 배열의 일부가 될 요소의 수를 알게 되면, 우리는 끝에서부터 복사하기 시작할 수 있습니다.
끝에서부터 복사하는 것은, 마지막 몇 개의 불필요한 요소들을 덮어쓸 수 있기 때문에, 어떤 요소도 잃어버리지 않게 해줍니다.

Algorithm

1️⃣. 중복될 제로의 수를 찾습니다. 이를 possible_dups라고 합시다.
최종 배열의 일부가 되지 않을 잘린 제로들을 세지 않도록 주의해야 합니다.
버려진 제로들은 최종 배열의 일부가 되지 않기 때문입니다.
possible_dups의 개수는 원래 배열에서 잘릴 요소의 수를 알려줄 것입니다.
따라서 어느시점에서든, length_ - possible_dups는 최종 배열에 포함될 요소의 수입니다.



참고: 위의 다이어그램에서는 이해를 돕기 위해 원본 배열과 대상 배열을 보여줍니다
우리는 이러한 연산들을 오직 하나의 배열에서만 수행할 것입니다.


2️⃣. 남은 요소들의 경계에 있는 제로에 대한 에지 케이스를 처리합니다.

이 문제의 에지 케이스에 대해 이야기해 봅시다.
남은 배열에서 제로를 복제할 때는 특별한 주의가 필요합니다.
이 주의는 경계에 놓인 Zero에 대해서 취해져야 합니다.
왜냐하면, 이 제로는 가능한 중복으로 간주되거나, 그것의 복제를 수용할 공간이 없을 때 남은 부분에 포함될 수 있기 때문입니다.
만약 그것이 possible_dups의 일부라면 우리는 그것을 복제하고 싶을 것이고, 그렇지 않다면 복제하지 않을 것입니다.


    에지 케이스의 예는 - [8,4,5,0,0,0,0,7] 입니다.
    이 배열에서 첫 번째와 두 번째로 제로의 중복을 수용할 공간이 있습니다.
    하지만 세번째 제로의 중복을 위한 충분한 공간이 없습니다.
    따라서 복사할 때 세 번째 제로에 대해선 두 번 복사하지 않도록 주의해야 합니다.
    결과 = [8,4,5,0,`0`,0,`0`,0]



3️⃣. 배열의 끝에서부터 순회하여, 0이 아닌 요소는 한 번, 0 요소는 두 번 복사합니다.
우리가 불필요한 요소들을 버린다고 할 때, 이는 단순히 불필요한 요소들의 왼쪽에서 시작하여 새로운 값들로 그것들을 덮어쓰고, 결국 남은 요소들은 오른쪽으로 이동시켜 배열 안에 중복된 요소들을 위한 공간을 만들어낸다는 것을 의미합니다.




class Solution {
    func duplicateZeros(_ arr: inout [Int]) {
        var possibleDups = 0
        let length_ = arr.count - 1
        // 복제할 0의 개수를 찾습니다.
        // 원래 배열의 마지막 요소를 넘어서면 중지합니다.
        // 수정된 배열의 일부가 될 마지막 요소를 넘어서면 중지합니다.
        for left in 0...(length_ - possibleDups) {
            // 0 숫자 세기
            if arr[left] == 0 {
                // Edge case: 이 0은 복제할 수 없습니다. 더 이상 공간이 없습니다.
                // 왼쪽은 포함될 수 있는 마지막 요소를 가리키고 있습니다.
                if left == length_ - possibleDups {
                    // 이 0의 경우 중복 없이 복사합니다.
                    arr[length_] = 0
                    break
                }
                possibleDups += 1
            }
        }
        
        // 새 배열의 일부가 될 마지막 요소부터 거꾸로 시작합니다.
        var last = length_ - possibleDups
        
        // 0을 두 번 복사하고 0이 아닌 것을 한 번 복사합니다.
        while last &gt;= 0 {
            if arr[last] == 0 {
                arr[last + possibleDups] = 0
                possibleDups -= 1
                arr[last + possibleDups] = 0
            } else {
                arr[last + possibleDups] = arr[last]
            }
            last -= 1
        }
    }
}


Complexity Analysis

  시간 복잡도(Time Complexity): O(N), 여기서 N은 배열의 요소 수입니다. 우리는 배열을 두 번 순회하는데, 하나는 possible_dups의 수를 찾기 위해, 다른 하나는 요소들을 복사하기 위해 사용됩니다. 최악의 경우, 배열에 zero가 적거나 없을 때 배열 전체를 순회할 수도 있습니다.
  공간 복잡도(Space Complexity): O(1), 우리는 추가적인 공간을 사용하지 않습니다.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-20</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Leet-Code/2024-01-19-InsertingAnywhereInTheArray.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Leet-Code/2024-01-19-InsertingAnywhereInTheArray.html"><h1 class="title_post">📝 배열 삽입 3(배열의 아무 곳에나 삽입하기 - Inserting Anywhere in the Array)</h1></a>
                        <a href="/2024/Leet-Code/2024-01-19-InsertingAnywhereInTheArray.html" class="txt_post">
                            배열 삽입 시리즈


    배열 삽입1 (배열의 끝에 삽입하기-Inserting at the End of an Array)


    배열 삽입2 (배열의 시작 부분에 삽입하기 - Inserting at the Start of an Array)




마찬가지로, 주어진 인덱스에 삽입하기 위해서는, 해당 인덱스부터 시작하는 모든 요소들을 오른쪽으로 한 자리씩 이동시켜야 합니다.
새 요소를 위한 공간이 생성되면, 삽입을 진행합니다.
생각해보면, 시작 부분에 삽입하는 것은 사실 주어진 인덱스에 요소를 삽입하는 것의 특별한 경우에 해당합니다.
그 경우에 주어진 인덱스는 0이었습니다.



다시 한 번 말씀드리지만, 이것도 비용이 많이 드는 작업입니다.
새 요소를 실제로 삽입하기 전에 거의 모든 다른 요소들을 오른쪽으로 이동시켜야 할 수도 있기 때문입니다.
위에서 보셨듯이, 많은 요소들을 오른쪽으로 한 칸씩 이동시키는 것은 삽입 작업의 시간 복잡도를 증가시킵니다.

다음은 코드의 모습입니다
// 배열 삽입 1,2 코드 참고
var intArray = [Int](repeating: 0, count: 6)
var length = 0


for i in 0..&lt;3 {
	intArray[length] = i
	length += 1
}

func printArray() {
	for i in 0..&lt;intArray.count {
			print("Index \(i) contains \(intArray[i])")
	}
}

intArray[length] = 10
length += 1


for i in(0...3).reversed() {
	intArray[i + 1] = intArray[i]
}

intArray[0] = 20

// 인덱스 2에 요소를 삽입하고 싶다고 가정해봅시다.
// 먼저, 새로운 요소를 위한 공간을 만들어야 합니다.
for i in stride(from: 4, through: 2, by: -1) {
	// 각 요소를 오른쪽으로 한 위치씩 이동시킵니다.
	intArray[i + 1] = intArray[i]
}

// 이제 새로운 요소를 위한 공간을 만들었으므로,
// 필요한 인덱스에 삽입할 수 있습니다.
intArray[2] = 30

printArray()


다음은 printArray를 실행한 결과입니다.

Index 0 contains 20.
Index 1 contains 0.
Index 2 contains 30.
Index 3 contains 1.
Index 4 contains 2.
Index 5 contains 10.


주의해야 할 주요한 것은 array.capacity가 베열의 전체 용량을 제공한다는 점을 기억하는 것입니다.
마지막으로 사용된 슬롯을 알고 싶다면 count 변수를 사용하여 직접 추적해야합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Leet-Code/2024-01-19-InsertingAtTheStartOfAnArray.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Leet-Code/2024-01-19-InsertingAtTheStartOfAnArray.html"><h1 class="title_post">📝 배열 삽입 2(배열의 시작 부분에 삽입하기 - Inserting at the Start of an Array)</h1></a>
                        <a href="/2024/Leet-Code/2024-01-19-InsertingAtTheStartOfAnArray.html" class="txt_post">
                            배열 삽입 시리즈

배열 삽입1 (배열의 끝에 삽입하기-Inserting at the End of an Array)



배열의 시작 부분에 삽입하기(Inserting at the Start of an Array)

배열의 시작 부분에 요소를 삽입하려면, 새 요소를 위한 공간을 만들기 위해 배열의 다른 모든 요소들을 오른쪽으로 하나의 인덱스만큼 이동시켜야 합니다.
이것은 비용이 매우 많이 드는 작업입니다, 왜냐하면 기존의 요소들을 모두 오른쪽으로 한 단계씩 이동시켜야 하기 때문입니다.
모든 것을 이동시켜야 한다는 것은 이 작업이 상수 시간 작업이 아니라는 것을 의미합니다.
사실, 배열의 시작 부분에 삽입하는 데 걸리는 시간은 배열의 길이에 비례할 것입니다.
시간 복잡도 분석 측면에서 이는 선형 시간 복잡도, 즉 O(N)인데, 여기서 N은 배열의 길이입니다.



다음은 코드의 모습입니다.
// 배열삽입 1 코드 참고
var intArray = [Int](repeating: 0, count: 6)
var length = 0


for i in 0..&lt;3 {
	intArray[length] = i
	length += 1
}

func printArray() {
	for i in 0..&lt;intArray.count {
			print("Index \(i) contains \(intArray[i])")
	}
}

intArray[length] = 10
length += 1

// 먼저, 새로운 요소를 위한 공간을 만들어야 합니다.
// 이를 위해 각 요소를 오른쪽으로 하나의 인덱스만큼 이동시킵니다.
// 이것은 먼저 인덱스 3의 요소를 이동시키고, 그 다음 2, 그 다음 1, 마지막으로 0을 이동시킵니다.
// 어떤 요소도 덮어쓰지 않기 위해 뒤에서부터 진행해야 합니다.
for i in(0...3).reversed() {
    intArray[i + 1] = intArray[i]
}

// 이제 새로운 요소를 위한 공간을 만들었으므로,
// 시작 부분에 삽입할 수 있습니다.
intArray[0] = 20

printArray()


다음은 printArray()를 실행한 결과입니다.

Index 0 contains 20.
Index 1 contains 0.
Index 2 contains 1.
Index 3 contains 2.
Index 4 contains 10.
Index 5 contains 0.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Leet-Code/2024-01-19-InsertingAtTheEndOfAnArray.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Leet-Code/2024-01-19-InsertingAtTheEndOfAnArray.html"><h1 class="title_post">📝 배열 삽입 1(배열의 끝에 삽입하기-Inserting at the End of an Array)</h1></a>
                        <a href="/2024/Leet-Code/2024-01-19-InsertingAtTheEndOfAnArray.html" class="txt_post">
                            배열에 새로운 요소를 삽입하는 것은 여러 형태를 가질 수 있습니다:


  배열의 끝에 새 요소를 삽입하기.
  배열의 시작 부분에 새 요소를 삽입하기.
  배열 내의 주어진 인덱스에 새 요소를 삽입하기.


배열의 끝에 삽입하기(Inserting at the End of an Array).

어느 시점에서든, 우리는 length 변수에 추적해둔 배열의 마지막 요소의 인덱스를 알고 있습니다.
끝에 요소를 삽입하기 위해 해야 할 일은 현재 마지막 요소 다음 인덱스에 새 요소를 할당하는 것뿐입니다.



이것은 우리가 이미 본 것과 거의 같습니다.
최대 6개의 항목을 담을 수 있는 새 배열을 만들고, 그 다음 첫 3개의 인덱스에 항목을 추가하는 코드입니다.

// 6개의 요소를 가진 정수 배열 선언
var intArray = [Int](repeating: 0, count: 6)
var length = 0

// 배열에 3개의 요소 추가
for i in 0..&lt;3 {
    intArray[length] = i
    length += 1
}


우리가 무슨 일이 일어나고 있는지 시각화하는 데 도움이 되는 함수, printArray를 정의해봅시다.

for i in 0..&lt;intArray.count {
    print("Index \(i) contains \(intArray[i])")
}


우리가 printArray 함수를 실행하면 다음과 같은 출력을 얻을 수 있습니다.

Index 0 contains 0.
Index 1 contains 1.
Index 2 contains 2.
Index 3 contains 0.
Index 4 contains 0.
Index 5 contains 0.


인덱스 3, 4, 5가 모두 0을 포함하고 있는 것을 보셨나요?
이것은 Swift가 사용하지 않는 int 배열 슬롯을 0으로 채우기 때문입니다.

이제 4번째 요소를 추가해봅시다. 숫자 10을 추가할 것입니다.

// 배열 끝에 새 요소를 삽입. 다시 한번,
// 새 요소를 삽입하기 위해 배열에 충분한 공간이 있는지 확인하는 것이 중요합니다.
intArray[length] = 10
length += 1


길이를 1 증가시킨 이유를 알아채셨나요?
길이를 1 증가시키는 것이 중요합니다.
이 단계를 건너 뛰면 다음에 다른 요소를 추가할 때 방금 추가한 요소를 실수로 덮어쓰게 됩니다!
printArray를 다시 실행하면 다음과 같은 결과를 얻을 수 있습니다.

Index 0 contains 0.
Index 1 contains 1.
Index 2 contains 2.
Index 3 contains 10.
Index 4 contains 0.
Index 5 contains 0.


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Leet-Code/2024-01-19-BasicArrayOperations.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Leet-Code/2024-01-19-BasicArrayOperations.html"><h1 class="title_post">📝 기본 배열 작업</h1></a>
                        <a href="/2024/Leet-Code/2024-01-19-BasicArrayOperations.html" class="txt_post">
                            기본 배열 작업.

배열은 데이터 구조로, 특정 형식으로 데이터를 저장하고 저장된 데이터에 대해 특정 작업을 지원합니다.
DVD 재고 관리 소프트웨어를 생각해 보세요.
이 소프트웨어를 사용하여 수행하고 싶은 몇 가지 작업들을 살펴보겠습니다:


  특정 위치에 새 DVD 컬렉션에 삽입(Insert) 합니다.
  더 이상 재고에 보관할 필요가 없다면 기존 컬렉션에서 DVD를 삭제(Delete) 합니다.
  컬렉션에서 특정 DVD를 검색(Search) 합니다. 이것은 컬렉션에서 가장 흔하게 실행되는 작업 중 하나입니다. 왜냐하면 우리의 재고 관리 소프트웨어는 사용자가 요청한 특정 DVD를 찾기 위해 하루에 수백 번 사용될 것이기 때문입니다.


거의 모든 데이터 구조에서 지원하는 세 가지 기본 작업인 삽입(Insert), 삭제(Delete), 검색(Search) 에 대해 자세히 알아보고 학습해야 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/HackTheSwift/2024-01-18-Multi-line-String.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/HackTheSwift/2024-01-18-Multi-line-String.html"><h1 class="title_post">👾 Day 2 - Multi-line String</h1></a>
                        <a href="/2024/HackTheSwift/2024-01-18-Multi-line-String.html" class="txt_post">
                            표준 스위프트 문자열은 이중 따옴표("")를 사용하지만, 여기에는 줄바꿈을 포함할 수 없습니다.

여러 줄에 걸친 문자열을 원한다면 약간 다른 문법이 필요합니다: 세 개의 따옴표로 시작하고 끝내야 합니다.
예를 들면 이렇습니다.
var str1 = """
이것은
여러 줄에
걸쳐 있습니다
"""
// 출력 결과
// 이것은
// 여러 줄에
// 걸쳐 있습니다


스위프트는 이 따옴표를 작성하는 방법에 매우 엄격합니다: 여는 따옴표와 닫는 따옴표 세 개는 각각 별도의 줄에 있어야 하지만,여는 줄바꿈과 닫는 줄바꿈은 최종 문자열에 포함되지 않습니다.

코드를 깜끔하게 정리하기 위해서만 여러 줄 문자열을 원하고, 실제 문자열에 줄바꿈이 포함되길 원하지 않는다면,
각 줄의 끝에 \를 붙이면 됩니다.
예를 들면 이렇게 말이죠:
var str2 = """
이것은 \
여러 줄에 \
걸쳐 있습니다
"""

// 출력 결과
// 이것은 여러 줄에 걸쳐 있습니다


                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/HackTheSwift/2024-01-18-StringAndIntegers.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/HackTheSwift/2024-01-18-StringAndIntegers.html"><h1 class="title_post">👾 Day 2 - String And Integers</h1></a>
                        <a href="/2024/HackTheSwift/2024-01-18-StringAndIntegers.html" class="txt_post">
                            Swift는 타입 안전(type-safe) 언어로 알려져 있으며, 이는 모든 변수가 하나의 특정 타입이어야 한다는 것을 의미합니다.
Xcode가 우리를 위해 생성한 greeting 변수는 “Hello, Kobe”라는 글자들의 문자열을 담고 있으므로 Swift는 이 변수에 String 타입을 할당합니다.

반면, 누군가의 나이를 저장하고 싶다면 다음과 같은 변수를 만들 수 있습니다.

var age = 34


이 변수는 전체 숫자를 담고 있으므로 Swift는 이에 Int 타입을 할당합니다 - ‘integer’의 줄임말입니다.

큰 숫자를 다룰 때, Swift는 턴 단위 구분자로 밑줄을 사용할 수 있게 해줍니다. - 이것은 숫자를 변경하지 않지만 읽기 쉽게 만들어줍니다.
예를 들어:
var population = 8_000_000


문자열과 정수는 다른 타입이며, 혼합될 수 없습니다.
그래서 greeting을 “Hello, Min Seong”으로 변경하는 것은 안전하지만, 34로 변경하는 것은 불가능합니다.
왜냐하면 그것은 Int이지 String이 아니기 때문입니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/Leet-Code/2024-01-16-ArrayCapacity-VS-Length.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/Leet-Code/2024-01-16-ArrayCapacity-VS-Length.html"><h1 class="title_post">📝 배열의 용량 vs 배열의 길이</h1></a>
                        <a href="/2024/Leet-Code/2024-01-16-ArrayCapacity-VS-Length.html" class="txt_post">
                            Array Capacity VS Length

만약 누군가가 당신에게 DVD 배열의 길이가 얼마나 되는지 물어본다면, 당신의 대답은 무엇일까요?

당신은 두 가지 다른 대답을 할 수 있습니다.


  상자가 가득 차있을 경우, 상자가 담을 수 있는 DVD의 수, 또는
  현재 상자에 들어있는 DVD의 수.

이 두 답변은 모두 정확하며, 매우 다른 의미를 가집니다!
이 둘의 차이를 이해하고 올바르게 사용하는 것이 중요합니다.
우리는 첫 번째를 배열의 ‘용량’이라고 부르고, 두번째를 ‘길이’라고 부릅니다.


Array Capacity

DVD[] array = new DVD[6]


array[6]에 요소를 삽입하는 것이 유효한 작업일까요?
array[10]은 어떨까요?

아니요, 이 두 경우 모두 유효하지 않습니다.
배열을 생성할 때, 이 배열이 최대 6 개의 DVD를 담을 수 있다고 지정했습니다.
이것이 배열의 용량입니다.

인덱싱이 0부터 시작한다는 것을 기억한다면, 우리는 오직 array[0], array[1], array[2], array[3], array[4] 그리고 array[5]에만 항목을 삽입할 수 있습니다.
array[-3], array[6], array[100]과 같이 다른 곳에 요소를 넣으려고 하면 ArrayIndexOutOfBoundsExecption으로 코드가 충돌하게 됩니다.

배열의 용량은 배열이 생성될 때 결정되어야 합니다.
용량은 나중에 변경할 수 없습니다.
우리가 사용한 종이 상자에 DVD를 넣는 비유로 돌아가 보면, 배열의 용량을 변경하는 것은 종이 상자를 더 크게 만들려는 것과 같습니다.
고정된 크기의 종이 상자를 더 크게 만드는 것은 비현실적이며, 컴퓨터의 배열에서도 마찬가지입니다!

그렇다면 7번째 DVD를 얻었을 때, 모든 DVD를 같은 배열에 넣고 싶다면 어떻게 할까요?
불행히도 종이 상자의 경우와 마찬가지입니다.
더 큰 상자를 새로 구해서, 기존의 DVD들과 새로운 것을 모두 옮겨야 합니다

자바에서 배열의 용량은 배열의 length 속성값을 확인함으로써 알 수 있습니다.
이는 arr.length라는 코드를 사용하여 확인되는데, 여기서 arr은 배열의 이름입니다.
다른 프로그래밍 언어들은 배열의 길이를 확인하는 데 다른 방법을 사용합니다.

int capacity = array.length;
System.out.println("The Array has a capacity of " + capacity);


이 코드를 실행하면 다음과 같은 출력이 나옵니다:

The Array has a capacity of 6


capacity property of Swift

Instance Property
capacity
배열이 새로운 저장 공간을 할당하지 않고 담을 수 있는 요소의 총 수입니다.

모든 배열은 그 내용을 저장하기 위해 특정 양의 메모리를 예약합니다.
배열에 요소를 추가하고 그 배열이 예약된 용량을 초과하기 시작하면, 배열은 더 큰 메모리 영역을 할당하고 그 요소들을 새로운 저장 공간으로 복사합니다.
새로운 저장 공간은 기존 저장 공간 크기의 배수입니다.
이 지수적 성장 전략은 요소 추가 작업이 평균적으로 상수 시간 내에 이루어지게 하여, 많은 추가 작업의 성능을 평균화합니다.
재할당을 유발하는 추가 작업에는 성능 비용이 들지만, 배열이 커짐에 따라 그런 작업은 점점 덜 자주 발생합니다.

다음 예시는 배열 리터럴로부터 정수 배열을 생성한 다음, 다른 컬렉션의 요소들을 추가합니다.
추가 하기 전에, 배열은 결과 요소들을 저장할 수 있을 만큼 충분히 큰 새로운 저장 공간을 할당합니다.

var numbers = [10, 20, 30, 40, 50]
// numbers.count == 5
// numbers.capacity == 5

numbers.append(contentsOf: stride(from: 60, through: 100, by: 10))
// numbers.count == 10
// numbers.capacity == 10


Array Length

길이(length) 의 또 다른 정의는 배열에 현재 들어 있는 DVD의 수, 또는 다른 항목들의 수입니다
이것은 직접 추적해야 할 것이며, 기존 DVD를 덮어쓰거나 배열에 공백을 남겨두어도 오류는 발생하지 않습니다.

이전 예제에서 length 변수를 사용하여 다음 비어 있는 인덱스를 추적하고 있는 것을 눈치챘을 수 있습니다.

// 용량이 6인 새 배열을 생성합니다.
int[] array = new int[6];

// 현재 길이는 0이며, 요소가 0개 있기 때문입니다.
int length = 0;

// 그 안에 3개의 항목을 추가합니다.
for (int i = 0; i &lt; 3; i++) {
    array[i] = i * i;
    // 요소를 추가할 때마다 길이가 1씩 증가합니다.
    length++;
}

System.out.println("배열의 용량은 " + array.length + "입니다.");
System.out.println("배열의 길이는 " + length + "입니다.");


이 코드를 실행하면 다음과 같은 출력이 나옵니다:

The Array has a capacity of 6
The Array has a length of 3


count property of Swift

Instance Property
count

배열의 요소(elements) 수 입니다.

var count: Int { get }


Handling Array Parameters(배열 매개변수 처리하기)

LeetCode에서의 대부분의 배열 문제는 “길이”나 “용량” 매개변수 없이 매개변수로 배열을 전달합니다.
이게 무슨 뜻일까요?
예를 들어 설명해 보겠습니다.
여기 당신이 풀게 될 첫 번째 문제의 설명이 있습니다.

‘이진 배열이 주어졌을 때, 이 배열에서 연속된 1의 최대 개수를 찾아라.’

그리고 여기 주어진 코드 템플릿이 있습니다.

class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        
    }
}


유일한 매개변수는 'nums' 인데, 이는 배열입니다. 'nums'의 길이를 모르면 이 문제를 해결할 수 없습니다.
다행히도 이는 간단합니다.
매개변수로 주어진 배열에 대한 추가 정보가 없을때는 길이 == 용량 (length == capacity) 이라고 안전하게 가정할 수 있습니다.
즉, 배열은 그 데이터를 모두 담기에 정확히 적합한 크기입니다.
따라서 .length를 사용할 수 있습니다.

하지만 조심하세요, 배열은 0부터 시작하는 인덱스입니다.
용량(capacity)/길이(length)는 항목의 수이지 최고 인덱스가 아닙니다.
최고 인텍스는 .lenght -1 입니다.
따라서 배열의 모든 항목을 순회하기 위해 다음과 같이 할 수 있습니다.

class Solution {
    public int findMaxConsectiveOnes(int[] nums) {
        // 힌트: 여기에 변수를 초기화하고 선언하여
        // 연속된 1이 몇 개인지 추적합니다.
        for (int i = 0; i &lt; nums.length; i++) {
            // nums[i] 요소로 무언가를 합니다.
        }
    }
}


이것이 바로 시작하기 위해 필요한 배열의 기본 사항입니다!

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/HackTheSwift/2024-01-14-WhyDoseSwiftHaveVariables.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/HackTheSwift/2024-01-14-WhyDoseSwiftHaveVariables.html"><h1 class="title_post">📝 스위프트에 왜 변수가 있을까?</h1></a>
                        <a href="/2024/HackTheSwift/2024-01-14-WhyDoseSwiftHaveVariables.html" class="txt_post">
                            변수는 프로그램에서 임시 정보를 저장하는 데 사용되며, 거의 모든 Swift 프로그램의 핵심 부분을 이룹니다.
여러분의 프로그램은 어떤 식으로든 데이터를 변환할 것입니다: 사용자가 할 일 목록 작업을 입력하고 체크하게 하거나, 황량한 섬에서 자본주의적인 너구리를 위해 돌아다니게 하거나, 기기 시간을 읽고 시계에 표시하는 등입니다.
어쨋든, 어떤 종류의 데이터를 받아 어떤 식으로든 변환하고 사용자에게 보여주는 것입니다.

물론, ‘어떤 식으로든 변환하는’ 부분이 진짜 마법이 일어나는 곳입니다, 왜냐하면 그곳이 여러분의 놀라운 아이디어가 실현되는 곳이기 때문입니다.
하지만 데이터를 메모리에 저장하는 과정 - 사용자가 입력한 것이나 인터넷에서 다운로드한 것을 기억하는 것 - 이 곳이 변수가 사용되는 곳 입니다.

var 를 사용하여 변수를 생성하면, var 를 다시 사용하지 않고도 원하는 만큼 변경할 수 있습니다.
예를 들어:
var favoriteSports = "Tennis"
favoriteSports = "MMA"
favoriteSports = "Crossfit"


만약 도움이 된다면, var 를 “새로운 변수 생성(create a new variable)”으로 읽어보세요.
따라서, 위의 첫 번째 줄은 “새로운 변수 favoriteSports 를 생성하고 그것에 Tennis 값을 주세요”로 읽을 수 있습니다.
두 번째와 세 번째 줄에는 var 가 없으므로, 새 변수를 생성하는 것이 아니라 기존 값을 수정합니다.

이제 모든 세 줄에 var 가 있다고 상상해보세요 - 매번 var favoriteSports 를 사용했습니다.
그것은 많은 의미가 없을 것입니다, 왜냐하면 여러분은 “새로운 변수 favoriteSports 를 생성하라”고 세 번 반복하게 되고, 변수는 첫 번째 시도 후에 분명히 새로운 것이 아닙니다.
Swift는 이것을 오류로 표시할 것이고, 여러분이 변수에 다른 이름을 선택할 때까지 코드를 실행하지 못하게 할 것입니다.

그것이 성가신 행동처럼 보일 수 있지만, 신뢰하세요: 그것은 도움이 됩니다!
Swift는 여러분에게 명확해지길 원합니다: 기존 변수를 수정하려고 하고 있다면(그렇다면 두 번째와 그 이후에는 var 를 제거하세요), 아니면 새 변수를 생성하려고 하는 것인가요?(그 경우에는 다른 이름을 지으세요.)

마지막으로: 변수가 많은 Swift 프로그램의 핵심을 이루고 있지만, 때때로 그것들을 피하는 것이 가장 좋다는 것을 배우게 될 것입니다.
이에 대해서는 나중에 더 자세히 학습하겠습니다

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/2024/HackTheSwift/2024-01-14-Variables.html" class="thumbnail_post empty" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/empty.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/2024/HackTheSwift/2024-01-14-Variables.html"><h1 class="title_post">👾 Day 1 - Variables</h1></a>
                        <a href="/2024/HackTheSwift/2024-01-14-Variables.html" class="txt_post">
                            변수(Variables)는 프로그램 데이터를 저장할 수 있는 장소입니다.
‘변수(variables)’라고 불리는 이유는 그 값이 변할 수 있기 때문입니다.
즉, 값을 자유롭게 변경할 수 있다는 뜻 입니다.

플레이그라운드를 열고 아래와 같은 코드를 작성해봅시다.

var greeting = "Hello, Kobe"


위 코드는 ‘Hello, Kobe’라는 값을 가진 greeting라는 새로운 변수를 생성합니다.플레이그라운드 오른쪽에 있는 영역을 보면 ‘Hello, Kobe’를 볼 수 있습니다. - 이것은 Xcode가 값을 설정했다는 것을 보여주는 것 입니다.

greeting은 변수이기 때문에 변경이 가능합니다:

greeting = "Hello, Min Seong"


값을 선언 또는 초기화 한 이후 값을 변경하려 할 때는 ‘var’ 키워드는 필요하지 않습니다.
왜냐하면 변수가 이미 생성되었기 때문입니다. - 우리는 단지 그것을 변경하는 것뿐입니다.

                        </a>
                        <div class="info-post">
                                <a href="/2024" class="category">2024</a>
                            
                                <span class="date">· 2024-01-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        </ul>
    
</div>
<div class="pagination">
    <nav class="pagination-container">
        <button class="pagination-button" id="prev-button" aria-label="Previous page" title="Previous page">
            &lt;
        </button>
    
        <div id="pagination-numbers"></div>
      
        <button class="pagination-button" id="next-button" aria-label="Next page" title="Next page">
            &gt;
        </button>
    </nav>
</div>
                
            </div>
        </div>
        <div id="search">
    <div class="wave"></div>
    <div class="wave"></div>
    <div class="wave"></div>

    <div class="search-box">
        <mark>Touch background to close</mark>
        <div class="input-box">
            <input id="search-input" type="search" tabindex="1" spellcheck="false" placeholder="Search...">
            <button id="btn-clear">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"></path></svg>
            </button>
        </div>
        <ul id="search-result"></ul>
    </div>
</div>
    </body>
    <script defer src="/assets/js/background.js"></script>
<script defer src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }

    gtag('js', new Date());
    gtag('config', '');
</script>
    
        <script src="/assets/js/subject.js"></script>
    
    <script src="/assets/js/common.js"></script>
    <script defer>
    var posts = [];

    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > AWS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/AWS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > CPP_DS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/CPP_DS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > CS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/CS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > DataStructure",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/DataStructure/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Database",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Database/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > HackTheSwift",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/HackTheSwift/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Leet-Code",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Leet-Code/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > MySQL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/MySQL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Network",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Network/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > OS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/OS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Read English Book",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Read%20English%20Book/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > SQL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/SQL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > TIL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/TIL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Web",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Web/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > AWS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/AWS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > AnD",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/AnD/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > CS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/CS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > DB",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/DB/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > ENG",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/ENG/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Java多識",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Java%E5%A4%9A%E8%AD%98/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Math",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Math/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Network",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Network/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Post",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Post/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > TIL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/TIL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Metacognition > Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Metacognition/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Metacognition",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Metacognition/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "👾 Day 1 - Variables",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift",
            'url'      : "/2024/HackTheSwift/2024-01-14-Variables.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-15"
        });
    

        posts.push({
            'title'    : "📝 스위프트에 왜 변수가 있을까?",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift, Article",
            'url'      : "/2024/HackTheSwift/2024-01-14-WhyDoseSwiftHaveVariables.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-15"
        });
    

        posts.push({
            'title'    : "📝 배열의 용량 vs 배열의 길이",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-16-ArrayCapacity-VS-Length.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-18"
        });
    

        posts.push({
            'title'    : "👾 Day 2 - String And Integers",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift, Programming",
            'url'      : "/2024/HackTheSwift/2024-01-18-StringAndIntegers.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-18"
        });
    

        posts.push({
            'title'    : "👾 Day 2 - Multi-line String",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift",
            'url'      : "/2024/HackTheSwift/2024-01-18-Multi-line-String.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 기본 배열 작업",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-BasicArrayOperations.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 1(배열의 끝에 삽입하기-Inserting at the End of an Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAtTheEndOfAnArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 2(배열의 시작 부분에 삽입하기 - Inserting at the Start of an Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAtTheStartOfAnArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 3(배열의 아무 곳에나 삽입하기 - Inserting Anywhere in the Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAnywhereInTheArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "🆙 [LeetCode] 1089.Duplicate Zeros.",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-20-DuplicateZeros.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-20"
        });
    

        posts.push({
            'title'    : "🆙 [LeetCode] 88.Merge Sorted Array.",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-22-MergeSortedArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-21"
        });
    

        posts.push({
            'title'    : "👾[Day 3] Doubles and Booleans",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "swift, programming",
            'url'      : "/2024/HackTheSwift/2024-01-22-DoubleAndBool.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-22"
        });
    

        posts.push({
            'title'    : "🌐[Network] 웹소켓(WebSocket)",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Server, Back-end",
            'url'      : "/2024/Network/2024-01-22-webSocket.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "🌐[Network] HTTP 통신.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, HTTP",
            'url'      : "/2024/Network/2024-01-23-HTTP.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "🌐[Network] 패킷(Packet)",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-01-23-Packet.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea.",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-25-TheOldManAndTheSea.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-25"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (2).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-26-TheOldManAndTheSea2.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-26"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (3).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-27-TheOldManAndTheSea3.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-26"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (5).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-29-TheOldManAndTheSea5.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-28"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (4).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-28-TheOldManAndTheSea4.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수 선언.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java",
            'url'      : "/2024/Java/2024-02-01-VariableDeclaration.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-01"
        });
    

        posts.push({
            'title'    : "🌐 [AWS] IAM이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Cloud platform",
            'url'      : "/2024/AWS/post-01.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [AWS] VPC?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "VPC",
            'url'      : "/2024/AWS/post-04.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [Network, AWS] Subnet이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/2024/AWS/post-03.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [Network, AWS] Routing Table이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "Network, AWS",
            'url'      : "/2024/AWS/post-02.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (6).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-02-03-TheOldManAndTheSea6.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-03"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크 기초 용어.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-03-networkBasicTerm1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-04"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 컬럼명 변경, 순서변경, 타입변경, 추가.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-05-COLUMN1.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-05"
        });
    

        posts.push({
            'title'    : "🌐[Network] 시스템(System).",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-05-system.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "🌐[Network] 인터페이스(Interface).",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-05-interface.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (7).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-02-06-TheOldMadAndTheSea7.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "☕️[JAVA] Packaing 옵션.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "JAVA, Programming language",
            'url'      : "/2024/Java/2024-02-06-JavaFormat.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "☕️[JAVA] while문과 for문.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, programming language",
            'url'      : "/2024/Java/2024-02-07-loop.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스코프 존재 이유 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming language",
            'url'      : "/2024/Java/2024-02-07-scope1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-07"
        });
    

        posts.push({
            'title'    : "🌐[Network] 전송매체.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-08-TransmissionMedia.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 형변환 정리.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-09-typecasting.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-09"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 라이브러리 살펴보기",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framwork",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-09-springFramework1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-09"
        });
    

        posts.push({
            'title'    : "🌐[Network] 프로토콜.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-10-protocol.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 향상된 for문",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-11-foreach.html",
            'image'    : "/assets/img/thumbnail/forloop.jpeg",
            'date'     : "2024-02-11"
        });
    

        posts.push({
            'title'    : "🍃[Spring Boot] 스프링?",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring Boot, Framework, Spring",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-13-Spring.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드(2)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-method2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드정의",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-method3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 반환타입.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-methodReturnType.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-methodStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 리펙토링 - 입.출금",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-14-JavaRefAccount1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-14"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-14-aboutNetwork.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-14"
        });
    

        posts.push({
            'title'    : "💾[Database] DBMS의 분류",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/2024/Database/2024-02-15-classificationOfDBMS.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "💾[Database] 데이터베이스의 정의와 특징",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/2024/Database/2024-02-15-databaseDefinition.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 파트 정리.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-15-methodSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스가 필요한 이유.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-15-whyWeNeedClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 인터넷",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Internet",
            'url'      : "/2024/Network/2024-02-15-internet.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 표준화",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Standardization",
            'url'      : "/2024/Network/2024-02-15-standardization.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Route 53에 등록된 서브도메인 github page에 연결하기",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/2024/AWS/post-05.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "💾[Database] SQL의 개요",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database, SQL",
            'url'      : "/2024/Database/2024-02-16-IntroSQL.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-classIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스, 객체, 인스턴스 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-termSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 사용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-useObject.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] MySQL Server Start/Stop",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-16-trobleshootingMysql1.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 배열 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-17-arrayIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🍃[Spring] MVC와 템플릿 엔진",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-17-mvcAndTemplateEngine.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 정적 컨텐츠",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-17-staticContent.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 테이블에 데이터 입력 INSERT INTO",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-InsertInto.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] null 컬럼 변경하기.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-nullColumn.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] SELECT 조회 결과 LIMIT 1000 ROW 해제하기.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-selectAndLimit.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 테이블 삭제하기",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-19-drop.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🍃[Spring] API",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-18-apiSummary.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 배열 도입 - 리팩토링",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-19-arrayIntro-refactoring.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(1)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-20-referenceAndPrimitive.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(2) - 변수 대입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-20-referenceAndPrimitive2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] null",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-null.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(3) - 메서드 호출",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-referenceAndPrimitive3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 참조형과 메서드 호출 - 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-referenceTypesAndMethodCalls.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 초기화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-variableAndInit.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "🌐[Network] 시스템의 구분",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-21-systemClassification.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "🍃[Spring] Gradle과 Maven",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework, Build System",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-21-buildSystem.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] NullPointerException",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-22-NullPointerException.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(1)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-22-procedure-oriented-programming(1).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 지향 프로그래밍 vs 절차 지향 프로그래밍",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-OOPvsPOPsummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 메서드",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-classAndMethod.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 지향 프로그래밍",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-object-oriented-programming.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(2)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-procedure-oriented-programming(2).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(3)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-procedure-oriented-programming(3).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 필요한 이유",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-init(1).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-init(2).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] this",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-this.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본 생성자",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-init(3).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 오버로딩 this()",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-initOverloadingAndThis.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 - import",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-packageImport.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 - 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-packageStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 규칙",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-26-ruleOfpackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-26"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-26-usesOfPackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-26"
        });
    

        posts.push({
            'title'    : "🆙[Cpp DataStructure] 교환(Swap)과 정렬(Sort)",
            'path'     : "2024 > CPP_DS",
            'type'     : "post",
            'tags'     : "Cpp, DataStructure",
            'url'      : "/2024/CPP_DS/2024-02-27-SwapAndSort.html",
            'image'    : "/assets/img/thumbnail/cpp.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자 이해 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-27-accessModifier-1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자 이해 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-27-accessModifier-2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 종류",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 사용 - 필드, 메서드",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-4.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 사용 - 클래스 레벨",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-5.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터의 구성",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-02-29-cs.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-02-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] 캡슐화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-01-Encapsulation.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 메모리 구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-JavaMemoryStructure.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택 영역",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-Stack.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택 영역과 힙 영역",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-StackAndHeap.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택과 큐 자료구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-StackAndQueue.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-04-static1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-04-staticVariable1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticMethod1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticMethod2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticVariable2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticVariable3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-06-staticMethod3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-06"
        });
    

        posts.push({
            'title'    : "🆙[Cpp DataStructure] 안정성(stability) 확인",
            'path'     : "2024 > CPP_DS",
            'type'     : "post",
            'tags'     : "Cpp, DataStructure",
            'url'      : "/2024/CPP_DS/2024-03-07-stableAndUnstable.html",
            'image'    : "/assets/img/thumbnail/cpp.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 상수 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndConstant1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 상수 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndConstant2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 참조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndReference.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 기능 추가",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-InheritanceAndAddingFeatures.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 메모리 구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-InheritanceAndMemoryStructure.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속관계",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-extendRelationship.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속 - 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-extendStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 메서드 오버라이딩",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-09-InheritanceAndMethodOverriding.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 접근 제어",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-10-inheritanceAndAccessControl.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 메서드에 사용되는 final",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-finalUsedInClassesAndMethods.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] super - 부모 참조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-super.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] super - 생성자",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-super2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 구조를 알아야 하는 이유",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-14-WhyYouNeedToKnowComputerArchitecture.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "💾 [CS] 패턴 매칭(Pattern Matching)과 표현 매칭(Expression Matching)",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-14-patternMatchingAndExpressionMatching.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성과 캐스팅",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-14-polymorphismAndCasting.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성(Polymorphism) 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-14-polymorphismStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다운캐스팅과 주의점",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-DowncastingAndPrecaution.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 캐스팅의 종류",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-TypesOfCasting.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] instanceof",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-instanceof.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성과 메서드 오버라이딩",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-17-polymorphismAndMethodOverriding.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-17"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 구조의 큰 그림",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-18-TheBigPictureOfComputerArchitecture.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-19-TakeAdvantageOfPolymorphism3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상 클래스 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-20-AbstractClass1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상 클래스 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-20-AbstractClass2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-20"
        });
    

        posts.push({
            'title'    : "💾 [CS] 0과 1로 숫자를 표현하는 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-21-HowToRepresentNumbersWithZeroAndOne.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 메모리를 16진수로 표시하는 이유",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-21-whyIsComputerMemoryExpressedInhex.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-21-Interface.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스 - 다중구현",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-22-Interface-MultipleImplementation.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 인터페이스 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-22-UsingClassesAndInterfaces.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-23-Polymorphism-RoleImplementatioonExample1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 좋은 객체 지향 프로그래밍이란?",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-23-WhatIsGoodOOP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-24-Polymorphism-RoleImplementatioonExample2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-24"
        });
    

        posts.push({
            'title'    : "💾 [CS] 0과 1로 문자를 표현하는 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-25-HowToRepresentCharactersWithZeroAndOne.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] OCP(Open-Closed Principle) 원칙",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-25-OCP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-25-Polymorphism-RoleImplementatioonExample3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "💉[SQL] 데이터베이스 모델링",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-27-DatabaseModeling.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "💉[SQL] 테이블과 컬럼, SQL",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-27-TableColumnsAndSQL.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "🌐[Web] 웹 브라우저 작동 원리",
            'path'     : "2024 > Web",
            'type'     : "post",
            'tags'     : "Web",
            'url'      : "/2024/Web/2024-03-27-HowWebBrowsersWork.html",
            'image'    : "/assets/img/thumbnail/sparta.jpg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-28-ObjectClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] java.lang 패키지 소개",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-28-java-langPackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 배열",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-ObjectArray.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 다형성",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-ObjectPolymorphism.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] toString()",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-toString.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "💉[SQL] WHERE란?",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-29-WHERE.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "💉[SQL] AND, OR, NOT",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-30-ANDORNOT.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-30"
        });
    

        posts.push({
            'title'    : "💉[SQL] BETWEEN, IN, LIKE",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-30-BETWEENINLIKE.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-30"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object와 OCP",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-31-ObjectAndOCP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] equals() - 1.동일성과 동등성",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-31-equals1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "💉[SQL] SQL 문의 기본 구조, SQL",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-31-sql.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "💾 [CS] 소스코드와 명령어",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-01-SourceCodeAndCommands.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] equals() - 2. 구현",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-01-equals2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "💉[SQL] SUM, AVG, COUNT, MIN, MAX",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-01-SUMAVGCOUNTMINMAX.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "💉[SQL] Query 작성시 플로우",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-01-sqlFlow.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형의 공유",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-02-SharingOfBasicTypesAndReferenceTypes.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "💉[SQL] GROUP BY",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-02-GROUPBY.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "💉[SQL] ORDER BY",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-02-ORDERBY.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-03-ImmutableObjectsIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 공유 참조와 사이드 이펙트",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-03-SharedReferencesAndSideEffects.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-03"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어의 구조",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-04-commandStructure.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 예제",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-04-ImmutableObjectExample.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "💉[SQL] REPLACE, SUBSTRING, CONCAT",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-04-ReplaceSubstringConcat.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 값 변경",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-05-ImmutableObjectChangeValue.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-05-ImmutableObjectSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 기본",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-06-StringClassBasic.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-06"
        });
    

        posts.push({
            'title'    : "💾 [CS] ALU와 제어장치",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-08-ALUandControlUnit.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 비교",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-08-StringClassComparison.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 불변객체",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-09-StringClassImmutableObject.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 주요 메서드 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-09-StringClassMethod-1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] StringBuilder - 가변 String",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-10-StringBuilder.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 주요 메서드 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-10-StringClassMethod2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-10"
        });
    

        posts.push({
            'title'    : "💾 [CS] 레지스터",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-11-register.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 체이닝 - Method Chaining",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-11-MethodChaining.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 최적화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-11-StringOptimization.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-14-StringClassSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-14"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어 사이클과 인터럽트",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-15-InstructionCycleAndIntrrupts.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 기본형의 한계 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-15-WrapperClass-LimitationsOfBaseTypes1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240415 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-15-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 오토 박싱",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-AutoBoxing.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 자바 래퍼 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-JavaWrapperClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 기본형의 한계 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-LimitationOfBaseTypes2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240417 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 주요 메서드와 성능",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-18-WrapperClass-MainMethodsAndPerformance.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240418 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-18"
        });
    

        posts.push({
            'title'    : "💾 [CS] 빠른 CPU를 위한 설계 기법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-19-DesignTechniquesForFastCPUs.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어 병렬 처리 기법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-19-InstructionParallelProcessingTechnique.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] Class 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-19-Class.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] System 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-19-SystemClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240419 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-19-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 변수",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 복합 자료 구조",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 배열",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure3.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 문자열",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-22-DataStructure-2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 삽입 정렬",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-22-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "💻[Operating System] 커널(kernel)이란?",
            'path'     : "2024 > OS",
            'type'     : "post",
            'tags'     : "Operating System",
            'url'      : "/2024/OS/2024-04-22-OS-2.html",
            'image'    : "/assets/img/thumbnail/os.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "💻[Operating System] 리눅스와 우분투의 차이점",
            'path'     : "2024 > OS",
            'type'     : "post",
            'tags'     : "Operating System",
            'url'      : "/2024/OS/2024-04-22-OS.html",
            'image'    : "/assets/img/thumbnail/os.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240422 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-22-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 문제 정의와 선형 스캔",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-23-DataStructure-2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-23"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 변수와 배열이 중요한 이유와 이진 탐색",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-23-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-23"
        });
    

        posts.push({
            'title'    : "💾 [CS] CISC와 RISC",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-25-CISCandRISC.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] Math, Random 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-26-MathAndRandomClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-26"
        });
    

        posts.push({
            'title'    : "[AnD] 두 수의 합.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "Algorithm, DataStructure",
            'url'      : "/Backend/AnD/2024-05-01-AnD-1.html",
            'image'    : "/assets/img/thumbnail/AnD.jpeg",
            'date'     : "2024-05-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바란?",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-01-AboutJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 소개",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-IntroJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 코테 맛보기(1) - 코테를 위한 자바 프로그래밍 언어 사용 숙련도",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-TasteTheCodingTest-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 코테 맛보기(2) - 코테를 위한 자료구조와 알고리즘 개념 구현 방법 숙지",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-TasteTheCodingTest-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 변수와 자료형(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "[Math] 기초수학 - 소개",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-02-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240502 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-02-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 타입 비교.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-03-TypeComparison.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 변수와 자료형(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 자료형(3)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240503 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-03-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 자료형(4)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-04"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240504 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-04-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 여러가지 연산자(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-05-VariousOperator-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 여러가지 연산자(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-05-VariousOperators-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 조건문",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-05-conditionalStatement.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240505 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-05-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "💾 [CS] 메모리의 주소 공간",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-06-addressSpaceInMemory.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "☕️[Java] 반복문",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-06-loopStatement.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240506 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-06-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 객체(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-07-ClassesAndObjects-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다차원 배열",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-07-MultidimensionalArray.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240507 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-07-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 객체(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-08-ClassesAndObjects-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-08"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240508 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-08-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-09-Inheritance.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-09"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240509 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-09-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상클래스",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-10-abstractClass.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-10-polymorphism.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240510 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-10-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 내부 클래스",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-11-InnerClass.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 입출력(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-11-Input-Output-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-11-Interface.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "📝[blog post] 프론트엔드와 백엔드는 무엇이 다를까?(+내가 백엔드 개발자가 되고 싶은 이유)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "제로베이스, 백엔드, Java, Spring, 개발자, 백엔드공부, 백엔드스쿨",
            'url'      : "/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240511 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-11-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 예외 처리",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-12-ExceptionHandling.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 입출력(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-12-Input-Ouput-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240512 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-12-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 컬렉션 프레임워크",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-CollectionFramework.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] HashMap에 key 값은 항상 int 여야 할까요?",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 람다식",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-lambda.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 람다식은 하나만!",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-lambdaIsOnlyOne.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240513 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-13-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스트림",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-14-Stream.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-14"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240514 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-14-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-14"
        });
    

        posts.push({
            'title'    : "📝[blog post] 연습 문제 풀이 정리(1)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging",
            'url'      : "/Backend/Post/2024-05-16-PracticeSummary-1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-16"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240516 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-16-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 예외 처리 - 트러블슈팅",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "📝[blog post] 연습 문제 풀이 정리(2)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging",
            'url'      : "/Backend/Post/2024-05-17-PracticeSummary-2.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240517 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 문자열 비교 - 트러블슈팅",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-18-Troubleshooting-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-18-Math-1.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "[Math] 수학적 귀납법",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-18-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "📝[blog post] 나는 어떤 백엔드 개발자가 되고 싶은걸까?",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "제로베이스, 백엔드, Java, Spring, 개발자, 백엔드공부, 백엔드스쿨",
            'url'      : "/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240518 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "💾 [CS] RAID의 정의와 종류",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-21-RAID.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 자료구조 소개",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-21-IntroDataStructureAndAlgorithm.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 선형 자료구조 - 배열",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-21-linearDS-Array.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240521 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-21-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "💾 [CS] 다양한 보조기억장치",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-22-VariousAuxiliaryMemoryDevices.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-22"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240522 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-22-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-22"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 큐(Queue)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-23-Queue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 원형 큐(Circular Queue)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-23-circularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240523 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-23-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 해시(Hash)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-24-Hash.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-24"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240524 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-24-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-24"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 해시 테이블(Hash Table)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-25-HashTable.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-25"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240525 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-25-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-25"
        });
    

        posts.push({
            'title'    : "💾 [CS] 장치 컨트롤러와 장치 드라이버",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-27-dviceControllerAndDeviceDriver.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 이진 트리(Binary Tree)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-BinaryTree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 완전 이진 트리(Complete Binary Tree)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-CompleteBinaryTree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 노드(Node)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-Node.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 트리(Tree)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-Tree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240527 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-27-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 스택(Stack)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-28-Stack.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-28"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240528 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-28-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-28"
        });
    

        posts.push({
            'title'    : "💾 [CS] 다양한 입출력 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-30-VariousInputOutputMethods.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-29"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240529 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-29-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-29"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 큐(Queue)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-30-Queue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-30"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240530 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-30-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-30"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 배열에서 특정 인덱스의 요소를 삭제하기.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-01-RemoveSpecificIndexFromArray.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-01"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240601 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-01-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-01"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Java의 배열.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-02-ArrayOfJava.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "📝[blog post] Java Docs 보는 방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging, Documentation",
            'url'      : "/Backend/Post/2024-06-02-HowToReadJavaDocs.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240602 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-02-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] IntStream",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-03-IntStream.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-03"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240603 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-03-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-03"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Deque(데크, 덱)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-05-Deque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-05"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240605 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-05-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-05"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] ArrayDeque",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-06-ArrayDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-06"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240606 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-06-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-06"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] LinkedList를 사용한 Deque.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-07-LinkedListDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-07"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240607 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-07-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 제네릭(Generic)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-08-Generic.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] Primitive Type과 Wrapper Class.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-08-PrimitiveAndWrapper.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240608 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-08-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)란?",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-09-CircularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성(Polymorphism)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-09-polymorphism.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240609 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-09-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Deque에서의 front와 rear의 변화.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-10-ChangeBetweenFrontAndRearInDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-10"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240610 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-10-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-10"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240611 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-11-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-11"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)의 중간 지점 찾기.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-12-CircularQueueFindMiddleIndex.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-12"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240612 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-12-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-12"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 알고리즘(Algorithm)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-13-AboutAlgorithm.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)를 배열로 구현시 rear를 -1으로 설정하지 않는 이유.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-13-ReasonOfRearIsntSetToMinusOneInCircularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240613 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-13-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📚[ENG] 240616 Studing English through Newsletters",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study, Newsletters",
            'url'      : "/Backend/ENG/240616-ENG-STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-16"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240616 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-16-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-16"
        });
    

        posts.push({
            'title'    : "💭 [Metacognition] 240616 JAVA의 정석",
            'path'     : "Metacognition > Java",
            'type'     : "post",
            'tags'     : "Metacognition, Java",
            'url'      : "/Metacognition/Java/2024-06-16-Meta-Java-PrimitiveType.html",
            'image'    : "/assets/img/thumbnail/META.jpg",
            'date'     : "2024-06-16"
        });
    

        posts.push({
            'title'    : "[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-06-17-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-06-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240617 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-17"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 클라우드 컴퓨팅의 유형",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240615_Types_of_Clould_Computing.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📚[ENG] 제목만 해석하는 영어 공부 :) ",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study",
            'url'      : "/Backend/ENG/240618_ENG_STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240618 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📚[ENG][240621] 제목만 해석하는 영어 공부 :)",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study",
            'url'      : "/Backend/ENG/240621-ENG-STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 프로그래밍 언어와 자바",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-24"
        });
    

        posts.push({
            'title'    : "📝[Post] 서버와 클라이언트의 개념(1)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-06-27-ServerAndClient-1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-06-27"
        });
    

        posts.push({
            'title'    : "☁️[AWS] HOSTNAME 바꾸는 방법",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240709_AWS_HOSTNAME.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-09"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023 플랫폼에 MySQL 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240710_AWS_MYSQL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-10"
        });
    

        posts.push({
            'title'    : "📝[Post] Spring과 SpringBoot의 개념.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-07-11-SpringAndSpringBoot.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-11"
        });
    

        posts.push({
            'title'    : "☁️[AWS] .gradlew 빌드 실패시 확인해야 할 것들",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240714_AWS_GRADLEW.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-14"
        });
    

        posts.push({
            'title'    : "💾[Database] 데이터베이스의 정의와 특징.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-07-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 프로그래밍 언어와 자바",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-16-Variable.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-16"
        });
    

        posts.push({
            'title'    : "📝[Post] 자바다식(Java多識) - 1",
            'path'     : "Backend > Java多識",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-19"
        });
    

        posts.push({
            'title'    : "📝[Post] 자바다식(Java多識) - 2",
            'path'     : "Backend > Java多識",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no2.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023에 Java8 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240726_AWS_JAVA_INSTALL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-26"
        });
    

        posts.push({
            'title'    : "💾[Database] MySQL DB에 한글 삽입.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database, MySQL",
            'url'      : "/Backend/DB/2024-07-26-korean-mysql.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-07-26"
        });
    

        posts.push({
            'title'    : "📝[Post] 아이피와 포트",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-07-28-ipAndport.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] @EntityListeners 어노테이션.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-31-EntityListeners.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] Main 클래스 생성 후 오류 대처.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-31-MainBuildFail.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] attribute의 의미와 역할",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-31-attribute.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "💾[Database] 트랜잭션의 의미와 역할.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/Backend/DB/2024-08-01-Transaction.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-08-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] ObjectMapper 클래스, 직렬화와 역직렬화",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-08-01-SerializationAndDeserialization.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] @Transactional의 역할과 의미.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-08-02-Transactional.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-02"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2에 Java8 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240804_AWS_JAVA8_INSTALL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] @RequiredArgsConstructor의 역할.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-08-05-RequiredArgsConstructor.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-05"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 클라우드(Cloud)란?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240807_AWS_CLOUD.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 온프레미스(on-premise)란?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240807_AWS_ON-PREMISE.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "📝[Post] 정적 웹사이트와 동적 웹사이트.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-07-webpage.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 로컬 파일을 EC2 서버에 올리는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240809_AWS_EC2_UPLOAD.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-09"
        });
    

        posts.push({
            'title'    : "🌐[Network] CIDR이란?",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-09-network-cidr.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-09"
        });
    

        posts.push({
            'title'    : "📝[Post] Nginx 설치방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-11-Nginx.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-11"
        });
    

        posts.push({
            'title'    : "🌐[Network] IP주소(Address)는 네트워크의 번지(주소)",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-14-network-ip.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-14"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 서비스 제공 형태에 따른 클라우드 분류.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/2024_08_15_AWS_CLOULD_CLASSIFICATION.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Bastion Host란?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_BASTION_HOST.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 인바운드 규칙(Inbounds Rules)와 아웃바운드 규칙(Outbound Rules)",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_RULES.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 서버리스, 개방형 클라우드와 폐쇄형 클라우드",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_ServerlessAndOpenAndClosedClould.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 가상화",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_Virtualization.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크 기초 용어.",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-15-network-basic-term.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 시스템 기초 용어.",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-16-system-basic-term.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-16"
        });
    

    searchPost(posts);

    
</script>
</html>

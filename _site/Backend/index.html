<!DOCTYPE html>
<html lang="en">
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
    
        Backend
    
</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Index | devkobe24.com</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="Index">
<meta property="og:locale" content="en_US">
<meta name="description" content="Kobe - Developer blog">
<meta property="og:description" content="Kobe - Developer blog">
<meta property="og:site_name" content="devkobe24.com">
<meta property="og:type" content="article">
<meta property="article:published_time" content="1900-01-01T00:00:00+09:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Index">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"1900-01-01T00:00:00+09:00","datePublished":"1900-01-01T00:00:00+09:00","description":"Kobe - Developer blog","headline":"Index","mainEntityOfPage":{"@type":"WebPage","@id":"/Backend/"},"url":"/Backend/"}</script>
<!-- End Jekyll SEO tag -->


<link rel="shortcut icon" type="image/png" href="/assets/img/favicon.webp">
<style>
@font-face {
    font-family: 'Nunito Sans';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Nunito Sans'),
         url("/assets/fonts/NunitoSans-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Righteous';
    font-style: normal;
    font-weight: 600;
    font-display: optional;
    src: local('Righteous'),
         url("/assets/fonts/Righteous-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Lato';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Lato'),
         url("/assets/fonts/Lato-Regular.woff2") format("woff2");
}
</style>

<script src="/assets/js/fontfaceobserver.js" type="text/javascript"></script>
<script type="text/javascript">
    const nunitoObserver = new FontFaceObserver('Nunito Sans');
    const righteousObserver = new FontFaceObserver('Righteous');
    const latoObserver = new FontFaceObserver('Lato');
  
    Promise.all([
        nunitoObserver.load(),
        righteousObserver.load(),
        latoObserver.load(),
    ]).then(function(){
        document.documentElement.className += " fonts-loaded";
    });
</script>

<meta name="baseurl" content="">
<meta name="description" content="Kobe - Developer blog">
        <link rel="preload" href="/assets/img/profile.jpg" as="image">
        <link rel="stylesheet" href="/assets/css/style.css">
        
    </head>
    <body>
        <script type="text/javascript">
            let currentTheme = localStorage.getItem('theme');
        
            document.body.classList[currentTheme === 'dark' ? 'add' : 'remove']('dark-theme');
        </script>
        <canvas id="stars" width="100%" height="100%"></canvas>
        <div class="sidebar sidebar-left">
    <div class="side-banner">
        <h1 class="site-tab">
            <a href="/" class="site-name">
                <img src="/assets/img/icon/house.webp" alt="" loading="lazy">
                <mark>devkobe24.com</mark>
            </a>
            <button id="btn-brightness" aria-label="brightness-button">
                <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
                <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
            </button>
            <button id="btn-search" aria-label="search-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
            </button>
            <button id="btn-nav" aria-pressed="false" aria-label="menu-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"></path></svg>
            </button>
        </h1>
        <a href="/" class="site-avatar" aria-label="site-avatar">
            <img src="/assets/img/profile.jpg" loading="lazy" alt="homepage" aria-label="homepage-button">
        </a>
    </div>
    <div class="side-info">
        <nav id="navigation">
    
    
    

    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

    
    
    

    <ul class="nav-list">
<li id="nav-first" aria-label="2024">
            <div class="nav-item">
                <a href="/2024/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>2024</span>
                </a><button class="nav-list-expander" aria-label="toggle items in 2024 category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="AWS">
                    <div class="nav-item">
                        <a href="/2024/AWS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>AWS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CPP_DS">
                    <div class="nav-item">
                        <a href="/2024/CPP_DS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CPP_DS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CS">
                    <div class="nav-item">
                        <a href="/2024/CS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="DataStructure">
                    <div class="nav-item">
                        <a href="/2024/DataStructure/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>DataStructure</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Database">
                    <div class="nav-item">
                        <a href="/2024/Database/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Database</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="HackTheSwift">
                    <div class="nav-item">
                        <a href="/2024/HackTheSwift/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>HackTheSwift</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/2024/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Leet-Code">
                    <div class="nav-item">
                        <a href="/2024/Leet-Code/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Leet-Code</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="MySQL">
                    <div class="nav-item">
                        <a href="/2024/MySQL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>MySQL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Network">
                    <div class="nav-item">
                        <a href="/2024/Network/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Network</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="OS">
                    <div class="nav-item">
                        <a href="/2024/OS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>OS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Read English Book">
                    <div class="nav-item">
                        <a href="/2024/Read%20English%20Book/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Read English Book</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="SQL">
                    <div class="nav-item">
                        <a href="/2024/SQL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>SQL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Spring &amp; Spring Boots">
                    <div class="nav-item">
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Spring &amp; Spring Boots</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="TIL">
                    <div class="nav-item">
                        <a href="/2024/TIL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>TIL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Web">
                    <div class="nav-item">
                        <a href="/2024/Web/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Web</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Backend">
            <div class="nav-item">
                <a href="/Backend/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Backend</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Backend category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="AWS">
                    <div class="nav-item">
                        <a href="/Backend/AWS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>AWS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="AnD">
                    <div class="nav-item">
                        <a href="/Backend/AnD/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>AnD</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CS">
                    <div class="nav-item">
                        <a href="/Backend/CS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="DB">
                    <div class="nav-item">
                        <a href="/Backend/DB/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>DB</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="ENG">
                    <div class="nav-item">
                        <a href="/Backend/ENG/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>ENG</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java多識">
                    <div class="nav-item">
                        <a href="/Backend/Java%E5%A4%9A%E8%AD%98/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java多識</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/Backend/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Math">
                    <div class="nav-item">
                        <a href="/Backend/Math/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Math</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Network">
                    <div class="nav-item">
                        <a href="/Backend/Network/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Network</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Post">
                    <div class="nav-item">
                        <a href="/Backend/Post/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Post</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="TIL">
                    <div class="nav-item">
                        <a href="/Backend/TIL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>TIL</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Metacognition">
            <div class="nav-item">
                <a href="/Metacognition/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Metacognition</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Metacognition category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list"><li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/Metacognition/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li></ul>
</li>
<li id="nav-first" aria-label="Home">
            <div class="nav-item">
                <a href="/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Home</span>
                </a>
</div>
</li>
</ul>
</nav>
        <div id="contact">
            <hr>
            <h3>Contact</h3>
            <ul class="contact-list">
                
                    <li><a aria-label="My Github" href="https://github.com/devKobe24">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Email" href="mailto:dev.skyachieve91@gmail.com">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48H48zM0 176V384c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V176L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"></path></svg>
                    </a></li>
                
                <!-- 
                    <li><a aria-label="My Twitter" href="https://twitter.com/twitter">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.4 151.7c.3 4.5 .3 9.1 .3 13.6 0 138.7-105.6 298.6-298.6 298.6-59.5 0-114.7-17.2-161.1-47.1 8.4 1 16.6 1.3 25.3 1.3 49.1 0 94.2-16.6 130.3-44.8-46.1-1-84.8-31.2-98.1-72.8 6.5 1 13 1.6 19.8 1.6 9.4 0 18.8-1.3 27.6-3.6-48.1-9.7-84.1-52-84.1-103v-1.3c14 7.8 30.2 12.7 47.4 13.3-28.3-18.8-46.8-51-46.8-87.4 0-19.5 5.2-37.4 14.3-53 51.7 63.7 129.3 105.3 216.4 109.8-1.6-7.8-2.6-15.9-2.6-24 0-57.8 46.8-104.9 104.9-104.9 30.2 0 57.5 12.7 76.7 33.1 23.7-4.5 46.5-13.3 66.6-25.3-7.8 24.4-24.4 44.8-46.1 57.8 21.1-2.3 41.6-8.1 60.4-16.2-14.3 20.8-32.2 39.3-52.6 54.3z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Instagram" href="https://www.instagram.com/instagram">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Facebook" href="https://www.facebook.com/facebook">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M512 256C512 114.6 397.4 0 256 0S0 114.6 0 256C0 376 82.7 476.8 194.2 504.5V334.2H141.4V256h52.8V222.3c0-87.1 39.4-127.5 125-127.5c16.2 0 44.2 3.2 55.7 6.4V172c-6-.6-16.5-1-29.6-1c-42 0-58.2 15.9-58.2 57.2V256h83.6l-14.4 78.2H287V510.1C413.8 494.8 512 386.9 512 256h0z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My LinkedIn" href="https://www.linkedin.com/in/linkedin">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
                    </a></li>
                 -->
            </ul>
            <hr>
            <span>
                Copyright © 2024 | <a href="https://github.com/byanko55/jekyll-theme-satellite">Yankos</a>
            </span>
        </div>
    </div>
</div>
<div class="sidebar sidebar-right">
    <div class="tools">
        <button id="btn-brightness" aria-label="brightness-button">
            <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
            <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
        </button>
        <button id="btn-search" aria-label="search-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
        </button>
    </div>
</div>

        <div id="post">
            <div class="inner-header">
                <span class="dot" style="background-color: #F86158;"></span>
                <span class="dot" style="background-color: #FBBF2D;"></span>
                <span class="dot" style="background-color: #2ACB45;"></span>
            </div>
            <div class="inner-content">
                <div class="category-tree">
<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 576 512"><path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"></path></svg>
    <p>
                <a href="/">Home</a>
                &gt;
            
                
                    Backend
                
            </p>
</div>
                
                    <div id="loading">
    <div class="loading_box">
        <img src="/assets/img/loading.webp" loading="lazy">
        <p>Now Loading ...</p>
    </div>
</div>
                    <h1 class="category-header">
    
        Backend
    
</h1>
<div id="category-list">
    <ul class="paginated-list" data-current-page="1" aria-live="polite">
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-14-network-ip.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-14-network-ip.html"><h1 class="title_post">🌐[Network] IP주소(Address)는 네트워크의 번지(주소)</h1></a>
                        <a href="/Backend/Network/2024-08-14-network-ip.html" class="txt_post">
                            🌐[Network] IP주소(Address)는 네트워크의 번지(주소).

  브라우저를 통해 웹 사이트에 접속할 때 우리에게 보이는 웹 페이지는 실제로 어느 주소에 존재하는 ‘웹 사이트를 호스팅하는 서버(웹 서버)’ 에 접속해서 취득한 웹 페이지 정보입니다.
  웹 서버는 데이터 센터에 있을 수도 있고 AWS와 같은 클라우드 서비스에 있을 수도 있습니다.
    
      그리고 웹 서버에 접근하기 위해서는 웹 서버가 그곳에 있다는 특정 정보가 필요합니다.
        
          이것이 IP 주소 입니다.
        
      
    
  
  웹 사이트에 접속할 때는 이 IP 주소를 바탕으로 위치를 특정해 그곳에 있는 웹 서버에 접속합니다.
  웹 서버뿐만 아니라 PC, 스마트폰 등 네트워크와 연결된 모든 장치에는 IP 주소가 할당됩니다.
    
      일반적으로 IPv4가 표준으로 사용됩니다.
        192.168.1.1
        
      
    
  
  (위 예시에서 ‘192’) 1개의 숫자는 0~255까지 256(2⁸)개의 범위를 갖습니다.
  IPv4는 네 개의 숫자가 마침표로 구분된 형식입니다.
  2⁸개의 숫자가 4개 있는 조합이므로 있는 조합이므로 2⁸ˣ⁴=2³²개의 IPv4 주소가 존재합니다.
  IP(v4) 주소는 4개의 숫자를 점으로 구분해 표시합니다.
  IPv4 외에 IPv6도 있습니다.
    
      IPv4는 주소가 2³²(약 43억 개) 존재하는 데 비해 IPv6 주소는 2¹²⁸개(약 340억 개)가 존재합니다.
    
  
  최근 IPv4 주소만으로는 주소를 할당할 수 없을 정도로 서버나 인터넷에 접속하는 기기가 많아져서 대체할 수 있는 IPv6가 주목받고 있습니다.
    
      하지만 IPv6는 아직 보편적으로 보급되지 않았고 기존에 사용하던 기기가 IPv4만 지원하는 경우가 대부분입니다.
    
  


1️⃣ 퍼블릭 IP 주소와 프라이빗 IP 주소.

  IP 주소는 두 가지로 구분할 수 있습니다.
    
      하나는 한국 또는 전 세계에서 ‘이 주소는 인터넷에서 이곳’이라고 특정할 수 있는 주소입니다.
        
          이를 퍼블릭 IP 주소 또는 글로벌 IP 주소라고 합니다.
        
      
    
  
  다른 하나는 프라이빗 IP 주소 입니다.
    
      퍼블릭 IP 주소는 전 세계에서 식별할 수 있는 주소지만, 프라이빗 주소는 닫힌 네트워크(근거리 통신-LAN) 내에서만 식별할 수 있는 IP 주소입니다.
        
          프라이빗 IP 주소로 사용할 수 있는 범위는 다음과 같습니다.
            
              10.0.0.0 ~ 10.255.255.255(10.0.0.0/8)
              172.16.0.0 ~ 172.31.255.255(172.16.0.0/12)
              192.168.0.0 ~ 192.168.255.255(192.168.0.0/16)
                
                  퍼블릭 IP 주소는 이 주소를 제외한 나머지 주소입니다.
                
              
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-08-11-Nginx.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-08-11-Nginx.html"><h1 class="title_post">📝[Post] Nginx 설치방법.</h1></a>
                        <a href="/Backend/Post/2024-08-11-Nginx.html" class="txt_post">
                            🙋‍♂️ Nginx 를 소스에서 직접 컴파일하여 설치하는 방법.

  이 방법은 Homebrew를 사용하지 않고도 Nginx를 설치하는 방법입니다.
  이 방법은 macOS를 기반으로 설치하는 방법을 설명합니다.


1️⃣ 필요한 도구 설치.

  Nginx를 컴파일하려면 Xcode 와 Xcode Command Line Tools 가 필요합니다.
    
      Xcode Command Line Tools 설치.
    
  


xcode-select --install


  프롬프트가 나타나면 설치를 진행합니다.


2️⃣ 소스 코드 다운로드.


  Nginx의 최신 소스 코드를 Nginx 공식 사이트에서 다운로드하거나 wget 명령어를 사용하여 다운로드할 수 있습니다.


curl -O http://nginx.org/download/nginx-1.26.1.tar.gz



  위 명령어에서 nginx-1.26.1 은 설치할 Nginx 버전에 따라 달라질 수 있습니다.
    
      최신 버전을 사용하려면 공식 사이트에서 최신 버전 번호를 확인하세요.
    
  


3️⃣ 소스 코드 압축 해제.

  다운로드한 소스 코드를 압축 해제합니다.


tar -zxvf nginx-1.26.1.tar.gz
cd nginx-1.26.1


4️⃣ Nginx 컴파일 및 설치.

  Nginx를 컴파일하기 위해 몇 가지 옵션을 지정한 후, make 명령어를 사용하여 컴파일하고 설치합니다.


./configure
make
sudo make install



  이 명령어는 기본 설정으로 Nginx를 컴파일하고 /usr/local/nginx 에 설치합니다.
  ./configure 명령어에 다양한 옵션을 추가하여 컴파일 설정을 조정할 수 있습니다.


5️⃣ Nginx 실행.

  컴파일이 완료되면, Nginx를 다음 명령어로 실행할 수 있습니다.


sudo /usr/local/nginx/sbin/nginx



  이제 Nginx가 실행 중일 것입니다.
    
      http://localhost 에 접속하여 Nginx 기본 환영 페이지를 확인할 수 있습니다.
    
  


6️⃣ Nginx 설정 파일

  소스에서 설치한 Nginx의 설정 파일은 /usr/local/nginx/conf/nginx.conf 에 있습니다.
    
      이 파일을 편집하여 설정을 변경할 수 있습니다.
    
  


sudo vi /usr/local/nginx/conf/nginx.conf



  설정을 변경한 후 Nginx를 재시작하여 변경 사항을 적용해야 합니다.


sudo /usr/local/nginx/sbin/nginx -s reload


7️⃣ Nginx 서비스 관리

  Nginx를 시작하고 중지하는 명령어는 다음과 같습니다.
    
      
        
          Nginx 시작.
              sudo /usr/local/nginx/sbin/nginx
            
          
        
      
      
        
          Nginx 중지.
              sudo /usr/local/nginx/sbin/nginx -s stop
            
          
        
      
      
        
          Nginx 재시작.
              sudo /usr/local/nginx/sbin/nginx -s reload
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-09-network-cidr.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-09-network-cidr.html"><h1 class="title_post">🌐[Network] CIDR이란?</h1></a>
                        <a href="/Backend/Network/2024-08-09-network-cidr.html" class="txt_post">
                            🌐[Network] CIDR이란?

  CIDR(Classless Inter-Domain Routing) 은 IP 주소와 관련된 라우팅 방법을 정의하는 표기법입니다.
  CIDR 표기법은 IPv4 주소를 네트워크와 호스트 부분으로 나누고, 네트워크의 크기(서브넷 크기)를 정의하는 데 사용됩니다.
    
      CIDR 표기법은 다음과 같은 형식으로 표현됩니다.
        192.168.0.0/24
        
      
    
  
  이 표기법은 두 부분으로 나뉩니다.
    
      IP 주소 부분 : 192.168.0.0
      서브넷 마스크 부분: /24
        
          여기서 /24 는 서브넷 마스크의 길이를 나타내며, 이는 네트워크 부분의 비트 수를 의미합니다.
            
              즉, 192.168.0.0/24 는 24비트가 네트워크를 정의하고 나머지 8비트(총 32비트 중)가 호스트를 정의하는 서브넷을 나타냅니다.
            
          
        
      
    
  


1️⃣ IPv4 CIDR의 구조.

  IPv4 주소는 32비트로 구성되어 있으며, 이를 네 개의 8비트 옥텟으로 표현합니다.
    
      예를 들어 다음과 같습니다.
        11000000.10101000.00000000.00000000 (이진)
192.168.0.0 (십진)
        
      
    
  
  CIDR 표기법에서 /24 는 첫 번째 24비트(세 개의 옥텟)가 네트워크 주소를 나타낸다는 것을 의미합니다.
    
      이 경우 192.168.0.0 네트워크에는 192.168.0.1 에서 192.168.0.254 까지의 호스트 주소를 가질 수 있습니다.
    
  


2️⃣ IPv4 CIDR의 용도.

  서브네팅 : 큰 네트워크를 작은 서브넷으로 나누기 위해 CIDR을 사용합니다.
  라우팅 : 인터넷 서비스 제공자(ISP) 및 네트워크 관리자는 CIDR을 사용하여 라우팅 테이블을 관리하고, IP 주소 공간을 효율적으로 사용합니다.
  IP 주소 관리 : CIDR은 IP 주소를 할당하고 네트워크를 관리하는 데 사용됩니다.


3️⃣ CIDR 블록의 생성 기준.

  CIDR 블록을 생성할 때는 네트워크 크기와 필요한 IP 주소 수를 고려해야 합니다. 일반적인 기준은 다음과 같습니다.
    
      1. 네트워크 크기 계산 :
        
          /24 서브넷은 256개의 IP 주소(호스트)를 제공합니다. 이 중 두개의 주소(네트워크 주소와 브로드캐스트 주소)를 제외하고, 254개의 호스트 IP 주소를 사용할 수 있습니다.
          /16 서브넷은 65,536개의 IP 주소를 사용할 수 있습니다.
          /32 는 단일 IP 주소를 나타냅니다.
        
      
      2. 필요한 IP 주소 수에 따라 결정 :
        
          만약 50개의 장치를 연결해야 한다면, /26(64개 IP 주소 제공) 서브넷을 사용할 수 있습니다.
          큰 네트워크에는 /16 이나 /12 처럼 더 작은 서브넷 마스크를 사용할 수 있습니다.
        
      
      3. 보안 및 관리 :
        
          더 작은 서브넷(CIDR 블록)을 사용하면 네트워크 트래픽을 보다 효율적으로 관리하고, 보안을 강화할 수 있습니다.
        
      
    
  


4️⃣ 예시.

  /32 : 단일 IP 주소. 예: 192.168.0.1/32
  /24 : 256개의 IP 주소 제공, 주로 작은 네트워크에서 사용. 예: 192.168.0.0/24
  /16 : 65,536개의 IP 주소 제공, 더 큰 네트워크에 사용. 예: 192.168.0.0/16
  /8 : 16,777,216개의 IP 주소 제공, 매우 큰 네트워크에서 사용. 예: 10.0.0.0/8


5️⃣ 결론.

  CIDR 표기법은 IP 주소와 서브넷 마스크를 결합한 표준입니다.
  네트워크의 크기와 IP 주소와 필요 수를 기준으로 CIDR 블록을 생성합니다.
  CIDR을 사용하면 네트워크를 보다 효율적으로 관리하고 라우팅 테이블을 최적화할 수 있습니다.



  🙋‍♂️ CIDR 블록을 설계할 때, 사용하려는 네트워크 규모와 IP 주소 요구 사항을 염두에 두고, 적절한 서브넷 마스크 길이를 선택하는 것이 중요합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240809_AWS_EC2_UPLOAD.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240809_AWS_EC2_UPLOAD.html"><h1 class="title_post">☁️[AWS] 로컬 파일을 EC2 서버에 올리는 방법.</h1></a>
                        <a href="/Backend/AWS/240809_AWS_EC2_UPLOAD.html" class="txt_post">
                            ☁️[AWS] 로컬 파일을 EC2 서버에 올리는 방법.
“저의 상황을 예로 들어 설명하도록 하겠습니다.”


  로컬 macBook에서 Amazon Linux 2023 EC2 서버로 파일을 업로드하는 방법 중 가장 일반적인 방법은 scp(secure copy) 를 사용하는 것 입니다.
    
      이 명령을 통해 안전하게 파일을 복사할 수 있습니다.
    
  



  🙋‍♂️ 아래 설명하는 단계들은 로컬에서 이루어져야 합니다.


1️⃣ EC2 인스턴스 연결 정보 확인.

  먼저 EC2 인스턴스의 퍼블릭 IP 주소와 연결에 사용하는 키 페어 파일(.pem)을 확인합니다.


2️⃣ 로컬 macBook에서 scp 명령어 사용.

  scp 명령어를 사용하여 로컬 파일을 EC2 인스턴스로 업로드합니다.
    
      예를 들어, 로컬 파일 localfile.txt 를 EC2 인스턴스의 /home/ec2-user/ 디렉토리에 업로드하려면 다음과 같이 합니다.
    
  


scp -i /path/to/your-key-pair.pem /path/to/localfile.txt ec2-uesr@&lt;EC2-Instance-Public-IP&gt;:/home/ec2-user/


👉 예제.

  키 페어 파일 경로 : /Users/bingGu/.ssh/my-key-pair.pem
  로컬 파일 경로 : /Users/bingGu/Documents/localfile.txt
  EC2 퍼블릭 IP : 43.201.230.99


/Users/bingGu/Documents/localfile.txt ec2-user@43.201.230.99:/home/ec2-user/


3️⃣ 디렉토리 업로드.

  만약 디렉토리를 업로드 하고 싶다면 -r 옵션을 사용하여 디렉토리를 재귀적으로 업로드할 수 있습니다.
    
      예를 들어, 로컬 디렉토리 localdir 을 EC2 인스턴스의 /home/ec2-user/ 디렉토리에 업로드하려면 다음과 같이 합니다.
    
  


scp -r -i /path/to/your-key-pair.pem /path/to/localdir ec2-user@&lt;EC2-Instance-Public-IP&gt;:/home/ec2-user/


4️⃣ 업로드 확인.

  EC2 인스턴스에 SSH로 접속하여 파일이나 디렉토리가 정상적으로 업로드되었는지 확인합니다.


ssh -i /path/to/your-key-pair.pem ec2-user@&lt;EC2-Instance-Public-IP&gt;
ls /home/ec2-user/


🎯 Troubleshooting

  Permission Denied : 키 파일의 권한이 적절하지 않을 때 발생할 수 있습니다.
    
      다음 명령어로 권한을 조정합니다.
        chmod 400 /path/to/your-key-pair.pem
        
      
    
  
  Host Key Verification Failed : 로컬 머신의 SSH 설정에서 이전에 연결한 적 없는 서버에 대해 경고가 뜨는 경우, 다음 명령어로 knows_hosts 파일을 업데이트할 수 있습니다.
    ssh-keygen -R &lt;EC2-Instance-Public-IP&gt;
    
  



  🙋‍♂️ 이 단계를 따르면 로컬 macBook에서 Amazon Linux 2023 EC2 인스턴스로 파일을 성골적으로 업로드할 수 있을 것입니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-08-07-webpage.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-08-07-webpage.html"><h1 class="title_post">📝[Post] 정적 웹사이트와 동적 웹사이트.</h1></a>
                        <a href="/Backend/Post/2024-08-07-webpage.html" class="txt_post">
                            🙋‍♂️ 정적 웹사이트와 동적 웹사이트.

  정적 웹사이트와 동적 웹사이트는 웹페이지를 생성하고 제공하는 방식에서 큰 차이를 보입니다.
  각각의 특징을 이해하면 어떤 상황에서 어떤 타입의 웹사이트를 사용해야 하는지 결정하는 데 도움이 됩니다.


1️⃣ 정적 웹사이트.

  정적 웹사이트는 미리 만들어진 HTML 파일들을 그대로 웹 서버에서 사용자의 브라우저로 전송하여 보여주는 웹사이트입니다.
    
      이 파일들은 서버에 미리 저장되어 있으며, 사용자의 요청에 따라 변하지 않고 그대로 제공됩니다.
    
  


👍 정적 웹사이트의 장점.

  단순성과 속도.
    
      복잡한 서버 측 처리 없이 바로 파일을 전송하기 때문에 로딩 시간이 빠릅니다.
    
  
  호스팅 비용.
    
      낮은 서버 자원 사용으로 인해 비용이 저렴합니다.
    
  
  보안.
    
      동적 콘텐츠를 처리하는 서버 측 스크립트가 없어 보안 리스크가 상대적으로 낮습니다.
    
  


👎 정적 웹사이트의 단점.

  유연성 부족.
    
      각 페이지를 수동으로 업데이트해야 하며, 대규모 사이트에서는 유지 관리가 어려울 수 있습니다.
    
  
  사용자 상호작용 부족.
    
      사용자 입력에 따라 내용이 바뀌지 않으므로, 폼 제출이나 검색과 같은 기능을 직접 구현하기 어렵습니다.
    
  


2️⃣ 정적 웹사이트의 예시.

  1. 포트폴리오 웹사이트.
    
      웹 개발자, 디자이너, 사진작가 등의 포트폴리오를 위한 웹사이트들은 주로 정적입니다.
      이 웹사이트들은 작품을 보여주는 갤러리, 연락처 정보, 이력서 등의 고정된 내용을 포함합니다.
    
  
  2. 기업 정보 페이지.
    
      소규모 기업이나 스타트업이 회사 정보, 제품 설명, 연락처 정보 등을 제공하는 단순한 웹사이트를 운영할 때, 이는 종종 정적 웹사이트로 구성됩니다.
    
  
  3. 이벤트 안내 페이지.
    
      특정 이벤트의 일시, 장소, 등록 방법 등을 안내하는 웹페이지로, 주로 내용의 변경이 적고, 정보의 전달이 주 목적일 때 정적 웹사이트로 구현됩니다.
    
  


3️⃣ 동적 웹사이트.

  동적 웹사이트는 서버 측 프로그래밍 언어를 사용하여 사용자의 요청에 따라 실시간으로 웹페이지를 생성하고 제공합니다.
  데이터베이스와의 상호작용을 통해 컨텐츠를 동적으로 생성하고 사용자의 요청에 맞춰 개별적으로 내용을 조정할 수 있습니다.


👍 동적 웹사이트의 장점.

  유연성.
    
      사용자의 입력이나 상호작용에 따라 내용을 쉽게 변경할 수 있습니다.
    
  
  기능성.
    
      데이터베이스에 정보를 저장하고 검색하는 등의 복잡한 기능을 구현할 수 있습니다.
    
  
  개인화.
    
      사용자의 선호나 행동에 따라 개인화된 경험을 제공할 수 있습니다.
    
  


👎 동적 웹사이트의 단점.

  비용과 복잡성.
    
      서버 측 처리를 위한 추가적인 자원이 필요하며, 구현과 유지 관리가 복잡해질 수 있습니다.
    
  
  보안 위험.
    
      데이터베이스와 서버 측 스크립트를 사용함으로써 보안 취약점이 발생할 수 있습니다.
    
  
  속도.
    
      페이지를 실시간으로 생성하므로 처리 시간이 길어질 수 있습니다.
    
  


4️⃣ 동적 웹사이트의 예시.

  1. 전자 상거래 플랫폼.
    
      Amazon, eBay 등의 쇼핑 웹사이트는 사용자의 검색, 구매 이력, 상품의 재고 상태 등에 따라 실시간으로 정보를 업데이트하고 표시해야 합니다.
        
          이런 기능은 동적 웹사이트 기술을 필요로 합니다.
        
      
    
  
  2. 소셜 네트워킹 서비스.
    
      Facebook, Twitter와 같은 소셜 미디어 플랫폼은 사용자의 상호 작용에 기반하여 내용이 계속 업데이트 되며, 이러한 동적 상호 작용을 지원합니다.
    
  
  3. 온라인 교육 플랫폼.
    
      Coursera, Udemy, Inflearn와 같은 교육 플랫폼은 사용자가 선택한 강좌에 따라 개인화된 학습 내용을 제공하고, 퀴즈 점수를 기록하며, 진행 상태를 추적합니다.
    
  


🙋‍♂️ 마무리

  정적 웹사이트와 동적 웹사이트 선택은 프로젝트의 요구 사항, 예산, 기대하는 사용자 경험 등에 따라 달라집니다.
    
      간단한 정보 제공 사이트의 경우 정적 웹사이트가 적합할 수 있고, 사용자 상호작용과 데이터 처리가 중요하 서비스는 동적 웹사이트가 더 적합할 수 있습니다.
    
  
  이러한 예시들을 통해 정적 웹사이트가 주로 고정된 내용을 제공하는 반면, 동적 웹사이트는 사용자의 입력과 상호작용에 따라 콘텐츠가 변경되는 복잡한 기능을 필요로 함을 알 수 있습니다.
    
      각각의 사례에서 요구하는 기능과 특성에 맞춰 웹사이트의 형태를 결정합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240807_AWS_ON-PREMISE.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240807_AWS_ON-PREMISE.html"><h1 class="title_post">☁️[AWS] 온프레미스(on-premise)란?</h1></a>
                        <a href="/Backend/AWS/240807_AWS_ON-PREMISE.html" class="txt_post">
                            ☁️[AWS] 온프레미스(on-premise)란?


  온프레미스(on-premise)란 사용자가 관리하는 시설 내에 서버 등의 기기를 설치해 운용하는 환경입니다.
  AWS와 같은 클라우드 서비스가 등장하기 전까지는 정보 시스템을 구축하기 위해 다음 그림과 같이 자체적으로 관련 기기를 준비하고 설정해야 했습니다.
  이런 기기를 설치하고 운용하는 시설을 일반적으로 데이터 센터(Data Center) 라고 합니다.





  구매, 물리적 설치, 케이블 배선, 네트워크의 설정이 필요하지만 이러한 작업은 전문 업체에 위탁할 수 있습니다.
    
      결과적으로 기기 구매비, 작업에 필요한 인건비 같은 초기 투자 비용이 커지고 설치나 설정에도 시간이 걸리므로 정보 시스템을 구축하기 위한 준비 기간이 길어집니다.
        
          그 대신 기기는 사용자가 자유롭게 이용할 수 있고 이용 형태에 맞게 자유롭게 구성할 수 있습니다.
          초기 투자 비용은 많이 들지만, 이후에 들어가는 비용은 전기 요금과 인터넷 회선 이용 요금 정도이므로 전체 비용에서 운용 비용의 비율이 비교적 낮습니다.
            
              그러나 기기 고장 등 예측하지 못한 상황이 발생해 추가 비용이 발생하는 때도 있습니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240807_AWS_CLOUD.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240807_AWS_CLOUD.html"><h1 class="title_post">☁️[AWS] 클라우드(Cloud)란?</h1></a>
                        <a href="/Backend/AWS/240807_AWS_CLOUD.html" class="txt_post">
                            ☁️[AWS] 클라우드(Cloud)란?


  클라우드(Cloud) 는 클라우드 서비스 제공자가 서버 등의 기기를 준비하고 거기에 구축된 가상 서버나 응용 프로그램 등을 사용자에게 제공하여 이용료를 받는 형태입니다.
  물리적인 기기나 네트워크는 서비스 제공자가 준비해 놨으므로 사용자는 바로 정보 시스템을 구축할 수 있습니다.
  클라우드의 정식 명칭은 클라우드 컴퓨팅(cloud computing) 입니다.
  클라우드의 어원은 단어 뜻 그대로 구름입니다.
    
      보이지 않는 컴퓨팅 자원을 활용한다는 것에서 유래했습니다.
        
          이 말을 풀어 써보면 ‘사용자에게는 보이지 않지만 중앙의 서버 컴퓨팅 자원을 활용해 서비스를 받을 수 있게 하는 플랫폼’ 입니다.
        
      
    
  





  서비스 제공자는 서버나 응용 프로그램을 제공할 뿐만 아니라 내부의 모든 하드웨어를 관리하므로 사용자는 하드웨어 장애에 대해 신경 쓰지 않아도 됩니다.
    
      하지만 사용자는 제공되는 서비스 범위 내에서만 시스템을 이용할 수 있으므로 시스템 구성 자유도는 낮습니다.
      그리고 매원 각종 서비스 사용료를 지불해야 하므로 전체 비용이 커질 수 있습니다.
        
          하지만 기기 노후화나 고장 걱정 없이 안정적으로 컴퓨팅 자원을 사용할 수 있다는 장점이 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-08-05-RequiredArgsConstructor.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-08-05-RequiredArgsConstructor.html"><h1 class="title_post">☕️[Java] @RequiredArgsConstructor의 역할.</h1></a>
                        <a href="/Backend/Java/2024-08-05-RequiredArgsConstructor.html" class="txt_post">
                            ☕️[Java] @RequiredArgsConstructor 역할.


  RequiredArgsConstructor 어노테이션은 Lombok 라이브러리에서 제공하는 기능 중 하나로, 클래스에 필수적인 생성자를 자동으로 생성하는 역할을 합니다.
  이 어노테이션을 클래스에 적용하면, Lombok 이 그 클래스의 final 필드 또는 @NonNull 어노테이션이 붙은 필드를 인자로 받는 생성자를 자동으로 생성합니다.


1️⃣ @RequiredArgsConstructor의 주요 기능.

  1. 자동 생성자 생성
    
      클래스 내의 모든 final 필드와 @NonNull 어노테이션이 붙은 필드에 대한 생성자를 자동으로 생성합니다.
      이 생성자는 이 필드들을 초기화하는 데 필요한 파라미터를 요구합니다.
    
  
  2. 코드 간결화
    
      수동으로 생성자를 작성하는 번거로움을 줄여줍니다.
      특히 많은 필드를 가진 클래스에서 유용하게 사용될 수 있습니다.
    
  
  3. 불변성 강화
    
      final 필드를 사용함으로써 클래스의 불변성을 강화할 수 있습니다.
      생성자를 통해 한 번 설정되면, 이 필드들의 값은 변경될 수 없습니다.
    
  
  4. 의존성 주입 용이
    
      Spring과 같은 프레임워크에서 생성자를 통한 의존성 주입을 사용할 때 유용합니다.
      필요한 의존성을 생성자를 통해 주입받기 때문에, 컴포넌트 간의 결합도를 낮출 수 있습니다.
    
  


2️⃣ 사용 예시.


  다음은 @RequiredArgsConstructor 어노테이션을 사용한 간단한 클래스 예제입니다.


import lombok.RequiredArgsConstructor;
import lombok.NonNull;

@RequiredArgsConstructor
public class UserData {
    private final String username; // final 필드에 대한 생성자 파라미터 자동 포함.
    @NonNull private String email; // @NonNull 필드에 대한 생성자 파라미터 자동 포함.
    
    // 추가 메소드 등
}



  위 코드에서 UserData 클래스에는 username 과 email 두 필드가 있으며, username 은 final 로 선언되어 수정할 수 없고, email 은 @NonNull 어노테이션이 붙어 null 값을 허용하지 않습니다.
  Lombok은 이 두 필드를 초기화하는 생성자를 자동으로 생성합니다.


3️⃣ 주의 사항.

  @RequiredArgsConstructor 는 필드가 많고, 특히 final 또는 @NonNull 필드가 있는 경우 유용합니다.
    
      그러나 생성자를 통한 초기화가 필요하지 않은 필드에는 적용되지 않습니다.
    
  
  Lombok을 사용하면 코드가 간결해지고 가독성이 향상되지만, 코드의 명시성이 다소 떨어질 수 있습니다.
    
      따라서 Lombok 사용 시, 팀 내에서 Lombok에 대한 이해도가 충분한지 확인하는 것이 좋습니다.
    
  





  Lombok 의 @RequiredArgsConstructor 는 반복적인 코드 작성을 줄여주고, 오류 가능성을 감소시키며, 더 깔끔하고 관리하기 쉬운 코드베이스를 유지하는 데 도움을 줄 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240804_AWS_JAVA8_INSTALL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240804_AWS_JAVA8_INSTALL.html"><h1 class="title_post">☁️[AWS] Amazon Linux 2에 Java8 설치하는 방법.</h1></a>
                        <a href="/Backend/AWS/240804_AWS_JAVA8_INSTALL.html" class="txt_post">
                            1️⃣ EC2 인스턴스에 로그인.

  SSH를 통해 EC2 인스턴스에 로그인 합니다.
    ssh -i "your-key.pem" ec2-user@your-instance-ip
// 또는
ssh "config에 등록한 서비스명" 
    
  


2️⃣ 업데이트 및 패키지 매니저 설치 확인.

  인스턴스의 패키지 리스트를 업데이트하고 , yum 패키지 매니저가 최신 상태인지 확인합니다.
    sudo yum update -y
    
  


3️⃣ OpenJDK 8 설치.

  OpenJDK 8은 Amazon Linux 2의 기본 레포지토리에서 사용할 수 있습니다.
    
      다음 명령어를 사용하여 설치할 수 있습니다.
        sudo yum install -y java-1.8.0-openjdk
        
      
    
  


4️⃣ 설치된 Java 버전 확인.

  설치가 성공적으로 완료되었는지 확인하기 위해 Java 버전을 확인합니다.
    java -version
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-08-02-Transactional.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-08-02-Transactional.html"><h1 class="title_post">☕️[Java] @Transactional의 역할과 의미.</h1></a>
                        <a href="/Backend/Java/2024-08-02-Transactional.html" class="txt_post">
                            ☕️[Java] @Transactional의 역할과 의미.


  @Transaction 어노테이션은 스프링 프레임워크에서 제공하는 선언적 트랜젝션 관리 기능을 활용하기 위해 사용됩니다.
  이 어노테이션을 사용함으로써, 특정 메서드 또는 클래스 전체에 걸쳐 데이터베이스 트랜잭션의 경계를 설정할 수 있습니다.
  트랜잭션은 일련의 연산들이 전부 성공적으로 완료되거나, 하나라도 실패할 경우 전체를 취소(롤백)하여 데이터의 일관성과 정합성을 보장하는 것을 목적으로 합니다.


1️⃣ @Transactional의 주요 기능과 특징.


  1. 자동 롤백
    
      @Transactional 이 적용된 메서드에서 런타임 예외(RuntimeException)가 발생하면, 그 트랜잭션에서 수행된 모든 변경이 자동으로 롤백됩니다.
      이는 데이터의 일관성을 유지하는 데 필수적입니다.
    
  
  2. 프로파게이션(Propagation)
    
      트랜잭션의 전파 행위를 제어합니다.
        
          예를 들어, 이미 진행 중인 트랜잭션이 있을 때 새로운 트랜잭션을 시작할 것인지, 아니면 기존 트랜잭션을 참여할 것인지 결정할 수 있습니다.
            
              REQUIRED(기본값) : 이미 진행 중인 트랜잭션이 있다면 그 트랜잭션이 참여하고, 없다면 새로운 트랜잭션을 시작합니다.
              REQUIRED_NEW : 항상 새로운 트랜잭션을 시작합니다. 이미 진행 중인 트랜잭션이 있다면 잠시 보류합니다.
            
          
        
      
    
  
  3. 격리 수준(Isolation Level)
    
      다른 트랜잭션이 데이터에 동시에 접근했을 때 발생할 수 있는 문제를 제어합니다.
        
          예를 들어, READ_COMMITTEED, REPEATED_READ, SERIALIZABLE 등 다양한 격리 수준을 지정할 수 있습니다.
        
      
    
  
  4. 읽기 전용(Read-Only)
    
      트랜잭션을 읽기 전용으로 설정할 수 있어, 데이터 수정이 이루어지지 않는다는 것을 데이터베이스 최적화 엔진에 알려 성능을 향상시킬 수 있습니다.
    
  
  5. 롤백 규칙(Rollback Rules)
    
      특정 예외가 발생했을 때 롤백을 수행할지 아니면 커밋을 수행할지를 세밀하게 제어할 수 있습니다.
      기본적으로 런타임 예외에서는 롤백을 수행하고, 체크 예외에서는 커밋을 수행합니다.
    
  


2️⃣ 사용 예제.
import org.springframework.transaction.annotation.Transactional;
import org.springframework.stereotype.Service;

@Service
public class TransactionalService {
    
    @Transactional(readOnly = true)
    public User getUser(Long id) {
        return userRepository.findById(id);
    }
    
    @Transactional(rollbackFor = Exception.class)
    public User updateUser(User user) {
        return userRepository.save(user);
    }
}


  위 예시처럼, getUser 메서드는 데이터를 변경하지 않고 조회만 수행하기 때문에 readOnly = true 로 설정했습니다.
  반면, updateUser 메서드는 데이터를 변경할 가능성이 있으므로, 모든 예외(Exception)가 발생할 경우 롤백하도록 설정했습니다.




@Transactional 을 사용함으로써 개발자는 복잡한 트랜잭션 관리 코드를 직접 작성하지 않고도, 스프링 프레임워크가 제공하는 선언적 방식을 통해 간단하게 트랜잭션을 관리할 수 있게 됩니다.
이는 애플리케이션의 데이터 처리 로직을 더욱 안정적이고 효율적으로 만듭니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-08-01-SerializationAndDeserialization.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-08-01-SerializationAndDeserialization.html"><h1 class="title_post">☕️[Java] ObjectMapper 클래스, 직렬화와 역직렬화</h1></a>
                        <a href="/Backend/Java/2024-08-01-SerializationAndDeserialization.html" class="txt_post">
                            ☕️[Java] ObjectMapper 클래스, 직렬화와 역직렬화.


  ObjectMapper 는 주로 JSON 데이터를 처리하기 위해 사용되는 Jackson 라이브러리의 핵심 클래스입니다.
  이 클래스는 자바 객체와 JSON 형식 간의 직렬화(Serialization)와 역직렬화(Deserialization)를 수행합니다.
  ObjectMapper 는 JSON 데이터를 자바 객체로 변환하거나 자바 객체를 JSON 데이터로 변환하는 등의 작업을 매우 효율적으로 처리할 수 있게 해줍니다.


1️⃣ 직렬화(Serialization)


  ObjectMapper 를 사용하여 자바 객체를 JSON 문자열로 직렬화하는 과정은 다음과 같습니다.


import com.fasterxml.jackson.databind.ObjectMapper;

// 예시 자바 객체
pulbic class User {
    public String name;
    public int age;
}

// 직렬화 예제
ObjectMapper mapper = new ObjectMapper();
User user = new User();
user.name = "Kobe";
user.age = "30";

String json = mapper.writeValueAsString(user); // 자바 객체를 JSON 문자열로 변환

System.out.println(json);


2️⃣ 역직렬화(Deserialization)


  ObjectMapper 를 사용하여 JSON 문자열을 자바 객체로 역직렬화하는 과정은 다음과 같습니다.


import com.fasterxml.jackson.databind.ObjectMapper;

// 예시 자바 객체
public class User {
    public String name;
    public int age;
}

// 역직렬화 예제
ObjectMapper mapper = new ObjectMapper();
String json = "{\"name\":\"Kobe\", \"age\":30}";

User user = mapper.readValue(json, User.class); // JSON 문자열을 자바 객체로 변환

Systeom.out.println(user.name + " is" + user.age + " year old.");


3️⃣ 주요 기능


  
    다양한 데이터 포맷 지원 :  ObjectMapper 는 JSON 외에도 XML, CSV 등 여러 데이터 포맷을 지원합니다.(Jackson 데이터 포맷 모듈 설치 필요).
  
  유연성과 설정 : ObjectMapper 는 맞춤 설정이 가능하여, 다양한 JSON 직렬화/역직렬화 방법을 지원합니다.
    
      예를 들어, 필드 이름의 자동 감지, 날짜 형식 지정, 무시할 필드 설정 등을 조정할 수 있습니다.
    
  
  성능 : Jackson은 JSON 처리를 위해 최적화된 라이브러리 중 하나로, 대용량 데이터 처리에도 뛰어난 성능을 보입니다.




🤔 직렬화와 역직렬화란?


  직렬화(Serialization)와 역직렬화(Deserialization)는 데이터 구조 또는 객체 상태를 저장하고 전송하기 위해 다루기 쉬운 데이터 포맷으로 변환하는 과정을 의미합니다.
    
      컴퓨터 과학의 맥락에서 이 개념은 특히 중요하며, 객체 지향 프로그래밍에서 널리 사용됩니다.
    
  


1️⃣ 직렬화(Serialization)

  직렬화는 객체의 상태(즉, 객체가 가진 데이터와 그 구조)를 일련의 바이트로 변환하는 과정입니다.
    
      이 바이트 스트림은 나중에 파일, 데이터베이스 또는 네트워크를 통해 쉽게 저장하거나 전송할 수 있습니다.
        
          예를 들어, 자바에서는 Serialization 인터페이스를 구현한 객체를 바이트 스트림으로 변환하여 파일 시스템에 저장하거나 네트워크를 통해 다른 시스템으로 보낼 수 있습니다.
        
      
    
  


2️⃣ 직렬화의 주요 목적.

  
    
      영속성 : 객체의 상태를 영구적으로 저장하여 나중에 다시 로드할 수 있습니다.
    
  
  
    
      네트워크 전송 : 객체를 네트워크를 통해 다른 시스템으로 전송하기 위해 사용됩니다.
    
  
  
    
      데이터 교환 : 다양한 언어나 플랫폼 간의 데이터 교환이 가능하도록 합니다.
    
  


3️⃣ 역직렬화(Deserialization)

  역직렬화는 직렬화된 바이트 스트림을 다시 원래의 객체 상태로 복원하는 과정입니다.
    
      즉, 파일, 데이터베이스 또는 네트워크로부터 바이트 스트림을 읽어 들여서 실행 중인 프로그램에서 사용할 수 있는 실제 객체로 변환합니다.
      이 과정은 직렬화의 반대 과정으로, 복원된 객체는 원복 객체와 동일한 상태를 가집니다.
    
  


4️⃣ 역직렬화의 주요 사용 사례.

  
    
      객체 복원 : 저장되거나 전송된 데이터로부터 객체를 재구성합니다.
    
  
  
    
      상태 복구 : 애플리케이션의 이전 상태를 복구하는 데 사용됩니다.
    
  
  
    
      데이터 접근 : 다른 시스템에서 전송된 데이터를 로컬 시스템에서 접근하고 사용할 수 있게 합니다.
    
  


5️⃣ 데이터 포맷과 직렬화 도구

  다양한 데이터 포맷(JSON, XML, YAML 등)과 여러 프로그래밍 언어 또는 라이브러리에서 직렬화와 역직렬화를 지원합니다.
  자바에서는 ObjectMapper 를 사용해 JSON 데이터 포맷으로의 직렬화와 역직렬화를 처리하며, 이는 데이터를 쉽게 읽고 쓸 수 있는 구조로 만드는 데 유용합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/DB/2024-08-01-Transaction.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/DB/2024-08-01-Transaction.html"><h1 class="title_post">💾[Database] 트랜잭션의 의미와 역할.</h1></a>
                        <a href="/Backend/DB/2024-08-01-Transaction.html" class="txt_post">
                            💾[Database] 트랜잭션의 의미와 역할.

  트랜잭션은 데이터베이스 관리 시스템(DBMS)에서 데이터의 일관성과 정확성을 유지하기 위해 사용되는 기본 단위입니다.
  데이터베이스에서 수행하는 작업들을 안전하게 실행하여, 여러 작업이 모두 성공하거나 모두 실패하도록 보장하는 역할을 합니다.


1️⃣ 트랜잭션의 주요 특징(ACID).


  1. 원자성(Atomicity)
    
      트랜잭션 내의 모든 연산은 원자적으로 처리됩니다. 즉, 연산들은 모두 완벽하게 수행되거나 아예 수행되지 않아야 합니다.
      트랜잭션 중 하나라도 실패하면 전체 트랜잭션은 롤백(취소)되어 원래 상태로 복구됩니다.
    
  
  2. 일관성(Consistency)
    
      트랜잭션이 실행되지 전과 후에 데이터베이스의 상태는 일관된 상태를 유지해야 합니다.
      트랜잭션은 데이터베이스의 일관된 상태를 받아 변경 후에도 그 일관성을 유지하는 변경만을 수행해야 합니다.
        
          이는 데이터의 무결성 제약 조건들을 준수함을 의미합니다.
        
      
    
  
  3. 독립성(Isolation)
    
      동시에 여러 트랜잭션이 실행될 때, 각 트랜잭션이 다른 트랜잭션의 연산에 영향을 받지 않아야 합니다. 이를 통해 데이터베이스의 안정성을 보장합니다.
      DBMS는 이러한 독립성을 보장하기 위해 다양한 격리 수준(Isolation Level)을 제공합니다.
    
  
  4. 지속성(Durability)
    
      트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 데이터베이스에 반영도어야 합니다.
      시스템 장애가 발생해도 이러한 트랜잭션 결과는 손실되지 않습니다.
    
  


2️⃣ 트랜잭션의 역할.


  데이터 무결성 유지
    
      트랜잭션은 데이터의 정확성과 일관성을 유지하며 데이터베이스 시스템의 신뢰성을 보장합니다.
    
  
  시스템 장애 대응
    
      시스템 오류나 장애 발생 시, 트랜잭션은 롤백을 통해 데이터베이스를 안정적인 상태로 복구할 수 있게 돕습니다.
    
  
  동시성 제어
    
      다수의 사용자가 데이터베이스에 동시에 접근할 때, 트랜잭션은 각각의 사용자가 데이터를 안전하게 읽고, 쓸 수 있도록 관리합니다.
    
  




트랜잭션은 데이터베이스 시스템에서 꼭 필요한 기능으로, 데이터의 일관성과 안정성을 보장하는 중요한 메커니즘 입니다. 이를 통해 사용자는 데이터베이스의 신뢰성 있는 동작을 기대할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-31-attribute.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-31-attribute.html"><h1 class="title_post">☕️[Java] attribute의 의미와 역할</h1></a>
                        <a href="/Backend/Java/2024-07-31-attribute.html" class="txt_post">
                            ☕️[Java] attribute의 의미와 역할.


  Java 백엔드 개발에서 “attribute”라는 용어는 몇 가지 다른 맥락에서 사용될 수 있습니다.
  주로 두 가지 의미로 사용되는 경우가 많은데, 클래스의 속성 을 의미하는 경우와 웹 개발에서 HTTP 요청이나 세션과 관련된 데이터를 지칭하는 경우입니다.


1️⃣ 클래스의 속성(Field or Property)

  Java에서 클래스의 “attribute” 는 해당 클래스의 상태를 정의하는 변수를 말합니다.
    
      이러한 변수들은 객체의 데이터이터를 저장하고, 클래스의 인스턴스들이 갖는 특징과 상태 정보를 나타냅니다.
        
          예를 들어, ‘Person’ 클래스가 있다면, ‘name’, ‘age’ 같은 필드들이 이 클래스의 “attribute” 가 됩니다.
        
      
    
  


public class Person {
    private String name; // Attribute
    private int age; // Attribute
    
    // Constructors, getters, setters 등
}


2️⃣ 웹 개발에서의 Attribute

  웹 개발에서 “attribute” 는 주로 세션(Session)이나 요청(Request) 객체에 저장된 데이터를 지칭 합니다.
    
      이 데이터는 사용자가 웹 사이트를 이용하는 동안 지속되거나 요청 동안에만 존재할 수 있습니다.
        
          예를 들어, 사용자가 로그인을 하면 그 사용자의 정보를 세션 attribute로 저장하여 다른 페이지에서도 사용자 정보를 유지할 수 있게 합니다.
        
      
    
  


// 세션에 사용자 정보 저장
request.getSession().setAttribute("user", userObject);

// 세션에서 사용자 정보 가져오기
User user = (User) request.getSession().getAttribute("user");



  이 두 가지 사용 사례는 Java 백엔드 개발에서 매우 흔하게 접할 수 있으며, 각각의 맥락에서 attribute가 가지는 의미와 역할을 이해하는 것은 중요합니다.
    
      첫 번째 경우는 객체 지향 프로그래밍의 핵심 요소로 클래스의 속성을 정의합니다.
      두 번째 경우에는 웹 애플리케이션의 상태 관리를 돕는 수단으로서 활용됩니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-31-MainBuildFail.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-31-MainBuildFail.html"><h1 class="title_post">☕️[Java] Main 클래스 생성 후 오류 대처.</h1></a>
                        <a href="/Backend/Java/2024-07-31-MainBuildFail.html" class="txt_post">
                            ☕️[Java] Main 클래스 생성 후 오류 대처.

1️⃣ 메인 클래스 생성.

  모든 프로젝트에는 메인 클래스가 있어야 합니다.
    
      직접 만든 클래스를 메인 클래스로 사용하기 위해 다음과 같이 코드를 입력했다고 가정해봅시다.
    
  


// PortfolioBolgApplication.java

package com.devkobe.portfolioBlog;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PortfolioBolgApplication {
    public static void main(String[] args) {
        SpringApplication.run(PortfolioBolgApplication.class, args);
    }
}



  코드 작성이 끝났다면 클래스 왼쪽에 실행 아이콘 ▶︎을 누르고, [RUN] 버튼을 눌러 클래스를 실행했을 경우 콘솔창에서 애플리케이션이 실행되면 성공입니다.


2️⃣ 실패했을 경우.

Process 'command...bin/java 'finshed with non-zero exit value 1'


  콘솔창에 위와 같은 오류 발생시에는 다음과 같이 순차적으로 해결하면 됩니다.
    
      
        
          Settings 로 들어갑니다.
        
      
      
        
          Build, Excecution, Deplyment 카테고리를 찾아 펼칩니다.
        
      
      
        
          하위에 Gradle을 클릭합니다.
        
      
      
        
          ‘Build and run using’ 이라는 색션을 찾습니다.
            
              이것의 선택값이 ‘Gradle(default)’ 일 것입니다.
            
            
              이 값을 ‘IntelliJ IDEA’ 로 바꿔 프로젝트를 다시 시작합니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-31-EntityListeners.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-31-EntityListeners.html"><h1 class="title_post">☕️[Java] @EntityListeners 어노테이션.</h1></a>
                        <a href="/Backend/Java/2024-07-31-EntityListeners.html" class="txt_post">
                            ☕️[Java] @EntityListeners 어노테이션.

1️⃣ 사용 방법.


  @EntityListeners 어노테이션은 엔티티 클래스 또는 매핑된 슈퍼클래스에서 사용할 수 있으며, 하나 이상의 리스너 클래스를 지정할 수 있습니다.
    
      이 리스너 클래스들은 앞서 언급한 이벤트를 처리할 메소드들을 포함하고 있어야 합니다.
    
  


import javax.persistence.EntityListeners;
import javax.persistence.PostPersist;

@EntityListeners(MyEntityListner.class)
public class MyEntity {
    // 엔티티 필드와 메서드
}

public class MyEntityListner {
    @PostPersist
    public void afterPersist(Object entity) {
        System.out.println("Entity has been persisted: " + entity);
    }
}


2️⃣ 사용 사례.

  엔티티 리스너는 로깅, 유효성 검사, 보안 검사, 비즈니스 로직 실행 등 다양한 목적으로 사용할 수 있습니다.
    
      
        예를 들어, 사용자 계정의 엔티티가 데이터베이스에 저장될 때 비밀번호 강도를 자동으로 검증하거나, 엔티티가 업데이트 될 때 특정 필드의 변경을 추적할 수 있습니다.
      
    
  


이처럼 @EntityListeners는 JPA 엔티티의 생명주기에 자동으로 반응하는 메소드를 구현함으로써, 엔티티와 관련된 비즈니스 로직을 분리하고 관리하는 데 큰 도움을 줍니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-07-28-ipAndport.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-07-28-ipAndport.html"><h1 class="title_post">📝[Post] 아이피와 포트</h1></a>
                        <a href="/Backend/Post/2024-07-28-ipAndport.html" class="txt_post">
                            🙋‍♂️ 아이피와 포트

1️⃣ 아이피(IP)

  인터넷에서 컴퓨터 또는 기기들이 서로를 식별하고 통신하기 위한 주소입니다.
    
      그래서 아이피를 알면 서버를 찾을 수 있습니다.
        
          하지만 서버를 이용하려면 아이피만 알아서는 안 됩니다. 포트까지 알아야 합니다.
        
      
    
  


2️⃣ 포트(Port)

  아이피가 서버를 찾기 위한 번호라면 포트는 그 서버에서 운용되고 있는 서비스를 구분하기 위한 번호입니다.
    
      쉽게 말해서 아이피가 백화점이라면 포트는 각자 다른 물건을 살 수 있는 매장이라고 생각하면 됩니다.
    
  


3️⃣ 예시

  예를 들어 우리가 흔히 사용하는 웹 브라우저에 주소에는 사실 아이피와 포트가 들어 있습니다.
    
      www.google.com과 같은 주소는 아이피트를 쉽게 알아보기 위해 이름표를 붙인 것입니다.
      그 앞에 있는 https:// 라는 것은 서버의 443번 포트를 사용하기 위한 입력입니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/DB/2024-07-26-korean-mysql.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/DB/2024-07-26-korean-mysql.html"><h1 class="title_post">💾[Database] MySQL DB에 한글 삽입.</h1></a>
                        <a href="/Backend/DB/2024-07-26-korean-mysql.html" class="txt_post">
                            💾[Database] MySQL DB에 한글 삽입.


  한글을 MySQL 데이터베이스에 삽입하려고 할 때 발생하는 오류는 주로 데이터베이스, 테이블 또는 열의 문자 세트와 관련 있습니다.
    
      이 문제를 해결하기 위해서는 데이터베이스와 테이블의 문자 세트를 UTF-8로 설정해야 합니다.
    
  


🙋‍♂️ 데이터베이스와 테이블의 문자 세트를 UTF-8로 설정하는 방법.

1️⃣ 데이터베이스 생성 시 문자 세트 설정.

CREATE DATABASE {데이터베이스 이름} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


2️⃣ 기존 데이터베이스의 문자 세트 변경.

ALTER DATABASE {데이터베이스 이름} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


3️⃣ 테이블 생성 시 문자 세트 설정.

CREATE TABLE test (
    id INT AUTO_INCREMENT PRIMARY KEY,
    content TEXT
) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


4️⃣ 기존 테이블의 문자 세트 변경.

ALTER TABLE test CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


5️⃣ 각 열의 문자 세트 확인 및 변경.

ALTER TABLE test MODIFY content TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


6️⃣ MySQL 서버의 기본 문자 세트를 변경.

  my.cnf(또는 my.ini) 파일을 수정하여 기본 문자 세트를 utf8mb4로 설정합니다.
    
      보통 이 파일은 /etc/my.cnf 또는 /etc/mysql/my.cnf 에 위치해 있습니다.
    
  
  my.cnf 파일에 다음 내용을 추가합니다.
```ini
[client]
default-character-set = utf8mb4


[mysql]
default-character-set = utf8mb4

[mysqld]
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci

### 7️⃣ MySQL 서버 재시작.
```shell
sudo systemctl restart mysqld



  이제 한글을 포함한 데이터를 데이터베이스에 삽입할 수 있을 것입니다.
    
      예를 들어, 한글 데이터를 삽입하려면:
        INSERT INTO test (content) VALUES ('테스트 데이터');
        
      
    
  
  이 방법으로 UTF-8 설정을 적용하면 한글 데이터를 MySQL 데이터베이스에 문제 없이 저장할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240726_AWS_JAVA_INSTALL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240726_AWS_JAVA_INSTALL.html"><h1 class="title_post">☁️[AWS] Amazon Linux 2023에 Java8 설치하는 방법.</h1></a>
                        <a href="/Backend/AWS/240726_AWS_JAVA_INSTALL.html" class="txt_post">
                            1️⃣ 시스템 패키지 업데이트

  먼저 시스템 패키지를 업데이트 합니다.


sudo dnf update -y


2️⃣ Amazon Corretto 8 저장소 추가.

  Amazon Corretto는 Amazon에서 제공하는 무료, 멀티플랫폼, 생산성 사용 준비가 된 OpenJDK 배포판입니다.
    
      Correttio 8은 Java 8과 호환됩니다.
    
  


sudo dnf install -y java-1.8.0-amazon-corretto


3️⃣ Java 8 설치 확인

  Java 8이 설치되었는지 확인하려면 다음 명령어를 사용합니다.


java -version



  이 명령어를 실행하면 Java 버전 정보가 출력됩니다. openjdk version "1.8.0_xxx" 와 같이 Java 8이 설치된 것을 확인할 수 있습니다.


4️⃣ 기본 Java 버전 설정


  시스템에 여러 버전의 Java가 설치되어 있을 수 있습니다.
    
      기본으로 사용할 Java 버전을 설정하려면 alternatives 명령어를 사용합니다.
    
  
  먼저 현재 사용 가능한 Java 버전을 확인합니다.


sudo alternatives --config java


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no2.html"><h1 class="title_post">📝[Post] 자바다식(Java多識) - 2</h1></a>
                        <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no2.html" class="txt_post">
                            자바다식(Java多識) 2편.

1. @AfterEach 어노테이션.


  @AfterEach 어노테이션은 JUnit 5에서 제공하는 기능입니다.
  각 테스트 메서드가 실행된 후에 수행되어야 하는 작업을 지정하는 데 사용됩니다.
  이 어노테이션은 테스트 클래스 내의 메서드에 적용하여 테스트 메서드가 끄탄 후 필요한 정리 작업(cleanup)을 수행할 수 있도록 합니다.


주요 역할

1. 자원 해제 : 테스트 메서드가 사용한 자원(예: 파일, 데이터베이스 연결, 네트워크 연결 등)을 해제하는 데 사용됩니다.

2. 상태 초기화 : 테스트가 완료된 후 상태를 초기화하여 다음 테스트가 깨끗한 환경에서 실행될 수 있도록 합니다.

3. 로그 기록 : 테스트 실행 결과를 로그에 기록하거나 추가적인 분석을 위해 데이터를 저장하는 데 사용할 수 있습니다.

예제 코드

아래는 @AfterEach 어노테이션을 사용한 간단한 예제입니다.

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class MyTest {
    
    @BeforeEach
    void setUp() {
        System.out.println("Setting up before each test");
    }
    
    @Test
    void testMethod1() {
        System.out.println("Executing test method 1");
    }
    
    @Test
    void testMethod2() {
        Systemo.out.println("Executing test method 2");
    }
    
    @AfterEach
    void tearDown() {
        System.out.println("Tearing down after each test")
    }
}


실행 순서


  
    setUp() : 각 테스트 메서드 실행 전 @BeforeEach 메서드가 호출됩니다.
  
  
    testMethod1() : 첫 번째 테스트 메서드가 실행됩니다.
  
  
    tearDown() : 첫 번째 테스트 메서드 실행 후 @AfterEach 메서드가 호출됩니다.
  
  
    setUp() : 두 번째 테스트 메서드 실행 전 @BeforeEach 메서드가 다시 호출됩니다.
  
  
    testMethod2() : 두 번째 테스트 메서드가 실행됩니다.
  
  
    tearDown() : 두 번째 테스트 메서드 실행 후 @AfterEach 메서드가 호출됩니다.
  


요약


  @AfterEach 어노테이션은 각 테스트 메서드 실행 후 호출되는 메서드를 지정합니다.
  주로 자원 해제, 상태 초기화, 로그 기록 등의 작업을 수행하는 데 사용됩니다.
  각 테스트 메서드마다 실행되므로, 테스트 간의 독립성을 유지하고 깨끗한 테스트 환경을 보장할 수 있습니다.




2. @Builder 어노테이션.


  @Builder 는 Lombok 라이브러리에서 제공하는 어노테이션으로, 빌더 패턴을 간편하게 사용할 수 있도록 지원합니다.
  빌더 패턴은 객체의 생성과 관련된 복잡성을 줄이고, 가독성을 높이며, 가변 객체를 만들지 않도록 도와줍니다.
    
      특히, 많은 필드를 가진 객체를 생성할 때 유용합니다.
    
  


주요 특징 및 역할.


  유연한 객체 생성
    
      빌더 패턴을 사용하면 객체를 생성할 때 생성자나 정적 팩토리 메서드보다 더 유연하게 객체를 구성할 수 있습니다.
      필요한 필드만 설정할 수 있고, 설정 순서에 구애받지 않습니다.
    
  
  가독성 향상
    
      많은 필드를 가진 객체를 생성할 때, 빌더 패턴을 사용하면 코드의 가독성이 높아집니다.
      각 필드의 이름을 명시적으로 설정할 수 있어 어떤 값이 어떤 필드에 설정되는지 쉽게 할 수 있습니다.
    
  
  불변 객체 생성
    
      빌더 패턴을 사용하면 불변 객체를 쉽게 생성할 수 있습니다.
      객체가 생성된 후에는 필드 값을 변경할 수 없습니다.
    
  


사용 예시

Lombok 없이 빌더 패턴 구현
public class User {
    private final String name;
    private final int age;
    private final String email;

    private User(UserBuilder builder) {
        this.name = builder.name;
        this.age = builder.age;
        this.email = builder.email;
    }

    public static class UserBuilder {
        private String name;
        private int age;
        private String email;

        public UserBuilder setName(String name) {
            this.name = name;
            return this;
        }

        public UserBuilder setAge(int age) {
            this.age = age;
            return this;
        }

        public UserBuilder setEmail(String email) {
            this.email = email;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}


Lombok을 사용한 빌더 패턴 구현

Lombok의 @Builder 어노테이션을 사용하면 위의 코드가 크게 단축됩니다.

import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
public class User {
    private String name;
    private int age;
    private String email;
}


객체 생성 예시

위의 Lombok을 사용한 User 클래스를 이용해 객체를 생성하는 예시입니다.

public class Main {
    public static void main(String[] args) {
        User user = User.builder()
                        .name("devKobe")
                        .age(77)
                        .email(devKobe@gamil.com)
                        .build();
        
        System.out.println(user.getName()); // devKobe
        System.out.println(user.getAge()); // 77
        System.out.println(user.getEmail()) // devKobe@gmail.com
    }
}


위 예시처럼 Lombok의 @Builder 를 사용하면 빌더 패턴을 간단하게 구현하고 사용할 수 있습니다.
이로 인해 객체 생성 코드가 더 깔끔하고 직관적으로 변합니다.



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no1.html"><h1 class="title_post">📝[Post] 자바다식(Java多識) - 1</h1></a>
                        <a href="/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no1.html" class="txt_post">
                            자바다식(Java多識) 1편.

1. ‘mainClassName’ 속성 추가.

메인 클래스의 경로를 지정해주는 속성을 추가하는 방법입니다.
초기 진입점을 지정해준다고 생각하면 됩니다.


  application 블록 안에 메인 클래스 이름을 지정합니다. 예를 들어, 메인 클래스가 com.example.Main 이라고 가정합니다.
  아래의 코드는 bundle.gradle 파일 내부에서 수정해야 합니다.


plugins {
    id 'java'
    id 'application'
}

application {
    mainClassName = 'com.example.Main' // 여기에 메인 클래스의 경로를 입력합니다.
    applicationDefaultJvmArgs = [
        "-XX:+EnableDynamicAgentLoading",
        "-Djdk.instrument.traceUsage"
    ]
}

repositories {
    mavenCentral()
}

dependencies {
    // Your dependencies here
}


메인 클래스 예시


  예를 들어, 메인 클래스는 다음과 같이 생겼을 수 있습니다.


package com.example;

public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}




2. @ExtendWith 어노테이션.


  @ExtendWith 어노테이션은 Junit 5에서 제공하는 기능으로, 테스트 클래스나 메서드에 확장 기능을 추가할 수 있도록 해줍니다.
  JUnit 5의 확장 모델은 다양한 확장 기능을 통해 테스트 실행의 특정 지점에서 사용자 정의 동작을 수행할 수 있게 합니다.


@ExtendWith 어노테이션의 역할


  확장 클래스 지정 : @ExtendWith 어노테이션은 확장 클래스를 지정할 수 있습니다. 지정된 확장 클래스는 테스트 라이프사이클의 특정 지점에서 호출됩니다.
    
      예를 들어, 테스트 실행 전후, 각 테스트 메서드 전후 등 다양한 시점에서 특정 동작을 추가할 수 있습니다.
    
  
  
    컨텍스트 설정 및 주입 : 확장 기능을 통해 테스트 컨텍스트를 설정하고, 테스트 메서드에 필요한 객체나 리소스를 주입할 수 있습니다. 이를 통해 테스트 코드를 더 간결하고 모듈화할 수 있습니다.
  
  조건부 실행 : 특정 조건에 따라 테스트 메서드를 실행하거나 건너뛸 수 있도록 지원합니다.
    
      예를 들어, 특정 환경 설정이나 시스템 상태에 따라 테스트 실행 여부를 결정할 수 있습니다.
    
  
  커스텀 어서션 및 보고 : 확장을 통해 사용자 정의 어서션 로직을 추가하거나 테스트 결과를 커스텀 방식으로 보고할 수 있습니다.


예제 코드

아래는 @ExtendWith 어노테이션을 사용한 간단한 예제입니다.

import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.extension.BeforeEachCallback;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.Test;

class MyExtension implements BeforeEachCallback {
    @Override
    public void beforeEach(ExtensionContext context) {
        System.out.println("Before each test method");
    }
}

@ExtendWith(MyExtension.class)
public class MyTest {
    
    @Test
    void testMethod1() {
        System.out.println("Test method 1");
    }
    
    @Test
    void testMethod2() {
        System.out.println("Test method 2");
    }
}



  위 코드에서 MyExtension 클래스는 BeforeEachCallback 인터페이스를 구현하여 각 테스트 메서드가 실행되기 전에 메시지를 출력합니다.
  @ExtendWith(MyExtension.class) 어노테이션을 통해 MyTest 클래스에 이 확장 기능을 추가했습니다.
    
      따라서 각 테스트 메서드 실행 전에 “Before each test method” 메시지가 출력됩니다.
    
  
  이처럼 @ExtendWith 어노테이션은 JUnit 5의 확장 모델을 활용하여 테스트에 필요한 다양한 기능을 추가할 수 있게 해줍니다.




3. 어서션(Assertion)


  어서션(Assertion)은 프로그래밍 및 소프트웨어 테스트에서 코드의 특정 상태나 조건이 참인지 확인하는 데 사용되는 문장이나 명령문을 의미합니다.
  어서션을 통해 코드의 논리적 일관성과 정확성을 검증할 수 있으며, 주로 디버깅과 테스트에 사용됩니다.


주요 기능과 목적.


  
    조건 검증 : 어서션(Assertion)은 특정 조건이 참인지 검증합니다. 조건이 거짓이면 프로그램은 즉시 실행을 중단하고 오류를 보고합니다.
  
  
    디버깅 도구 : 어서션(Assertion)은 개발 중에 코드의 오류를 조기에 발견하고 수정하는 데 도움이 됩니다. 코드의 가정이 잘못된 경우 어서션을 통해 문제를 빨리 찾을 수 있습니다.
  
  
    문서화 : 어서션(Assertion)은 코드의 논리적 전제 조건을 명시적으로 표현하여, 코드가 어떤 상태에 작동해야 하는지 명확하게 나타냅니다.
  


어서션(Assertion)의 예


  자바(Java)
    public void setAge(int age) {
 assert age &gt; 0 : "Age must be positive";
 this.age = age;
}
    
  
  JUnit (Java)
```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;


public class MyTest {

@Test
void testAddition() {
    int result = 2 + 3;
    assertEquals(5, result, "2 + 3 should equal 5");
} } ```


어서션 사용 시기

  개발 중 : 개발자가 코드의 논리적 일관성을 검증하기 위해 사용합니다. 디버깅 과정에서 주로 사용되며, 프로덕션 환경에서는 보통 비활성화합니다.
  테스트 코드 : 테스트 프레임워크(JUnit, TestNG 등)를 사용하여 테스트를 작성할 때, 특정 조건이 기대한 대로 동작하는지 확인합니다.


주의 사항

  프로덕션 코드에서의 사용 : 어서션은 주로 개발 및 테스트 환경에서 사용되며, 프로덕션 환경에서는 비활성화되는 경우가 많습니다. 프로덕션 환경에서 조건 검증이 필요한 경우에는 예외 처리를 사용합니다.
  부작용 없는 코드 : 어서션 내부에서는 부작용이 없는 코드를 사용하는 것이 좋습니다. 어서션은 상태를 변경하지 않고 조건만 검증해야 합니다.


요약.


  어서션은 코드의 특정 조건이 참임을 검증하는 도구로, 디버깅과 테스트 과정에서 코드의 논리적 일관성을 유지하는데 중요한 역할을 합니다.
    
      이를 통해 개발자는 코드의 가정과 실제 동작이 일치하는지 확인하고, 문제를 조기에 발견하여 수정할 수 있습니다.
    
  




                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-16-Variable.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-16-Variable.html"><h1 class="title_post">☕️[Java] 프로그래밍 언어와 자바</h1></a>
                        <a href="/Backend/Java/2024-07-16-Variable.html" class="txt_post">
                            변수 선언.


  컴퓨터 메모리(RAM)은 수많은 번지들로 구성된 데이터 저장 공간입니다.
  프로그램은 데이터를 메모리에 저장하고 읽는 작업을 비번히 수행합니다.
    
      이때 데이터를 어디에, 어떤 방식으로 저장할지 정해져 있지 않다면 메모리 관리가 무척 어려워집니다.
        
          이 문제를 해결하기 위해 변수(Variable)을 사용합니다.
        
      
    
  
  변수(Variable)는 하나의 값을 저장할 수 있는 메모리 번지에 붙여진 이름입니다.
  변수를 통해 프로그램은 메모리 번지에 값을 저장하고 읽을 수 있습니다.
  자바의 변수는 다양한 타입의 값을 저장할 수 없습니다.
    
      즉, 정수형 변수에는 정수값만 저장할 수 있고, 실수형 변수에는 실수값만 저장할 수 있습니다.
    
  
  변수를 사용하려면 변수 선언이 필요합니다.
    
      변수 선언은 어떤 타입의 데이터를 저장할 것인지 그리고 변수 이름이 무었인지 결정하는 것입니다.
        int age; // 정수(int) 값을 저장할 수 있는 age 변수 선언
double value; // 실수(double) 값을 저장할 수 있는 value 변수 선언
        
      
    
  
  변수 이름의 첫 번째 글자가 문자여야 하고, 중간부터는 문자, 숫자, $, _를 포함할 수 있습니다.
    
      또한, 첫 문자를 소문자로 시작하되 캐멀 케이스로 작성하는 것이 관례입니다.
    
  
  변수가 선언 되었다면 값을 저장할 수 있습니다.
    
      이때 대입 연산자인 =를 사용합니다.
      수학에서 등호(=)는 ‘같다’라는 의미이지만, 자바에서는 우측 값을 좌측 변수에 대입하는 연산자로 사용됩니다.
        int score; // 변수 선언
score = 60; // 값 대입
        
      
    
  
  변수 선언은 저장되는 값의 타입과 이름만 결정한 것이지, 아직 메모리에 할당된 것은 아닙니다.
    
      변수에 최초로 값이 대입될 때 메모리에 할당되고, 해당 메모리에 값이 저장됩니다.
    
  
  변수에 최초로 값을 대입하는 행위를 변수 초기화라고 하고, 이때의 값을 초기값이라고 합니다.
    
      초기 값은 다음과 같이 변수를 선언함과 동시에 대입할 수도 있습니다.
        int score = 90;
        
      
    
  
  초기화되지 않은 변수는 아직 메모리에 할당되지 않았기 때문에 변수를 통해 메모리 값을 읽을 수 없습니다.
    
      따라서 다음은 잘못된 코딩입니다.
        int value; // &lt;- 1.변수 value 선언
int result = value + 10; // &lt;- 2.변수 value 값을 읽고 10을 더해서 변수 result에 저장
        
      
    
  
  1 에서 변수 value가 선언되었지만, 초기화되지 않았기 때문엔 2 value + 10에서 value 변수값은 읽어올 수 없습니다.
    
      따라서 위 코드는 다음과 같이 변경해야 합니다.
        int value = 30; // 변수 value가 30으로 초기화됨
int result = value + 10; // 변수 value 값(30)을 읽고 10을 더해서 변수 result에 저장
        
      
    
  
  다음 예제는 초기화되지 않은 변수를 연산식에 사용할 경우 컴파일 에러(The local variable value may not have been initializer)가 발생하는 것을 보여줍니다.
    public class VariableInitializationExample {
  public static void main(String[] args) {
      // 변수 value 선언
      int value;
        
      // 연산 결과를 변수 result의 초기값으로 대입
      int result = value + 10; // &lt;------- 컴파일 오류
        
      // 변수 result 값을 읽고 콘솔에 출력
      System.out.println(result);
  }
}
    
  
  변수는 출력문이나 연산식에 사용되어 변수값을 활용합니다.
  
    다음 예제는 변수를 문자열과 결합 후 출력하거나 연산식에서 활용하는 모습을 보여줍니다.
```java
public class VariableUseExample {
  public static void main(String[] args) {
      int hour = 3;
      int minute = 5;
      System.out.println(hour + “시간” + minute + “분”);

      int totalMinute = (hour*60) + minute;
  System.out.println("총" + totalMinute + "분");   } }
    
  


// 실행 결과
// 3시간 5분
// 총 185분
- 변수는 또 다른 변수에 대입되어 메모리 간에 값을 복사할 수 있습니다.
    - 다음 코드는 변수 x 값을 변수 y 값으로 복사합니다.
```java
int x = 10; // 변수 x에 10을 대입
int y = x; // 변수 y에 변수 x값을 대입


  다음 예제는 두 변수의 값을 교환하는 방법을 보여줍니다.
    
      
        두 변수의 값을 교환하기 위해서 새로운 변수 temp를 선언한 것에 주목합시다.
```java
public class VariableExchangeExample {
  public static void main(String[] args) {
  int x = 3;
  int y = 5;
  System.out.println(“x:” + x + “, y:” + y);

        int temp = x;
  x = y;
  y = temp;
  System.out.println(“x:” + x + “, y:” + y);
  }
}
      
    
  


// 실행 결과
// x:3, y:5
// x:5, y:3
```

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html"><h1 class="title_post">💾[Database] 데이터베이스의 정의와 특징.</h1></a>
                        <a href="/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html" class="txt_post">
                            💾[Database] 데이터베이스의 정의와 특징.

1️⃣ 데이터베이스 : 여러 사용자나 응용 프로그램이 공유하고 동시에 접근 가능한 ‘데이터의 집합’ 이라고 정의할 수 있습니다.

2️⃣ DBMS(DataBase Management System) : ‘데이터베이스’를 ‘관리,운영하는 소프트웨어’ 입니다.


  🙋‍♂️ 데이터베이스
  
    ‘데이터 저장 공간’ 자체를 의미하기도 합니다.

    DBMS 중 하나인 MySQL에서는 ‘데이터베이스’를 ‘자료가 저장되는 디스크 공간(주로 파일로 구성됨)’으로 취급합니다.
  




위 그림은 데이터베이스, DBMS, 사용자, 응용 프로그램의 관계를 보여줍니다.

위 그림에서 보듯이 DBMS는 데이터베이스를 관리하는 역할을 하는 소프트웨어입니다.

여러 사용자나 응용 프로그램은 DBMS가 관리하는 데이터에 동시에 접속하여 데이터를 공유합니다.

👉 즉, DBMS에서는 데이터베이스에서 사용되는 데이터가 집중 관리됩니다.


  🙋‍♂️ 데이터베이스와 DBMS
  
    데이터베이스를 DBMS와 혼용해서 같은 용어처럼 사용하는 경우도 흔히 있습니다.
바라보는 시각에 따라 그렇게 사용하는 것이 틀린 것은 아니지만
저는 데이터베이스를 ‘데이터의 집합’ 또는 ‘데이터의 저장 공간’으로 보고,
DBMS는 데이터베이스를 운영하는 ‘소프트웨어’라는 의미로 공부하겠습니다.
  


DBMS에는 MySQL 외에도 많은 종류의 프로그램이 있습니다.

  MySQL
  MariaDB
  PostgreSQL
  Oracle
  SQL Server
  DB2
  Access
  SQLite
  …



  🙋‍♂️ 위 명시된 리스트는 2018년 기준 많이 사용되는 DBMS입니다.


3️⃣ DBMS 또는 데이터베이스의 몇 가지 중요한 특징.


  👉 데이터 무결성
    
      데이터베이스 안의 데이터는 어떤 경로를 통해 들어왔든 오류가 있어서는 안 되는데 이를 무결성(Integrity)이라고 합니다.
      무결성을 지키기 위해 데이터베이스는 제약 조건(constraint)을 따릅니다.
        
          예를 들어 학생 데이터에서 모든 학생은 학번이 반드시 있어야 하고 학번이 중복되면 안 된다는 제약 조건을 생각해봅시다.
          이 제약 조건을 충실히 지킨다면 학번으로도 학번으로도 학생 데이터에서 학생을 정확히 찾을 수 있습니다.
            
              즉, 학번은 무결한 데이터를 보장하는 요소이며, 자동 발급기로 성적 증명서나 재학 증명서를 뗄 떼 학번만 조회해도 정확한 자료를 줄력할 수 있습니다.
            
          
        
      
    
  
  👉 데이터의 독립성
    
      데이터베이스의 크기를 변경하거나 데이터 파일의 저장소를 변경하더라도 기존에 작성된 응용 프로그램은 전혀 영향을 받지 않습니다.
        
          즉 데이터베이스와 응용 프로그램은 서로 의존적인 관계가 아니라 독립적인 관계입니다.
            
              예를 들어 데이터베이스가 저장된 디스크가 새것으로 변경되어도 기존에 사용하던 응용 프로그램은 아무런 변경 없이 계속 사용할 수 있습니다.
            
          
        
      
    
  
  👉 보안
    
      데이터베이스 안에 데이터는 아무나 접근할 수 있는 것이 아니라 데이터를 소유한 사람이나 데이터에 접근이 허가된 사람만 접근할 수 있습니다.
      또한, 같은 데이터에 접근할 때도 사용자의 계정에 따라서 각각 다른 권한을 갖습니다.
      최근 들어 고객 정보 유출 사고가 빈번하여 보안(Security)은 데이터베이스에서 더욱 중요한 이슈가 되고 있습니다.
    
  
  👉 데이터 중복 최소화
    
      데이터베이스에서는 동일한 데이터가 여러 군데 중복 저장되는 것을 방지합니다.
        
          학교를 예로 들면, 학생 정보를 이용하는 교직원들(학생처, 교무처, 과사무실 등)이 각 직원마다 별도의 엑셀 파일로 학생 정보를 관리하면 한 명의 학생 정보가 각각의 엑셀 파일에 중복 저장됩니다.
          그러나 데이터베이스에 통합하여 관리하면 하나의 테이블에 데이터를 저장한 후 응용 프로그램마다 이를 공유하여 사용할 수 있어 데이터의 중복을 최소화할 수 있습니다.
        
      
    
  
  👉 응용 프로그램 제작 및 수정 용이
    
      기존 파일 시스템에서는 각각의 파일 포맷에 맞춰 응용 프로그램을 개발했습니다.
      그러나 데이터베이스를 이용하면 통일된 방식으로 응용 프로그램을 작성할 수 있고 유지,보수 또한 쉽습니다.
    
  
  👉 데이터의 안전성 향상
    
      대부분의 DBMS는 데이터의 백업/복원 기능을 제공합니다.
      따라서 데이터가 손상되는 문제가 발생하더라도 원래의 상태로 복원 또는 복구할 수 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240714_AWS_GRADLEW.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240714_AWS_GRADLEW.html"><h1 class="title_post">☁️[AWS] .gradlew 빌드 실패시 확인해야 할 것들</h1></a>
                        <a href="/Backend/AWS/240714_AWS_GRADLEW.html" class="txt_post">
                            1️⃣ Amazon Corretto JDK 8이 올바르게 설치되었는지 확인하기.

$ls -l /usr/lib/jvm/ava-1.8.0-amazon-corretto.x86_64


위 명령어를 통해 내부를 들여다보니 디렉토리 안에는 jre 디렉토리만 있고, JDK 디렉토리 구조가 포함되어 있지 않아서 JAVA_HOME 으로 설정할 수 없는 오류가 발생했었습니다.

이는 java-1.8.0-amazon-corretto-devel 패키지가 올바르게 설치되지 않았음을 의미할 수 있습니다.

🙋‍♂️ Amazon Corretto JDK 8 설치 및 확인.

먼저, Amazon Corretto JDK 8이 올바르게 설치되었는지 확인하고, 제대로 설치되지 않았다면 다시 설치합니다.


  기존 JDK 제거(필요시)
    sudo dnf remove -y java-1.8.0-amazon-corretto java-1.8.0-amazon-corretto-devel
    
  
  Amazon Corretto JDK 8 설치
    sudo dnf install -y java-1.8.0-amazon-corretto-devel
    
  
  설치된 디렉토리 확인.
    ls -l /usr/lib/jvm/
    
  
  JDK 디렉토리 구조 확인.
    
      JDK 디렉토리 구조가 포함되어 있는지 확인합니다.
        ls -l /usr/lib/jvm/java-1.8.0-amazon-corretto.x86_64/
        
      
    
  


🙋‍♂️ 올바른 JAVA_HOME 설정 및 빌드

  JAVA_HOME 및 PATH 설정
    export JAVA_HOME=/usr/lib/jvm/java-1.8.0-amazon-corretto.x86_64
export PATH=$JAVA_HOME/bin:$PATH
    
  
  설정확인
    echo $JAVA_HOME
java -version
javac -version
    
  
  Gradl 빌드 실행
    ./gradlew clean
./gradlew build
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-07-11-SpringAndSpringBoot.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-07-11-SpringAndSpringBoot.html"><h1 class="title_post">📝[Post] Spring과 SpringBoot의 개념.</h1></a>
                        <a href="/Backend/Post/2024-07-11-SpringAndSpringBoot.html" class="txt_post">
                            



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240710_AWS_MYSQL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240710_AWS_MYSQL.html"><h1 class="title_post">☁️[AWS] Amazon Linux 2023 플랫폼에 MySQL 설치하는 방법.</h1></a>
                        <a href="/Backend/AWS/240710_AWS_MYSQL.html" class="txt_post">
                            Amazon Linux 2023 플랫폼에 MySQL이 기본적으로 설정되어 있지 않습니다.

그러므로 따로 설치해줘야 합니다.

기본적인 방법은 아래와 같습니다.

1️⃣ RPM 파일 다운로드.
sudo wget https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm


위 명령어를 사용하여 RPM 파일을 다운로드 받아줍니다.


  🙋‍♂️ 모든 파일의 설정은 ec2 cli에서 설정해야 합니다.


2️⃣ GPC 퍼블릭 키 설정
sudo dnf install mysql80-community-release-el9-1.noarch.rpm -y


mysql 설치를 위해 퍼블릭 키를 import하는 과정입니다.

sudo dnf update -y


3️⃣ MySQL 설치.

이 부분은 mysql-client와 mysql-server로 나뉩니다.

먼저 mysql-client 설치부터 합니다.

1️⃣ mysql-client 설치.
sudo dnf install mysql-community-client -y


이후에 mysql-server를 설치합니다.

2️⃣ mysql-server 설치.
sudo dnf install mysql-community-server -y


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240709_AWS_HOSTNAME.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240709_AWS_HOSTNAME.html"><h1 class="title_post">☁️[AWS] HOSTNAME 바꾸는 방법</h1></a>
                        <a href="/Backend/AWS/240709_AWS_HOSTNAME.html" class="txt_post">
                            EC2 인스턴스의 호스트 이름을 바꾸는 방법.

🙋‍♂️ 모든 과정은 EC2에 접속 후에 이루어집니다.

1️⃣ 호스트 이름 설정.
hostnamectl 명령어를 사용하여 호스트 이름을 설정합니다.

sudo hostnamectl set-hostname {my-new-hostname}


2️⃣ /etc/sysconfig/network 파일 수정.
/etc/sysconfig/network 파일에 새로운 호스트 이름을 추가합니다.

sudo vi /etc/sysconfig/network


HOSTNAME 항목을 추가하거나 수정합니다.

NETWORKING=yes
HOSTNAME={my-new-hostname}


3️⃣ /etc/hosts 파일 수정.
/etc/hosts 파일을 열어 호스트 이름을 추가합니다.

sudo vi /etc/hosts


파일 내용은 다음과 같이 수정합니다.

127.0.0.1 localhost localhost.localdomain
::1       localhost localhost.localdomain
127.0.0.1 {my-new-hostname}


4️⃣ 즉시 호스트 이름 변경.
호스트 이름을 즉시 적용합니다.

sudo hostname {my-new-hostname}


5️⃣ 셸 프롬프트 구성.
셸 프롬프트에 새로운 호스트 이름이 표시되도록 .bashrc 파일을 수정합니다.

vi ~/.bashrc


다음 줄을 추가하거나 수정합니다.

PS1='[\u@\h \W]\$ '


변경 사항을 적용합니다.

source ~/.bashrc


6️⃣ 인스턴스 재부팅

위의 모든 단계를 수행한 후 인스턴스를 재부팅합니다.

sudo reboot


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-06-27-ServerAndClient-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-06-27-ServerAndClient-1.html"><h1 class="title_post">📝[Post] 서버와 클라이언트의 개념(1)</h1></a>
                        <a href="/Backend/Post/2024-06-27-ServerAndClient-1.html" class="txt_post">
                            🙋‍♂️ Preview

이번 포스트에서는 컴퓨터 과학에서 말하는 서버와 클라이언트의 개념을 크게 세 가지로 나눠 살펴보겠습니다.

  이것은 이해를 돕기 위한 분류로, 서버와 클라이언트라는 개념에 익숙해지고 난 후에 다시 보면 왜 이렇게 나누었는지 이해가 될 것 입니다.


1️⃣ 네트워크에서의 서버와 클라이언트.


  서버(Server) : “서비스를 제공하는 쪽”
  클라이언트(Client) : “서비스를 제공받는 쪽”





  그림에서 서버는 실제 존재하는 물리적인 고성능 컴퓨터이고, 클라이언트는 데스크톱이나 노트북, 스마트폰 등과 같은 사용자들의 단말기를 나타냅니다.
    
      즉, 물리적 장치와 또 다른 물리적 장치 사이의 관계를 의미합니다.
        
          이렇게 물리적인 장치 간에 서로 통신이 이루어지기 위해서는 “통신을 시작하는 쪽”이 “상대방의 네트워크 주소인 IP 주소를 알고 있어야 합니다.”
            
              “클라이언트가 서버의 IP주소를 알고있어야 서버와 클라이언트로서의 관계를 맺을 수 있습니다.”
            
          
        
      
    
  


1️⃣ 트래픽(Traffic) 처리 방법.

우리가 컴퓨터나 스마트폰으로 이용하는 서비스들은 수백만 명 이상의 사용자가 동시에 사용하고 있는 경우가 대부분입니다.
그렇다면 이러한 서비스를 운영하는 서버가 모두 고성능일까요? 🤔

당연히 그렇지 않습니다 ❌

한꺼번에 수백만 명 이상의 사용자로부터 생기는 “트래픽(Traffic)”을 처리하기 위한 방법은 여러가지가 있습니다.

여기서는 가장 범용적이고 직관적인 방법 두 가지, “로드 밸런싱” 과 “캐시”에 대해 간단히 설명하겠습니다.

1️⃣ 로드 밸런싱(Load Balancing).


  “로드 밸런싱(Load Balancing)” : 부하 분산.
    
      즉, 서버에 가해지는 부하(Load)를 분산하는 것입니다.
        
          사용자들의 트래픽을 여러 서버가 나눠 받도록 구성하며, 일반적으로 네트워크 장비인 “스위치(Switch)” 를 할당해 “로드 밸런싱”할 수 있습니다.
            
              스위치에서 어떤 서버로 로드 밸런싱이 되도록 할지는 소프트웨어적으로 제어할 수 있습니다.
            
          
        
      
    
  





  “로드 밸런싱” 은 “스위치” 라는 장비가 “클라이언트의 트래픽을 먼저 받아” 서 여러 대의 서버로 “분산” 해 주는 방식입니다.
    
      이렇게 하면 부하가 분산되는 효과 외에도 스위치 뒤에 연결된 서버들을 필요에 따라 추가하거나 삭제할 수 있어 편리합니다.
    
  


2️⃣ 캐시(Cache).


  “캐시(Cache)” : 비용이 큰 작업의 결과를 어딘가에 저장하여 비용이 작은 작업으로 동일한 효과를 내는 것.
    
      캐시를 이용하면 매번 요청이 들어올 때마다 비용이 큰 작업을 다시 수행할 필요 없이 미리 저장된 결과로 응답하면 됩니다.
        
          물론 이렇게 하면 가장 최신의 데이터는 아닐 수 있지만, 성능을 극대화시키고자 하는 캐시의 목적을 생각해 데이터의 실시간성을 조금 포기해도 되는 경우가 많습니다.
        
      
    
  



  ✏️ Example
  
    음원 서비스

    데이터베이스에 저장된 수많은 음원의 다운로드 수, 스트리밍 수, 추천 수 등으로 인기 점수를 계산하려 100갸의 곡을 오름차순 순위로 제공합니다.

    만약 사용자가 한 번 음원을 조회할 때마다 모든 음원의 인기 점수를 계산해 순위를 매긴다면 아마 사용자가 수백 명만 되어도 서버 부하로 응답 시간이 매우 느려질 것입니다.

    이렇게 수많은 음원의 인기 점수를 매번 계산하여 순위를 매기는 작업이 바로 ‘비용이 큰 작업’ 입니다.

    

    매시 정각마다 TOP 100을 계산한 결과를 저장했다가 사용자의 요청이 들어왔을 때 응답해주면 ‘비용이 작은 작업’으로 대체할 수 있습니다.

    사용자는 16시 30분에 16시에 저장된 TOP 100 결과로도 큰 불편함을 느끼지 않습니다.

    이렇게 사용자가 캐시된 과거의 데이터를 보더라도 서비스 시용에 지장이 없다면 캐시 사용을 충분히 고려할 만합니다.

    
  



  “캐시” 는 다양한 상황에서 비슷한 뜻으로 사용되지만, 공통적으로, ‘비용이 큰 작업을 비용이 작은 작업으로 대신하는 것’이라고 정리할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html"><h1 class="title_post">☕️[Java] 프로그래밍 언어와 자바</h1></a>
                        <a href="/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html" class="txt_post">
                            1️⃣ 프로그래밍 언어와 자바.


  기계어(Machine language)
    
      0과 1로 이루어진 이진 코드를 사용합니다.
      사람이 이해하기에는 어렵습니다.
    
  
  프로그래밍 언어(Programming language)
    
      고급 언어(High-level language)와 저급 언어(Low-level language)로 구분됩니다.
    
  
  고급 언어(High-level language)
    
      컴퓨터와 대화할 수 있도록 만든 언어 중에서 사람이 쉽게 이해할 수 있는 언어를 말합니다.
      고급 언어로 작성된 소스 파일(Source file)은 컴퓨터가 바로 이해할 수 없기 때문에 컴파일(Compile)이라는 과정을 통해서 컴퓨터가 이해할 수 있는 0과 1로 이루어진 기계어(Machine language)로 변환한 후 컴퓨터가 사용하게 됩니다.
    
  



  🤔 MORE : 소스 파일(Source file).
프로그래밍 언어에서 “소스 파일(Source file)” 이란 특정 프로그래밍 언어로 작성된 텍스트 파일을 의미합니다.
이 파일에는 개발자가 작성한 코드가 포함되어 있으며, 컴퓨터가 이를 이해하고 실행할 수 있도록 하기 위해서는 보통 컴파일러나 인터프리터가 필요합니다.



  저급 언어(Low-level language)
    
      기계어에 가까운 언어를 말하는데, 대표적으로 어셈블리어가 저급언어에 속합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/ENG/240621-ENG-STUDY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ENG.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/ENG/240621-ENG-STUDY.html"><h1 class="title_post">📚[ENG][240621] 제목만 해석하는 영어 공부 :)</h1></a>
                        <a href="/Backend/ENG/240621-ENG-STUDY.html" class="txt_post">
                            1️⃣ Why You Should Stop Using @Value Annotations In Spring (And Use This Instead)

  🙋‍♂️ 해석: “Spring에서 @Value 어노테이션(주석)을 사용을 중단하고 (대신 이를 사용해야 하는 이유)”
  📝Reference


2️⃣ Be part of a better internet

  🙋‍♂️ 해석: “더 나은 인터넷의 일원이 되세요.”
    
      Be part of : “일원이 되다” 또는 “참여하다” 라는 뜻을 가지고 있습니다. 어떤 단체나 활동, 또는 상황에 참여하거나 속하는 것을 의미합니다.
        
          예를 들어 “Be part of team”은 “팀의 일원이 되다”라는 뜻이 됩니다.
        
      
    
  
  📝Reference


3️⃣ Unpacking the “Day Job”

  🙋‍♂️ 해석: "’본업’을 해부하기”
    
      “Unpacking” : 문자 그대로는 “짐을 풀다”라는 뜻이지만, 비유적으로는 어떤 주제나 개념을 자세히 분석하거나 설명하는 것을 의미합니다.
        
          예를 들어, “Unpacking the ‘Day Job’“은 “본업에 대해 자세히 분석하기” 또는 “본업을 해부하기”라는 의미로 이해할 수 있습니다.
        
      
    
  
  📝Reference


4️⃣ 10 Cheap Desk Upgrades Every Programmer Needs #DeskSeries

  🙋‍♂️ 해석: “모든 프로그래머가 필요한 저렴한 책상 업그레이드 10가지”
  📝Reference


5️⃣ These Dividend Sell-Offs Could Mean Higher Starting Yields For You!

  🙋‍♂️ 해석: “이 배당금 매도는 더 높은 초기 수익률을 의미할 수 있습니다!”
    
      “Dividend” : 주식시장에서 “배당금” 을 의미합니다.
        
          이는 기업이 이익의 일부를 주주들에게 분배하는 금액입니다. 배당금은 주로 보통 현금으로 지급되지만, 주식 형태로 지급되기도 합니다. 배당금은 주로 정기적으로, 예를 들어 분기별이나 연간으로 지급됩니다.
        
      
      “Sell-Offs” : 금융 시장에서 “대규모 매도” 를 의미합니다.
        
          이는 투자자들이 대량으로 자산을 매도하여 시장에 공급이 급증하고, 그로 인해 가격이 하락하는 상황을 말합니다. 주식, 채권, 상품 등 다양한 자산에서 발생할 수 있습니다.
        
      
      “Yields” : 금융 및 투자 분야에서 “수익률” 을 의미합니다.
        
          이는 투자로부터 얻을 수 있는 수익의 비율을 나타내며, 보통 퍼센트로 표시됩니다. 수익률은 다양한 방식으로 계산될 수 있으며, 주식의 경우 배당금 수익률, 채권의 경우 이자 수익률 등이 이에 해당합니다. 일반적으로 수익률은 투자자에게 해당 자산이 얼마나 수익을 창출할 수 있는지를 보여주는 중요한 지표입니다.
        
      
    
  
  📝Reference


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-18-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-18-TIL.html"><h1 class="title_post">📝 [TIL] 240618 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-18-TIL.html" class="txt_post">
                            
  [AWS] 클라우드 컴퓨팅의 유형 정리
  [ENGLISH STUDY] 제목만 해석하는 영어 공부
  [배열 학습]


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/ENG/240618_ENG_STUDY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ENG.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/ENG/240618_ENG_STUDY.html"><h1 class="title_post">📚[ENG] 제목만 해석하는 영어 공부 :) </h1></a>
                        <a href="/Backend/ENG/240618_ENG_STUDY.html" class="txt_post">
                            1️⃣ Which IDE/Code Editor is best for Java Developer 2024

  🙋‍♂️ 해석: “2024년도 Java 개발자들에게 가장 적합한 IDE/코드 편집기는 무엇입니까?”
    
      best for : ~에 가장 적합
    
  
  📝Reference


2️⃣ A Third of My Online College Students are AI-Powered Spambots. Now what?

  🙋‍♂️ 해석: “온라인 대학 수강생의 3분의 1이 AI 스팸봇입니다. 이제 어떻게 해야 할까요?”
  📝Reference


3️⃣ Check your team for get-there-itis

  🙋‍♂️ 해석: “당신의 팀이 ‘목적지 집착증’에 걸렸는지 확인하세요.”
    
      “Get-there-itis” 는 주로 항공 및 해양 분야에서 사용되는 용어로, 목표에 너무 집중한 나머지 안전이나 절차를 무시하고 빨리 도착하려는 경향을 의미합니다.
        
          이 용어는 공식적인 의학 용어는 아니지만, 비공식적으로 목표 지향적인 강박증을 나타냅니다.
          따라서 “Check your team for get-there-itis” 라는 문구는 “당신의 팀이 ‘목적지 집착증’에 걸렸는지 확인하세요” 라는 번역이 개념적으로 맞다고 할 수 있습니다.
        
      
    
  
  💭 나의 생각 : 조금 더 자연스럽게 번역한다면 나라면 “당신의 팀이 너무 ‘목표에 집착’하고 있는지 확인해보세요.” 라고 번역할 것 같다.
  📝Reference


4️⃣ The unsexy problem problem

  🙋‍♂️ 해석: “매력적이지 않은 문제에 대한 문제”
  💭 나의 생각 : “problem” 이라는 단어가 두 번 나와서 어떻게 번역/해석을 해야 하는지 갈피를 못잡았다. 그래서 ChatGPT의 도움을 받았다.
    
      나의 친구(ChatGPT)가 말하길 “The unsexy problem problem” 이라는 문장에서 “problem” 이라는 단어가 두 번 나오기 때문에, 이 표현을 한국어로 번역시, 이를 고려하여 자연스럽게 전달해야 한다고 말해줬다.
      나의 친구는 의미를 좀 더 명확하게 전달하기 위해 “섹시하지 않은 문제라는 문제” 또는 “매력적이지 않은 문제에 대한 문제” 라는 두 번역 예시를 나에게 추천해줬다.
      그 이유를 설명하길 “이렇게 번역하면 원문에서 ‘problem’이 두 번 나오는 이유를 더 잘 반영하면서 의미를 명확하게 전달할 수 있습니다.” 라고 말해줬다. :)
    
  
  📝Reference


5️⃣ Why are my Java virtual threads slower than the platform threads?

  🙋‍♂️ 해석: “왜 나의 자바 가상 스레드는 플랫폼 스레드보다 느릴까?”
  📝Reference


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240615_Types_of_Clould_Computing.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240615_Types_of_Clould_Computing.html"><h1 class="title_post">☁️[AWS] 클라우드 컴퓨팅의 유형</h1></a>
                        <a href="/Backend/AWS/240615_Types_of_Clould_Computing.html" class="txt_post">
                            



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-17-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-17-TIL.html"><h1 class="title_post">📝 [TIL] 240617 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-17-TIL.html" class="txt_post">
                            
  수학, 필요.충분 조건


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-06-17-Math.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-06-17-Math.html"><h1 class="title_post">[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.</h1></a>
                        <a href="/Backend/Math/2024-06-17-Math.html" class="txt_post">
                            












                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-16-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-16-TIL.html"><h1 class="title_post">📝 [TIL] 240616 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-16-TIL.html" class="txt_post">
                            
  Studing English through Newsletters
  Metacognition JAVA의 정석 - 기본형 크기와 특징
  [수학] 명제와 증명 학습


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/ENG/240616-ENG-STUDY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ENG.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/ENG/240616-ENG-STUDY.html"><h1 class="title_post">📚[ENG] 240616 Studing English through Newsletters</h1></a>
                        <a href="/Backend/ENG/240616-ENG-STUDY.html" class="txt_post">
                            1️⃣ AI’s Going to Cost Us

  “AI로 인해 비용이 발생할 것”
  📝Reference


2️⃣ Has the AI Revolution Crashed?

  “AI 혁명은 무너졌는가?”
  📝Reference


3️⃣ Do NOT Make This Navigation Mistake in Jetpack Compose

  “Jetpack Compose에서 이러한 Navigation 실수를 저지르지 마세요”
  📝Reference


4️⃣ Obsidian Plugins Review

  “옵시디언 플러그인 리뷰”
  📝Reference


5️⃣ Software Architecture is Hard

  “소프트웨어 아키텍처는 어렵다.”
  📝Reference


6️⃣ Whenever I Forget Someone’s Name, I Always Use This Brilliant Hack

  “누군가의 이름을 잊어버릴 때마다 나는 항상 이 놀라운 꿀팁을 사용합니다.”
  📝Reference


7️⃣ Mastering WidgetState in Flutter 3.22

  “Flutter 3.22에서 WidgetState 마스터하기.”
  📝Reference


8️⃣ Visualize Like a Pro: Annotate Matplotlib Graphs for Stunning Data Stories

  “전문가처럼 시각화: 놀라운 데이터 스토리를 위해 Matplotilb 그래프에 주석 달기.”
  📝Reference


9️⃣ The Earning Potential of Software Programmers

  “소프트웨어 프로그래머의 수익 잠재력”
  📝Reference


1️⃣0️⃣ End Tech Debt Conversations Forever with 6 Easy Hacks to Team Culture

  “팀 문화에 대한 6가지 쉬운 해킹으로 기술 부채 대화를 영원히 끝내세요.”
  📝Reference


1️⃣1️⃣ With SimPO You Don’t Need a Reference Model to Align Your LLM

  “SimPO를 사용하면 LLM을 정렬하기 위해 참조 모델이 필요하지 않습니다.”
  📝Reference


1️⃣2️⃣ Even if you had perfect data, you should still be building defensive data pipelines

  “완벽한 데이터가 있더라도 여전히 방어적인 데이터 파이프라인을 구축해야 합니다.”
  📝Reference


1️⃣3️⃣ Designing our new REST API

  “새로운 REST API 설계”
  📝Reference


1️⃣4️⃣ Koin-Depondent Composable Previews in Android Jetpack Compose

  “Android Jetpack Compose의 Koin 종속 컴포저블 미리보기”
  📝Reference


1️⃣5️⃣ Let’s Build a RESTful API in Rust

  “Rust에서 RESTful API를 구축해 봅시다”
  📝Reference


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-13-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-13-TIL.html"><h1 class="title_post">📝 [TIL] 240613 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-13-TIL.html" class="txt_post">
                            
  원형 큐를 구현할 때 rear의 초기값을 -1로 설정하지 않는 이유.
  알고리즘
  피자 나눠 먹기(2)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-13-ReasonOfRearIsntSetToMinusOneInCircularQueue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-13-ReasonOfRearIsntSetToMinusOneInCircularQueue.html"><h1 class="title_post">📦[DS,Algorithm] Circular Queue(원형 큐)를 배열로 구현시 rear를 -1으로 설정하지 않는 이유.</h1></a>
                        <a href="/Backend/AnD/2024-06-13-ReasonOfRearIsntSetToMinusOneInCircularQueue.html" class="txt_post">
                            1️⃣ Circular Queue(원형 큐)를 배열로 구현시 rear를 -1으로 설정하지 않는 이유.

Java에서 원형 큐를 구현할 때 ‘rear’ 의 초기값을 ‘-1’ 로 설정하지 않는 이유는 여러 가지가 있습니다.

주요 이유는 큐의 인덱싱을 단순화하고, 논리적인 흐름을 일관되게 유지하기 위함입니다.

다음은 그 이유를 자세히 설명한 것입니다.

1️⃣ 인덱스의 일관성 유지.


  ‘rear’ 를 ‘0’ 으로 초기화하면 큐의 인덱싱이 단순해집니다.
    
      ‘rear’ 와 ‘front’ 모두 0에서 시작하여, 큐의 크기를 ‘capacity’ 로 나눈 나머지를 사용하여 인덱스를 순환시킵니다.
      이는 모듈로 연산을 사용하여 인덱스를 관리하는 데 있어 편리합니다.
    
  
  ‘rear’ 를 ‘-1’ 로 설정할 경우, 요소를 추가할 때마다 매번 ‘rear’ 를 ‘0’ 으로 조정하는 특별한 처리가 필요하게 됩니다.
    
      이는 코드의 복잡성을 증가시키고 실수의 가능성을 높입니다.
    
  


2️⃣ 코드의 단순화.


  ‘rear’ 를 ‘0’ 으로 초기화하면 초기 상태와 요소 추가, 삭제시 별도의 조건 검사를 줄일 수 있습니다.
    
      예를 들어 ‘rear’ 가 ‘-1’ 인지 확인하는 추가 조건문을 피할 수 있습니다.
    
  
  ‘0’ 부터 시작하면 ‘enqueue’ 와 ‘dequeue’ 연산에서 ‘rear’ 와 ‘front’ 인덱스의 증가와 감소가 일관되게 처리됩니다.


3️⃣ 편리한 초기 상태 처리.


  ‘rear’ 를 ‘0’ 으로 설정하면 초기 상태에서 큐가 비어 있는지 확인하는 것이 더 직관적입니다.
    
      예를 들어 ‘isEmpty’ 메서드는 단순히 ‘size’ 변수를 확인하여 큐가 비어 있는지 확인할 수 있습니다. ‘rear’ 가 ‘-1’ 이면 추가적인 상태 검사가 필요할 수 있습니다.
    
  


2️⃣ 예시 코드.

다음은 ‘rear’ 의 초기값을 ‘0’ 으로 설정하는 원형 큐의 코드입니다.

public class CircularQueue {
	private int[] queue;
	private int front;
	private int rear;
	private int size;
	private int capacity;

	public CircularQueue(int capacity) {
		this.capacity = capacity;
		this.queue = new int[capacity];
		this.front = 0;
		this.rear = 0;
		this.size = 0;
	}

	public boolean isFull() {
		return size == capacity;
	}

	public boolean isEmpty() {
		return size == 0;
	}

	public void enqueue(int data) {
		if (isFull()) {
			throw new RuntimeException("Queue is full");
		}
		queue[rear] = data;
		rear = (rear + 1) % capacity;
		size++;
	}

	public int dequeue() {
		if (isEmpty()) {
			throw new RuntimeException("Queue is empty");
		}
		int data = queue[front];
		front = (front + 1) % capacity;
		size--;
		return data;
	}

	public int peek() {
		if (isEmpty()) {
			throw new RuntimeException("Queue is empty");
		}
		return queue[front];
	}

	public int getSize() {
		return size;
	}

	public void displayCircularQueue() {
		if (isEmpty()) {
			throw new RuntimeException("Queue is empty");
		}
		int i = front;
		int count = 0;
		while (count &lt; size) {
			System.out.print("["+ queue[i] + "]");
			i = (i + 1) % capacity;
			count++;
		}
		System.out.println();
	}

	public int getMiddle() {
		if (isEmpty()) {
			throw new RuntimeException("Queue is empty");
		}
		int middleIndex = (front + size / 2) % capacity;
		return queue[middleIndex];
	}
}

// Main
public class Main {

	public static void main(String[] args) {
		CircularQueue circularQueue = new CircularQueue(5);
		CircularQueue.enqueue(10);
		CircularQueue.enqueue(20);
		CircularQueue.enqueue(30);
		CircularQueue.enqueue(40);
		CircularQueue.enqueue(50);
		CircularQueue.displayCircularQueue();
		System.out.println();

		System.out.println("Middle element: " + circularQueue.getMiddle());
		circularQueue.displayCircularQueue();
		System.out.println();

		System.out.println("===DEQUEU===");
		System.out.println(circularQueue.dequeue());
		circularQueue.enqueue(60);
		circularQueue.displayCircularQueue();
		System.out.println();

		System.out.println("Middle element: " + circularQueue.getMiddle());
		circularQueue.displayCircularQueue();
	}
}

// === 출력 ===
/*
[10][20][30][40][50]

Middle element: 30
[10][20][30][40][50]

===DEQUEU===
10
[20][30][40][50][60]

Middle element: 40
[20][30][40][50][60]
*/



  위 코드에서 ‘rear’ 를 0으로 설정함으로써 큐의 인덱싱과 상태 처리가 단순해지고, 이해하기 쉬워집니다.
이는 코드의 가독성과 유지보수성을 높이는 데 도움이 됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-13-AboutAlgorithm.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-13-AboutAlgorithm.html"><h1 class="title_post">📦[DS,Algorithm] 알고리즘(Algorithm)</h1></a>
                        <a href="/Backend/AnD/2024-06-13-AboutAlgorithm.html" class="txt_post">
                            1️⃣ 알고리즘(Algorithm).

알고리즘(Algorithm)은 주어진 문제를 해결하기 위해 일련의 명확한 단계로 구성된 절차나 방법을 의미합니다.

쉽게 말해, 알고리즘은 문제 해결을 위한 일련의 규칙 또는 지침입니다.

1️⃣ 알고리즘(Algorithm)의 정의.

알고리즘은 다음과 같은 요소를 갖춘 절차를 말합니다.


  
    입력(Input) : 알고리즘이 처리할 하나 이상의 값이 주어집니다.
  
  
    출력(Output) : 알고리즘의 수행 결과로 하나 이상의 값이 생성됩니다.
  
  
    명확성(Definiteness) : 각 단계는 명확하게 정의되어 있어야 합니다. 모호한 부분 없이 명확한 지침이어야 합니다.
  
  
    유한성(Finiteness) : 알고리즘은 유한한 단계 내에서 종료되어야 합니다. 즉, 알고리즘은 무한히 실행되지 않고, 한정된 단계 내에서 끝나야 합니다.
  
  
    유효성(Effectiveness) : 알고리즘의 모든 단계는 실제로 수행 가능해야 하며, 사람이 직접 수행할 수 있을 정도로 기본적인 연산으로 구성되어 있어야 합니다.
  


2️⃣ 알고리즘의 특성

알고리즘은 다음과 같은 특성을 가질 수 있습니다.


  
    정확성(Correctness) : 알고리즘은 올바른 결과를 생성해야 합니다.
  
  
    시간 복잡도(Time Complexity) : 알고리즘이 문제를 해결하는 데 걸리는 시간입니다. 일반적으로 크기에 대한 함수로 표현됩니다.
  
  
    공간 복잡도(Space Complexity) : 알고리즘이 문제를 해결하는 데 사용하는 메모리 양입니다. 이 또한 입력 크기에 대한 함수로 표현됩니다.
  
  
    효율성(Efficiency) : 알고리즘이 주어진 자원을 얼마나 효율적으로 사용하는지 나타냅니다. 여기에서는 시간 복잡도와 공간 복잡도가 포함됩니다.
  
  
    확장성(Scalability) : 알고리즘이 입력 크기에 따라 얼마나 잘 동작하는지 나타냅니다. 확장성 있는 알고리즘은 큰 입력 크기에서도 효율적으로 작동합니다.
  


3️⃣ 알고리즘의 중요성.

알고리즘(Algorithm)은 컴퓨터 과학 및 프로그래밍에서 핵심적인 역할을 합니다.

효율적인 알고리즘을 사용하면 컴퓨터 프로그램이 더 빠르고 적은 자원을 사용하여 문제를 해결할 수 있습니다.

또한 알고리즘은 문제 해결의 논리적이고 체계적인 접근 방식을 제공하여 복잡한 문제를 단순화하고 해결하는 데 도움을 줍니다.


  알고리즘을 잘 이해하고 사용하는 것은 프로그래머와 컴퓨터 과학자에게 필수적인 기술입니다.
이를 통해 다양한 문제를 효율적으로 해결하고, 더 나은 소프트웨어와 시스템을 설계할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-12-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-12-TIL.html"><h1 class="title_post">📝 [TIL] 240612 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-12-TIL.html" class="txt_post">
                            
  Deque에서의 front와 rear의 변화 정리 및 복습.
  Circular Queue(원형 큐)의 중간 지점 찾기.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-12-CircularQueueFindMiddleIndex.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-12-CircularQueueFindMiddleIndex.html"><h1 class="title_post">📦[DS,Algorithm] Circular Queue(원형 큐)의 중간 지점 찾기.</h1></a>
                        <a href="/Backend/AnD/2024-06-12-CircularQueueFindMiddleIndex.html" class="txt_post">
                            1️⃣ Circular Queue(원형 큐)의 중간 지점 찾기.

Java에서 배열을 사용하여 구현한 원형 큐에서 중간 지점을 찾는 방법은 큐의 시작 위치(‘front’)와 끝 위치(‘rear’)를 기준으로 계산할 수 있습니다.

중간 지점을 찾는 공식은 원형 큐의 특성을 고려하여 적절히 조정되어야 합니다.

2️⃣ 중간 지점을 찾기 위한 방법.

1️⃣ 중간 지점 계산 공식.

중간 지점을 찾는 방법은 큐의 시작점과 끝점을 이용하여 계산할 수 있습니다.

원형 큐의 크기, 시작 인덱스(front), 끝 인덱스(rear)를 사용하여 중간 인덱스를 계산할 수 있습니다.

이때 중간 지점을 계산하는 공식은 다음과 같습니다.

(front + size / 2) % capacity


여기서 ‘size’ 는 큐에 현재 저장된 요소의 수이고, ‘capacity’ 는 큐의 전체 크기입나다.

3️⃣ 예시

public class CircularQueue {
    private int[] queue;
    private int front, rear, size, capacity;

    public CircularQueue(int capacity) {
        this.capacity = capacity;
        this.queue = new int[capacity];
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    public boolean isFull() {
        return size == capacity;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public void enqueue(int data) {
        if (isFull()) {
            throw new RuntimeException("Queue is full");
        }
        queue[rear] = data;
        rear = (rear + 1) % capacity;
        size++;
    }

    public int dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
        }
        int data = queue[front];
        front = (front + 1) % capacity;
        size--;
        return data;
    }

    public int getMiddle() {
        if (isEmpty()) {
            throw new RuntimeException("Queue is empty");
        }
        int middleIndex = (front + size / 2) % capacity;
        return queue[middleIndex];
    }

    public static void main(String[] args) {
        CircularQueue cq = new CircularQueue(5);
        cq.enqueue(10);
        cq.enqueue(20);
        cq.enqueue(30);
        cq.enqueue(40);
        cq.enqueue(50);
        
        System.out.println("Middle element: " + cq.getMiddle());  // Output: Middle element: 30
        
        cq.dequeue();
        cq.enqueue(60);
        
        System.out.println("Middle element: " + cq.getMiddle());  // Output: Middle element: 40
    }
}



이 코드에서는 ‘CircularQueue’ 클래스를 정의하고, ‘enqueue’, ‘dequeue’, ‘isFull’, ‘isEmpty’ 메서드를 포함합니다.

또한, 큐의 중간 요소를 반환하는 ‘getMiddle’ 메서드를 정의합니다.

이 메서드는 현재 큐의 크기와 시작 인덱스를 사용하여 중간 인덱스를 계산한 후 해당 인덱스의 요소를 반환합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-11-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-11-TIL.html"><h1 class="title_post">📝 [TIL] 240611 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-11-TIL.html" class="txt_post">
                            
  피자 나눠 먹기(1)
  과제 수행(Java)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-10-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-10-TIL.html"><h1 class="title_post">📝 [TIL] 240610 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-10-TIL.html" class="txt_post">
                            
  deque에서의 front와 rear의 변화


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-10-ChangeBetweenFrontAndRearInDeque.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-10-ChangeBetweenFrontAndRearInDeque.html"><h1 class="title_post">📦[DS,Algorithm] Deque에서의 front와 rear의 변화.</h1></a>
                        <a href="/Backend/AnD/2024-06-10-ChangeBetweenFrontAndRearInDeque.html" class="txt_post">
                            🧨 시발점.

Deque을 공부하던 중 동적으로 변하는 front와 rear가 근본적으로 어떻게 동작하는지 궁금해졌습니다.

이것을 알게되면 정확하게 Deque의 addFirst, addLast, removeFirst, removeLast 시 front와 rear가 어디에 위치하는지 알 수 있고 Deque의 원리를 이해 할 수 있을 것 같았습니다.

1️⃣ Deque의 front와 rear의 위치는 변할 수 있나요? 🤔

‘Deque‘ (Double Ended Queue)에서 ‘front‘ 와 ‘rear‘ 의 위치는 변할 수 있습니다.

‘Deque‘ 는 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조이기 때문에, ‘front‘ 와 ‘rear‘ 의 위치는 데이터가 삽입되거나 제거될 때마다 변합니다.

2️⃣ Deque에서의 front와 rear의 변화. 🤩

1️⃣ 삽입 연산 (‘addFirst‘ 와 ‘addLast‘)


  ‘addFirst’ : 요소를 덱의 앞쪽에 삽입합니다.
    
      ‘front‘ 위치가 바뀝니다.
    
  
  ‘addLast’ : 요소를 덱의 뒤쪽에 삽입합니다.
    
      ‘rear‘ 위치가 바뀝니다.
    
  


2️⃣ 삭제 연산 (‘removeFirst‘ 와 ‘removeLast‘)


  ‘removeFirst’ : 덱의 앞쪽에서 요소를 제거합니다.
    
      ‘front‘ 위치가 바뀝니다.
    
  
  ‘removeLast’ : 덱의 뒤쪽에서 요소를 제거합니다.
    
      ‘rear‘ 위치가 바뀝니다.
    
  


3️⃣ 예제 코드.

아래는 ‘Deque’ 의 ‘LinkedList’ 구현을 사용하여 ‘front’ 와 ‘rear’ 의 변화를 보여주는 예제 코드입니다.

import java.util.Deque;
import java.util.LinkedList;

public class DequeExample {
	public static void main(String[] args) {
		Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();

		// 요소를 덱의 앞과 뒤에 추가
		deque.addFirst("A"); // front: A
		deque.addLast("B"); // rear: B
		deque.addFirst("C"); // front: C, rear: B
		deque.addLast("D"); // rear: D

		System.out.println("Initial Deque: " + deque); // 출력 : [C,A,B,D]

		// 앞쪽에서 요소 제거
		System.out.println("Removed from front: " + deque.removeFirst()); // 출력: C

		// 뒤쪽에서 요소 제거
		System.out.println("Removed from rear: " + deque.removeLast()); // 출력: D

		System.out.println("Deque after removals: " + deque); // 출력: [A, B]

		// 덱의 앞쪽과 뒤쪽에서 요소 확인
		System.out.println("Front element: " + deque.getFirst()); // 출력: A
		System.out.println("Rear element: " + deque.getLast()); // 출력: B
	}
}


👉 설명.

1️⃣ 삽입 연산.


  
    ‘deque.addFirst(“A”)’ : “A”를 덱의 앞에 삽입합니다.
  
  
    ‘deque.addLast(“B”)’ : “B”를 덱의 뒤에 삽입합니다.
  
  
    ‘deque.addFirst(“C”)’ : “C”를 덱의 앞에 삽입합니다.
  
  
    ‘deque.addLast(“D”)’ : “D”를 덱의 뒤에 삽입합니다.
  



  이 연산들은 ‘front’ 와 ‘rear’ 의 위치를 업데이트합니다.


2️⃣ 삭제 연산.


  
    ‘deque.removeFirst()’ : 덱의 앞쪽에서 “C”를 제거합니다.
  
  
    ‘deque.removeLast()’ : 덱의 뒤쪽에서 “D”를 제거합니다.
  



  이 연산들은 ‘front’ 와 ‘rear’ 의 위치를 다시 업데이트합니다.


3️⃣ 요소 확인.


  
    ‘deque.getFirst()’ : 덱의 앞쪽 요소를 확인합니다.
  
  
    ‘deque.getLast()’ : 덱의 뒤쪽 요소를 확인합니다.
  



  이 예시 코드는 ‘front’ 와 ‘rear’ 가 데이터의 삽입 및 삭제 연산에 따라 어떻게 변하는지 잘 보여줍니다.
‘Deque’ 는 이처럼 양쪽 끝에서의 삽입과 삭제 연산을 지원하므로, ‘front’ 와 ‘rear’ 의 위치는 동적입니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-09-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-09-TIL.html"><h1 class="title_post">📝 [TIL] 240609 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-09-TIL.html" class="txt_post">
                            
  짝수는 싫어요
  다형성
  Circular Queue(원형 큐)란?


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-09-CircularQueue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-09-CircularQueue.html"><h1 class="title_post">📦[DS,Algorithm] Circular Queue(원형 큐)란?</h1></a>
                        <a href="/Backend/AnD/2024-06-09-CircularQueue.html" class="txt_post">
                            1️⃣ Circular Queue(원형 큐)란?

원형 큐는 큐의 일종으로, 배열을 사용하여 구현되며, 큐의 마지막 위치가 처음 위치와 연결되어 원형 구조를 가지는 큐입니다.

원형 큐는 고정된 크기의 배열을 사용하여 구현되므로, 큐의 마지막 인덱스가 배열의 끝에 도달하면 다음 인덱스가 배열의 시작 부분으로 이동합니다.

이를 통해 메모리를 효율적으로 사용할 수 있으며, 큐의 처음과 끝을 관리하는 데 도움이 됩니다.

2️⃣ 원형 큐의 원리.


  
    고정된 크기 : 원형 큐는 고정된 크기의 배열을 사용하여 구현됩니다. 따라서 배열의 크기를 초과하여 요소를 추가할 수 없습니다.
  
  
    연결된 인덱스 : 큐의 마지막 인덱스가 배열의 끝에 도달하면, 다음 인덱스는 배열의 처음 부분으로 이동합니다.
  
  두 개의 포인터 : 원형 큐는 두 개의 포인터를 사용하여 구현됩니다.
    
      ‘front’ : 큐의 첫 번째 요소를 가리킵니다.
      ‘rear’ : 큐의 마지막 요소를 가리킵니다.
    
  
  비어 있는 상태와 가득 찬 상태 : 큐가 비어 있는 상태와 가득 찬 상태를 구별해야 합니다. 이를 위해 추가적인 변수를 사용하거나 포인터의 위치를 비교하여 상태를 확인합니다.


3️⃣ 원형 큐의 주요 연산.


  
    초기화 : 큐의 크기를 설정하고, ‘front’ 와 ‘rear’ 포인터를 초기화합니다.
  
  
    isEmpty() : 큐가 비어 있는지 확인합니다.
  
  
    isFull() : 큐가 가득 찼는지 확인합니다.
  
  
    enqueue() : 큐에 요소를 추가합니다. ‘rear’ 포인터를 업데이트합니다.
  
  
    dequeue() : 큐에서 요소를 제거하고 반환합니다. ‘front’ 포인터를 업데이트합니다.
  
  
    peek() : 큐의 첫 번째 요소를 반환합니다.
  


4️⃣ 원형 큐의 예제 구현.

public class CircularQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    // 생성자
    public CircularQueue(int capacity) {
        this.capacity = capacity;
        queue = new int[capacity];
        front = 0;
        rear = -1;
        size = 0;
    }

    // 큐가 비어 있는지 확인
    public boolean isEmpty() {
        return size == 0;
    }

    // 큐가 가득 찼는지 확인
    public boolean isFull() {
        return size == capacity;
    }

    // 큐에 요소 추가
    public void enqueue(int element) {
        if (isFull()) {
            System.out.println("Queue is full");
            return;
        }
        rear = (rear + 1) % capacity;
        queue[rear] = element;
        size++;
    }

    // 큐에서 요소 제거
    public int dequeue() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return -1;
        }
        int element = queue[front];
        front = (front + 1) % capacity;
        size--;
        return element;
    }

    // 큐의 첫 번째 요소 확인
    public int peek() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return -1;
        }
        return queue[front];
    }

    // 큐의 크기 반환
    public int getSize() {
        return size;
    }

    // 큐의 모든 요소 출력
    public void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }
        int i = front;
        int count = 0;
        while (count &lt; size) {
            System.out.print(queue[i] + " ");
            i = (i + 1) % capacity;
            count++;
        }
        System.out.println();
    }

    // 메인 메서드 (테스트용)
    public static void main(String[] args) {
        CircularQueue cq = new CircularQueue(5);

        cq.enqueue(10);
        cq.enqueue(20);
        cq.enqueue(30);
        cq.enqueue(40);
        cq.enqueue(50);

        cq.display(); // 출력: 10 20 30 40 50

        System.out.println("Dequeued: " + cq.dequeue()); // 출력: Dequeued: 10
        System.out.println("Dequeued: " + cq.dequeue()); // 출력: Dequeued: 20

        cq.display(); // 출력: 30 40 50

        cq.enqueue(60);
        cq.enqueue(70);

        cq.display(); // 출력: 30 40 50 60 70

        System.out.println("Front element: " + cq.peek()); // 출력: Front element: 30
    }
}


🙋‍♂️ 설명.


  큐 초기화:
    
      ‘capacity’ : 큐의 최대 크기입니다.
      ‘queue’ : 큐를 저장할 배열입니다.
      ‘front’ : 큐의 첫 번째 요소를 가리키는 인덱스입니다.
      ‘rear’ : 큐의 마지막 요소를 가리키는 인덱스입니다.
      ‘size’ : 큐에 있는 요소의 개수입니다.
    
  
  메서드:
    
      ‘isEmpty()’ : 큐가 비어 있는지 확인합니다.
      ‘isFull()’ : 큐가 가득 찼는지 확인합니다.
      ‘enqueue(int element)’ : 큐에 요소를 추가합니다.
      ‘dequeue()’ : 큐에서 요소를 제거하고 반환합니다.
      ‘peek()’ : 큐의 첫 번째 요소를 반환합니다.
      ‘getSize()’ : 큐에 있는 요소의 개수를 반환합니다.
      ‘display()’ : 큐의 모든 요소를 출력합니다.
    
  


5️⃣ 결론.

원형 큐는 배열을 효율적으로 사용하여 큐의 크기를 고정하고, 처음과 끝이 연결된 형태로 큐를 관리하는 자료구조입니다.

이를 통해 큐의 공간을 최대한 활용하고, 큐가 비어 있는지 가득 찼는지를 쉽게 확인할 수 있습니다.

🤔 궁금했던 부분.

rear = (rear + 1) % capacity;


1️⃣ 이 코드에서 % capacity 를 하는 이유는 무엇일까?

원형 큐에서 ‘rear’ 포인터를 업데이트 할 때 % capacity 를 사용하는 이유는 큐가 마지막 인덱스에 도달한 후, 다시 처음 인덱스로 돌아가도록 하기 위해서입니다.

이를 통해 큐가 원형으로 동작할 수 있습니다.

구체적으로 말하면, 큐의 크기를 고정된 크기의 배열로 구현할 때, 배열의 끝에 도달했을 때 다시 처음으로 돌아가는 기능을 제공합니다.

2️⃣ % 연산자의 역할.

배열의 인덱스는 0부터 시작하여 배열의 크기보다 1 작은 값까지입니다.

예를 들어, 배열의 크기가 5라면 인덱스는 0부터 4까지입니다.

원형 큐에서 새로운 요소를 추가할 때마다 ‘rear’ 포인터를 증가시키는데, 이 포인터가 배열의 끝을 넘어가지 않도록 해야 합니다.

이를 위해 % capacity 연산을 사용합니다.


  rear = (rear + 1) % capacity;


이 연산은 ‘rear’ 포인터를 1씩 증가시키다가, 배열의 끝에 도달하면 다시 0으로 돌아가게 합니다.

즉, 배열의 인덱스가 배열의 크기를 넘어가면, 다시 처음 인덱스(0)로 순환되게 합니다.

👉 예제.

배열의 크기가 5인 원형 큐를 생각해봅시다.


  초기 상태: ‘rear = -1’
  요소 추가 시, ‘rear’ 포인터의 변화를 관찰해보면
    
      첫 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 0’
      두 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 1’
      세 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 2’
      네 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 3’
      다섯 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 4’
      여섯 번째 추가: ‘rear = (rear + 1) % 5 -&gt; rear = 0’ (다시 처음으로 돌아감)
    
  


이렇게 ‘rear’ 포인터가 배열의 끝에 도달하면 다시 배열의 시작 부분으로 순환되므로, 배열을 효율적으로 사용할 수 있게 됩니다.

💻 코드 예제.

위 개념을 이용한 원형 큐의 ‘enqueue’ 메서드 구현

public void enqueue(int element) {
    if (isFull()) {
        System.out.println("Queue is full");
        return;
    }
    rear = (rear + 1) % capacity; // rear 포인터를 증가시키고, 배열의 처음으로 순환시킴.
    queue[rear] = element;
    size++;
}


6️⃣ 정리.

원형 큐에서 ’% capacity’ 연산은 ‘rear’ 포인터와 ‘front’ 포인터가 배열의 끝에 도달했을 때, 다시 배열의 시작 부분으로 돌아가기 위해 사용됩니다.

이를 통해 배열의 고정된 크기를 효율적으로 활용하며, 원형 큐의 특성을 유지할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-09-polymorphism.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-09-polymorphism.html"><h1 class="title_post">☕️[Java] 다형성(Polymorphism)</h1></a>
                        <a href="/Backend/Java/2024-06-09-polymorphism.html" class="txt_post">
                            1️⃣ 다형성(Polymorphism).

‘다형성(Polymorphism)’ 은 ‘객체 지향 프로그래밍(OOP)’ 의 중요한 개념 중 하나로, 같은 인터페이스를 통해 서로 다른 데이터 타입의 객체를 조작할 수 있도록 합니다.

다형성은 코드의 재사용성과 유연성을 높여주며, 유지보수를 쉽게 해줍니다.

Java에서 ‘다형성’ 은 주로 ‘상속’ 과 ‘인터페이스’ 를 통해 구현됩니다.

2️⃣ 다형성의 개념.

다형성은 “하나의 인터페이스로 여러 가지 형태를 구현할 수 있는 능력” 을 의미합니다.

이는 같은 메서드가 다양한 객체에서 다르게 동작할 수 있게 합니다.

3️⃣ 다형성의 두 가지 형태.

1️⃣ 컴파일 시간 다형성(Compile-time Polymorphism)


  
    메서드 오버로딩(Method Overloading)을 통해 구현됩니다.
  
  
    컴파일 시점에 어떤 메서드가 호출될지 결정됩니다.
  
  
    같은 이름의 메서드를 여러 개 정의하지만, 매개변수의 타입이나 개수가 달라야 합니다.
  


2️⃣ 런타임 다형성 (Runtime Polymorphism)


  
    메서드 오버라이딩(Method Overriding)을 통해 구현됩니다.
  
  
    실행 시점에 어떤 메서드가 호출될지 결정됩니다.
  
  
    부모 클래스의 메서드를 자식 클래스에서 재정의하여 사용합니다.
  


4️⃣ 컴파일 시간 다형성(Method Overloading).

메서드 오버로딩은 같은 클래스 내에서 같은 이름을 가진 메서드를 여러 개 정의하는 것입니다.

단, 매개변수의 수나 타입이 달라야 합니다.

💻 예제.

public class MathOperations {
	// 정수 두 개의 합
	public int add(int a, int b) {
		return a + b;
	}

	// 실수 두 개의 합
	public double add(double a, double b) {
		return a + b;
	}

	// 새 개의 정수의 합
	public int add(int a, int b, int c) {
		return a + b + c;
	}

	public static void main(String[] args) {
		MathOperations mathOperations = new MathOperations();
		System.out.println(mathOperations.add(1, 2)); // 3
		System.out.println(mathOperations.add(1.5, 2.5)); // 4.0
		System.out.println(mathOperations.add(1, 2, 3)); // 6
	}
}


5️⃣ 런타임 다형성(Method Overriding).

메서드 오버라이딩은 자식 클래스가 부모 클래스의 메서드를 재정의하는 것을 말합니다.

이를 통해 자식 클래스의 객체가 부모 클래스의 메서드를 호출할 때, 자식 클래스의 메서드가 실행되도록 합니다.

💻 예제.

class Animal {
	void makeSound() {
		System.out.println("Animal makes a sound");
	}
}

class Dog extends Animal {
	@Override
	void makeSound() {
		System.out.println("Dog barks");
	}
}

class Cat extends Animal {
	@Override
	void makeSound() {
		System.out.println("Cat meows");
	}
}

public class Main {

	public static void main(String[] args) {
		Animal myDog = new Dog(); // Animal 타입으로 Dog 객체 생성
		Animal myCat = new Cat(); // Animal 타입으로 Cat 객체 생성

		myDog.makeSound(); // Dog barks
		myCat.makeSound(); // Cat meows
	}
}


6️⃣ 인터페이스를 통한 다형성.

인터페이스를 통해서도 다형성을 구현할 수 있습니다.

인터페이스는 메서드의 서명만을 정의하며, 이를 구현하는 클래스가 메서드의 구체적인 동작을 정의합니다.

💻 예제.

interface Shape {
	void draw();
}

class Circle implements Shape {
	@Override
	public void draw() {
		System.out.println("Drawing a Circle");
	}
}

class Square implements Shape {
	@Override
	public void draw() {
		System.out.println("Drawing a Square");
	}
}

public class Main {

	public static void main(String[] args) {
		Shape myShape1 = new Circle();
		Shape myShape2 = new Square();

		myShape1.draw(); // Drawing a Circle
		myShape2.draw(); // Drawing a Square
	}
}


7️⃣ 다형성의 장점.


  
    코드 재사용성 : 상위 클래스나 인터페이스를 사용하여 다양한 하위 클래스나 구현체를 다룰 수 있어 코드의 재사용성이 높아집니다.
  
  
    유연성 : 새로운 클래스나 기능을 추가할 때 기존 코드를 수정할 필요 없이 확장할 수 있습니다.
  
  
    유지보수성 : 코드를 이해하고 유지보수하는 것이 더 쉬워집니다. 메서드의 호출이 어디서 어떻게 이루어지는지 명확하기 때문입니다.
  


8️⃣ 예제: 다형성의 실질적 사용.

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class PolymorphismExample {

	public static void main(String[] args) {
		List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
		List&lt;String&gt; linkedList = new LinkedList&lt;&gt;();

		arrayList.add("ArrayList Item");
		linkedList.add("LinkedList Item");

		printList(arrayList); // ArrayList Item
		printList(linkedList); // LinkedList Item
	}

	public static void printList(List&lt;String&gt; list) {
		for (String item : list) {
			System.out.println(item);
		}
	}
}



  이 예제에서는 ‘List‘ 인터페이스를 사용하여 ‘ArrayList‘ 와 ‘LinkedList‘ 를 동일한 방식으로 처리합니다.
이를 통해 다양한 구현체를 다룰 수 있는 유연한 코드를 작성할 수 있습니다.


📝 결론.

다형성은 객체 지향 프로그래밍의 핵심 개념 중 하나로, 코드의 유연성과 재사용성을 크게 향상시킵니다.

이를 통해 다양한 형태의 객체를 동일한 방식으로 다룰 수 있으며, 새로운 기능을 쉽게 확장하고 유지보수할 수 있습니다.

다형성은 상속과 인터페이스를 통해 구현되며, 메서드 오버로딩과 오버라이딩을 통해 다양한 형태를 취할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-08-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-08-TIL.html"><h1 class="title_post">📝 [TIL] 240608 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-08-TIL.html" class="txt_post">
                            
  Primitive Type과 Wrapper Class
  제네릭
  나머지 구하기
  중앙값 구하기


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-08-PrimitiveAndWrapper.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-08-PrimitiveAndWrapper.html"><h1 class="title_post">☕️[Java] Primitive Type과 Wrapper Class.</h1></a>
                        <a href="/Backend/Java/2024-06-08-PrimitiveAndWrapper.html" class="txt_post">
                            1️⃣ 도화선 🧨

‘int와 Integer의 차이가 무엇이 있을까?’ 하는 호기심이 도화선이 되어 이 글을 쓰게 되었습니다 :)

먼저 ‘int와 Integer의 차이’를 알아보니 ‘int’ 는 ‘Primitive Type’ 이고, ‘Integer’ 는 ‘Wrapper Class’ 라는 것을 알게 되었습니다.

2️⃣ Primitive Type과 Wrapper Class.

Java에서 Primitive Type 과 Wrapper Class는 각각 기본 데이터 타입과 그 기본 타입을 객체로 감싸는 클래스입니다.

이 둘의 개념과 차이점을 이해하는 것은 Java 프로그래밍에서 매우 중요합니다.

1️⃣ Primitive Type (기본 데이터 타입).

Primitive Type은 Java에서 가장 기본적인 데이터 타입을 말합니다.

Java는 다음과 같은 8가지 기본 데이터 타입을 제공합니다.


  
    
      boolean : 논리값(true 또는 false).
    
  
  
    
      byte : 8비트 정수.
    
  
  
    
      short : 16비트 정수.
    
  
  
    
      int : 32비트 정수.
    
  
  
    
      long : 64비트 정수.
    
  
  
    
      float : 32비트 부동 소수점.
    
  
  
    
      double : 64비트 부동 소수점.
    
  
  
    
      char : 16비트 유니코드 문자.
    
  


이러한 타입들은 성능이 뛰어나고 메모리를 적게 사용하며, 객체를 생성할 필요 없이 값 그 자체를 저장하고 조작할 수 있습니다.

예시

int a = 10;
boolean isJavaFun = true;
char letter = 'A';


2️⃣ Wrapper Class (래퍼 클래스)

Wrapper Class 는 각 Primitive Type 에 대응되는 클래스입니다.

이 클래스들은 Primitive Type을 객체로 감싸기 때문에 “래퍼 클래스” 라고 불립니다.

Java는 각 기본 타입에 대한 래퍼 클래스를 제공합니다.


  
    
      boolean -&gt; ‘Boolean’
    
  
  
    
      byte -&gt; ‘Byte’
    
  
  
    
      short -&gt; ‘Short’
    
  
  
    
      int -&gt; ‘Integer’
    
  
  
    
      long -&gt; ‘Long’
    
  
  
    
      float -&gt; ‘Float’
    
  
  
    
      double -&gt; ‘Double’
    
  
  
    
      char -&gt; ‘Character’
    
  


Wrapper Class 는 다음과 같은 이유로 사용됩니다.


  Primitive Type 을 객체로 다루어야 할 때(예: 컬렉션 프레임워크에서는 객체만 저장할 수 있음)
  null 값을 처리해야 할 때
  추가 메서드 및 기능을 사용해야 할 때(예: 문자열을 정수로 변환하는 메서드 등)


예시

Integer a = 10;
Boolean isJavaFun = true;
Character letter = 'A';


3️⃣ Autoboxing 과 Unboxing

Java는 기본 타입과 래퍼 클래스 간의 자동 변환을 지원합니다.

이를 Autoboxing 과 Unboxing 이라고 합니다.


  
    Autonboxing : 기본 타입이 자동으로 해당 래퍼 클래스 객체로 변환되는 것.
  
  
    Unboxing : 래퍼 클래스 객체가 자동으로 해당 기본 타입으로 변환되는 것,
  


예시

int primitiveInt = 5;
Integer wrapperInt = primitiveInt; // Autoboxing

Integer anotherWrapperInt = 10;
int anotherPrimitiveInt = anotherWrapperInt; // Unboxing


4️⃣ Primitive Type 과 Wrapper Class의 차이점.


  
    
      메모리 사용 :
        
          Primitive Type : 메모리 효율적, 객체 오버헤드 없음.
          Wrapper Class : 객체 오버헤드가 있어 더 많은 메모리 사용.
        
      
    
  
  
    
      기본값 :
        
          Primitive Type : 기본값이 정의되어 있음 (예: int는 0, boolean은 false).
          Wrapper Class : 기본값이 ‘null’ 일 수 있음.
        
      
    
  
  
    
      성능 :
        
          Primitive Type : 빠른 연산 속도.
          Wrapper Class : 객체 생성과 가비지 컬렉션의 오버헤드로 인해 상대적으로 느립.
        
      
    
  
  
    
      기능성 :
        
          Primitive Type : 단순한 데이터 저장과 연산에 적합.
          Wrapper Class : 다양한 유틸리티 메서드 제공 (예: 문자열 반환, 비교 메서드 등).
        
      
    
  


예제 코드

다음은 Primitive Type과 Wrapper Class의 사용 예를 보여주는 코드입니다.

import java.util.ArrayList;
import java.util.List;

public class Main {

	public static void main(String[] args) {
		// Primitive Type 사용
		int primitiveInt = 100;
		boolean primitiveBoolean = true;

		// Wrapper Class 사용
		Integer wrapperInt = Integer.valueOf(100); // 명시적 변환
		Boolean wrapperBoolean = Boolean.valueOf(true);

		// Autoboxing and Unboxing
		Integer autoboxedInt = 200; // Autoboxing
		int unboxedInt = autoboxedInt; // Unboxing

		// Primitive Type은 컬렉션에 저장할 수 없음
		List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();
		intList.add(primitiveInt); // Autoboxing
		intList.add(wrapperInt);

		// 컬렉션에서 값을 가져올 때 Unboxing
		int sum = 0;
		for (int num : intList) {
			sum += num; // Unboxing
		}

		System.out.println("Sum: " + sum); // Output: Sum: 200
	}
}



  이 예제에서는 기본 타입과 래퍼 클래스를 사용하여 변수레 값을 저장하고, 컬렉션에 저장된 래퍼 클래스 객체를 사용하려 연산을 수행하는 과정을 보여줍니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-08-Generic.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-08-Generic.html"><h1 class="title_post">☕️[Java] 제네릭(Generic)</h1></a>
                        <a href="/Backend/Java/2024-06-08-Generic.html" class="txt_post">
                            1️⃣ 제네릭(Generic)

Java에서의 제네릭(Generic) 은 클래스나 메서드에서 사용할 데이터 타입을 나중에 지정할 수 있도록 하는 기능입니다.

제네릭을 사용하면 코드의 재사용성을 높이고, 컴파일 시 타입 안전성을 제공하며, 명시적 타입 캐스팅을 줄일 수 있습니다.

2️⃣ 제네릭(Generic)의 주요 개념.


  타입 매개변수 :
    
      제네릭 클래스나 메서드는 타입 매개변수를 사용하여 타입을 정의합니다. 이 타입 매개변수는 클래스나 메서드가 호출될 때 구체적인 타입으로 대체됩니다.
    
  
  타입 안정성 :
    
      제네릭을 사용하면 컴파일 시 타입을 검사하므로, 런타입에 발생할 수 있는 타입 오류를 줄일 수 있습니다.
    
  
  재사용성 :
    
      제네릭 클래스나 메서드는 다양한 타입에 대해 동작하도록 설계할 수 있어, 코드의 재사용성을 높입니다.
    
  


3️⃣ 제네릭 클래스.

제네릭 클래스는 클래스 선언에 타입 매개변수를 포함하여 정의합니다.

일반적으로 타입 매개변수는 한 글자로 표현 되며, ‘T(Tyep)‘, ‘E(Element)‘, ‘K(Key)‘, ‘V(Value)‘ 등이 자주 사용됩니다.

예제.

// Box 클래스
public class Box&lt;T&gt; {
	private T item;

	public void setItem(T item) {
		this.item = item;
	}

	public T getItem() {
		return item;
	}
}

// Main 클래스
public class Main {

	public static void main(String[] args) {
		Box&lt;String&gt; stringBox = new Box&lt;&gt;();
		stringBox.setItem("Hello");
		System.out.println("String item: " + stringBox.getItem()); // String item: Hello

		Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();
		integerBox.setItem(123);
		System.out.println("Integer item: " + integerBox.getItem()); // Integer item: 123
	}
}


4️⃣ 제네릭 메서드.

제네릭 메서드는 메서드 선언 타입 매개변수를 포함하여 정의합니다.

예제.

public class GenericMethodExample {
	public static &lt;T&gt; void printArray(T[] array) {
		for (T element : array) {
			System.out.print(element + " ");
		}
		System.out.println();
	}

	public static void main(String[] args) {
		Integer[] intArray = {1, 2, 3, 4, 5};
		String[] strArray = {"A", "B", "C", "D"};

		printArray(intArray); // 1 2 3 4 5 
		printArray(strArray); // A B C D 
	}
}


5️⃣ 제네릭 타입 제한 (Bounded Type Parameters)

제네릭 타입 매개변수에 제한을 걸어 특정 타입의 하위 클래스나 인터페이스만 허용할 수 있습니다.

상한 제한 (Upper Bound)

public class BoundedTypeExample&lt;T extends Number&gt; {
	private T number;

	public BoundedTypeExample(T number) {
		this.number = number;
	}

	public void printNumber() {
		System.out.println("Number: " + number);
	}

	public static void main(String[] args) {
		BoundedTypeExample&lt;Integer&gt; intExample = new BoundedTypeExample&lt;&gt;(123);
		intExample.printNumber(); // Number: 123

		BoundedTypeExample&lt;Double&gt; doubleExample = new BoundedTypeExample&lt;&gt;(45.67);
		doubleExample.printNumber(); // Number: 45.67
	}
}



  여기서 ‘T’ 는 ‘Number’ 클래스나 그 하위 클래스만 될 수 있습니다.


하한 제한 (Lower Bound)

하한 제한은 와일드카드(’? super T‘)를 사용하여 정의됩니다.

예를 들어 ‘List&lt;? super Integer&gt;‘ 는 ‘Integer‘ 의 상위 타입인 ‘Number‘, ‘Object‘ 등이 될 수 있습니다.

import java.util.ArrayList;
import java.util.List;

public class LowerBoundWildcardExample {
	public static void addNumbers(List&lt;? super Integer&gt; list) {
		for (int i = 0; i &lt; 5; i++) {
			list.add(i);
		}
	}

	public static void main(String[] args) {
		List&lt;Number&gt; numberList = new ArrayList&lt;&gt;();
		addNumbers(numberList);
		System.out.println(numberList); // [0, 1, 2, 3, 4]
	}
}


6️⃣ 제네릭의 제한 사항.


  Primitive Type 사용 불가 : 제네릭은 참조 타입만 허용하며, 기본 타입은 사용할 수 없습니다.


// 올바르지 않음
Box&lt;int&gt; intBox = new Box&lt;&gt;(); // 컴파일 오류



  정적 컨텍스트에서의 타입 매개변수 사용 : 정적 메서드나 정적 변수에서는 타입 매개변수를 사용할 수 없습니다.


public class GenericClass&lt;T&gt; {
    private static T item; // 컴파일 오류
}



  제네릭 배열 생성 불가 : 제네릭 배열을 직접 생성할 수 없습니다.


// 올바르지 않음
T[] array = new T[10]; // 컴파일 오류



  제네릭은 Java의 강력한 기능으로, 타입 안전성을 높이고 코드의 재사용성을 극대화할 수 있게 해줍니다.
이를 적절히 활용하면 더 안정적이고 유지보수하기 쉬운 코드를 작성할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-07-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-07-TIL.html"><h1 class="title_post">📝 [TIL] 240607 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-07-TIL.html" class="txt_post">
                            
  LinkedList를 이용한 Deque
  분수의 덧셈 복습


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-07-LinkedListDeque.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-07-LinkedListDeque.html"><h1 class="title_post">📦[DS,Algorithm] LinkedList를 사용한 Deque.</h1></a>
                        <a href="/Backend/AnD/2024-06-07-LinkedListDeque.html" class="txt_post">
                            1️⃣ LinkedList를 사용한 Deque.

‘LinkedList‘ 는 ‘Deque‘ 인터페이스를 구현한 클래스 중 하나로, 양쪽 끝에서 삽입과 삭제가 가능한 이중 연결 리스트 기반의 자료 구조입니다.

‘LinkedList‘ 는 ‘Deque‘ 뿐만 아니라 ‘List‘, ‘Queue‘ 인터페이스도 구현하여 다양한 형태로 사용할 수 있습니다.

2️⃣ 주요 특징.


  
    이중 끝 큐 : 양쪽 끝에서 요소를 추가하고 제거할 수 있습니다.
  
  
    이중 연결 리스트 : 각 노드는 이전 노드와 다음 노드를 가리키는 두 개의 포인터를 가집니다.
  
  
    비동기적 : ‘LinkedList‘ 는 비동기적으로 동작하므로 동기화된 환경에서 안전하지 않습니다.
  


3️⃣ 주요 메서드.

삽입 연산.


  
    ‘addFirst(E e)’ : 지정된 요소를 덱의 앞쪽에 추가합니다.
  
  
    ‘addLast(E e)’ : 지정된 요소를 덱의 뒤쪽에 추가합니다.
  
  
    ‘offerFirst(E e)’ : 지정된 요소를 덱의 앞쪽에 추가합니다.
  
  
    ‘offerLast(E e)’ : 지정된 요소를 덱의 뒤쪽에 추가합니다.
  


삭제 연산.


  
    ‘removeFirst()’ : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘removeLast()’ : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘pollFirst()’ : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘pollLast()’ : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.
  


조회 연산.


  
    ‘getFirst()’ : 덱의 앞쪽에 있는 요소를 반환합니다.
  
  
    ‘getLast()’ : 덱의 뒤쪽에 있는 요소를 반환합니다.
  
  
    ‘peekFirst()’ : 덱의 앞쪽에 있는 요소를 반환합니다.
  
  
    ‘peekLast()’ : 덱의 뒤쪽에 있는 요소를 반환합니다.
  


스택 연산.


  
    ‘push(E e)’ : 스택의 맨 위에 요소를 추가합니다.(FIFO, First In First Out)
  
  
    ‘pop()’ : 스택의 맨 위에 있는 요소를 제거하고 반환합니다.(LIFO, Last In First Out)
  


4️⃣ 시간 복잡도


  삽입과 삭제 연산 : ‘addFirst‘, ‘addLast‘, ‘removeFirst‘, ‘removeLast‘, ‘offerFirst‘, ‘offerLast‘, ‘pollFirst‘, ‘pollLast‘ 등의 연산은 O(1)입니다.
    
      이중 연결 리스트를 사용하기 때문에 양쪽 끝에서의 삽입과 삭제는 상수 시간 내에 수행됩니다.
    
  
  
    조회 연산 : ‘getFirst‘, ‘getLast‘, ‘peekFirst‘, ‘peekLast‘ 등의 연산은 O(1)입니다.
  
  임의 접근 연산( **‘get(int index)‘, ‘set(int index, E element)’ 등) :** 인덱스를 사용한 접근 연산은 리스트의 중간에 있는 요소를 찾기 위해 리스트를 순회해야 하므로 O(n) 시간이 걸립니다.


5️⃣ 코드 예시.

아래 코드는 ‘LinkedList‘ 를 ‘Deque‘ 로 사용하는 예제입니다.

import java.util.Deque;
import java.util.LinkedList;

public class LinkedListDequeExample {

	public static void main(String[] args) {
		// LinkedList로 Deque 생성
		Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();

		// 요소 삽입
		deque.addFirst(1);
		deque.addLast(2);
		deque.offerFirst(0);
		deque.offerLast(3);

		// 요소 조회
		System.out.println("First element: " + deque.getFirst());
		System.out.println("Last element: " + deque.getLast());
		System.out.println("Peek first element: " + deque.peekFirst());
		System.out.println("Peek last element: " + deque.peekLast());

		// 요소 식제
		System.out.println("Removed first element: " + deque.removeFirst());
		System.out.println("Removed last element: " + deque.removeLast());
		System.out.println("Poll first element: " + deque.pollFirst());
		System.out.println("Poll last element: " + deque.pollLast());

		// 덱의 크기와 비어 있는지 여부 확인
		System.out.println("Deque size: " + deque.size());
		System.out.println("Is deque empty? " + deque.isEmpty());

		// 스택 연산.
		deque.push(4);
		System.out.println("Pushed element: " + deque.peekFirst());
		System.out.println("Popped element: " + deque.pop());
	}
}
/*
=== 출력 ===

First element: 0
Last element: 3
Peek first element: 0
Peek last element: 3
Removed first element: 0
Removed last element: 3
Poll first element: 1
Poll last element: 2
Deque size: 0
Is deque empty? true
Pushed element: 4
Popped element: 4
*/


🙋‍♂️ 설명.


  
    
      베열 초기화 : ‘DEFAULT_CAPACITY‘ 크기의 배열을 초기화하고, ‘head‘, ‘tail‘, ‘size‘ 변수를 초기화 합니다.
    
  
  
    
      삽입 연산( **‘addFirst‘, ‘addLast‘) :** 요소를 덱의 첫 번째 또는 마지막에 추가합니다.
    
  
  
    
      삭제 연산( **‘removeFirst‘, ‘removeLast‘) :** 첫 번째 요소와 마지막 요소를 각각 제거합니다.
    
  
  
    
      조회 연산( **‘getFirst‘, ‘getLast‘, ‘peekFirst‘, ‘peekLast‘) :** 첫 번째 요소와 마지막 요소를 반환합니다.
    
  
  
    
      기타 메서드 : ‘size‘ 와 ‘isEmpty‘ 메서드는 덱의 크기와 비어 있는지 여부를 반환합니다.
    
  
  
    
      스택 연산( **‘push‘, ‘pop‘) :** 스택의 맨 위에 요소를 추가하고, 스택의 맨 위에 있는 요소를 제거하고 반환합니다.
    
  



  위 예시 코드에서는 ‘LinkedList‘ 를 ‘Deque‘ 로 사용하여 다양한 연산을 수행하는 방법을 보여줍니다.
‘LinkedList‘ 는 이중 연결 리스트를 사용하기 때문에 양쪽 끝에서의 삽입과 삭제가 빠르고 효율적입니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-06-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-06-TIL.html"><h1 class="title_post">📝 [TIL] 240606 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-06-TIL.html" class="txt_post">
                            
  ArrayDeque
  코딩테스트 입문 - 두 수의 나눗셈
  코딩테스트 입문 - 숫자 비교하기
  코딩테스트 입문 - 분수의 덧셈
  코딩테스트 입문 - 배열 두 배 만들기


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-06-ArrayDeque.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-06-ArrayDeque.html"><h1 class="title_post">📦[DS,Algorithm] ArrayDeque</h1></a>
                        <a href="/Backend/AnD/2024-06-06-ArrayDeque.html" class="txt_post">
                            1️⃣ ArrayDeque.

Java에서 ‘ArrayDeque‘ 는 ‘java.util‘ 패키지에 속하는 클래스이며, 큐(Queue)와 덱(Deque)의 기능을 모두 지원하는 배열 기반의 자료 구조입니다.

‘ArrayDeque‘ 는 ‘Deque‘ 인터페이스를 구현하며, 그기가 가변적인 배열을 사용하여 요소를 저장합니다.

2️⃣ 주요 특징.


  
    이중 끝 큐 : 양쪽 끝에서 요소를 추가하고 제거할 수 있습니다.
  
  
    크기 조정 : 필요에 따라 내부 배열의 크기를 자동으로 조정합니다.
  
  
    스택 및 큐로 사용 가능 : ‘ArrayDeque‘ 는 스택(LIFO, Last In First Out)과 큐(FIFO, First In First Out) 모두로 사용할 수 있습니다.
  
  
    비동기적 : ‘ArrayDeque‘ 는 비동기적으로 동작하므로 동기화된 환경에서 안전하지 않습니다.
  


3️⃣ 주요 메서드.

삽입 연산.


  
    ‘addFirst(E e)’ : 지정된 요소를 덱의 앞쪽에 추가합니다.
  
  
    ‘addLast(E e)’ : 지정된 요소를 덱의 뒤쪽에 추가합니다.
  
  
    ‘offerFirst(E e)’ : 지정된 요소를 덱의 앞쪽에 추가합니다.
  
  
    ‘offerLast(E e)’ : 지정된 요소를 덱의 뒤쪽에 추가합니다.
  


삭제 연산.


  
    ‘removeFirst()’ : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘removeLast()’ : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘pollFirst()’ : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  
  
    ‘pollLast()’ : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.
  


조회 연산.


  
    ‘getFirst()’ : 덱의 앞쪽에 있는 요소를 반환합니다.
  
  
    ‘getLast()’ : 덱의 뒤쪽에 있는 요소를 반환합니다.
  
  
    ‘peekFirst()’ : 덱의 앞쪽에 있는 요소를 반환합니다.
  
  
    ‘peekLast()’ : 덱의 뒤쪽에 있는 요소를 반환합니다.
  


스택 연산.


  
    ‘push(E e)’ : 스택의 맨 위에 요소를 추가합니다.(LIFO, Last In First Out)
  
  
    ‘pop(E e)’ : 스택의 맨 위에 있는 요소를 제거하고 반환합니다.(LIFO, Last In First Out)
  


4️⃣ 시간 복잡도.


  
    삽입과 삭제 연산 : ‘addFirst‘, ‘addLast‘, ‘removeFirst‘, ‘removeLast‘, ‘offerFirst‘, ‘offerLast‘, ‘pollFirst‘, ‘pollLast‘, 등의 연산은 평균적으로 O(1)입니다.
  
  
    조회 연산 : ‘getFirst‘, ‘getLast‘, ‘peekFirst‘, ‘peekLast‘ 등의 연산은 O(1)입니다.
  
  
    크기 조정 : 베열의 크기가 가득 찼을 때 크기를 두 배로 늘리거나 줄이는 작업은 O(n) 시간이 걸리지만, 이는 드물게 발생하므로 평균적으로는 O(1)로 간주합니다. (amortized O(1)).
  


5️⃣ 예제 코드

아래의 코드는 ‘ArrayDeque‘ 를 사용한 예제 코드입니다.

import java.util.ArrayDeque;
import java.util.Deque;

public class ArrayDequeExample {

	public static void main(String[] args) {
		// ArrayDeque로 Deque 생성
		Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();

		// 요소 삽입
		System.out.println("=== 요소 삽입 ===");
		deque.addFirst(1);
		deque.addLast(2);
		deque.offerFirst(0);
		deque.offerLast(3);
		System.out.println(deque);
		System.out.println();

		// 요소 조회
		System.out.println("=== 요소 조회 ===");
		System.out.println("First element: " + deque.getFirst());
		System.out.println("Last element: " + deque.getLast());
		System.out.println("Peek first element: " + deque.peekFirst());
		System.out.println("Peek last element: " + deque.peekLast());
		System.out.println();

		// 요소 삭제
		System.out.println("=== 요소 삭제 ===");
		System.out.println("Removed first element: " + deque.removeFirst());
		System.out.println("Removed last element: " + deque.removeLast());
		System.out.println("Poll first element: " + deque.pollFirst());
		System.out.println("Poll last element: " + deque.pollLast());
		System.out.println();

		// 덱의 크기와 비어 있는지 여부 확인
		System.out.println("=== 덱의 크기와 비어 있는지 여부 확인 ===");
		System.out.println("Deque size: " + deque.size());
		System.out.println("Is deque empty? " + deque.isEmpty());
		System.out.println();
		
		// 스택 연산
		System.out.println("=== 스택 연산 ===");
		deque.push(4);
		System.out.println("Pushed element: " + deque.peekFirst());
		System.out.println("Popped element: " + deque.pop());
	}
}

/*
=== 출력 ===
=== 요소 삽입 ===
[0, 1, 2, 3]

=== 요소 조회 ===
First element: 0
Last element: 3
Peek first element: 0
Peek last element: 3

=== 요소 삭제 ===
Removed first element: 0
Removed last element: 3
Poll first element: 1
Poll last element: 2

=== 덱의 크기와 비어 있는지 여부 확인 ===
Deque size: 0
Is deque empty? true

=== 스택 연산 ===
Pushed element: 4
Popped element: 4
*/


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-05-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-05-TIL.html"><h1 class="title_post">📝 [TIL] 240605 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-05-TIL.html" class="txt_post">
                            
  Deque(덱, 데크))
  코딩테스트 입문 - 두 수의 합
  코딩테스트 입문 - 두 수의 차
  코딩테스트 입문 - 두 수의 곱
  코딩테스트 입문 - 몫 구하기


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-05-Deque.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-05-Deque.html"><h1 class="title_post">📦[DS,Algorithm] Deque(데크, 덱)</h1></a>
                        <a href="/Backend/AnD/2024-06-05-Deque.html" class="txt_post">
                            1️⃣ Deque(덱, Double Ended Queue)

Deque(덱, Double Ended Queue)는 양쪽 끝에서 삽입과 삭제를 할 수 있는 자료 구조입니다.

Java에서는 java.util 패키지에서 제공하는 Deque 인터페이스와 이를 구현한 클래스인 ArrayDeque 와 LinkedList 를 통해 사용할 수 있습니다.

Deque 는 큐(Queue)와 스택(Stack)의 기능을 모두 포함하고 있습니다.

1️⃣ 데크 기본 구조


  
    데크의 기본 구조는 양방향에서 삽입 삭제 가능한 구조
  
  
    일부 기능을 제한하여 용도에 맞게 변형 가능
  





  add나 remove 계열은 예외를 발생시킵니다.
    
      때문에 예외 처리가 가능합니다.
    
  
  offer이나 poll 계열은 null이나 false를 반환합니다.
    
      때문에 return값 (반환값)을 받아서 처리할 수 있습니다.
    
  


2️⃣ Deque의 주요 메서드.

1️⃣ 삽입 연산.


  addFirst(E e) : 지정된 요소를 덱의 앞쪽에 추가합니다.
  addLast(E e) : 지정된 요소를 덱의 뒤쪽에 추가합니다.
  offerFirst(E e) : 지정된 요소를 덱의 앞쪽에 추가합니다.
  offerLast(E e) : 지정된 요소를 덱의 뒤쪽에 추가합니다.


2️⃣ 삭제 연산.


  removeFirst() : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  removeLast() : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.
  pollFirst() : 덱의 앞쪽에서 요소를 제거하고 반환합니다.
  pollLast() : 덱의 뒤쪽에서 요소를 제거하고 반환합니다.


3️⃣ 조회 연산.


  getFirst() : 덱의 앞쪽에 있는 요소를 반환합니다.
  getLast() : 덱의 뒤쪽에 있는 요소를 반환합니다.
  peekFirst() : 덱의 앞쪽에 있는 요소를 반환합니다.
  peekLast() : 덱의 뒤쪽에 있는 요소를 반환합니다.


4️⃣ 기타 연산.


  size() : 덱에 있는 요소의 수를 반환합니다.
  isEmpty() : 덱이 비어 있는지 여부를 확인합니다.


3️⃣ 시간 복잡도.

Deque 인터페이스의 시간 복잡도는 이를 구현한 클래스에 따라 달라집니다.

Java에서는 주로 ArrayDeque 와 LinkedList 를 사용하여 Deque 를 구현합니다.

1️⃣ ArrayDeque


  삽입과 삭제 연산 (앞과 뒤 모두): 평균적으로 O(1)
  조회 연산 (앞과 뒤 모두): O(1)
  ArrayDeque 는 배열을 기반으로 구현되기 때문에, 배열이 꽉 차면 자동으로 크기를 늘리지만, 이 과정은 amortized O(1)로 간주됩니다.


2️⃣ LinkedList


  삽입과 삭제 연산 (앞과 뒤 모두): O(1)
  조회 연산 (앞과 뒤 모두): O(1)
  LinkedList 는 이중 연결 리스트로 구현되어 있어 각 노드가 이전과 다음 노드에 대한 참조를 가지고 있습니다.


LinkedList는 각 노드가 이전 노드와 다음 노드의 참조를 가지고 있어 삽입과 삭제가 O(1)의 시간 복잡도를 가집니다.
하지만 탐색에는 O(n)의 시간이 소요됩니다.

ArrayDeque는 배열을 사용하여 내부적으로 구현되기 때문에 삽입과 삭제 시에도 평균적으로 O(1)의 시간 복잡도를 가지며,
특히 큐의 끝에서의 연산이 빠릅니다.

다만, 내부적으로 배열이 가득 차면 크기를 조정해야 하므로 최악의 경우 O(n)의 시간 복잡도가 발생할 수 있습니다.


  Deque 는 다양한 상황에서 유연하게 사용될 수 있는 유용한 자료구조입니다.
특히 양쪽 끝에서의 빠른 삽입과 삭제가 필요한 경우 유용합니다.


3️⃣ 직접 Deque 인터페이스 구현.

간단한 배열을 사용하여 Deque 를 구현해보겠습니다.

import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class SimpleArrayDeque&lt;E&gt; {
  private static final int DEFALT_CAPACITY = 10;
  private E[] elements;
  private int head;
  private int tail;
  private int size;

  public SimpleArrayDeque() {
    elements = (E[]) new Object[DEFALT_CAPACITY];
    head = 0;
    tail = 0;
    size = 0;
  }

  public void addFirst(E e) {
    if (size == elements.length) {
      resize();
    }
    head = (head - 1 + elements.length) % elements.length;
    elements[head] = e;
    size++;
  }

  public void addLast(E e) {
    if (size == elements.length) {
      resize();
    }
    elements[tail] = e;
    tail = (tail + 1) % elements.length;
    size++;
  }

  public E removeFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    E element = elements[head];
    elements[head] = null; // for garbege collection
    head = (head + 1);
    size--;
    return element;
  }

  public E removeLast() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    tail = (tail - 1 + elements.length) % elements.length;
    E element = elements[tail];
    elements[tail] = null; // for garbage collection
    size--;
    return element;
  }

  public E getFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[head];
  }

  public E getLast() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[(tail - 1 + elements.length) % elements.length];
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size == 0;
  }

  private void resize() {
    int newCapacity = elements.length * 2;
    E[] newElements = (E[]) new Object[newCapacity];
    for (int i = 0; i &lt; size; i++) {
      newElements[i] = elements[(head + i) % elements.length];
    }
    elements = newElements;
    head = 0;
    tail = size;
  }

  public ArrayList&lt;E&gt; toArrayList() {
    return IntStream.range(0, size)
                    .mapToObj(i -&gt; elements[(head + i) % elements.length])
                    .collect(Collectors.toCollection(ArrayList::new));
  }
}

// Main
import java.util.ArrayList;

public class Main {

  public static void main(String[] args) {
    SimpleArrayDeque&lt;Integer&gt; deque = new SimpleArrayDeque&lt;&gt;();
    deque.addFirst(1);
    deque.addLast(2);
    deque.addFirst(0);
    deque.addLast(3);

    ArrayList&lt;Integer&gt; dequeList = deque.toArrayList();
    System.out.println("=== dequeList === ");
    System.out.println(dequeList);


    System.out.println("First element: " + deque.getFirst());
    System.out.println("Last element: " + deque.getLast());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Removed first element: " + deque.removeFirst());
    System.out.println("Remove last element: " + deque.removeLast());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Deque size: " + deque.size());
    System.out.println("Is deque empty? " + deque.isEmpty());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);
  }
}

/*
=== 출력 ===
=== dequeList === 
[0, 1, 2, 3]
First element: 0
Last element: 3
=== dequeList === 
[0, 1, 2, 3]
Removed first element: 0
Remove last element: 3
=== dequeList === 
[1, 2]
Deque size: 2
Is deque empty? false
=== dequeList === 
[1, 2]
*/


4️⃣ 입력 제한 Deque(Input-Restricted Deque).

입력 제한 Deque(Input-Restricted Deque)은 덱의 한쪽 끝에서만 삽입이 가능하고, 양쪽 끝에서 삭제가 가능한 자료구조입니다.

import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class InputRestrictedDeque&lt;E&gt; {
  private static final int DEFAULT_CAPACITY = 10;
  private E[] elements;
  private int head;
  private int tail;
  private int size;

  @SuppressWarnings("unchecked")
  public InputRestrictedDeque() {
    elements = (E[]) new Object[DEFAULT_CAPACITY];
    head = 0;
    tail = 0;
    size = 0;
  }

  public void addLast(E e) {
    if (size == elements.length) {
      resize();
    }
    elements[tail] = e;
    tail = (tail + 1) % elements.length;
    size++;
  }

  public E removeFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    E element = elements[head];
    elements[head] = null; // for garbage collection
    head = (head + 1) % elements.length;
    size--;
    return element;
  }

  public E removeLast() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    tail = (tail - 1 + elements.length) % elements.length;
    E element = elements[tail];
    elements[tail] = null; // for gatbage collection
    size--;
    return element;
  }

  public E getFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[head];
  }

  public E getLast() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[(tail - 1 + elements.length) % elements.length];
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size == 0;
  }

  private void resize() {
    int newCapacity = elements.length * 2;
    @SuppressWarnings("unchecked")
    E[] newElements = (E[]) new Object[newCapacity];
    for (int i = 0; i &lt; size; i++) {
      newElements[i] = elements[(head + i) % elements.length];
    }
    elements = newElements;
    head = 0;
    tail = size;
  }

  public ArrayList&lt;E&gt; toArrayList() {
    return IntStream.range(0, size)
                    .mapToObj(i -&gt; elements[(head + i) % elements.length])
                    .collect(Collectors.toCollection(ArrayList::new));
  }
}

// Main
import java.util.ArrayList;

public class Main {

  public static void main(String[] args) {
    InputRestrictedDeque&lt;Integer&gt; deque = new InputRestrictedDeque&lt;&gt;();
    deque.addLast(1);
    deque.addLast(2);
    deque.addLast(3);

    ArrayList&lt;Integer&gt; dequeList = deque.toArrayList();
    System.out.println("=== dequeList ===");
    System.out.println(dequeList);

    System.out.println("First element: " + deque.getFirst());
    System.out.println("Last element: " + deque.getLast());
    System.out.println("=== dequeList ===");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Remove first element: " + deque.removeFirst());
    System.out.println("Remove last elment: " + deque.removeLast());
    System.out.println("=== dequeList ===");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Deque size: " + deque.size());
    System.out.println("Is deque empty? " + deque.isEmpty());
  }
}
/*
=== 출력 ===
=== dequeList ===
[1, 2, 3]
First element: 1
Last element: 3
=== dequeList ===
[1, 2, 3]
Remove first element: 1
Remove last elment: 3
=== dequeList ===
[2]
Deque size: 1
Is deque empty? false
*/


1️⃣ 코드 설명.


  
    배열 초기화 : DEFAULT_CAPACITY 크기의 배열을 초기화하고, head, tail, size 변수를 초기화합니다.
  
  
    삽입 연산(addLast) : 요소를 덱의 마지막 에 추가합니다. 배열이 가득 차면 크기를 두 배로 늘립니다.
  
  
    삭제 연산(removeFirst, removeLaste) : 첫 번째 요소와 마지막 요소를 각각 제거합니다.
  
  
    조회 연산(getFirst, getLast) : 첫 번째 요소와 마지막 요소를 반환합니다.
  
  
    기타 메서드 : size 와 isEmpty 메서드는 덱의 크기와 덱이 비어 있는지 여부를 반환합니다.
  
  
    배열 크기 조정 (resize) : 배열이 가득 찰 때 호출되며, 배열의 크기를 두 배로 늘리고 요소를 새 배열로 복사합니다.
  



  이 예제에서는 요소를 덱의 끝에만 삽입할 수 있는 입력 제한 덱을 구현했습니다.
필요에 따라 이 구현을 확장하거나 수정하여 요구사항에 맞게 사용할 수 있습니다.


5️⃣ 출력 제한 Deque(Output-Restricted Deque).

출력 제한 Deque(Output-Restricted Deque)은 양쪽 끝에서 삽입이 가능하지만, 한쪽 끝에서만 삭제가 가능한 자료 구조입니다.

이 구조는 양쪽 끝에서 요소를 추가할 수 있지만, 삭제는 한쪽 끝에서만 할 수 있습니다.

import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class OutputRestrictedDeque&lt;E&gt; {
  private static final int DEFAULT_CAPACITY = 10;
  private E[] elements;
  private int head;
  private int tail;
  private int size;

  @SuppressWarnings("unchecked")
  public OutputRestrictedDeque() {
    elements = (E[]) new Object[DEFAULT_CAPACITY];
    head = 0;
    tail = 0;
    size = 0;
  }

  public void addFirst(E e) {
    if (size == elements.length) {
      resize();
    }
    head = (head - 1 + elements.length) % elements.length;
    elements[head] = e;
    size++;
  }

  public void addLast(E e) {
    if (size == elements.length) {
      resize();
    }
    elements[tail] = e;
    tail = (tail + 1) % elements.length;
    size++;
  }

  public E removeFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    E element = elements[head];;
    elements[head] = null; // for garbage collection
    head = (head + 1) % elements.length;
    size--;
    return element;
  }

  public E getFirst() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[head];
  }

  public E getLast() {
    if (size == 0) {
      throw new NoSuchElementException();
    }
    return elements[(tail - 1 + elements.length) % elements.length];
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size == 0;
  }

  private void resize() {
    int newCapacity = elements.length * 2;
    @SuppressWarnings("unchecked")
    E[] newElements = (E[]) new Object[newCapacity];
    for (int i = 0; i &lt; size; i++) {
      newElements[i] = elements[(head + 1) % elements.length];
    }
    elements = newElements;
    head = 0;
    tail = size;
  }

  public ArrayList&lt;E&gt; toArrayList() {
    return IntStream.range(0, size)
                    .mapToObj(i -&gt; elements[(head + i) % elements.length])
                    .collect(Collectors.toCollection(ArrayList::new));
  }
}

// Main
import java.util.ArrayList;

public class Main {

  public static void main(String[] args) {
    OutputRestrictedDeque&lt;Integer&gt; deque = new OutputRestrictedDeque&lt;&gt;();
    deque.addFirst(1);
    deque.addLast(2);
    deque.addFirst(0);
    deque.addLast(3);

    ArrayList&lt;Integer&gt; dequeList = deque.toArrayList();
    System.out.println("=== dequeList === ");
    System.out.println(dequeList);

    System.out.println("First element: " + deque.getFirst());
    System.out.println("Last element: " + deque.getLast());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Remove first element: " + deque.removeFirst());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);

    System.out.println("Deque size: " + deque.size());
    System.out.println("Is deque empty? " + deque.isEmpty());
    System.out.println("=== dequeList === ");
    dequeList = deque.toArrayList();
    System.out.println(dequeList);
  }
}

/*
=== 출력 ===
=== dequeList ===
[0, 1, 2, 3]
First element: 0
Last element: 3
=== dequeList ===
[0, 1, 2, 3]
Remove first element: 0
=== dequeList ===
[1, 2, 3]
Deque size: 3
Is deque empty? false
=== dequeList ===
[1, 2, 3]
*/


1️⃣ 코드 설명.


  
    배열 초기화 : DEFAULT_CAPACITY 크기의 배열을 초기화하고, head, tail, size 변수를 초기화 합니다.
  
  
    삽입 연산(addFirst, addLast) : 요소를 덱의 첫 번째 또는 마지막에 추가합니다. 배열이 가득 차면 크기를 두 배로 늘립니다.
  
  
    삭제 연산(removeFirst) : 첫 번째 요소를 제거합니다. 출력 제한 덱에서는 첫 번째 요소만 제거할 수 있습니다.
  
  
    조회 연산(getFirst, getLast) : 첫 번째 요소와 마지막 요소를 반환합니다.
  
  
    기타 메서드 : size 와 isEmpty 메서드는 덱의 크기와 덱이 비어 있는지 여부를 반환합니다.
  
  
    배열 크기 조정(resize) : 배열이 가득 찰 때 호출되며, 배열의 크기를 두 배로 늘리고 요소를 새 배열로 복사합니다.
  



  이 예제에서는 요소를 덱의 양쪽 끝에서 삽입할 수 있고, 첫 번째 요소만 제거할 수 있는 출력 제한 덱을 구현했습니다.
필요에 따라 이 구현을 확장하거나 수정하여 요구사항에 맞게 사용할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-03-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-03-TIL.html"><h1 class="title_post">📝 [TIL] 240603 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-03-TIL.html" class="txt_post">
                            
  IntStream


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-03-IntStream.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-03-IntStream.html"><h1 class="title_post">☕️[Java] IntStream</h1></a>
                        <a href="/Backend/Java/2024-06-03-IntStream.html" class="txt_post">
                            1️⃣ Java Docs - IntStream.


  Module : java.base
  Package : java.util.stream


Interface IntStream

All SuperInterfaces : AutoCloseble, BaseStream&lt;Integer, IntStream&gt;


  AutoCloseble
  BaseStream
  Integer
  IntStream




public interface IntStream extends BaseStream&lt;Integer, IntStream&gt;



  순차 및 병렬 집계 연산을 지원하는 기본 int 값 요소의 시퀀스입니다. 이것은 Stream의 int 기본형 특수화입니다.
    
      IntStream 이 Stream 의 한 형태로, int 값의 시퀀스를 처리하며 순차 및 병렬 연산을 지원한다는 의미입니다.
    
  
  다음 예제는 Stream과 IntStream을 사용하여 빨간색 위젯의 무게 합계를 계산하는 집계 연산을 보여줍니다.


int sum = widgets.stream()
                 .filter(w -&gt; w.getColor() == RED)
                 .mapToInt(w -&gt; w.getWeight())
                 .sum();



  streams(스트림), stream operations(스트림 연산), stream pipelines(스트림 파이프라인), and parallelism(및 병렬 처리)에 대한 추가적인 명세는 Stream 클래스 문서와 java.util.stream 패키지 문서를 참조하십시오.


Since : 1.8

Nested Class Summary

Nested Classes

  Modifier and Type: static interface
  Interface: IntStream.Builder
  Description: IntStream용 변경 가능한 빌더입니다.


2️⃣ IntStream.

IntStream 은 Java의 스트림 API(Stream API)의 일부로, 기본형 int 에 특화된 스트림을 나타냅니다.

IntStream 은 Java 8에서 도입된 스트림 API의 일부로, 컬렉션(리스트, 배열 등)과 같은 데이터 소스를 함수형 프로그래밍 스타일로 처리할 수 있게 해줍니다.

IntStream 은 Stream&lt;Integer&gt; 와는 달리 오토박싱과 언박싱의 오버헤드가 없는 것이 특징입니다.

🙋‍♂️ IntStream의 주요 기능

1. 생성:


  IntStream 을 생성하는 방법은 여러가지가 있습니다.
    
      예를 들어, 배열, 범위, 임의의 수 등을 사용하여 생성할 수 있습니다.
    
  


2. 연산:


  스트림 연산은 두 가지로 나뉩니다.
    
      중간 연산과 최종 연산.
        
          중간 연산은 또 다른 스트림을 반환하고, 지연(lazy) 평가됩니다.
          최종 연산은 스트림을 소비하여 결과를 반환합니다.
        
      
    
  


🙋‍♂️ IntStream 생성 방법.

1. of() 메서드:


  고정된 개수의 int 값을 스트림으로 생성합니다.


IntStream stream = IntStream.of(1, 2, 3, 4, 5);


2. range() 및 rangeClosed() 메서드:


  범위를 지정하여 스트림을 생성합니다. range 는 시작 값 포함, 끝 값 미포함, rangeClosed 는 시작 값과 끝 값을 모두 포함합니다.


IntStream stream = IntStream.range(0, 5); // 0, 1, 2, 3, 4, 5
IntStream closedStream = IntStream.rangeClosed(0, 5); // 0, 1, 2, 3, 4, 5


3. generate() 메서드:


  람다 표현식을 사용하여 무한 스트림을 생성합니다.
    
      🚨 주의: 무한 스트림은 반드시 제한을 걸아야 합니다.
    
  


IntStream stream = IntStream.generate(() -&gt; 1).limit(5); // 1, 1, 1, 1, 1


4. iterate() 메서드:


  초기값과 반복 함수로 스트림을 생성합니다.


IntStream stream = IntStream.iterate(0, n -&gt; n + 2).limit(5); // 0, 2, 4, 6, 8


5. builder() 메서드:


  IntStream.Builder 를 사용하여 스트림을 생성합니다.


IntStream.Builder builder = IntStream.builder()l
builder.add(1).add(2).add(3).add(4).add(5);
IntStream stream = builder.builder();


6. 배열에서 생성:


  배열을 스트림으로 변환합니다.


int[] array = {1, 2, 3, 4, 5};
IntStream stream = Arrays.stream(array);


🙋‍♂️ IntStream의 주요 메서드.

1. 중간 연산:


  map() : 각 요소에 함수 적용.
  filter() : 조건에 맞는 요소만 통과
  distinct() : 중복 요소 제거
  sorted() : 정렬
  limit() : 스트림 크기 제한
  skip() : 처음 n개 요소 건너뛰기


2. 최종 연산:


  forEach() : 각 요소에 대해 액션 수행
  toArray() : 배열로 변환
  reduce() : 모든 요소를 누적하여 하나의 값으로
  collect() : 컬렉션으로 변환
  sum() : 합계 연산
  average() : 평균 계산
  min(), max() : 최소, 최대값 찾기
  count() : 요소 개수 반환


💻 예제 코드

예제 1: 0에서 5까지 거꾸로 출력.

import java.util.stream.IntStream;

public class Reverse {

	public static void main(String[] args) {
		IntStream.rangeClosed(0, 5)
		         .map(i -&gt; 5 - i)
		         .forEach(System.out::println);
	}
}
/*
=== 출력 ===
5
4
3
2
1
0
*/


예제 2: 배열의 합계 계산

import java.util.stream.IntStream;

public class ArraySum {

	public static void main(String[] args) {
		int[] array = {1, 2, 3, 4, 5};
		int sum = IntStream.of(array).sum();
		System.out.println("sum = " + sum); // sum = 15
	}
}


예제 3: 짝수 필터링

import java.util.stream.IntStream;

public class FilterEvenNumber {

	public static void main(String[] args) {
		IntStream.rangeClosed(1, 10)
		         .filter(n -&gt; n % 2 == 0)
		         .forEach(System.out::println);
	}
}
/*
=== 출력 ===
2
4
6
8
10
*/


📝 요약

IntStream 은 Java의 스트림 API의 일부분으로, 기본형 int에 특화된 스트림입니다.

이를 통해 컬렉션이나 배열을 함수형 프로그래밍 스타일로 처리할 수 있습니다.

IntStream 은 다양한 생성 방법과 중간 및 최종 연산을 제공하여 효율적이고 직관적인 데이터 처리를 가능하게 합니다.

📚 참고 문헌.

  Java Docs - IntStream


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-02-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-02-TIL.html"><h1 class="title_post">📝 [TIL] 240602 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-02-TIL.html" class="txt_post">
                            
  자바의 배열
  JAVA DOCS 보는 법


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-06-02-HowToReadJavaDocs.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-06-02-HowToReadJavaDocs.html"><h1 class="title_post">📝[blog post] Java Docs 보는 방법.</h1></a>
                        <a href="/Backend/Post/2024-06-02-HowToReadJavaDocs.html" class="txt_post">
                            📝 Java Docs를 읽는 능력이 필요한 이유. :)

저는 Documentation이 그 어떤 유명 테크 블로거의 글 보다 중요하고 심도있게 읽어야 한다는 개인적인 의견이 있습니다.

그 이유는 Java를 개발한 개발자분들이 직접 만든 설명서나 다름 없기 때문입니다.

우리가 레고를 생각해 봅시다.

내가 좋아하는 레고를 사서 집에서 조립할 때 무엇을 보나요? 🤔

맞습니다!

레고 패키지 안에 들어있는 “설명서”를 기반으로 레고를 조립합니다.

레고를 디자인하고 만드신 분이 직접 “이렇게 순서대로 만들면 당신이 원하는 멋진 레고 완성품을 얻을 수 있습니다!” 라는 것을 직.간접적으로 보여주는 아주 자세한 설명이 들어있죠 📝

설명서는 직접 디자인하고 설계한 사람의 철학과 그들이 왜 그렇게 만들었는지 그리고 어떻게 쓰여야하는지 정확, 명료하게 명시되어 있습니다.

또한 다른 구성품과 맞춰볼 수 있는 것도 제안하거나 보여주기도 합니다.

그래서 Documentation을 보고 제대로 활용할 줄 아는 것이 개발자에게는 중요한 능력 중 하나가 아닐까 하는 생각을 합니다 🙋‍♂️

1️⃣ Java Documentation 보기.

1. 온라인 문서.


  Java SE Documentation은 Oracle 공식 사이트에서 제공됩니다.
    
      Java 버전에 따라 다른 문서가 제공되니, 사용하는 Java 버전에 맞는 문서를 선택해야 합니다.
    
  


2. IDE 내장 문서.


  많은 통합 개발 환경(IDE)에는 JavaDoc을 쉽게 볼 수 있는 기능이 내장되어 있습니다. InteillJ IDEA, Eclipes, NetBeans 등에서 코드 작성 시 JavaDocs를 볼 수 있습니다.
    
      예를 들어, IntelliJ IDEA에서 클래스나 메소드 이름 위에 커서를 올리면 해당 클래스나 메소드의 JavaDoc이 팝업으로 표시됩니다.
    
  


3. 로컬 문서.


  Java JDK를 설치할 때, JavaDoc을 로컬에 다운로드할 수 있습니다. 이를 통해 인터넷 연결 없이도 문서를 참조할 수 있습니다.
  JDK 설치 경로 아래의 docs 폴더에 HTML 형식의 문서가 저장되어 있습니다.


2️⃣ Java Documentation 활용 방법

Java Documentation을 효과적으로 활용하는 방법을 알아봅시다.🤩

1. 클래스 및 메소드 탐색.


  API 문서에서 패키지, 클래스, 메소드, 필드 등의 세부 정보를 탐색할 수 있습니다.
    
      예를 들어, java.util 패키지에 어떤 클래스가 포함되어 있는지, ArrayList 클래스에 어떤 메소드가 있는지 등을 확인할 수 있습니다.
    
  


2. 사용 예제 찾기.


  각 클래스와 메소드에는 사용 예제가 포함되어 있을 수 있습니다. 이러한 예제는 해당 API를 올바르게 사용하는 방법을 이해하는 데 도움이 됩니다.


3. 메소드 시그니처 및 설명.


  메소드의 매개변수, 반환값, 예외 등을 설명하는 시그니처와 설명을 통해 메소드의 사용법을 정확히 알 수 있습니다.
    
      예를 들어, String 클래스의 substring 메소드의 시그니처와 설명을 보면, 매개변수로 전달해야 할 값과 반환되는 값에 대한 정보를 얻을 수 있습니다.
    
  


4. 상속 구조 및 인터페이스.


  클래스가 구현하는 인터페이스와 상속받는 클래스에 대한 정보를 확인할 수 있습니다. 이를 통해 클래스의 기능을 확장하거나 인터페이스를 구현하는 방법을 이해할 수 있습니다.


3️⃣ 예제

다음은 Java Documentation을 활용하는 몇 가지 예제입니다.

예제 1: ArrayList 클래스의 메소드 사용법 확인 🙋‍♂️


  온라인 문서에서 ArrayList 클래스를 찾습니다.
    
      Java SE Documentation에서 java.util.ArrayList 를 검색합니다.
      ArrayList 클래스의 API 문서를 열어 메소드 목록을 확인합니다.
    
  
  add(E e) 메소드 사용법 확인하기.
    
      add(E e) 메소드는 리스트의 끝에 요소를 추가하는 메소드입니다.
      메소드 설명을 읽고, 예제를 확인하여 사용법을 이해합니다.
    
  


예제 2. String 클래스의 substring 메소드 사용법 확인 🙋‍♂️


  IDE 내장 문서 활용하기.
    
      IntelliJ IDEA나 Eclipse에서 String 클래스의 substring 메소드를 사용하려고 할 때, 메소드 이름 위에 커서를 올리면 JavaDoc이 표시됩니다.
      JavaDoc을 통해 substring(int beingIndex, int endIndex) 메소드의 매개변수와 반환 값에 대한 설명을 읽습니다.
    
  


public class Main {
    public static void main(String[] args) {
        String text = "Hello, World!";
        String subText = text.substring(7, 12); // "World"
        System.out.println(subText);
    }
}


위 예제에서 substring 메소드의 매개변수가 beginIndex 와 endIndex 임을 알 수 있으며, 이는 시작 인덱스부터 종료 인덱스 전까지의 문자열을 반환합니다.

예제 3. 예외 처리 방법 확인 🙋‍♂️


  예외 클래스 문서 확인하기.
    
      java.lang.NullPointerException 클래스의 문서를 확인하여 언제 이 예외가 발생하는지, 그리고 이를 어떻게 처리할 수 있는지에 대한 정보를 얻습니다.
    
  
  예외 처리 예제


public class Main {
    public static void main(String[] args) {
        try {
            String text = null;
            System.out.println(text.length());
        } catch (NullPointerException e) {
            System.out.println("Caught a NullPointerException");
        }
    }
}


이 예제는 NullPointException 이 발생할 때 이를 처리하는 방법을 보여줍니다.

📝 요약.


  Java Documentation은 Java API를 이해하고 사용하는 데 필수적인 자료입니다.
  Java Documentation를 온라인, IDE, 또는 로컬에서 접근할 수 있습니다.
  API 문서를 통해 클래스와 메소드의 세부 정보를 확인하고, 예제를 참고하여 올바르게 사용하는 방법을 배울 수 있습니다.
  상속 구조와 인터페이스 구현 방법을 이해하여 코드의 재사용성과 확장성을 높일 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-02-ArrayOfJava.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-02-ArrayOfJava.html"><h1 class="title_post">📦[DS,Algorithm] Java의 배열.</h1></a>
                        <a href="/Backend/AnD/2024-06-02-ArrayOfJava.html" class="txt_post">
                            1️⃣ Java의 배열.

1️⃣ 배열이란 무엇인가?

배열(Array)은 동일한 타입의 여러 요소를 하나의 변수로 관리할 수 있게 해주는 자료구조입니다.

배열은 연속된 메모리 공간에 할당되며, 각 요소는 인덱스를 통해 접근할 수 있습니다.

2️⃣ 배열의 선언과 초기화.

Java에서 배열은 다음과 같이 선언하고 초기화할 수 있습니다.

int[] array = new int[5]; // 크기가 5인 정수형 배열 선언.
int[] array = {10, 20, 30, 40, 50}; // 초기화와 동시에 배열 선언


3️⃣ 배열의 요소와 접근.

배열의 각 요소는 인덱스를 통해 접근할 수 있으며, 인덱스는 0부터 시작합니다.

int firstElement = array[0]; // element = 10, 첫 번째 요소에 접근
array[1] = 25; // [10, 25, 30, 40, 50], 두 번째 요소에 값 25를 저장


4️⃣ 배열의 시간 복잡도.

배열의 시간 복잡도는 연산의 종류에 따라 다릅니다.

아래는 일반적인 배열 연산과 그 시간 복잡도를 설명한 것입니다.

1. 접근(Access)


  특정 인덱스의 요소에 접근하는 시간 복잡도는 O(1)입니다.
    
      이유 : 배열은 연속된 메모리 공간에 저장되므로 인덱스를 통해 바로 접근할 수 있기 때문입니다.
    
  


// 접근(Access)
int element = array[2]; 
// element = 30,  time complexity = O(1)
// [10, 25, 30, 40, 50]


2. 탐색(Search)


  배열에서 특정 값을 찾는 시간 복잡도는 O(n)입니다.
    
      이유: 최악의 경우 배열의 모든 요소를 검사해야 할 수도 있기 때문입니다.
    
  


boolean found = false;
int target = 30;

for (int i = 0; i &lt; array.length; i++) {
    if (array[i] == target) { // i = 2, array[i] = 30
        found = true;
        break;
    }
}
// [10, 25, 30, 40, 50]


3. 삽입(Insertion)


  배열의 끝에 요소를 추가하는 시간 복잡도는 O(1)입니다.
  배열의 특정 위치에 요소를 삽입하는 시간 복잡도는 O(n)입니다.
    
      이유: 특정 위치에 삽입하기 위해서는 해당 위치 이후의 모든 요소를 한 칸씩 뒤로 밀어야 하기 때문입니다.
    
  


// 삽입(Insertion)

// 배열 삽입시 index가 array.length가 아니고 array.length - 1인 이유는
// array.length는 배열의 크기, 즉 5를 나타내기 때문입니다.
// index는 0부터 시작하기 때문에 배열의 크기가 5인 배열의 끝 index는 4입니다.
// 때문에 array.length - 1을 해줍니다.

array[array.length - 1] = 60; // 배열 끝에 삽입 (O(1)), [10, 25, 30, 40, 60]

// 배열 중간에 삽입하는 메서드
public static void insertion(int[] array, int index, int insertValue) {
  // 배열 중간에 삽입(O(n))
  for (int i = array.length - 1; i &gt; index; i--) {
    array[i] = array[i - 1];
  }
  array[index] = insertValue;
  System.out.println(Arrays.toString(array));
}


4. 삭제(Deletion)


  배열의 끝에서 요소를 제거하는 시간 복잡도는 O(1)입니다.
  배열의 특정 위치의 요소를 제거하는 시간 복잡도는 O(n)입니다.
    
      이유: 특정 위치의 요소를 제거한 후에는 해당 위치 이후의 모든 요소를 한 칸씩 앞으로 당겨야 하기 때문입니다.
    
  


// 삭제(Deletion)
    array[array.length - 1] = 0; // 배열의 끝에서 삭제 ((O(1)), [10, 25, 30, 77, 0]
    System.out.println(Arrays.toString(array));

    // 배열 중간에서 삭제하는 메서드
    int deletionValue = deletion(array, 2);
    System.out.println(deletionValue); // 30

// 배열 중간에 삭제하는 메서드
  public static int deletion(int[] array, int index) {
    // 배열 중간에 삭제(O(n))
    int[] returnValue = new int[array.length];

    for (int i = index, j = 0; i &lt; array.length - 1 ; i++) {
      returnValue[j] = array[i];
      j++;
      array[i] = array[i + 1];

    }
    array[array.length - 1] = 0; // 마지막 요소 초기화.
    int deletionValue = returnValue[0]; // 배열을 메모리에서 지우기
    returnValue = null;
    return deletionValue;
  }


5️⃣ 배열의 장점과 단점.

장점.

  빠른 접근 속도 : 인덱스를 통해 O(1) 시간에 요소를 접근할 수 있습니다.
  메모리 효율 : 연속된 메모리 공간을 사용하므로 메모리 사용이 효율적입니다.


단점.

  고정된 크기 : 배열의 크기는 선언 시에 고정되므로, 실행 중에 크기를 변경할 수 없습니다.
  삽입 및 삭제의 비효율성 : 배열 중간에 요소를 삽입하거나 삭제할 때 O(n)의 시간이 소요됩니다.
  연속된 메모리 할당 필요 : 큰 배열을 사용할 떄는 연속된 메모리 공간이 필요하여 메모리 할당에 제한이 있을 수 있습니다.



  배열은 이러한 특성들로 인해 빠른 접근이 필요한 상황에서는 매우 유용하지만, 삽입 및 삭제가 빈번히 일어나는 경우에는 비효율적일 수 있습니다.
따라서 상황에 맞게 적절한 자료구조를 선택하는 것이 중요합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-01-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-01-TIL.html"><h1 class="title_post">📝 [TIL] 240601 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-01-TIL.html" class="txt_post">
                            
  배열의 특정 인덱스의 요소를 삭제하는 방법.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-06-01-RemoveSpecificIndexFromArray.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-06-01-RemoveSpecificIndexFromArray.html"><h1 class="title_post">📦[DS,Algorithm] 배열에서 특정 인덱스의 요소를 삭제하기.</h1></a>
                        <a href="/Backend/AnD/2024-06-01-RemoveSpecificIndexFromArray.html" class="txt_post">
                            1️⃣ 배열에서 특정 인덱스의 요소를 삭제하기.

Java에서 배열의 특정 인덱스의 요소를 삭제하는 방법은 배열의 구조 특성상 직접적으로 제공되지 않습니다.

때문에 일반적으로 요소를 삭제하기 위해 다음의 방법을 사용합니다.

2️⃣ 배열에서 요소를 삭제하는 방법 2가지.

1️⃣ 새로운 배열을 생성하여 요소를 복사하는 방법 :)

● 특정 인덱스의 요소를 건너뛰고 나머지 요소를 새로운 배열에 복사합니다.

방법 1 : 새로운 배열 생성하여 복사.
// 배열의 특정 인덱스의 요소를 삭제하는 방법 - 1
// 방법1. 새로운 배열을 생성하여 요소를 복사하는 방법
// - 특정 인덱스의 요소를 건너뛰고 나머지 요소를 새로운 배열에 복사합니다.
public class Main {

  public static void main(String[] args) {
    int[] array = {10, 20, 30, 40, 50};
    array = removeElement(array, 0);

    for (int value : array) {
      System.out.println(value + " ");
    }

  }

  // 특정 배열을 지우는 메소드
  public static int[] removeElement(int[] array, int index) {
    if (index &lt; 0 || index &gt;= array.length) {
      throw new IndexOutOfBoundsException("Index out of bounds");
    }
    
    // 새로운 배열은 특정 요소를 지우기 때문에 기존 배열의 크기에서 -1 한 크기로 생성합니다.
    int[] newArray = new int[array.length - 1];

    for (int i = 0, j = 0; i &lt; array.length; i++) {

      if (i != index) {
        newArray[j++] = array[i];
      }
    }
    return newArray;
  }
}
/* 
=== 출력 ===
20 
30 
40 
50 
*/


  “방법1의 장.단점”
    
      새 배열 생성 : 메모리 사용량이 증가하지만, 원래 배열을 유지하고 싶은 경우 유용합니다.
    
  


2️⃣ 기존 배열을 이용하여 요소를 덮어쓰는 방법 :)

● 특정 인덱스 이후의 요소들을 앞으로 한 칸씩 이동시켜 덮어씁니다.

방법 2 : 기존 배열을 이용하여 요소 덮어쓰기.
// 배열의 특정 인덱스의 요소를 삭제하는 방법 - 2
// 방법2. 기존 배열을 이용하여 요소를 덮어쓰는 방법.
// - 특정 인덱스 이후의 요소들을 앞으로 한 칸씩 이동시켜 덮어 씁니다.
public class Main {

  public static void main(String[] args) {
    int[] array = {10, 20, 30, 40, 50};
    array = removeElementInPlace(array, 0);

    for (int value : array) {
      System.out.println(value + " ");
    }
  }

  public static int[] removeElementInPlace(int[] array, int index) {
    if (index &lt; 0 || index &gt;= array.length) {
      throw new IndexOutOfBoundsException("Index out of bounds");
    }

    for (int i = index; i &lt; array.length - 1; i++) {
      array[i] = array[i + 1];
    }

    // 배열의 마지막 요소를 0 또는 다른 기본값으로 설정 (선택 사항)
    array[array.length - 1] = 0;

    return array;
  }
}
/*
=== 출력 ===
20 
30 
40 
50 
0 
*/ 


  “방법2의 장.단점”
    
      기존 배열 사용 : 메모리를 절약할 수 있지만, 배열의 마지막 요소는 기본값으로 설정해야 합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-30-Queue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-30-Queue.html"><h1 class="title_post">📦[DS,Algorithm] 큐(Queue)</h1></a>
                        <a href="/Backend/AnD/2024-05-30-Queue.html" class="txt_post">
                            1️⃣ 큐(Queue).

큐(Queue)는 선형 자료구조 중 하나로, 데이터가 들어온 순서대로 처리되는 선입선출(FIFO, First In First Out) 구조를 가집니다.

1️⃣ 큐(Queue).

큐(Queue)는 가장 먼저 삽입된 데이터가 가장 먼저 제거됩니다.

2️⃣ 큐(Queue)의 연산.




  Enqueue : 큐의 뒤(rear) 끝에 데이터를 추가하는 연산입니다.





  
    Dequeue : 큐의 앞(front) 끝에서 데이터를 제거하고 반환하는 연산입니다.
  
  
    front 또는 Peek : 큐의 앞 끝에 있는 데이터를 제거하지 않고 반환하는 연산.
  
  
    isEmpty : 큐가 비어 있는지 확인하는 연산.
  
  
    Size : 큐에 저장된 데이터의 개수를 반환하는 연산.
  


3️⃣ 큐(Queue)의 실제 응용 사례.


  프린터 작업 대기열.
  CPU 작업 스케줄링.
  BFS(Breath-First Search, 너비 우선 탐색)



  큐는 배열이나 연결 리스트를 이용하여 구현할 . 수있습니다.


4️⃣ 큐의 시간 복잡도.

큐의 각 연산은 다음과 같은 시간 복잡도를 가집니다.


  Enqueue : O(1)
    
      큐의 뒤 끝에 데이터를 추가하는 연산은 항상 일정한 시간 내에 완료됩니다.
    
  
  Dequeue : O(1)
    
      큐의 앞 끝에서 데이터를 제거하는 연산도 항상 일정한 시간 내에 완료됩니다.
    
  
  Front 또는 Peek : O(1)
    
      큐의 앞 끝에 있는 데이터를 확인하는 연산은 데이터 접근만 필요하기 때문에 일정한 시간 내에 완료됩니다.
    
  
  isEmpty : O(1)
    
      큐가 비어 있는지 확인하는 연산은 큐의 크기만 확인하면 되므로 일정한 시간 내에 완료됩니다.
    
  
  Size : O(1)
    
      큐에 현재 저장된 데이터의 개수를 반환하는 연산도 일정한 시간 내에 완료됩니다.
    
  


5️⃣ 큐의 구현


  배열을 이용한 큐는 고정된 크기를 가지며, 원형 큐(Circular Queue)로 구현하여 배열의 끝에서 시작으로 순환할 수 있도록 합니다.


배열을 이용한 큐 구현.
// ArrayQueue
public class ArrayQueue {
  private int maxSize; // 큐의 최대 크기
  private int front; // 큐의 앞 끝을 가리키는 인덱스
  private int rear; // 큐의 뒤 끝을 가리키는 인덱스
  private int[] queueArray; // 큐를 저장할 배열
  private int nItems; // 큐에 저장된 데이터의 개수

  // 생성자
  public ArrayQueue(int size) {
    maxSize = size;
    queueArray = new int[maxSize];
    front = 0;
    rear = -1;
    nItems = 0;
  }

  // 큐의 값을 Enqueue하는 메소드.
  public void enqueue(int value) {
    if (isFull()) {
      System.out.println("큐가 가득 찼습니다.");
      return;
    }

    if (rear == maxSize - 1) {
      rear = -1; // 원형 큐 처리
    }

    queueArray[++rear] = value;
    nItems++;
  }

  // 큐에서 값을 dequeue하는 메소드.
  public int dequeue() {
    if (isEmpty()) {
      System.out.println("큐가 비어있습니다.");
      return -1; // 에러를 나타내기 위해 -1 반환.
    }
    int temp = queueArray[front++];

    if (front == maxSize) {
      front = 0; // 원형 큐 처리.
    }
    nItems--;
    return temp;
  }

  // 큐의 앞 끝 값을 반환하는 메소드
  public int peekFront() {
    if (isEmpty()) {
      System.out.println("큐가 비어있습니다.");
      return -1; // 에러를 나타내기 위해  -1 반환.
    }
    return queueArray[front];
  }

  // 큐가 비어있는지 확인하는 메소드.
  public boolean isEmpty() {
    return (nItems == 0);
  }

  // 큐가 가득 찼는지 확인하는 메소드.
  public boolean isFull() {
    return (nItems == maxSize);
  }

  // 큐의 크기를 반환하는 메소드.
  public int size() {
    return nItems;
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    ArrayQueue queue = new ArrayQueue(5); // 크기가 5인 큐 생성.

    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    queue.enqueue(4);
    queue.enqueue(5);

    System.out.println("=== 출력 ===");
    System.out.println();
    System.out.println("Queue의 앞 끝 값: " + queue.peekFront());
    System.out.println("Queue의 크기: " + queue.size());

    // while 문의 조건은 queue가 비어있을 경우 false 이므로 순회하지 않습니다.
    // 그러나 queue가 비어있지 않을 경우 true가 되므로 while 블록을 들어가 queue가 비어있을 때까지(!queue.isEmpty()) 동작합니다.
    while (!queue.isEmpty()) {
      System.out.println("Dequeue : " + queue.dequeue());
    }

    System.out.println("Queue의 크기 : " + queue.size());

  }
}

/*
=== 출력 ===

Queue의 앞 끝 값: 1
Queue의 크기: 5
Dequeue : 1
Dequeue : 2
Dequeue : 3
Dequeue : 4
Dequeue : 5
Queue의 크기 : 0
*/


7️⃣ 큐(Queue) 기본 구조.

큐(Queue)는 선형 자료구조 중 하나로, 데이터를 선입선출(FIFO, First In First Out) 방식으로 처리합니다.

👉 1️⃣ 큐의 기본 구성 요소.


  
    Front : 큐의 가장 앞쪽을 가리키는 포인터 입니다. Dequeue 연산이 발생할 때 데이터를 제거하는 위치를 나타냅니다.
  
  
    Rear : 큐의 가장 뒤쪽을 카리키는 포인터 입니다. Enqueue 연산이 발생할 때 데이터를 추가하는 위치를 나타냅니다.
  
  
    Queue Array(또는 List) : 큐의 데이터를 저장하는 자료구조. 배열이나 연결 리스트를 사용할 수 있습니다.
  




👉 2️⃣ 연결 리스트를 이용한 큐의 구현 방법.


  연결 리스트를 이용한 큐는 동적으로 크기를 조절할 수 있으며, 각 노드가 데이터와 다음 노드를 가리키는 포인터를 포함합니다.


// LinkedListQueue
public class LinkedListQueue {
  private class Node {
    int data;
    Node next;

    Node(int data) {
      this.data = data;
    }
  }

  private Node front; // 큐의 앞쪽 노드.
  private Node rear; // 큐의 뒤쪽 노드.
  private int size; // 큐에 저장된 데이터의 개수.

  // 생성자
  public LinkedListQueue() {
    front = null;
    rear = null;
    size = 0;
  }

  // 큐의 값을 추가하는 메소드.
  public void enqueue(int value) {
    Node newNode = new Node(value);

    if (isEmpty()) {
      front = newNode;
    } else {
      rear.next = newNode;
    }
    rear = newNode;
    size++;
  }

  // 큐에서 값을 제거하고 반환하는 메소드.
  public int dequeue() {
    if (isEmpty()) {
      System.out.println("큐가 비어있습니다.");
      return -1; // 에러를 나타내기 위해 -1 반환.
    }

    int value = front.data;
    front = front.next;

    if (front == null) {
      rear = null;
    }

    size--;

    return value;
  }

  // 큐의 앞쪽 값을 반환하는 메소드.
  public int peekFront() {
    if (isEmpty()) {
      System.out.println("큐가 비어있습니다.");
      return -1; // 에러를 나타내기 위해  -1 반환.
    }
    return front.data;
  }

  // 큐가 비어있는지 확인하는 메소드.
  public boolean isEmpty() {
    return (front == null);
  }

  // 큐의 크기를 반환하는 메소드.
  public int size() {
    return size;
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    LinkedListQueue queue = new LinkedListQueue();

    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    queue.enqueue(4);
    queue.enqueue(5);

    System.out.println("=== 출력 ===");
    System.out.println();
    System.out.println("Queue의 앞 끝 값 : " + queue.peekFront());
    System.out.println("Queue의 크기 : " + queue.size());

    // while 문의 조건은 queue가 비어있을 경우 false 이므로 순회하지 않습니다.
    // 그러나 queue가 비어있지 않을 경우 true가 되므로 while 블록을 들어가 queue가 비어있을 때까지(!queue.isEmpty()) 동작합니다.
    while (!queue.isEmpty()) {
      System.out.println("Dequeue : " + queue.dequeue());
    }

    System.out.println("Queue의 크기 : " + queue.size());
  }
}
/*
=== 출력 ===

Queue의 앞 끝 값: 1
Queue의 크기: 5
Dequeue : 1
Dequeue : 2
Dequeue : 3
Dequeue : 4
Dequeue : 5
Queue의 크기 : 0
*/


이와 같이 큐는 연결 리스트를 이용하여 구현할 수 있습니다.


  큐를 배열 또는 연결 리스트를 이용하여 구현했을 때 각각의 장단점.

  배열 기반 큐는 간단하고 빠르지만 고정된 크기 문제를 해결해야 합니다.

  연결 리스트 기반 큐는 동적으로 크기를 조절할 수 있지만 메모리 사용량이 더 많을 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-30</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-30-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-30-TIL.html"><h1 class="title_post">📝 [TIL] 240530 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-30-TIL.html" class="txt_post">
                            
  다양한 입출력 방법
  큐(Queue)
  큐 구현(LinkedList)
  큐 구현(List)
  큐 구현(Array)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-30</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-29-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-29-TIL.html"><h1 class="title_post">📝 [TIL] 240529 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-29-TIL.html" class="txt_post">
                            
  스택 문제 풀이


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-29</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-28-Stack.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-28-Stack.html"><h1 class="title_post">📦[DS,Algorithm] 스택(Stack)</h1></a>
                        <a href="/Backend/AnD/2024-05-28-Stack.html" class="txt_post">
                            1️⃣ 스택(Stack).

스택(Stack)은 자료구조의 한 종류로, 데이터가 일렬로 쌓이는 구조를 가지고 있습니다.

1️⃣ 스택(Stack)의 특징.

“후입선출(LIFO, Last In First Out)”로, 가장 나중에 삽입된 데이터가 가장 먼저 꺼내진다는 점이 특징입니다.

2️⃣ 스택(Stack)의 기본 연산.


  
    푸시(Push) : 스택의 맨 위에 데이터를 삽입하는 연산.
  
  
    팝(Pop) : 스택의 맨 위에 있는 데이터를 제거하고 반환하는 연산.
  


3️⃣ 스택(Stack)의 부가적인 연산.


  
    피크(peek) 또는 탑(top) : 스택의 맨 위에 있는 데이터를 제거하지 않고 반환하는 연산.
  
  
    isEmpty : 스택이 비어 있는지 여부를 확인하는 연산.
  
  
    size : 스택에 있는 데이터의 개수를 반환하는 연산.
  


4️⃣ 스택(Stack)의 실제 응용 사례.


  웹 브라우저의 방문 기록(뒤로 가기 기능)
  함수 호출시의 호출 스택
  역폴란드 표기법 계산 등


5️⃣ 스택(Stack)의 구현.

스택은 배열이나 연결 리스트를 이용하여 구현할 수 있습니다.

배열을 이용한 스택 구현은 고정된 크기를 가지며, 연결 리스트를 이용한 스택 구현은 동적으로 크기를 조절할 수 있습니다.


  
    배열을 이용한 스택 : 고정된 크기의 배열을 사용하여 스택을 구현할 수 있습니다. 이 경우 스택의 크기가 초과되면 더 큰 배열로 복사하는 추가 작업이 필요할 수 있습니다.
  
  
    연결 리스트를 이용한 스택 : 동적으로 크기를 조절할 수 있는 연결 리스트를 사용하여 스택을 구현할 수 있습니다. 연결 리스트의 노드 삽입 및 삭제는 O(1)의 시간 복잡도를 가지므로, 스택 연산을 효율적으로 수행할 수 있습니다.
  


6️⃣ 시간 복잡도

스택의 각 연산은 일반적으로 다음과 같은 시간 복잡도를 가집니다.


  Push : O(1)
    
      데이터를 스택의 맨 위에 추가하는 연산은 항상 일정한 시간 내에 완료됩니다.
    
  
  Pop : O(1)
    
      데이터를 스택의 맨 위에서 제거하는 연산도 항상 일정한 시간 내에 완료됩니다.
    
  
  Peek 또는 Top : O(1)
    
      스택의 맨 위에 있는 데이터를 확인하는 연산은 데이터 접근만 필요하기 때문에 일정한 시간 내에 완료됩니다.
    
  
  isEmpty : O(1)
    
      스택이 비어 있는지 확인하는 연산은 스택의 크기만 확인하면 되프로 일정한 시간 내에 완료됩니다.
    
  
  Size : O(1)
    
      스택에 있는 데이터의 개수를 반환하는 연산은 스택의 크기 정보를 유지하고 있으면 일정한 시간 내에 완료됩니다.
    
  


7️⃣ 스택 구현.
// Stack
public class Stack {
  private int maxSize; // 스택의 최대 크기
  private int top; // 스택의 맨 위를 가리키는 인덱스
  private int[] stackArray; // 스택을 저장할 배열

  // 생성자
  public Stack(int size) {
    maxSize = size;
    stackArray = new int[maxSize];
    top = -1; // 스택이 비어있음을 나타냄
  }

  // 스택에 값을 푸시하는 메소드
  public void push(int value) {
    if (isFull()) {
      System.out.println("스택이 가득 찼습니다.");
      return;
    }
    stackArray[++top] = value;
  }

  // 스택에서 값을 팝하는 메소드
  public int pop() {
    if (isEmpty()) {
      System.out.println("스택이 비어있습니다.");
      return -1; // 에러를 나타내기 위해 -1 반환
    }
    return stackArray[top--];
  }

  // 스택의 맥 위 값을 반환하는 메소드
  public int peek() {
    if (isEmpty()) {
      System.out.println("스택이 비어있습니다.");
      return -1; // 에러를 나타내기 위해 -1 반환
    }
    return stackArray[top];
  }

  // 스택이 비어있는지 확인하는 메소드
  public boolean isEmpty() {
    return (top == -1);
  }

  // 스택이 가득 찼는지 확인하는 메소드
  public boolean isFull() {
    return (top == maxSize -1);
  }

  // 스택의 크기를 반환하는 메소드
  public int size() {
    return top + 1;
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    Stack stack = new Stack(5); // 크기가 5인 스택 생성

    stack.push(1);
    stack.push(2);
    stack.push(3);
    stack.push(4);
    stack.push(5);

    System.out.println("스택의 맨 위 값 : " + stack.peek());
    System.out.println("스택의 크기 : " + stack.size());

    while (!stack.isEmpty()) {
      System.out.println("팝 : " + stack.pop());
    }

    System.out.println("스택의 크기 : " + stack.size());
  }
}
/*
===출력===
스택의 맨 위 값 : 5
스택의 크기 : 5
팝 : 5
팝 : 4
팝 : 3
팝 : 2
팝 : 1
스택의 크기 : 0
*/


주요 메서드 설명


  push(int value) : 스택의 맨 위에 값을 추가합니다. 스택이 가득 찼을 경우, 에러 메시지를 출력합니다.
  pop() : 스택의 맨 위 값을 제거하고 반환합니다. 스택이 비어 있을 경우, 에러 메시지를 출력하고 -1을 반환합니다.
  peek() : 스택의 맨 위 값을 반환하지만, 스택에서 제거하지는 않습니다. 스택이 비어 있을 경우, 에러 메시지를 출력하고 -1을 반환합니다.
  isEmpty() : 스택이 비어 있는지 여부를 확인합니다.
  isFull() : 스택이 가득 찼는지 여부를 확인합니다.
  size() : 스택에 현재 저장된 데이터의 개수를 반환합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-28-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-28-TIL.html"><h1 class="title_post">📝 [TIL] 240528 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-28-TIL.html" class="txt_post">
                            
  스택(Stack)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-27-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-27-TIL.html"><h1 class="title_post">📝 [TIL] 240527 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-27-TIL.html" class="txt_post">
                            
  노드(Node)
  장치 컨트롤러와 장치 드라이버
  트리(Tree)
  이진 트리(Binary Tree)
  완전 이진 트리(Complete Binary Tree)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-27-Tree.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-27-Tree.html"><h1 class="title_post">📦[DS,Algorithm] 트리(Tree)</h1></a>
                        <a href="/Backend/AnD/2024-05-27-Tree.html" class="txt_post">
                            1️⃣ 트리(Tree).

트리(Tree) 는 계층적 구조를 나타내는 자료구조로, 노드(Node)와 에지(Edge)로 구성됩니다.

트리는 사이클이 없는 연결 그래프(Connected Graph)이며, 계층적 데이터 표현에 매우 유용합니다.

트리는 부모-자식 관계를 가지며, 데이터의 조직화와 검색, 계층적 데이터 표현에 사용됩니다.

1️⃣ 트리의 구성 요소.


  
    노드(Node) : 트리의 기본 단위로, 데이터를 저장합니다.
  
  
    에지(Edge) : 노드와 노드를 연결하는 선으로, 부모-자식 관계를 나타냅니다.
  
  
    루트(Root) : 트리의 최상위 노드로, 부모 노드가 없습니다.
  
  
    부모(Parent) : 다른 노드를 가리키는 노드입니다.
  
  
    자식(Child) : 부모 노드에 의해 가리켜지는 노드입니다.
  
  
    잎(Leaf) : 자식 노드가 없는 노드입니다.
  
  
    내부 노드(Internal Node) : 자식 노드가 있는 노드입니다.
  
  
    레벨(Level) : 루트 노드에서 특정 노드까지의 에지 수를 나타냅니다.
  
  
    높이(Height) : 트리의 최대 레벨을 의미합니다.
  


2️⃣ 트리의 특성.


  계층적 구조 : 트리는 계층적 구조로 데이터를 조직화합니다.
  사이클 없음 : 트리는 사이클이 없는 그래프입니다.
  연결성 : 모든 노드는 하나의 연결된 구성 요소로 되어 있습니다.
  한 개의 루트 노드 : 트리는 하나의 루트 노드를 가지며, 루트 노드는 트리의 시작점입니다.


3️⃣ 트리의 종류.


  
    이진 트리(Binary Tree) : 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리입니다.
  
  
    이진 탐색 트리(Binary Search Tree, BST) : 이진 트리의 일종으로, 왼쪽 자식 노드의 값이 부모 노드의 값보다 작고, 오른쪽 자식 노드의 값이 부모 노드의 값보다 큰 특성을 가집니다.
  
  
    균형 이진 트리(Balanced Binary Tree) : AVL 트리, 레드-블랙 트리 등과 같이 트리의 높이가 균형을 이루도록 유지하는 트리입니다.
  
  
    B-트리(B-Tree) : 데이터베이스와 파일 시스템에서 사용되는 트리로, 자식 노드의 수가 정해진 다진 트리(Multiway Tree)입니다.
  
  
    힙(Heap) : 완전 이진 트리의 일종으로, 부모 노드의 값이 자식 노드의 값보다 크거나 작은 특성을 가집니다.
  
  
    트라이(Trie) : 문자열 검색을 위한 트리 자료구조로, 접두사 검색에 유용합니다.
  


4️⃣ 트리의 주요 연산.


  삽입(Insertion) : 트리에 새로운 노드를 추가합니다.
  삭제(Deletion) : 트리에서 노드를 제거합니다.
  탐색(Search) : 트리에서 특정 값을 찾습니다.
  순회(Traversal) : 트리의 모든 노드를 방문합니다. 전위(Preorder), 중위(Inorder), 후위(Postorder), 레벨 순회(Level Order) 방식이 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-27-Node.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-27-Node.html"><h1 class="title_post">📦[DS,Algorithm] 노드(Node)</h1></a>
                        <a href="/Backend/AnD/2024-05-27-Node.html" class="txt_post">
                            1️⃣ Node(노드).

Node(노드) 는 연결 리스트, 트리, 그래프 등의 자료구조에서 기본적인 단위 요소를 의미합니다.

노드는 데이터를 저장하며, 다른 노드와의 연결을 나타내는 포인터(참조)를 포함합니다.

1️⃣ Node의 구성 요소.


  
    데이터(Data) : 노드가 저장하는 실제 값입니다. 이는 숫자, 문자, 객체 등 모든 데이터 타입이 될 수 있습니다.
  
  
    포인터(참조, Pointer) : 다음 노드(또는 다른 관련된 노드)를 가리지는 참조입니다. 포인터의 수와 종류는 자료구조에 따라 다릅니다.
    
      Singly Linked List : 하나의 다음 노드를 가리키는 포인터를 가집니다.
      Doubly Linked List : 이전 노드와 다음 노드를 가리키는 두 개의 포인터를 가집니다.
      트리(Tree) : 부모 노드, 자식 노드 등 여러 방향의 포인터를 가질 수 있습니다.
      그래프(Graph) : 여러 개의 인접 노드를 가리키는 포인터를 가질 수 있습니다.
    
  


Singly Linked List의 Node
Singly Linked List에서의 노드는 다음과 같은 구조를 가집니다.

public class Node {
  int data; // 노드가 저장하는 데이터
  Node next; // 다음 노드를 가리키는 포인터

  public Node(int data) {
    this.data = data;
    this.next = null;
  }
}


Doubly Linked List의 Node
Doubly Linked List에서의 노드는 다음과 같은 구조를 가집니다.
public class DoublyNode {
  int data; // 노드가 저장하는 데이터
  DoublyNode next; // 다음 노드를 가리키는 포인터
  DoublyNode prev; // 이전 노드를 가리키는 포인터

  public DoublyNode(int data) {
    this.data = data;
    this.next = null;
    this.prev = null;
  }
}


2️⃣ Node를 사용하는 예제.

Singly Linked List

Singly Linked List는 각 노드가 다음 노드를 가리키는 구조로 연결된 리스트 입니다.

아래는 Singly Linked List를 구현한 예제입니다.

//SinglyLinkedList
public class SinglyLinkedList {
  private Node head;

  public SinglyLinkedList() {
    this.head = null;
  }

  // 리스트의 맨 앞에 노드 추가
  public void addFirst(int data) {
    Node newNode = new Node(data);
    newNode.next = head;
    head = newNode;
  }

  // 리스트의 맨 끝에 노드 추가
  public void addLast(int data) {
    Node newNode = new Node(data);
    if (head == null) {
      head = newNode;
      return;
    }
    Node current = head;
    while (current.next != null) {
      current = current.next;
    }
    current.next = newNode;
  }

  // 리스트의 특정 값 삭제
  public void delete(int data) {
    if (head == null) {
      return;
    }

    if (head.data == data) {
      head = head.next;
      return;
    }

    Node current = head;

    while (current.next != null &amp;&amp; current.next.data != data) {
      current = current.next;
    }

    if (current.next != null) {
      current.next = current.next.next;
    }
  }

  // 리스트 출력
  public void printList() {
    Node current = head;
    while (current != null) {
      System.out.print(current.data + " ");
      current = current.next;
    }
    System.out.println();
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    // Singly Linked List 생성
    SinglyLinkedList singlyLinkedList = new SinglyLinkedList();

    singlyLinkedList.addFirst(1);
    singlyLinkedList.addLast(2);
    singlyLinkedList.addLast(3);
    singlyLinkedList.printList(); // 1 2 3

    singlyLinkedList.delete(2);
    singlyLinkedList.printList(); // 1 3
  }
}


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-27-CompleteBinaryTree.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-27-CompleteBinaryTree.html"><h1 class="title_post">📦[DS,Algorithm] 완전 이진 트리(Complete Binary Tree)</h1></a>
                        <a href="/Backend/AnD/2024-05-27-CompleteBinaryTree.html" class="txt_post">
                            1️⃣ 완전 이진 트리(Complete Binary Tree).

완전 이진 트리(Complete Binary Tree)는 이진 트리의 한 종류입니다.

1️⃣ 완전 이진 트리(Complete Binary Tree)의 특성.


  모든 레벨이 완전히 채워져 있다.
    
      마지막 레벨을 제외한 모든 레벨의 노드가 최대 개수로 채워져 있습니다.
      마지막 레벨의 노드들은 왼쪽부터 오른쪽으로 채워져 있습니다.
    
  
  노드의 배치
    
      트리의 높이가 ‘h’ 라면, 마지막 레벨을 제외한 모든 레벨에는 ‘2^k’ 개의 노드가 있습니다. 여기서 ‘k’ 는 해당 레벨의 깊이 입니다.
      마지막 레벨에는 1개 이상 ‘2^h’ 개 이하의 노드가 있으며, 이 노드들은 왼쪽부터 채워집니다.
    
  


2️⃣ 완전 이친 트리의 예.
        1
      /   \
     2     3
    / \   / \
   4   5 6   7
  / \
 8   9


위의 트리는 완전 이진 트리의 예입니다.

모든 레벨이 완전히 채워져 있고, 마지막 레벨의 노드들은 왼쪽부터 오른쪽으로 채워져있습니다.

3️⃣ 완전 이진 트리의 속성.


  노드 수
    
      높이가 ‘h’ 인 완전 이진 트리는 최대 ‘2^(h+1) - 1’ 개의 노드를 가질 수 있습니다.
      마지막 레벨을 제외한 모든 노드는 ‘2^h - 1’ 개의 노드를 가집니다.
    
  
  높이
    
      노드 수가 ‘n’ 인 완전 이진 트리의 높이는 ‘O(log n)’ 입니다.
    
  
  배열 표현
    
      완전 이진 트리는 배열을 사용하여 쉽게 표현할 수 있습니다. 이는 힙 자료구조에서 많이 사용됩니다.
    
  


4️⃣ 배열을 통한 완전 이진 트리 표현

완전 이진 트리는 배열을 사용하여 효율적으로 표현할 수 있습니다.

노드의 인덱스를 기준으로 부모-자식 관계를 쉽게 파악할 수 있습니다.

노드의 인덱스 규칙

  루트 노드 : 인덱스 0
  인덱스 ‘i’의 오른쪽 자식 노드 : ‘2*i + 1’
  인덱스 ‘i’의 부모 노드 : ‘(i - 1) / 2’


5️⃣ 예제 코드
아래는 완전 이진 트리를 배열로 표현하고, 이를 출력하는 간단한 예제 코드입니다.
public class CompleteBinaryTree {

  public static void main(String[] args) {
    int[] tree = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // 트리 출력
    printTree(tree);
  }

  // 배열로 표현된 완전 이진 트리 출력
  public static void printTree(int[] tree) {
    for (int i = 0; i &lt; tree.length; i++) {
      int leftChildIndex = 2 * i + 1;
      int rightChildIndex = 2 * i + 2;

      System.out.print("Node " + tree[i] + ": ");

      if (leftChildIndex &lt; tree.length) {
        System.out.print("Left Child: " + tree[leftChildIndex] + ", ");
      } else {
        System.out.print("Left Child: null, ");
      }

      if (rightChildIndex &lt; tree.length) {
        System.out.print("Right Child: " + tree[rightChildIndex]);
      } else {
        System.out.print("Right Child: null");
      }
      System.out.println();
    }
  }
}

/* 출력
Node 1: Left Child: 2, Right Child: 3
Node 2: Left Child: 4, Right Child: 5
Node 3: Left Child: 6, Right Child: 7
Node 4: Left Child: 8, Right Child: 9
Node 5: Left Child: null, Right Child: null
Node 6: Left Child: null, Right Child: null
Node 7: Left Child: null, Right Child: null
Node 8: Left Child: null, Right Child: null
Node 9: Left Child: null, Right Child: null
*/


설명


  트리 배열 초기화 : int[] tree = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    
      완전 이진 트리를 배열로 표현합니다.
    
  
  트리 출력 : printTree(tree)
    
      배열로 표현된 완전 이진 트리를 출력하는 함수입니다.
      각 노드에 대해 왼쪽 자식과 오른쪽 자식을 출력합니다.
    
  


시간 복잡도


  삽입(Insertion) : O(log n)
  삭제(Deletion) : O(log n)
  탐색(Search) : O(n) (일반적으로 완전 이진 트리는 탐색보다 삽입/삭제가 주된 연산입니다.)



  완전 이진 트리는 데이터의 구조적 특성 때문에 힙과 같은 자료구조에서 많이 사용됩니다.
이는 효율적인 삽입 및 삭제 연산을 제공하며, 배열을 통한 표현이 간편하여 다양한 알고리즘에서 유용하게 사용됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-27-BinaryTree.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-27-BinaryTree.html"><h1 class="title_post">📦[DS,Algorithm] 이진 트리(Binary Tree)</h1></a>
                        <a href="/Backend/AnD/2024-05-27-BinaryTree.html" class="txt_post">
                            1️⃣ 이진 트리(Binary Tree).

이진 트리(Binary Tree) 는 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리 구조입니다.

이 두 자식 노드는 일반적으로 왼쪽 자식(Left Child) 과 오른쪽 자식(Right Child) 이라고 불립니다.

이진 트리는 다양한 응용 프로그램에서 중요한 자료구조입니다.

1️⃣ 이진 트리의 구성 요소.


  노드(Node) : 데이터를 저장하는 기본 단위입니다.
  루트(Root) : 트리의 최상위 노드입니다.
  자식(Child) : 특정 노드로부터 연결된 하위 노드입니다.
  부모(Parent) : 특정 노드를 가리키는 상위 노드입니다.
  잎(Leaf) : 자식 노드가 없는 노드입니다.
  서브트리(Subtree) : 특정 노드와 그 노드의 모든 자식 노드로 구성된 트리입니다.


2️⃣ 이진 트리의 종류.


  
    포화 이진 트리(Full Binary Tree) : 모든 노드가 0개 또는 2개의 자식 노드를 가지는 트리입니다.
  
  
    완전 이진 트리(Complete Binary Tree) : 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 노드는 왼쪽부터 채워져 있는 트리입니다.
  
  
    높이 균형 이진 트리(Height-balanced binary Tree) : AVL 트리와 같이 각 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하인 트리입니다.
  
  
    이진 탐색 트리(Binary Search Tree, BST) : 왼쪽 서브트리의 모든 노드가 루트 노드보다 작고, 오른쪽 서브 트리의 모든 노드가 루트 노드보다 큰 트리입니다.
  


3️⃣ 이진 트리의 주요 연산 및 시간 복잡도.


  삽입(Insertion) : 새로운 노드를 트리에 추가합니다.
    
      일반적인 경우 시간 복잡도 : O(log n)(이진 탐색 트리에서)
      최악의 경우 시간 복잡도 : O(n)(편향된 트리에서)
    
  
  삭제(Deletion) : 트리에서 특정 노드를 제거합니다.
    
      일반적인 경우 시간 복잡도 : O(log n)(이진 탐색 트리에서)
      최악의 경우 시간 복잡도: O(n)(편향된 트리에서)
    
  
  탐색(Search) : 트리에서 특정 값을 찾습니다.
    
      일반적인 경우 시간 복잡도: O(log n)(이진 탐색 트리에서)
      최악의 경우 시간 복잡도 : O(n)(편향된 트리에서)
    
  
  순회(Traversal) : 트리의 모든 노드를 방문합니다. 순회 방법에는 전위(Preorder), 중위(Inorder), 후위(Postorder) 순회가 있습니다.
    
      시간 복잡도: O(n)(모든 노드를 방문하기 때문에)
    
  


4️⃣ 이진 트리의 예제
이진 탐색 트리(BST)의 구현
// TreeNode
public class TreeNode {
  int data;
  TreeNode left;
  TreeNode right;

  public TreeNode(int data) {
    this.data = data;
    this.left = null;
    this.right = null;
  }
}

// BinarySearchTree
public class BinarySearchTree {
  private TreeNode root;

  public BinarySearchTree() {
    this.root = null;
  }

  // 삽입 연산
  public void insert(int data) {
    root = insertRec(root, data);
  }

  private TreeNode insertRec(TreeNode root, int data) {
    if (root == null) {
      root = new TreeNode(data);
      return root;
    }

    if (data &lt; root.data) {
      root.left = insertRec(root.left, data);
    } else if (data &gt; root.data) {
      root.right = insertRec(root.right, data);
    }
    return root;
  }

  // 탐색 연산
  public boolean search(int data) {
    return searchRec(root, data);
  }

  private boolean searchRec(TreeNode root, int data) {
    if (root == null) {
      return false;
    }

    if (root.data == data) {
      return true;
    }

    if (data &lt; root.data) {
      return searchRec(root.left, data);
    } else {
      return searchRec(root.right, data);
    }
  }

  // 중위 순회(Inorder Traversal)
  public void inorder() {
    inorderRec(root);
  }

  private void inorderRec(TreeNode root) {
    if (root != null) {
      inorderRec(root.left);
      System.out.print(root.data + " ");
      inorderRec(root.right);
    }
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    BinarySearchTree bst = new BinarySearchTree();

    bst.insert(50);
    bst.insert(30);
    bst.insert(20);
    bst.insert(40);
    bst.insert(70);
    bst.insert(60);
    bst.insert(80);

    System.out.println("Inorder traversal of the BST:");
    bst.inorder(); // 출력: 20 30 40 50 60 70 80

    System.out.println("\nSearch for 40: " + bst.search(40)); // 출력: true
    System.out.println("Search for 90: " + bst.search(90)); // 출력: false
  }
}


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-25-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-25-TIL.html"><h1 class="title_post">📝 [TIL] 240525 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-25-TIL.html" class="txt_post">
                            
  해시 테이블(Hash Table)
  해시 맵 정리


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-25-HashTable.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-25-HashTable.html"><h1 class="title_post">📦[DS,Algorithm] 해시 테이블(Hash Table)</h1></a>
                        <a href="/Backend/AnD/2024-05-25-HashTable.html" class="txt_post">
                            1️⃣ 해시 테이블(Hash Table).

해시 테이블(Hash Table)은 데이터를 키-값 쌍(key-value pairs)으로 저장하는 자료구조입니다.

해시 테이블은 해시 함수를 사용하여 키를 해시 값으로 변환하고, 이 해시 값을 인덱스로 사용하여 배열에서 값을 저장하거나 검색합니다.

이를 통해 데이터에 빠르게 접근할 수 있습니다.

1️⃣ 해시 테이블의 구성 요소.


  
    키(key) : 각 데이터를 식별하기 위한 고유한 식별자입니다.
  
  
    값(Value) : 키와 연관된 데이터입니다.
  
  
    해시 함수(Hash Function) : 키를 입력으로 받아 해시 값을 출력하는 함수입니다. 이 해시 값은 보통 정수이며, 배열의 인덱스로 사용됩니다.
  
  
    버킷(Bucket) : 해시 값에 의해 인덱싱되는 배열의 각 위치입니다. 각 버킷은 하나의 키-값 쌍 또는 충돌 처리를 위한 데이터 구조(예: 연결 리스트)를 저장할 수 있습니다.
  


2️⃣ 해시 함수의 역할.

해시 함수는 키를 고정된 크기의 해시 값으로 매핑합니다.

이상적인 해시 함수는 키를 균등하게 분포시키고, 충돌을 최소화합니다.

3️⃣ 충동(Collision)과 충돌 해결 방법.

두 개 이상의 키가 동일한 해시 값을 가질 때 충돌이 발생합니다.

해시 테이블은 이러한 충돌을 처리하기 위한 여러가지 방법을 제공합니다.


  
    체이닝(Chaining) : 각 버킷에 연결 리스트를 사용하여 동일한 해시 값을 갖는 모든 요소를 저장합니다. 충돌이 발생하면 해당 버킷의 리스트에 요소를 추가합니다.
  
  
    개방 주소법(Open Addressing) : 충돌이 발생하면 다른 빈 버킷을 찾아 데이터를 저장합니다. 이를 위해 다양한 탐사 방법(예: 선형 탐사, 제곱 탐사, 이중 해싱)을 사용합니다.
  


4️⃣ 해시 테이블의 시간 복잡도.


  검색(Search) : O(1)(평균), O(n)(최악)
  삽입(Insertion) : O(1)(평균), O(n)(최악)
  삭제(Deletion) : O(1)(평균), O(n)(최악)


최악의 경우 시간 복잡도는 해시 충돌로 인해 모든 요소가 하나의 버킷에 저장될 때 발생합니다.

그러나, 좋은 해시 함수와 충돌 해결 방법을 사용하면 평균적으로 O(1)의 성능을 유지할 수 있습니다.

5️⃣ 해시 테이블의 장점과 단점.

장점

  빠른 검색, 삽입, 삭제 성능(평균적으로 O(1))
  키를 사용하여 데이터에 빠르게 접근 가능


단점

  해시 함수의 성능에 의존
  충돌 처이 필요
  메모리 사용량이 증가할 수 있슴(특히 체이닝을 사용하는 경우)


💻 해시 테이블의 구현 예제.

아래는 Java에서 간단한 해시 테이블을 구현한 예제입니다.


// HashTable
import java.util.LinkedList;

class HashTable {
  private class HashNode {
    String key;
    String value;
    HashNode next;

    public HashNode(String key, String value) {
      this.key = key;
      this.value = value;
    }
  }

  private LinkedList&lt;HashNode&gt;[] buckets;
  private int numBuckets;
  private int size;

  public HashTable() {
    numBuckets = 10; // 버킷의 초기 크기
    buckets = new LinkedList[numBuckets];
    size = 0;

    for (int i = 0; i &lt; numBuckets; i++) {
      buckets[i] = new LinkedList&lt;&gt;();
    }
  }

  private int getBucketIndex(String key) {
    int hashCode = key.hashCode();
    int index = hashCode % numBuckets;
    return index &lt; 0 ? index * -1 : index;
  }

  public void put(String key, String value) {
    int bucketIndex = getBucketIndex(key);
    LinkedList&lt;HashNode&gt; bucket = buckets[bucketIndex];

    for (HashNode node : bucket) {
      if (node.key.equals(key)) {
        node.value = value;
        return;
      }
    }

    bucket.add(new HashNode(key, value));
    size++;
  }

  public String get(String key) {
    int bucketIndex = getBucketIndex(key);
    LinkedList&lt;HashNode&gt; bucket = buckets[bucketIndex];

    for (HashNode node : bucket) {
      if (node.key.equals(key)) {
        return node.value;
      }
    }
    return null;
  }

  public String remove(String key) {
    int bucketIndex = getBucketIndex(key);
    LinkedList&lt;HashNode&gt; bucket = buckets[bucketIndex];

    HashNode prev = null;
    for (HashNode node : bucket) {
      if (node.key.equals(key)) {
        if (prev != null) {
          prev.next = node.next;
        } else {
          bucket.remove(node);
        }
        size--;
        return node.value;
      }
      prev = node;
    }
    return null;
  }

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return size == 0;
  }
}

// Main
public class Main {
  public static void main(String[] args) {
    HashTable hashTable = new HashTable();
    hashTable.put("one", "1");
    hashTable.put("two", "2");
    hashTable.put("three", "3");

    System.out.println("Value for key 'one': " + hashTable.get("one"));
    System.out.println("Value for key 'two': " + hashTable.get("two"));
    System.out.println("Removing key 'one': " + hashTable.remove("one"));
    System.out.println("Contains key 'one': " + (hashTable.get("one") != null));
  }
}

/*
출력
Value for key 'one': 1
Value for key 'two': 2
Removing key 'one': 1
Contains key 'one': false
*/


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-24-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-24-TIL.html"><h1 class="title_post">📝 [TIL] 240524 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-24-TIL.html" class="txt_post">
                            
  배열 문제 풀이
  배열 정리
  해시(Hash)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-24-Hash.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-24-Hash.html"><h1 class="title_post">📦[DS,Algorithm] 해시(Hash)</h1></a>
                        <a href="/Backend/AnD/2024-05-24-Hash.html" class="txt_post">
                            1️⃣ 해시(Hash).

해시(Hash)란 컴퓨터 과학에서 주어진 입력 데이터를 고정된 크기의 고유한 값(일반적으로 숫자)으로 변환하는 과정 또는 그 결과 값을 말합니다.

해시는 주로 데이터 검색, 데이터 무결성 검증, 암호화 등에 사용됩니다.

1️⃣ 해시의 개념.


  해시 함수(Hash Function)
    
      임의의 길이를 가진 데이터를 고정된 길이의 해시 값으로 변환하는 함수입니다.
      해시 함수는 동일한 입력에 대해 항상 동일한 해시 값을 생성해야 하며, 서로 다른 입력에 대해서는 가능한 한 다른 해시 값을 생성해야 합니다.
    
  
  해시 값(Hash Value)
    
      해시 함수를 통해 생성된 고정된 크기의 출력 값입니다.
        
          이를 해시 코드(Hash Code) 또는 다이제스트(Digest)라고도 합니다.
        
      
    
  


2️⃣ 해시 함수의 특징.


  
    결정성(Deterministic) : 동일한 입력에 대해 항상 동일한 해시 값을 반환합니다.
  
  
    효율성(Efficiency) : 해시 함수는 입력 데이터를 빠르게 처리하여 해시 값을 생성해야 합니다.
  
  
    충돌 저항성(Collision Resistance) : 서로 다른 두 입력이 동일한 해시 값을 갖지 않도록 해야 합니다. 현실적으로 완벽한 충돌 저항성은 불가능하므로, 가능한 충돌을 최소화하는 것이 중요합니다.
  
  
    역상 저항성(Pre-image Resistance) : 해시 값을 통해 원해의 입력 데이터를 유추하는 것이 어렵거나 불가능해야 합니다.
  
  
    두 번째 역상 저항성(Second Pre-image Resitance) : 특정 입력과 동일한 해시 값을 갖는 또 다른 입력을 찾는 또 다른 입력을 찾는 것이 어려워야 합니다.
  


3️⃣ 해시 함수의 용도.


  
    데이터 검색 : 해시 테이블(Hash Table)과 같은 자료구조에서 빠른 데이터 검색을 위해 사용됩니다.
  
  
    데이터 무결성 검증 : 데이터가 변경되지 않았음을 확인하기 위해 해시 값을 사용합니다. 예를 들어, 파일의 해시 값을 비교하여 파일이 손상되지 않았음을 확인할 수 있습니다.
  
  
    암호화 및 보안 : 패스워드 저장, 디지털 서명, 메시지 인증 코드(MAC) 등에서 데이터의 무결성과 기밀성을 보장하기 위해서 사용됩니다.
  


4️⃣ 해시 함수의 예

  
    SHA-256(Secure Hash Algorithm 256-bit) : 256비트의 해시 값을 생성하는 암호화 해시 함수입니다.
  
  
    MD5(Message Digest Algorithm 5) : 128비트의 해시 값을 생성하는 해시 함수로, 현재는 충돌 저항성의 취약성 때문에 보안 용도로는 권장되지 않습니다.
  
  
    CRC32(Cyclic Redundancy Check 32-bit) : 데이터 전송 오류 검출을 위해 사용되는 32비트 해시 함수입니다.
  


🙋‍♂️ 주요 포인트 요약

  
    해시(Hash) 는 데이터를 고정된 크기의 고유한 값으로 변환하는 과정입니다.
  
  
    해시 함수는 빠르고 효율적으로 해시 값을 생성하며, 충돌을 최소화하고 역상을 예측할 수 없도록 설계되어야 합니다.
  
  
    해시 함수는 데이터 검색, 무결성 검증, 암호화 등 다양한 용도로 사용됩니다.
  


💻 해시 함수의 예제 코드

아래는 Java에서 SHA-256 해시 함수를 사용하여 문자열의 해시 값을 생성하는 예제입니다.
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Main {

  public static void main(String[] args) {
    String input = "Hello World!";

    try {
      // SHA-256 해시 함수 인스턴스 생성
      MessageDigest digest = MessageDigest.getInstance("SHA-256");

      // 입력 문자열의 해시 값 계산
      byte[] hash = digest.digest(input.getBytes());

      // 해시 값을 16진수 문자열로 변환하여 출력
      System.out.println("Hash value: " + bytesToHex(hash));
    } catch (NoSuchAlgorithmException e) {
      e.printStackTrace();
    }
  }

  // 바이트 배열을 16진수 문자열로 변환하는 함수
  private static String bytesToHex(byte[] bytes) {
    StringBuilder hexString = new StringBuilder();

    for (byte b : bytes) {
      String hex = Integer.toHexString(0xff &amp; b);

      if (hex.length() == 1) hexString.append('0');
      hexString.append(hex);
    }
    return hexString.toString();
  }
}


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-23-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-23-TIL.html"><h1 class="title_post">📝 [TIL] 240523 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-23-TIL.html" class="txt_post">
                            
  큐(Queue)
  원형 큐(Circular Queue)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-23-circularQueue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-23-circularQueue.html"><h1 class="title_post">📦[DS,Algorithm] 원형 큐(Circular Queue)</h1></a>
                        <a href="/Backend/AnD/2024-05-23-circularQueue.html" class="txt_post">
                            1️⃣ 원형 큐(Circular Queue).

원형 큐(Circular Queue)란, “고정된 크기의 배열” 을 사용하여 구현된 큐로서, 배열의 끝에 도달하면 다시 배열의 시작 부분으로 돌아가는 구조를 가진 큐입니다.

이를 통해 큐가 꽉 차 있는지, 비어 있는지를 효율적으로 관리할 수 있으며, 공간을 효율적으로 사용할 수 있습니다.

1️⃣ 원형 큐의 특징.

  
    
      선입선출(FIFO, First In First Out) : 일반적인 큐와 마찬가지로 먼저 들어간 데이터가 먼저 나오는 구조입니다.
    
  
  
    
      순환 구조 : 배열의 끝에 도달하면 다시 처음으로 돌아갑니다. 이를 통해 고정된 크기의 배열을 이용하여 메모리를 효율적으로 사용합니다.
    
  
  3 고정 크기 : 큐의 최대 크기는 배열의 크기로 제한 됩니다.


2️⃣ 원형 큐의 주요 연산.

  
    
      Enqueue : 큐의 뒤쪽(rear)에 새로운 요소를 추가합니다.
    
  
  
    
      Dequeue : 큐의 앞쪽(front)에서 요소를 제거하고 반환합니다.
    
  
  
    
      Peek : 큐의 앞쪽(front) 요소를 제거하지 않고 반환합니다.
    
  
  
    
      IsEmpty : 큐가 비어 있는지 여부를 확인합니다.
    
  
  
    
      IsFull : 큐가 가득 찼는지 여부를 확인합니다.
    
  


3️⃣ 원형 큐의 장점.

  메모리 효율성 : 고정된 크기의 배열을 사용하여 메모리를 효율적으로 사용합니다.
  연속된 메모리 사용 : 배열을 사용하여 메모리를 연속적으로 사용하므로 캐시 효율성이 높습니다.


4️⃣ 원형 큐의 단점.

  고정 크기 제한 : 크기가 고정되어 있으므로, 큐가 가득 찬 경우 더 이상 요소를 추가할 수 없습니다. 이 문제를 해결하려면 동적으로 크기를 조절할 수 있는 방법을 추가로 구현해야 합니다.


5️⃣ 원형 큐의 구현 예제

// CircularQueue
public class CircularQueue {
  private int[] queue;
  private int front;
  private int rear;
  private int size;
  private int capacity;

  // 원형 큐 초기화
  public CircularQueue(int capacity) {
    this.capacity = capacity;
    queue = new int[capacity];
    front = 0;
    rear = -1;
    size = 0;
  }

  // 큐에 요소 추가
  public void enqueue(int element) {
    if (isFull()) {
      System.out.println("Queue is full");
      return;
    }

    rear = (rear + 1) % capacity;
    queue[rear] = element;
    size++;
  }

  // 큐에서 요소 제거 및 반환
  public int dequeue() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }
    int element = queue[front];
    front = (front + 1) % capacity;
    size--;
    return element;
  }

  // 큐의 앞쪽 요소 반환
  public int peek() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }
    return queue[front];
  }

  // 큐가 비어 있는지 확인
  public boolean isEmpty() {
    return size == 0;
  }

  // 큐가 가득 찼는지 확인
  public boolean isFull() {
    return size == capacity;
  }

  // 큐의 크기 반환
  public int getSize() {
    return size;
  }
}

// Main
public class Main {

  public static void main(String[] args) {
    CircularQueue circularQueue = new CircularQueue(5);

    circularQueue.enqueue(1);
    circularQueue.enqueue(2);
    circularQueue.enqueue(3);
    circularQueue.enqueue(4);
    circularQueue.enqueue(5);

    System.out.println("Dequeue: " + circularQueue.dequeue());
    System.out.println("Dequeue: " + circularQueue.dequeue());

    circularQueue.enqueue(6);
    circularQueue.enqueue(7);

    System.out.println("Peek: " + circularQueue.peek());

    while (!circularQueue.isEmpty()) {
      System.out.println("Dequeue: " + circularQueue.dequeue());
    }
  }
}

// 출력
/*
Dequeue: 1
Dequeue: 2
Peek: 3
Dequeue: 3
Dequeue: 4
Dequeue: 5
Dequeue: 6
Dequeue: 7
 */


코드 설명.


  
    
      CircularQueue 클래스:
        
          ‘queue’ : 큐를 저장하는 배열.
          ‘front’ : 큐의 앞쪽 인덱스.
          ‘rear’ : 큐의 뒤쪽 인덱스.
          ‘size’ : 현재 큐에 저장된 요소의 개수.
          ‘capacity’ : 큐의 최대 크기.
        
      
    
  
  
    
      메서드:
        
          ‘enqueue(int element)’ : 큐가 가득 차지 않았으면 요소를 큐에 추가합니다.
          ‘dequeue()’ : 큐가 비어 있지 않으면 큐의 앞쪽 요소를 제거하고 반환합니다.
          ‘peek()’ : 큐의 앞쪽 요소를 제거하지 않고 반환합니다.
          ‘isEmpty()’ : 큐가 비어 있는지 확인합니다.
          ‘isFull()’ : 큐가 가득 찼는지 확인합니다.
          ‘getSize()’ : 큐의 현재 크기를 반환합니다.
        
      
    
  
  
    
      main 메서드:
        
          원형 큐를 생성하고 여러 연산을 수행하여 큐의 동작을 테스트합니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-23-Queue.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-23-Queue.html"><h1 class="title_post">📦[DS,Algorithm] 큐(Queue)</h1></a>
                        <a href="/Backend/AnD/2024-05-23-Queue.html" class="txt_post">
                            1️⃣ 큐(Queue)

큐(Queue)는 컴퓨터 과학에서 흔히 사용되는 자료구조 중 하나로, 선입선출(FIFO, First In First Out) 방식으로 동작합니다.

즉, 큐에 먼저 들어간 데이터가 먼저 나오는 구조입니다.

큐의 주요연산.

  
    
      Enqueue : 큐의 뒤쪽(rear)에 새로운 요소를 추가합니다.
    
  
  
    
      Dequeue : 큐의 앞쪽(front)에서 요소를 제거하고 반환합니다.
    
  
  
    
      Peek 또는 Front : 큐의 앞쪽(front) 요소를 제거하지 않고 반환합니다.
    
  
  
    
      IsEmpty : 큐가 비어 있는지 여부를 확인합니다.
    
  


큐가 유용하게 사용되는 상황.

  프린터 대기열 : 인쇄 작업을 순서대로 처리합니다.
  프로세스 스케줄링 : 운영 체제에서 프로세스들이 CPU 시간을 얻기 위해 대기하는 순서를 유지합니다.
  너비 우선 탐색(BFS) : 그래프 탐색 알고리즘에서 각 노드를 방문할 순서를 유지합니다.


큐의 구현.
큐는 배열이나 연결 리스트를 사용하여 구현할 수 있습니다.

배열을 사용한 큐 구현 예제
public class QueueArray {
  private int[] elements;
  private int front;
  private int rear;
  private int size;
  private int capacity;

  public QueueArray(int capacity) {
    this.capacity = capacity;
    elements = new int[capacity];
    front = 0;
    rear = -1;
    size = 0;
  }

  // 큐에 요소 추가
  public void enqueue(int element) {
    if (size == capacity) {
      System.out.println("Queue is full");
      return;
    }

    rear = (rear + 1) % capacity;
    elements[rear] = element;
    size++;
  }

  // 큐에서 요소 제거 및 반환
  public int dequeue() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }

    int element = elements[front];
    front = (front + 1) % capacity;
    size--;
    return element;
  }

  // 큐의 앞쪽 요소 반환
  public int peek() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }
    return  elements[front];
  }

  // 큐가 비어 있는지 확인
  public boolean isEmpty() {
    return size == 0;
  }

  // 큐의 크기 반환
  public int getSize() {
    return size;
  }
}

// Main 클래스
public class Main {

  public static void main(String[] args) {
    QueueArray queue = new QueueArray(5);

    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);

    System.out.println("Front element: " + queue.peek());
    System.out.println("Dequeue element: " + queue.dequeue());
    System.out.println("Front element after dequeue: " + queue.peek());

    queue.enqueue(4);
    queue.enqueue(5);
    queue.enqueue(6);

    while (!queue.isEmpty()) {
      System.out.println("Dequeued element: " + queue.dequeue());
    }
  }
}

// 출력
/*
Front element: 1
Dequeue element: 1
Front element after dequeue: 2
Dequeued element: 2
Dequeued element: 3
Dequeued element: 4
Dequeued element: 5
Dequeued element: 6
 * /


연결 리스트를 사용한 큐 구현 예제
// Node
public class Node {
  int data;
  Node next;

  public Node(int data) {
    this.data = data;
    this.next = null;
  }
}

// QueueLinkedList
public class QueueLinkedList {
  private Node front;
  private Node rear;
  private int size;

  public QueueLinkedList() {
    front = null;
    rear = null;
    size = 0;
  }

  // 큐에 요소 추가
  public void enqueue(int data) {
    Node newNode = new Node(data);

    if (rear != null) {
      rear.next = newNode;
    }
    rear = newNode;

    if (front == null) {
      front = newNode;
    }
    size++;
  }

  // 큐에서 요소 제거 및 반환
  public int dequeue() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }

    int data = front.data;
    front = front.next;

    if (front == null) {
      rear = null;
    }
    size--;
    return data;
  }

  // 큐의 앞쪽 요소 반환
  public int peek() {
    if (isEmpty()) {
      System.out.println("Queue is empty");
      return -1;
    }
    return front.data;
  }

  // 큐가 비어 있는지 확인
  public boolean isEmpty() {
    return front == null;
  }

  // 큐의 크기 반환
  public int getSize() {
    return size;
  }
}

// Main 클래스
public class Main {

  public static void main(String[] args) {
    QueueLinkedList queue = new QueueLinkedList();

    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);

    System.out.println("Front element: " + queue.peek());
    System.out.println("Dequeue element: " + queue.dequeue());
    System.out.println("Front element after dequeue: " + queue.peek());

    queue.enqueue(4);
    queue.enqueue(5);

    while (!queue.isEmpty()) {
      System.out.println("Dequeued element: " + queue.dequeue());
    }
  }
}

// 출력
/*
Front element: 1
Dequeue element: 1
Front element after dequeue: 2
Dequeued element: 2
Dequeued element: 3
Dequeued element: 4
Dequeued element: 5
 * /


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-22-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-22-TIL.html"><h1 class="title_post">📝 [TIL] 240522 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-22-TIL.html" class="txt_post">
                            
  다양한 보조기억장치


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-21-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-21-TIL.html"><h1 class="title_post">📝 [TIL] 240521 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-21-TIL.html" class="txt_post">
                            
  자료구조 소개
  RAID의 정의와 종류
  선형 자료구조 - 배열


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-21-linearDS-Array.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-21-linearDS-Array.html"><h1 class="title_post">📦[DS,Algorithm] 선형 자료구조 - 배열</h1></a>
                        <a href="/Backend/AnD/2024-05-21-linearDS-Array.html" class="txt_post">
                            1️⃣ 선형 자료구조 - 배열.

자료구조 관점에서 배열을 이해하고 여러 방법으로 구현 가능

1️⃣ 배열(Array).

자료구조 관점에서 배열(Array)은 동일한 타입의 데이터를 연속된 메모리 공간에 저장하는 선형 자료구조입니다.

배열은 조정된 크기를 가지며, 인덱스를 사용하여 각 요소에 빠르게 접근할 수 있는 특징이 있습니다.

배열은 가장 기본적이고 널리 사용되는 자료구조 중 하나입니다.

특징.

  고정된 크기(Fixed Size)
    
      배열은 선언 시 크기가 결정되며, 배열의 크기는 변경할 수 없습니다. 이 크기는 배열을 사용하는 동안 고정되어 있습니다.
      예: ‘int[] numbers = new int[10];‘(크기가 10인 정수형 배열)
    
  
  연속된 메모리 공간(Contiguous Memory Allocation)
    
      배열의 요소들은 메모리상에 연속적으로 배치됩니다. 이는 인덱스를 통한 빠른 접근을 가능하게 합니다.
      첫 번째 요소의 메모리 주소를 기준으로 인덱스를 사용하여 다른 요소의 주소를 계산할 수 있습니다.
    
  
  인덱스를 통한 접근(Indexing)
    
      배열의 각 요소는 인덱스를 통해 접근할 수 있습니다. 인덱스는 0부터 시작하여 배열의 크기 -1까지의 값을 가집니다.
      예: ‘numbers[0]’,’numbers[1]‘,…,’numbers[9]‘
    
  
  동일한 데이터 타입(Homogeneous Data Type)
    
      배열은 동일한 데이터 타입의 요소들로 구성됩니다. 즉, 배열 내 모든 요소는 같은 데이터 타입이어야 합니다.
      예: 정수형 배열, 문자열 배열 등.
    
  


장점.

  빠른 접근 속도(Fast Access) :
    
      인덱스를 사용하여 O(1) 시간 복잡도로 배열의 임의의 요소에 접근할 수 있습니다. 이는 배열의 주요 장점 중 하나입니다.
    
  
  간단한 구현(Simple Implementation) :
    
      배열은 데이터 구조가 간단하여 구현이 용이합니다. 기본적인 자료구조로, 다른 복잡한 자료구조의 기초가 됩니다.
    
  


단점.


  고정된 크기(Fixed Size) :
    
      배열의 크기는 선언 시 결정되며, 크기를 변경할 수 없습니다. 이는 크기를 사전에 정확히 예측하기 어려운 경우 비효율적일 수 있습니다.
    
  
  삽입 및 삭제의 비효율성(Inefficient Insertions and Deletions) :
    
      배열의 중간에 요소를 삽입하거나 삭제할 경우, 요소들을 이동시켜야 하기 때문에 O(n) 시간이 소요됩니다. 이는 큰 배열의 경우 성능 저하를 초래할 수 있습니다.
    
  
  메모리 낭비(Memory Waste) :
    
      배열의 크기를 너무 크게 설정하면 사용되지 않는 메모리가 낭비될 수 있고, 너무 작게 설정하면 충분한 데이터를 저장할 수 없습니다.
    
  


배열의 사용 예시.


  정수형 배열 선언 및 초기화
    int[] numbers = new int[5];
numbers[0] = 10;
numbers[1] = 20;
numbers[2] = 30;
numbers[3] = 40;
numbers[4] = 50;
    
  
  배열의 요소 접근
    int firstElement = numbers[0]; // 10
int lastElement = numbers[4]; // 50
    
  
  배열의 순회
    for (int i = 0; i &lt; numbers.length; i++) {
  System.out.println(numbers[i]);
}
    
  


마무리.

배열은 다양한 상황에서 기본적인 데이터 저장과 접근 방법을 제공하며, 특정 요구사항에 맞춰 다른 자료구조와 함께 사용되기도 합니다.

배열의 빠른 접근 속도와 간단한 구조 덕분에, 많은 알고리즘과 프로그램에서 핵심적인 역할을 합니다.



2️⃣ 배열 직접 구현.
// CustomArray 클래스
public class CustomArray {
  private int[] data;
  private int size;

  // 특정 용량으로 배열을 초기화하는 생성자
  public CustomArray(int capacity) {
    data = new int[capacity];
    size = 0;
  }

  // 배열의 크기를 가져오는 메서드
  public int size() {
    return size;
  }

  // 배열이 비어 있는지 확인하는 메서드
  public boolean isEmpty() {
    return size == 0;
  }

  // 특정 인덱스의 요소를 가져오는 메서드
  public int get(int index) {
    if (index &lt; 0 || index &gt;= size) {
      throw new IndexOutOfBoundsException("Index out of bounds");
    }
    return data[index];
  }

  // 특정 인덱스에 요소를 설정하는 메서드
  public void set(int index, int value) {
    if (index &lt; 0 || index &gt;= size) {
      throw new IndexOutOfBoundsException("Index out of bounds");
    }
    data[index] = value;
  }

  // 배열에 요소를 추가하는 메서드
  public void add(int value) {
    if (size == data.length) {
      throw new IllegalStateException("Array is full");
    }
    data[size] = value;
    size++;
  }

  // 특정 인덱스의 요소를 삭제하는 메서드
  public void remove(int index) {
    if (index &lt; 0 || index &gt;= size) {
      throw new IndexOutOfBoundsException("Index out of bounds");
    }

    for (int i = index; i &lt; size - 1; i++) {
      data[i] = data[i + 1];
    }
    size--;
  }

  // 모든 요소를 출력하는 메서드
  public void print() {
    for (int i = 0; i &lt; size; i++) {
      System.out.print(data[i] + " ");
    }
    System.out.println();
  }
}


설명.

  필드:
    
      ‘data’ : 실제 데이터를 저장하는 배열.
      ‘size’ : 현재 배열에 저장된 요소의 개수.
    
  
  생성자:
    
      ‘CustomArray(int capacity)’ : 초기 용량을 설정하여 배열을 초기화 합니다.
    
  
  메서드:
    
      ‘size()’ : 현재 배열에 저장된 요소의 개수를 반환합니다.
      ‘isEmpty()’ : 배열이 비어있는지 확인합니다.
      ‘get(int index)’ : 특정 인덱스의 요소를 반환합니다.
      ‘set(int index, int value)’ : 특정 인덱스의 요소를 설정합니다.
      ‘add(int value)’ : 배열의 마지막에 요소를 추가합니다.
      ‘remove(int index)’ : 특정 인덱스의 요소를 제거하고, 이후의 요소들을 앞으로 이동시킵니다.
      ‘print()’ : 배열의 모든 요소를 출력합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-21-IntroDataStructureAndAlgorithm.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ds.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-21-IntroDataStructureAndAlgorithm.html"><h1 class="title_post">📦[DS,Algorithm] 자료구조 소개</h1></a>
                        <a href="/Backend/AnD/2024-05-21-IntroDataStructureAndAlgorithm.html" class="txt_post">
                            1️⃣ 자료구조(Data Structure)

자료구조(Data Structure)는 데이터를 효율적으로 저장하고 관리하며, 이를 통해 데이터를 효율적으로 접근하고 수정할 수 있도록 하는 체계적인 방법입니다.

자료구조는 알고리즘의 성능을 최적화하고 프로그램의 효율성을 향상시키는 데 중요한 역할을 합니다.

기본 개념.

자료구조는 데이터를 저장하는 방식과 데이터를 조작하는 방법을 정의합니다.

이는 데이터를 어떻게 배열하고, 접근하고, 수정하고, 삭제할지를 규정하는 규칙과 방법의 집합입니다.

주요 목적.


  효율적인 데이터 저장 및 접근.
    
      데이터를 효율적으로 저장하여 빠르게 접근하고 검색할 수 있도록 합니다.
    
  
  데이터 수정 및 삭제 용이.
    
      데이터를 쉽게 수정하고 삭제할 수 있도록 합니다.
    
  
  알고리즘 최적화.
    
      알고리즘의 성능을 최적화하고 실행 시간을 단축시킵니다.
    
  


주요 종류.


  배열(Array)
    
      고정된 크기의 연속된 메모리 공간에 데이터를 저장합니다.
      인덱스를 사용하여 데이터에 빠르게 접근할 수 있습니다.
    
  
  연결 리스트(Linked List)
    
      각 요소가 데이터와 다음 요소를 가리키는 포인터를 포함합니다.
      동적 크기 조절이 가능하며 삽입과 삭제가 용이합니다.
    
  
  스택(Stack)
    
      후입선출(LIFO, Last In First Out) 방식으로 동작합니다.
      데이터를 삽입하는 push와 삭제하는 pop 연산을 가집니다.
    
  
  큐(Queue)
    
      선입선출(FIFO, First In First Out) 방식으로 동작합니다.
      데이터를 삽입하는 enqueue와 삭제하는 dequeue 연산을 가집니다.
    
  
  트리(Tree)
    
      계층적 구조를 가지며, 노드와 에지로 구성됩니다.
      이진 트리, 이진 탐색 트리, AVL 트리 등 다양한 형태가 있습니다.
    
  
  그래프(Graph)
    
      노드(정점)와 에지(간선)로 구성된 자료구조로, 다양한 관계를 표현할 수 있습니다.
      방향 그래프, 무방향 그래프 등이 있습니다.
    
  
  해시 테이블(Hash Table)
    
      키-값 쌍을 저장하며, 해시 함수를 사용하여 데이터에 빠르게 접근할 수 있습니다.
      충돌 해결 방법으로 체이닝과 개방 주소법이 있습니다.
    
  


응용 사례.
자료구조는 데이터베이스, 운영체제, 네트워크, 인공지능, 게임 개발 등 다양한 분야에서 중요한 역할을 합니다.
적절한 자료구조의 선택은 프로그램의 성능과 효율성을 크게 향상시킬 수 있습니다.



2️⃣ 자료구조의 분류

1️⃣ 선형 자료구조(Linear Data Structure)

선형 자료구조(Linear Data Structure)는 데이터 요소들이 순차적으로 배열된 구조를 의미합니다.

이 자료구조에서는 데이터 요소들이 직선 형태로 연결되어 있으며, 각 요소는 한 다음 요소나 이전 요소와 연결되어 있습니다.

선형 자료구조의 주요 특징인 데이터 요소들이 한 줄로 배열되어 있다는 점 입니다.

주요 선형 자료구조르는 배열, 연결 리스트, 스택, 큐 등이 있습니다.

주요 선형 자료구조.


  배열(Array)
    
      정의 : 동일한 타입의 데이터 요소들이 연속된 메모리 공간에 저장되는 자료구조입니다.
      특징 : 고정된 크기를 가지며 인덱스를 통해 데이터에 빠르게 접근할 수 있습니다.
      예시 : 정수형 배열, 문자열 배열 등.
    
  
  연결 리스트(Linked List)
    
      정의 : 각 데이터 요소가 노드로 구성되고, 각 노드는 데이터와 다음 노드를 가리키는 포인터를 포함하는 자료구조입니다.
      특징 : 동적 크기 조절이 가능하며 삽입과 삭제가 용이하지만, 인덱스를 통한 접근은 배열보다 느립니다.
      종류 : 단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트 등.
    
  
  스택(Stack)
    
      정의 : 후입선출(LIFO, Last In First Out) 방식으로 동작하는 자료구조입니다.
      특징 : 데이터 삽입(push)과 삭제(pop)이 한쪽 끝에서만 이루어집니다.
      사용 사례 : 함수 호출 스택, 역순 문자열 처리 등.
    
  
  큐(Queue)
    
      정의 : 선입선출(FIFO, First In First Out) 방식으로 동작하는 자료구조입니다.
      특징 : 데이터의 삽입(enqueue)은 한쪽 끝(후단)에서, 삭제(dequeue)는 반대쪽 끝(전단)에서 이루어집니다.
      종류 : 원형 큐, 우선순위 큐, 덱(Deque) 등.
      사용 사례 : 운영 체제의 작업 스케줄링, 프린터 대기열 등.
    
  


선형 자료구조의 특징 및 장단점.

  특징.
    
      순차적 접근이 가능하며, 데이터를 차례대로 처리할 때 유리합니다.
      메모리에서 연속적으로 배치되므로 인덱스를 통해 직접 접근할 수 있습니다.(배열의 경우)
    
  
  장점.
    
      간단하고 구현이 용이합니다.
      데이터의 삽입과 삭제가 특정 조건 하에 효율적일 수 있습니다(예: 스택, 큐)
    
  
  단점
    
      데이터 크기에 따라 메모리 낭비가 발생할 수 있습니다(배열의 경우).
      특정 요소 접근이나 삽입/삭제 시 성능이 저하될 수 있습니다(연결 리스트의 경우)
    
  


마무리.

선형 자료구조는 데이터가 순차적으로 연결되어 있어 순차적 처리에 적합하며, 프로그램의 다양한 부분에서 사용되는 기초적인 자료구조입니다.



2️⃣ 비선형 자료구조(Non-linear Data Structure)

비선형 자료구조(Non-linear Data Structure)는 데이터 요소들이 계층적 또는 그물 형태로 배열된 구조를 의미합니다.

이 자료구조에서는 데이터 요소들이 순차적으로 배열되지 않고, 하나의 요소가 여러 요소들과 연결될 수 있습니다.

주요 비선형 자료구조로는 트리(Tree)와 그래프(Graph)가 있습니다.

주요 비선형 자료구조.


  트리(Tree)
    
      정의 : 노드와 그 노드들을 연결하는 간선으로 구성된 계층적 자료구조입니다. 트리는 루트 노드에서 시작하여 자식 노드로 분기하며, 사이클이 없습니다.
      특징 : 트리는 계층적 관계를 나타내며, 각 노드는 0개 이상의 자식 노드를 가질 수 있습니다.
      종류 :
        
          이진 트리(Binary Tree) : 각 노드가 최대 두 개의 자식 노드를 가지는 트리입니다.
          이진 탐색 트리(Binary Search Tree) : 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큰 값을 가지는 이진 트리입니다.
          균형 이진 트리(Balanced Binary Tree) : AVL 트리, 레드-블랙 트리 등과 같이 높이가 균형을 이루도록 유지되는 트리입니다.
          힙(Heap) : 완전 이진 트리의 일종으로, 최대 힙과 최소 힙이 있습니다.
          트라이(Trie) : 문자열을 저장하고 빠르게 검색하기 위해 사용되는 트리입니다.
        
      
    
  
  그래프(Graph)
    
      정의 : 정점(Vertex)들과 이 정점들을 연결하는 간선(Edge)들로 구성된 자료구조입니다.
      특징 : 그래프는 방향 그래프(Directed Graph)와 무방향 그래프(Undirceted Graph)로 나눌 수 있으며, 사이클이 존재할 수 있습니다.
      종류 :
        
          방향 그래프(Directed Graph) : 간선에 방향성이 있는 그래프입니다.
          무방향 그래프(Undirected Graph) : 간선에 방향성이 없는 그래프입니다.
          가중치 그래프(Weighted Graph) : 간선에 가중치가 부여된 그래프입니다.
          비가중치 그래프(Unweighted Graph) : 간선에 가중치가 없는 그래프입니다.
        
      
    
  


비선형 자료구조의 특징 및 장단점.

  특징 :
    
      계층적 또는 네트워크 구조를 나태내는 데 적합합니다.
      복잡한 관계를 표현할 수 있으며, 데이터 요소 간의 다대다 관계를 처리할 수 있습니다.
    
  
  장점 :
    
      데이터의 계층적 구조를 쉽게 표현할 수 있습니다(트리).
      복잡한 연결 관계를 효과적으로 모델링할 수 있습니다(그래프).
      특정 유형의 탐색, 정렬, 데이터 압축, 네트워크 라우팅 등에 유용합니다.
    
  
  단점 :
    
      구현과 관리가 선형 자료구조보다 복잡할 수 있습니다.
      특정 작업(예: 트리의 균형 유지, 그래프 탐색 등)에서 추가적인 알고리즘이 필요합니다.
    
  


마무리.

비선형 자료구조는 데이터가 단순히 순차적으로 배열되지 않고, 복잡한 관계를 나타내는 경우에 사용됩니다.

예를 들어, 파일 시스템의 디렉터리 구조, 데이터베이스 인덱스, 소셜 네트워크의 사용자 관계 등이 비선형 자료구조를 활용하는 사례입니다.



2️⃣ 자료구조의 구현.

1️⃣ 추상 자료형(Abstract Data Type, ADT)

자바 프로그래밍에서의 추상 자료형(Abstract Data Type, ADT)은 데이터의 논리적 구조와 이를 조작하는 연산들을 명확하게 정의한 개념입니다.

ADT는 구현 세부 사항을 숨기고, 데이터와 연산의 인터페이스를 통해 사용자에게 추상적인 수준에서 데이터 조작을 제공합니다.

즉, ADT는 데이터가 어떻게 저장되고 구현되는지에 대한 정보는 감추고, 데이터와 상호작용하는 방법만을 정의합니다.

주요 개념


  추상화(Abstraction)
    
      ADT는 데이터를 추상화하여 데이터의 실제 구현과 독립적으로 사용될 수 있도록 합니다.
      사용자는 데이터의 저장 방식이나 연산의 구현 방법을 알 필요 없이, ADT가 제공하는 인터페이스를 통해 데이터를 조작할 수 있습니다.
    
  
  인터페이스(Interface)
    
      ADT는 데이터 타입과 이를 다루는 연산들을 인터페이스를 통해 정의합니다.
      자바에서는 인터페이스(Interface) 키워드를 사용하여 ADT의 연산을 정의할 수 있습니다.
    
  
  캡슐화(Encapsulation)
    
      ADT는 데이터와 연산을 하나의 단위로 묶어 캡슐화합니다.
      데이터를 직접 접근하지 않고, 정의된 연산을 통해서만 접근할 수 있도록 하여 데이터 무결성을 보장합니다.
    
  


자바에서의 ADT 예시

다음은 자바에서 스택(Stack) ADT를 정의하고 구현하는 예시입니다.

스택 인터페이스 정의
public interface Stack&lt;T&gt; {
    void push(T item); // 스택에 아이템을 추가
    T pop(); // 스택에서 아이템을 제거하고 반환
    T peek(); // 스택의 맨 위 아이템을 반환(제거하지 않음)
    boolean isEmpty(); // 스택이 비어 있는지 확인
    int size(); // 스택의 크기 반환
}


스택 구현
import java.util.ArrayList;
import java.util.List;

public class ArrayListStack&lt;T&gt; implements Stack&lt;T&gt; {
    private List&lt;T&gt; list = new ArrayList&lt;&gt;();
    
    @Override
    public void push(T item) {
        list.add(item);
    }
    
    @Override
    public T pop() {
        if (isEmpty()) {
            throw new RuntimException("Stack is empty");
        }
        return list.remove(list.size() - 1);
    }
    
    @Override
    public T peek() {
        if (isEmpty()) {
            throw new RuntimeException("Stack is empty");
        }
        return list.get(list.size() - 1);
    }
    
    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }
    
    @Override
    public int size() {
        return list.size();
    }
}


설명

  
    ‘Stack&lt;T&gt;‘ 인터페이스는 스택 ADT의 연산을 정의합니다. 이 인터페이스는 ‘push’, ‘pop’, ‘peek’, ‘isEmpty’, ‘size’ 메서드를 포함합니다.
  
  ‘ArrayListStack&lt;T&gt;‘ 클래스는 ‘Stack&lt;T&gt;‘ 인터페이스를 구현합니다. 이 클래스는 ‘ArrayList’ 를 내부 데이터 구조로 사용하여 스택 연산을 구현합니다.
  ‘push’ 메서드는 스택에 아이템을 추가합니다.
  ‘pop’ 메서드는 스택에서 맨 위의 아이템을 제거하고 반환합니다.
  ‘peek’ 메서드는 스택의 맨 위 아이템을 제거하지 않고 반환합니다.
  ‘isEmpty’ 메서드는 스택이 비어 있는지 확인합니다.
  ‘size’ 메서드는 스택의 크기를 반환합니다.


이 예시에서 ‘Stack&lt;T&gt;‘ 인터페이스는 스택 ADT를 정의하고, ‘ArrayListStack&lt;T&gt;‘ 클래스는 이 ADT를 구현한 것입니다.

사용자는 ‘ArrayListStack’ 의 내부 구현을 알 필요 없이 ‘Stack’ 인터페이스를 통해 스택 연산을 사용할 수 있습니다.

이는 ADT의 주요 장점 중 하나인 구현의 독립성을 잘 보여줍니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-18-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-18-TIL.html"><h1 class="title_post">📝 [TIL] 240518 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-18-TIL.html" class="txt_post">
                            
  수학적 귀납법
  명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html"><h1 class="title_post">📝[blog post] 나는 어떤 백엔드 개발자가 되고 싶은걸까?</h1></a>
                        <a href="/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html" class="txt_post">
                            🤔 나는 어떤 백엔드 개발자가 되고 싶은걸까?

🙋‍♂️ 백엔드 개발자의 역할과 책임

어떤 백엔드 개발자가 되고 싶은지 말하기 전에 백엔드 개발자는 어떤 역할과 책임이 있는지 알아보아야 할 것 같아요.

1️⃣ 웹 서버 개발.

  웹 서버 및 API 개발.
  HTTP 요청 및 응답 처리.
  RESTful 서비스 설계 및 구현.


2️⃣ 데이터베이스 관리.

  데이터베이스 설계 및 최적화.
  SQL 및 NoSQL 데이터베이스 작업.
  데이터 모델링 및 스키마 설계.


3️⃣ 서버 사이드 로직.

  비즈니스 로직 구현.
  사용자 인증 및 권한 관리.
  데이터 유효성 검사.


4️⃣ API 개발 및 통합.

  외부 API와의 통합 작업.
  내부 API 설계 및 개발.
  API 문서화 및 유지보수.


5️⃣ 성능 최적화.

  서버 성능 모니터링 및 튜닝.
  캐싱 전략 설계 및 구현.
  로드 밸런싱 및 스케일링.


6️⃣ 보안 관리.

  데이터 보안 및 암호화.
  OWASP 및 기타 보안 지침 준수.
  침입 탐지 및 대응.


7️⃣ 클라우드 컴퓨팅.

  AWS, Azure, GCP 등 클라우드 플랫폼 사용.
  클라우드 기반 서비스 배포 및 관리.
  컨테이나화 및 오케이스트레이션(Docker, Kubernetes)


8️⃣ DevOps와 CI/CD.

  지속적 통합 및 배포(CI/CD) 파이프라인 구축.
  서버 및 서비스의 자동화 및 오케스트레이션.
  인프라스트럭처 코드화(Infrastructure as Code).


9️⃣ 로그 및 모니터링.

  애플리케이션 및 서버 로그 관리.
  모니터링 도구 설정(예: Prometheus, Grafana).
  로그 분석 및 문제 해결.


백엔드 개발자는 일반적으로 이 모든 역할을 하나의 프로젝트 내에서 수행하지 않아요.
회사나 팀의 구조에 따라 특정 역할에 집중하게 된답니다.
예를 들어, 일부 개발자는 데이터베이스 관리에 중점을 두고, 다른 개발자는 클라우드 인프라 관리에 집중할 수 있습니다.

🙋‍♂️ 내가 되고 싶은 백엔드 개발자.

  
    
      맡은 역할과 책임에 최선을 다하는 개발자
        
          저는 맡은 바에 항상 최선을 다해 임무를 완수합니다.
          내가 맡은 바에는 책임이라는 것이 따르기 때문에 항상 최선을 다해야 한다고 생각합니다.
        
      
    
  
  
    
      소통을 잘하는 백엔드 개발자.
        
          커뮤니케이션이 정말 중요하다고 생각합니다.
          하나의 프로그램을 만들기 위해서는 많은 사람들이 함께 만들어가는 것 이기 때문에 함께 협력하고 소통을 잘해야 합니다.
        
      
    
  
  
    
      유연한 사고를 가진 백엔드 개발자.
        
          나 자신의 의견 또는 생각 역시도 틀릴 수 있다는 것을 항상 인지하고 여러 모든 의견을 유연하게 받아들일 수 있는 백엔드 개발자가 되고 싶습니다.
        
      
    
  
  
    
      말이 아닌 코드로 증명하는 개발자.
        
          말로만 대단한 듯이 말하는 개발자가 아닌 진짜 코드로 증명해내는 그런 백엔드 개발자가 되고 싶습니다.
        
      
    
  
  
    
      겸손과 꾸준한 성장을 하는 백엔드 개발자.
        
          겸손의 미덕을 알고 있습니다. 언제나 배움의 자세를 가지고 항상 배우려 노력하며 꾸준히 성장하는 백엔드 개발자가 되고 싶습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-05-18-Math.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-05-18-Math.html"><h1 class="title_post">[Math] 수학적 귀납법</h1></a>
                        <a href="/Backend/Math/2024-05-18-Math.html" class="txt_post">
                            📝 수학적 귀납법이란?
수학적 귀납법은 자연수에 대한 명제의 참 여부를 증명하는 데 사용되는 강력한 수학적 증명 기법입니다.
이를 통해 무한히 많은 경우에 대해 명제가 참임을 보일 수 있습니다.

수학적 귀납법은 주로 ‘기본 단계’ 와 ‘귀납 단계’ 로 이루어집니다.

1️⃣ 기본 단계(Base Case)
명제가 첫 번째 자연수 n = 1(또는 특정 시작점 n = k)에 대해 참임을 증명합니다.

2️⃣ 귀납 단계(Inductive Step)
명제가 임의의 자연수 n = k에 대해 참이라고 가정했을 때, n = k + 1에도 참임을 증명합니다.

이를 좀 더 형식적으로 설명하면 다음과 같습니다.


  기본 단계:
    P(1)이 참임을 증명합니다.
    
  
  귀납 단계:
    P(k)가 참이라고 가정합니다.(귀납 가정)
P(k+1)이 참임을 증명합니다.
    
  


기본 단계와 귀납 단계가 모두 성립하면, 수학적 귀납법에 의해 모든 자연수 n에 대해 명제 P(n)이 참임을 증명할 수 있습니다.

3️⃣ 예제
자연수 n에 대해 다음 명제를 증명해봅시다:
1+2+3+...+n= n(n+1)/2



  기본 단계:
n = 1일때,
    1 = 1(1+1)/2 = 2/2 = 1
    
  


따라서 P(1)은 참입니다.


  귀납 단계:
P(k)가 참이라고 가정합니다 즉,
    1+2+3+...+k = k(k+1)/2
    
    이 가정하에 P(k+1)이 참임을 증명합니다.
  


1+2+3+...+k+(k+1) = k(k+1)/2+(k+1)


우변을 정리하면,
k(k+1)/2 + (k+1) = (k(k+1)+2(k+1))/2 = ((k+1)(k+2))/2


이는 P(k+1) 입니다.

기본 단계와 귀납단계가 모두 성립했으므로, 수학적 귀납법에 의해 모든 자연수 n에 대해 1+2+3+...+n = n(n+1)/2임을 증명할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-18-Troubleshooting-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-18-Troubleshooting-1.html"><h1 class="title_post">☕️[Java] 문자열 비교 - 트러블슈팅</h1></a>
                        <a href="/Backend/Java/2024-05-18-Troubleshooting-1.html" class="txt_post">
                            1️⃣ 문자열 비교.
  private static String exceptionHandleForPersonOfNationalMerit(Scanner scanner) throws InvalidCheckException {
    System.out.print("국가유공자 여부를 입력해 주세요.(y/n) :");
    String personOfNationalMerit = scanner.next();

    // 들어온 값이 y 또는 n이 아닌 경우 예외를 던집니다.
    if (personOfNationalMerit != "y" &amp;&amp; personOfNationalMerit != "n") {
      throw new InvalidCheckException("유효하지 않은 입력입니다. y 또는 n을 입력해주세요.");
    }
    return personOfNationalMerit;
  }


🤔 문제 상황.
1. 문자열 비교가 안되는 상황.

  ’==’ 연산자를 사용해서 “y” 또는 “n” 외의 다른 문자열이 들어올 경우 커스텀한 에러 를 발생시키려 했지만 정상적인 값인 “y” 와 n 을 넣어도 에러가 발생 하는 문제가 생겼습니다.


💻 트러블슈팅.
1. equals() 메소드의 사용.

자바에서는 문자열 비교를 할 때 ’==’ 연산자를 사용하는 것이 아니라 ‘equals()’ 메소드를 사용해야 합니다.

  ’==’ 연산자는 객체의 레퍼런스를 비교하기 때문에, 두 문자열이 같은 객체를 참조하는지 여부를 확인합니다.
  ‘equals()’ 메소드는 문자열의 내용을 비교합니다.


따라서, “y” 와 “n” 을 비교할 때 ’==’ 대신 ‘equals()’ 를 사용해야 합니다.

  private static String exceptionHandleForPersonOfNationalMerit(Scanner scanner) throws InvalidCheckException {
    System.out.print("국가유공자 여부를 입력해 주세요.(y/n) :");
    String personOfNationalMerit = scanner.next();

    // 들어온 값이 y 또는 n이 아닌 경우 예외를 던집니다.
    if (!personOfNationalMerit.equals("y") &amp;&amp; !personOfNationalMerit.equals("n")) {
      throw new InvalidCheckException("유효하지 않은 입력입니다. y 또는 n을 입력해주세요.");
    }
    return personOfNationalMerit;
  }


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-05-18-Math-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-05-18-Math-1.html"><h1 class="title_post">[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.</h1></a>
                        <a href="/Backend/Math/2024-05-18-Math-1.html" class="txt_post">
                            1️⃣ 기하학 - 설득술로서 발전해 온 수학

1️⃣ 명제와 증명.
“필요조건” 과 “충분조건” 에 대한 이해는 모든 논리의 기초가 되는 가장 중요한 사항이라 해도 과언이 아닙니다.

수학은 논리와 떼려야 뗄 수 없는 관계라는 것은 모두가 아는 사실이지만 ‘필요’ 와 ‘충분’ 은 수학의 논리 중에서도 가장 중요한 역할을 하는 기본적인 사고방식입니다.

‘이것 없이는 어떠한 수학적 논리도 전개할 수 없다’라고 단언할 수 있을 정도입니다.

또한, ‘부정’을 이용해서 증명하는 방법인 “대우” 와 “귀류법” 의 이해도 매우 중요합니다.

대우는 얼핏 보기에도 복잡해 보이는 명제를 단순화하고, 귀류법은 정면 돌파로는 증명할 수 없는(하기 어려운) 명제를 증명할 때 큰 힘을 발휘합니다.

명제란 무엇인지 먼저 확인해 봅시다.

명제: 참과 거짓을 객관적으로 판정할 수 있는 문장이나 식


예를 들어 ‘백두산은 한국에서 가장 높은 산이다’는 명제지만 ‘백두산은 멋있다’는 명제가 아닙니다.

백두산의 높이가 한국에서 가장 높은지는 객관적으로 판정할 수 있지만, 백두산이 멋지다고 느끼는 데는 개인차가 있으며(심지어 대부분이 ‘멋지다’고 생각할지라도) 참과 거짓을 객관적으로 판단할 수 없기 때문입니다.

💡 논리적 사고의 기초: 필요조건과 충분 조건.
우선 필요조건과 충분조건의 정의를 살펴보겠습니다.


  필요조건과 충분조건의 정의

  명제 ‘P이면 Q이다’ 가 참일 때,

  P를(Q이기 위한) “충분조건”

  Q를(P이기 위한) “필요조건”

  이라고 합니다.


‘P이면 Q이다’ 에서 P를 ‘재즈’라 하고 Q를 ‘음악’이라 하면 ‘재즈는 음악이다’가 됩니다.
이는 당연히 참이므로(올바르므로) 정의에 따라

  재즈: 충분조건
  음악: 필요조건


이 됩니다.

확실히 재즈가 되기 위해서는 (적어도) 음악일 필요가 있습니다.

또한, 음악이 되기 위해서 재즈면 (넉넉하게) 충분하다고 할 수 있습니다.

재즈는 음악의 한 장르이므로 이 둘의 관계를 그림으로 표현하면 다음과 같은 모습이 됩니다.



이처럼 한쪽이 다른 한쪽을 완전히 포함하는 경우를 다음과 같이 집합으로 이해해 보는 것도 매우 중요합니다.


  영역이 더 작은 쪽(재즈): 충분조건
영역이 더 큰 쪽(음악): 필요조건


특히 두 개의 명제 ‘P이면 Q다’ 와 ‘Q이면 P다’가 모두 참일 경우에는 ‘P와 Q가 서로의 필요충분조건이다’라고 합니다. 또는 ‘P와 Q는 서로 동치다’ 라고도 합니다.


  NOTE : 실수란

  수학에서는 일반적으로 부등식의 범위를 수직선에 나타낼 때,

  등호 없는 부등호(&lt;)는 ○와 대각선

  등호 있는 부등호(≤)는 ●와 (직선에) 수직으로 뻗은 선

  으로 표기합니다.

  예를 들어 1 ≤ x &lt; 4는 다음과 같이 표기합니다.

  


우리는 보통 무언가를 고를 때, 자연스레 “필요저건에 따라 후보를 줄여 나갑니다. 그리고 충분조건을 만족하는 후보를 탐색합니다.”

예를 들어 점심 메뉴를 고를 때, ‘8,000원 안팍의 메뉴’처럼 예산이 필요조건이 사람이 적지 않을 것입니다.

거기에 ‘30분 안에 먹을 수 있는 메뉴’ 혹은 ‘깔끔한 맛’ 등의 필요조건을 더 해, 그 모든 필요조건을 만족하는 메뉴로 후보를 줄여 나갑니다.

그리고 남은 메뉴(후보)가 오늘 점심으로 괜찮은지(충분한지) 고민합니다.

그 결과(예를 들어) ‘그럼 오늘 점심은 경양식 돈까스로 하자’고 결정하는 사고방식은 매우 당연하다고 생각할 것입니다.

이처럼 필요조건과 충분조건을 구분하는 능력은 문제를 해결할 때 대단한 위력을 발휘합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-17-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-17-TIL.html"><h1 class="title_post">📝 [TIL] 240517 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-17-TIL.html" class="txt_post">
                            
  연습 문제 풀이(2)
  예외 처리 - 트러블슈팅
  문자열 처리 - 트러블슈팅


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html"><h1 class="title_post">☕️[Java] 예외 처리 - 트러블슈팅</h1></a>
                        <a href="/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html" class="txt_post">
                            1️⃣ 예외 처리.

실제 코드를 작성하면서 예외 처리에 대한 문제를 맞닥뜨려 어떻게 해야 할지 고민하다 다음과 같이 풀어보았습니다.

  private static int enterTheAge(Scanner scanner) {
    while (true) {
      try {
        System.out.print("나이를 입력해 주세요.(숫자): ");
        int age = scanner.nextInt();
        return age;
      } catch (InputMismatchException e) {
        System.out.println("숫자를 입력해 주세요.");
        scanner.next();
      }
    }
  }


🤔 문제 상황.
1. 나이는 숫자만 입력되어야 한다.

  숫자가 아닌 것들이 들어왔을 경우 예외 처리를 해줘서 다시 유저가 나이를 입력할 수 있게끔 하도록 만드는 과정에서 문제 상황이 발견되었습니다.


💻 트러블슈팅.
1. while 반복문의 사용.

  while (true) 를 사용하여 무한 루프를 돌려 내부에서 숫자가 아니면 다시금 유저가 “유효하지 않은 입력입니다” 라는 예외 처리 출력문을 받고 “나이를 입력해 주세요” 라는 원래의 출력문을 받을 수 있도록 했습니다.


2. try-catch 문의 사용.

  try-catch 문을 사용하여 Scanner 클래스 메소드를 사용할 때 발생하는 예외중, 사용자가 기대하는 타입의 입력을 제공하지 않았을 때 던져지는 InputMismatchException 를 catch 문에 넣어주어 이 예외가 발생시 잡아서 실행하는 블럭 내부에 예외 처리 코드를 아래와 같이 삽입 하였습니다.
    try {
  System.out.print("나이를 입력해 주세요.(숫자): ");
  int age = scanner.nextInt();
  return age;
} catch (InputMismatchException e) {
  System.out.println("숫자를 입력해 주세요.");
  scanner.next();
}
    
  
  ‘scanner.next()’ 를 호출하여 잘못된 입력을 버리고, 다음 입력을 기다리도록 합니다.
  사용자가 유효한 숫자를 입력하면 ‘age’ 를 반환하고 메소드를 종료합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-17-PracticeSummary-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-17-PracticeSummary-2.html"><h1 class="title_post">📝[blog post] 연습 문제 풀이 정리(2)</h1></a>
                        <a href="/Backend/Post/2024-05-17-PracticeSummary-2.html" class="txt_post">
                            1️⃣ 수열과 재귀.

연습 문제를 풀다보니 수열과 재귀에 대해 많은 수학적 사고력이 필요하겠다는 생각이 들었습니다.


  수열 : 수학에서 수의 나열을 의미합니다.
    
      즉, 어떤 규착에 따라 나열된 수들의 집합을 말합니다.
      수열은 각 수를 나타내는 일련의 할(terms)으로 구성되며, 각 항은 특정 위치(index)를 가집니다.
      수열의 예로는 다음과 같은 것들이 있습니다.
        
          등차수열: 각 항이 일정한 값만큼 증가하거나 감소하는 수열(예: 2, 5, 8, 11…)(각 항이 3씩 증가)
          등비수열: 각 항이 일정한 비율로 증가하거나 감소하는 수열(예: 3, 9, 27, 81…)(각 항이 이전 항의 3배)
          피보나치 수열: 첫 두 항이 0과 1이고, 그 이후의 각 항이 바로 앞 두항의 합인 수열(예: 0, 1, 1, 2, 3, 5, 8….)
            
              수열은 다양한 수학적 문제를 해결하는 데 사용되며, 특히 함수, 극한, 미적분 등의 주제와 밀접한 관련이 있습니다.
            
          
        
      
    
  
  재귀 : 프로그래밍과 수학에서 사용되는 개념으로, 어떤 함수나 알고리즘이 자기 자신을 호출하는 방식울 말합니다.
    
      재귀를 통해 복잡한 문제를 더 작은 하위 문제로 나누어 해결할 수 있습니다.
      재귀 함수는 기본적으로 두 가지 부분으로 구성됩니다.
        
          1. 기저 조건(Base Case) : 재귀 호출이 더 이상 필요하지 않은 경우를 정의합니다. 기저 조건이 충족되면 함수는 더 이상 자기 자신을 호출하지 않고 종료됩니다.
          2. 재귀 호출(Recursive Call) : 함수가 자기 자신을 호출하여 문제를 더 작은 부분으로 나누어 해결하려고 시도합니다.
            
              재귀는 문제를 단순하고 직관적으로 표현할 수 있는 강력한 도구이지만, 재귀 호출이 과도하면 스택 오버플로(stack overflow)가 발생할 수 있으므로 주의가 필요합니다.
                
                  따라서 재귀를 사용할 때는 기저 조건을 잘 정의하고, 필요할 경우 반복(iteration)으로 문제를 해결하는 방법도 고려해야 합니다.
                
              
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-16-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-16-TIL.html"><h1 class="title_post">📝 [TIL] 240516 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-16-TIL.html" class="txt_post">
                            
  연습 문제 정리(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-16-PracticeSummary-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-16-PracticeSummary-1.html"><h1 class="title_post">📝[blog post] 연습 문제 풀이 정리(1)</h1></a>
                        <a href="/Backend/Post/2024-05-16-PracticeSummary-1.html" class="txt_post">
                            1️⃣ 이중 for 문.
이중 for 문은 for 문을 중첩해서 사용하는 것을 말합니다.

한 for 문 안에 또 다른 for 문 안에 또 다른 for 문이 들어있는 구조로, 주로 2차원 배열이나 리스트, 행렬을 처리할 때 사용됩니다.

1.1 기본 구조.
for (초기화1; 조건1; 증감1) {
    for (초기화2; 조건2; 증감2) {
        // 코드 블록
    }
}


1.2 예시
예를 들어, 2차원 리스트의 모든 요소를 출력하는 경우를 생각해 봅시다.
public class Main {
    public static void main(Stringp[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        for (int[] row : matrix) {
            for (int element : row) {
                System.out.println(element);
            }
        }
    }
}



  위 코드에서 ‘matrix’ 는 2차원 리스트입니다.
    
      첫 번째 for 문은 ‘matrix’ 의 각 행(row)을 순회하고, 두 번째 for 문은 각행의 요소(element)를 순회합니다.
    
  


출력 결과는 다음과 같습니다.
1
2
3
4
5
6
7
8
9


2️⃣ 규칙성을 찾는 것이 중요!
어떤 문제를 마주치면 규칙성을 찾는 것이 중요한 것 같습니다.
연습 문제 2-1 중 ‘정수형 숫자를 로마 숫자 표기로 변환하는 프로그램’ 을 작성하는 문제에서 그것을 깨달았습니다.

먼저 어떤 규칙성이 있는지 찾아낸 후 그 규칙성에 따라 문제를 풀고, 문제를 컴퓨터적 사고력을 이용하여 코딩을 하니 문제가 풀리는 것을 알게 되었습니다.

3️⃣ 인덱스를 자유자재로 가지고 놀 줄 알아야 합니다!
연습 문제를 풀면서 느낀 점 중 하나가 “인덱스를 자유자재로 가지고 놀 줄 알아야 한다” 는 부분이었습니다.

“인덱스를 자유자재로 가지고 논다” 라는 말은 문자열이 주어지면 인덱스를 활용하여 문자를 삽입, 삭제, 추출, 변환 등을 자유롭게 할 줄 알아야 한다는 의미입니다.

연습 문제 중 문자열에 대한 문제는 이 부분이 가장 중요시되는 것 같았습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-14-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-14-TIL.html"><h1 class="title_post">📝 [TIL] 240514 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-14-TIL.html" class="txt_post">
                            
  스트림


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-14-Stream.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-14-Stream.html"><h1 class="title_post">☕️[Java] 스트림</h1></a>
                        <a href="/Backend/Java/2024-05-14-Stream.html" class="txt_post">
                            1️⃣ 스트림.

1. 스트림(Stream)
자바에서 스트림(Stream) API는 자바 8에서 도입되어 컬렉션의 요소를 선언적으로 처리할 수 있는 방법을 제공합니다.
스트림 API를 이용하면 데이터 요소의 시퀀스를 효율적으로 처리할 수 있으며, 데이터를 병렬로 처리하는 것도 간단할게 할 수 있습니다.
스트림을 이용하면 복잡한 데이터 처리 작업을 간결하고 명확한 코드로 작성할 수 있습니다.

1.2 스트림의 주요 특정.

  
    1. 선언적 처리 : 스트림을 사용하면 무엇을 할 것인지(what)에 집중하여 작업을 설명할 수 있고, 어떻게 처리할 것인지(how)는 스트림 API가 알아서 최적화하여 처리합니다.
  
  
    2. 파이프라이닝 : 스트림 연산은 파이프라인을 형성할 수 있으며, 여러 단계의 처리 과정을 연결하여 복잡한 데이터 처리를 효과적으로 할 수 있습니다.
  
  
    3. 내부 반복 : 스트림은 “내부 반복”을 사용합니다. 즉, 데이터를 어떻게 반복할지 스트림이 처리하므로, 개발자는 각 요소에 어떤 처리를 할지만 정의하면 됩니다.
  
  
    4. 불변성 : 스트림은 데이터를 수정하지 않습니다. 대신, 각 단계에서 결과를 내는 새로운 스트림을 생성합니다. 이는 함수형 프로그래밍의 특성을 반영합니다.
  


1.3 스트림의 작업 흐름.
스트림 API의 작업 흐름은 크게 세 부분으로 나눌 수 있습니다.


  1. 스트림 생성 : 컬렉션, 배열, I/O 자원 등의 데이터 소스로부터 스트림을 생성합니다.
    List&lt;String&gt; myList = Arrays.asList("a1", "a2", "b1", "b2", "c2", "c1");
Stream&lt;String&gt; myStrean = myList.stream();
    
  
  2. 중간 연산(Intermediate operations) : 스트림을 변환하는 연산으로, 필터링, 매핑, 정렬 등이 있으며, 이 연산들은 연결 가능하고, 또한 게으르게(lazily) 실행됩니다.
    myStream.filter(s -&gt; s.startsWith("c"))
      .map(String::toUpperCase)
      .sorted();
    
  
  3. 종단 연산(Terminal operations) : 스트림의 요소들을 소모하여 결과를 생성하는 연산입니다. 예를 들어, forEach, reduce, collect 등이 있으며, 이 연산을 수행한 후 스트림은 더 이상 사용할 수 없습니다.
    myStream.forEach(System.out::println);
    
  


1.4 스트림과 병렬 처리.
스트림 API는 병렬 처리를 간단하게 지원합니다.
‘paralleStream()’ 을 호출하면 자동으로 여러 쓰레드에서 스트림 연산이 병렬로 수행됩니다.
이는 데이터가 큰 경우에 유용하며, 멀티코어 프로세서의 이점을 쉽게 활용할 수 있게 해줍니다.

1.5 📝 정리.
스트림은 자바에서 데이터 컬렉션을 함수형 스타일로 쉽게 처리할 수 있게 하는 강력한 도구입니다.
이는 코드의 간결성과 가독성을 높이는 데 큰 도움을 줍니다.



2. 중개 연산(Intermediate operations)
자바 스트림 API에서 중개 연산(Intermediate operations)은 스트림의 요소들을 처리하고 변형하는 연산들로서, 다른 스트림을 반환합니다.

중개 연산은 게으른(lazy) 특성을 가지며, 종단 연산(Terminal operation)이 호출되기 전까지는 실제로 실행되지 않습니다.

이런 특성은 연산의 체인을 구성할 때 성능 최적화에 도움을 줍니다.

2.1 중개 연산의 주요 특성.

  
    게으른 실행(Lazy Execution) : 중개 연산은 호출되었을 때 즉시 실행되지 않습니다. 대신, 종단 연산이 호출될 때 까지 실행이 지연됩니다.
  
  
    스트림 변환 : 각 중개 연산은 변형된 형태의 새로운 스트림을 변환합니다. 이는 연산을 연쇄적으로 연결할 수 있도록 합니다.
  


2.2 주요 중개 연산의 종류.

  1. 필터링(Filtering)
    
      ‘filter(Predicate&lt;T&gt; predicate)’ : 주어진 조건(프리디케이트)에 맞는 요소만을 포함하는 스트림을 반환합니다.
        List&lt;String&gt; names = Arrays.asList("Jo", "Lee", "Park", "Kang");
  names.stream()
   .filter(name -&gt; name.startsWith("K"))
   .forEach(System.out::println); // 출력: "Kang"
        
      
    
  
  2. 매핑(Mapping)
    
      ‘map(Function&lt;T, R&gt; mapper)’ : 스트림의 각 요소에 주어진 함수를 적용하고, 함수 결과로 주성된 새 스트림을 반환합니다.
      ‘flatMap(Function&lt;T, Stream&lt;R&gt;&gt; mapper)’ : 각 요소에 함수를 적용한 결과로 생성된 여러 스트림을 하나의 스트림으로 평탄화합니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);
numbers.stream()
 .map(number -&gt; number * number)
 .forEach(System.out::println); //출력: 1, 4, 9, 16
        
      
    
  
  3. 정렬(Sorting)
    
      ‘sorted() :’ 자연 순서대로 스트림을 정렬합니다.
      ‘sorted(Comparator&lt;T&gt; comparator) :’ 주어진 비교자를 사용하여 스트림을 정렬합니다.
        List&lt;String&gt; fruits = Arrays.asList("banana", "apple", "orange", "kiwi");
fruits.stream()
.sorted()
.forEach(System.out::println); // 출력: apple, banana, kiwi, orange
        
      
    
  
  4. 제한(Limiting) 및 건너뛰기(Skipping)
    
      ‘limit(long maxSize)’ : 스트림의 요소를 주어진 크기로 제한합니다.
      ‘skip(long n)’ : 스트림의 처음 n개 요소를 건너뜁니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
numbers.stream()
 .skip(2)
 .limit(3)
 .forEach(System.out::println); // 출력 3, 4, 5
        
      
    
  
  5. 중복 제거(Distinct)
    
      ‘distinct()’ : 스트림에서 중복된 요소를 제거합니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 2, 3, 4, 4, 5);
numbers.stream()
 .distinct()
 .forEach(System.out::println); // 출력: 1, 2, 3, 4, 5
        
      
    
  


2.3 📝 정리.
중개 연산을 통해 데이터 스트림을 세밀하게 제어하고 원하는 형태로 데이터를 변형 할 수 있습니다.
이러한 연산들은 다양한 데이터 처리 작업에서 매우 유용하게 사용됩니다.



3. 최종 연산(Terminal operations)
자바 스트림 API에서 최종 연산(Terminal operations)은 스트림 파이프라인의 실행을 트리거하고 스트림의 요소를 소비하여 결과를 생성하거나 부작용(side effect)을 일으키는 연산입니다.

최종 연산이 호출되기 전까지 중간 연산들은 게으른(lazy) 방식으로 처리되며 실행되지 않습니다.
최종 연산 후에는 스트림이 소비되어 더 이상 사용할 수 없게 됩니다.

3.1 최종 연산의 주요 유형.

  1. 수집(Collection)
    
      ‘collect(Collector&lt;T, A, R&gt; collector)’ : 스트림의 요소를 변환, 결합하고 컬렉션으로 또는 다른 형태로 결과를 수집합니다.
        
          예를 들어, ‘toList()’, ‘toSet()’, ‘toMap()’ 등이 있습니다.
            List&lt;String&gt; names = Array.asList("Alice", "Bob", "Charlie", "David");
List&lt;String&gt; list = names.stream()
               .filter(name -&gt; name.startsWith("A"))
               .collect(Collectors.toList());
System.out.println(list); // 출력 ["Alice"]
            
          
        
      
    
  
  2. 집계(Aggregation)
    
      ‘count()’ : 스트림의 요소 개수를 반환합니다.
      ‘max(Comparator&lt;T&gt; comparator)’ : 스트림에서 최대값을 찾습니다.
      ‘min(Comparator&lt;T&gt; comparator)’ : 스트림에서 최소값을 찾습니다.
      ‘reduce(BinaryOperator&lt;T&gt; accumulator)’ : 스트림의 요소를 결합하여 하나의 결과를 생성합니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);
int sum = numbers.stream()
           .reduce(0, (a, b) -&gt; a + b);
System.out.println(sum); // 출력: 10
        
      
    
  
  3. 반복(Iteration)
    
      ‘forEach(Consumer&lt;T&gt; action)’ : 각 요소에 대해 주어진 작업을 수행합니다. 스트림의 순서대로 실행됩니다.
        List&lt;String&gt; names = Arrays.asList("Alist", "Bob", "Charlie", "David");
names.stream()
   .forEach(System.out::println); // Alice, Bob, Charlie, David
        
      
    
  
  4. 조건 검사(Checking)
    
      ‘allMatch(Predicate&lt;T&gt; predicate) :’ 모든 요소가 주어진 조건을 만족하는지 검사합니다.
      ‘anyMatch(Predicate&lt;T&gt;predicate) :’ 어떤 요소라도 주어진 조건을 만족하는지 검사합니다.
      ‘noneMatch(Predicate&lt;T&gt;predicate) :’ 모든 요소가 주어진 조건을 만족하지 않는지 검사합니다.
        boolean allEven = numbers.stream()
                   .allMatch(n -&gt; n % 2 == 0);
System.out.println(allEven); // 출력: false
        
      
    
  
  5. 요소 검색(Finding)
    
      ‘findFirst()’ : 스트림의 첫 번째 요소를 Optional로 반환합니다.
      ‘findAny()’ : 스트림에서 임의의 요소를 Optional로 반환합니다. 병렬 스트림에서 유용합니다.
        Optional&lt;String&gt; first = names.stream()
                        .findFirst();
first.ifPresent(System.out::println); // 출력 Alice
        
      
    
  


3.2 📝 정리.
이러한 최종 연산들은 스트림 처리를 완료하고 필요한 결과를 도출하기 위해 사용됩니다.
스트림 API를 통해 데이터 처리를 선언적이고 간결하게 할 수 있으며, 복잡한 로직을 효과적으로 관리할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-13-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-13-TIL.html"><h1 class="title_post">📝 [TIL] 240513 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-13-TIL.html" class="txt_post">
                            
  컬렉션 프레임워크
  HashMap에 key 값은 항상 int 여야 할까요?
  람다식
  람다식은 하나만!


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-lambdaIsOnlyOne.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-lambdaIsOnlyOne.html"><h1 class="title_post">☕️[Java] 람다식은 하나만!</h1></a>
                        <a href="/Backend/Java/2024-05-13-lambdaIsOnlyOne.html" class="txt_post">
                            람다식은 하나만!😆
자바에서는 “하나의 추상 메소드를 갖는 인터페에스에 대해서만 람다식을 직접 사용할 수 있습니다.”
이를 함수형 인터페이스라고 부르며, 람다식은 이런 함수형 인터페이스의 구현을 간단히 할 수 있는 방법을 제공합니다.

하지만 아래의 코드와 같이 인터페이스 내에 두 개의 추상 메서드 (‘plus’, ‘minus’)가 있기 때문에, 이 인터페이스를 람다식으로 직접 구현하는 것은 불가능합니다.

interface Carculator {
    public abstract int plus(int x, int y);
    public abstract int minus(int x, int y);
}


람다식을 사용하려면 함수형 인터페이스가 필요하므로, 두 메소드 각각을 위한 두 개의 별도의 인터페이스를 정의하거나 기존 인터페이스 중 하나를 수정해야 합니다.

아래의 코드는 이를 위해 각 메소드를 분리하여 두 개의 함수형 인터페이스를 만든 예시입니다.
interface Calculator {
  public abstract int operation(int x, int y);
}
public class Main {

  public static void main(String[] args) {
    Calculator plus = (x, y) -&gt; { return x + y; };
    System.out.println(plus.operation(10,2)); // 12
    Calculator minus = (x, y) -&gt; { return x - y; };
    System.out.println(minus.operation(10,2)); // 8
  }
}


위 코드는 각 연산을 람다식으로 간단히 구현하고 있습니다.
만약 원래의 ‘Carculator’ 인터페이스를 유지고하고 싶다면 이를 직접적으로 람다식으로 구현할 수는 없으며, 대신 익명 클래스나 정규 클래스를 사용해야 합니다.

아래의 코드는 익명 클래스를 사용하는 방법을 보여줍니다.
Calculator calclator = new Calculator() {
    @Override
    public int plus(int x, int y) {
        return x + y;
    }
    
    @Override
    public int minus(int x, int y) {
        return x - y;
    }
}


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-lambda.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-lambda.html"><h1 class="title_post">☕️[Java] 람다식</h1></a>
                        <a href="/Backend/Java/2024-05-13-lambda.html" class="txt_post">
                            1️⃣ 람다식.

1. 람다 표현식(Lambda Expression)
자바 프로그래밍에서 람다식 또는 람다 표현식(Lambda Expression)은 간결한 방식으로 익명 함수(anonymous function)를 제공하는 기능입니다.

자바 8부터 도입된 이 기능은 함수형 프로그래밍의 일부 개념을 자바에 도입하여, 코드를 더 간결하고 명료하게 만들어 주며 특히 컬렉션의 요소를 처리할 때 유용하게 사용됩니다.

1.2 람다식의 특징.

  익명성 : 람다는 이름이 없기 때문에 익명으로 처리됩니다.
  함수 : 람다는 메서드와 유사하지만, 독립적으로 존재할 수 있는 함수입니다.
  전달성 : 람다 표현식은 메서드 인자로 전달되거나 변수에 저장될 수 있습니다.
  간결성 : 코드의 간결성을 높여, 불필요한 반복을 줄여줍니다.


1.3 람다 표현식의 기본 구조.
람타 표현식은 주로 매개 변수를 받아들여 결과를 반환하는 식의 형태로 작성됩니다.

일반적인 형태는 다음과 같습니다.
(parameters) -&gt; expression
또는
(parameters) -&gt; { statements; }


  매개 변수 : 괄호 안에 정의되며, 매개 변수의 타입을 명시할 수도 있고 생략할 수도 있습니다.
    
      매개 변수가 하나뿐인 경우, 괄호도 생략할 수 있습니다.
    
  
  
    화살표(-&gt;) : 매개 변수와 몸체를 구분짓는 역할을 합니다.
  
  몸체 : 람다의 실행 로직을 담고 있으며, 식(expression) 또는 문장(statements)이 올 수 있습니다.
    
      식은 단일 실행 결과를 반환하며, 중괄호는 생략할 수 있습니다.
      문장은 중괄호 안에 작성되며, 여러 줄의 코드를 포함할 수 있습니다.
    
  


1.4 예시

  Thread 실행하기
    new Thread(() -&gt; System.out.println("Hello from a thread")).start();
    
  
  리스트의 각 요소 출력하기
    List&lt;String&gt; list = Arrays.asList("Apple", "Banana", "Cherry");
list.forEach(item -&gt; System.out.println(item));
    
  
  Comparator를 통한 정렬
    List&lt;String&gt; cities = Arrays.asList("Seoul", "New York", "London");
Collections.sort(cities, (s1, s2) -&gt; s1.compareTo(s2));
    
  


1.5 📝 정리.
람다 표현식은 이벤트 리스너, 스레드의 실행 코드 등 여러 곳에서 기존에 익명 클래스를 사용하던 부분을 대체하여 코드를 더 간결하게 만들 수 있습니다.

또한, 스트림 API와 함께 사용될 때 강력한 데이터 처리 기능을 제공하여 복잡한 컬렉션 처리를 단순화시킬 수 있습니다.



2. 람다식의 장점.
자바에서 람다식(Lambda Expression)을 사용하는 것은 여러 가지 장점을 제공합니다.

이러한 장점들은 프로그래밍 스타일, 코드의 간결성, 효율성 및 기능성 측면에서 특히 두드러집니다.

2.1 람다식의 주요 장점들.

  1. 코드의 간결성 : 람다식을 사용하면 복잡한 익명 클래스를 사용할 필요가 없어지므로 코드를 훨씬 간결하게 작성할 수 있습니다.
    
      예를 들어, 스레드를 실행하거나 이벤트 리스너를 설정할 때 몇 줄의 코드로 작성할 수 있습니다.
    
  
  2. 가독성 향상 : 람다식은 기존의 익명 클래스보다 훨씬 읽기 쉽고 이해하기 쉬운 코드를 작성할 수 있게 합니다.
    
      이는 유지보수 시간을 줄이고 코드의 질을 향상시키는 데 도움이 됩니다.
    
  
  3. 함수형 프로그래밍 지원 : 람다식은 자바에 함수형 프로그래밍 스타일을 도입하였습니다.
    
      이는 데이터 처리와 조작을 보다 선언적으로 표현할 수 있게 해, 복잡한 데이터 처리 로직을 간결하고 효율적으로 작성할 수 있도록 합니다.
    
  
  4. 코드의 재사용성 증가 : 람다식을 사용하면 특정 동작을 수행하는 코드 블록을 쉽게 재사용할 수 있습니다.
    
      람다식은 변수처럼 취급될 수 있어, 메소드에 인자로 전달하거나 변수에 할당하여 다른 위치에서 사용할 수 있습니다.
    
  
  5. 병렬 실행 용이 : 자바 8 이후로 스트림 API와 결합된 람다식은 컬렉션 처리를 병렬로 쉽게 수행할 수 있게 해줍니다.
    
      이는 ‘parallelStream()’ 과 같은 메소드를 사용하여 멀티코어 프로세서의 이점을 쉽게 활용할 수 있게 합니다.
    
  
  6. 지연 실행(Lazy Evaluation) : 람다식은 지연 실행을 가능하게 합니다.
    
      예를 들어, 조건이 충족될 때까지 코드 실행을 지연시키거나, 필요할 때만 데이터를 처리하도록 할 수 있습니다.
        
          이는 성능 최적화에 도움을 줄 수 있습니다.
        
      
    
  
  7. 함수 인터페이스와의 호환성 : 람다식은 단일 추상 메소드를 가진 인터페이스(함수 인터페이스)와 호환됩니다.
    
      이는 많은 내장 함수 인터페이스(‘Runnable’, ‘Callable’, ‘Comparator’ 등)와 사용자 정의 함수 인터페이스에 람다식을 적용할 수 있음을 의미합니다.
    
  


2.2 📝 정리.
이러한 장점들로 인해 람다식은 자바 프로그래머들 사이에서 매우 인기 있는 기능이 되었으며, 모던 자바 코드에서는 필수적인 요소로 자리 잡고 있습니다.



3. 람다식의 단점.
자바에서 람다식을 사용하면 여러 가지 장점이 있지만, 몇 가지 단점 또는 주의할 점도 있습니다.

3.1 람다식의 사용과 관련된 단점.

  1. 디버깅의 어려움 : 람다식은 익명 함수이기 때문에 디버깅이 더 복잡할 수 있습니다.
    
      스택 트레이스에서 람다식이 어디에 위치하는지 명확하게 표시되지 않아 오류를 추적하기 어려울 수 있습니다.
    
  
  2. 코드의 남용 : 람다식을 과도하게 사용하면 코드가 오히려 더 복잡해지고 이해하기 어려워질 수 있습니다.
    
      특히 람다 내부에 긴 로직이나 조건문을 넣을 경우 가독성이 떨어질 수 있습니다.
    
  
  3. 람다 캡처링 오버헤드 : 람다식은 주변 환경의 변수를 캡처(Capture)할 수 있습니다.
    
      이 때, 람다가 외부 변수를 캡처 할 경우 추가적인 비용이 발생할 수 있으며, 이는 성능에 영향을 줄 수 있습니다.
    
  
  4. 직렬화의 문제 : 람다식은 기본적으로 직렬화가 보장되지 않습니다.
    
      따라서 람다식을 사용하는 객체를 직렬화하려고 할 때 문제가 발생할 수 있습니다.
        
          이는 분산 시스템에서 특히 중요한 이슈가 될 수 있습니다.
        
      
    
  
  5. 학습 곡선 : 자바 8 이전의 버전에 익숙한 개발자들에게 람다식과 스트림 API는 새로운 패러다임을 익혀야 하는 도전과제를 제시합니다.
    
      이는 초기 학습 곡선을 가파르게 만들 수 있습니다.
    
  
  6. 타입 추론의 복잡성 : 람다식에서는 자바 컴파일러가 타입을 추론해야 하는데, 때때로 이 추론이 개발자의 의도와 다른게 이루어질 수 있습니다.
    
      이는 코드의 명확성을 떨어뜨릴 수 있습니다.
    
  
  7. 함수형 인터페이스의 제약 : 람다식은 단 하나의 추상 메소드를 가진 함수형 인터페이스와 함꼐 사용됩니다.
    
      때로는 이런 제약이 프로그램 설계를 더 복잡하게 만들 수 있습니다.
    
  


3.2 📝 정리.
람다식의 단점들은 주로 개발과 관련된 트레이드오프와 관련이 있으며, 이러한 단점을 이해하고 적절히 관리한다면 람다식을 효과적으로 사용할 수 있습니다.



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html"><h1 class="title_post">☕️[Java] HashMap에 key 값은 항상 int 여야 할까요?</h1></a>
                        <a href="/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html" class="txt_post">
                            🤔 HashMap에 key 값은 항상 int 여야 할까요?

강의와 예제 코드를 열심히 보고 따라서 타이핑하고 있던 중 “문뜩!” 떠올랐습니다. 🤩

‘HashMap에 key 값은 항상 int 여야 할까요?🤔’

그래서 구글링과 챗 지피티 그리고 Java의 정석 도서를 살펴본 후 이 글을 쓰게 되었습니다 :)



🙅‍♂️ 대답은 “아니오!” 입니다.

자바 프로그래밍에서 ‘HashMap’ 의 키 값은 ‘int’ 형일 필요는 없다고 합니다.

‘HashMap’ 은 키로서 어떠한 객체도 사용할 수 있으며, 기는 자바의 ‘제네릭’ 을 통해 다양한 유형의 객체를 키로 사용할 수 있게 해준다고 합니다.
(오! “제네릭” 은 아직 안배웠지만 🥲 Swift에서 봐서 비슷한 느낌 같은데?!)

키 객체는 ‘Object’ 클래스의 ‘hashCode()’ 메소드와 ‘equals()’ 메소드를 적절히 구현해야 합니다.
(‘Object’ 클래스는 무엇이고,  ‘hashCode()’ 메소드와 ‘equals()’ 메소드는 무엇인가?!! 🤪)

이는 ‘HashMap’ 이 키의 해시 코드를 사용하여 데이터를 저장하고 검색하기 때문입니다.
(도통 무슨 소리인지 몰라서 아래 “제네릭”. “Object 클래스”, “hashCode()”, “equals()”를 정리했어요 ㅎㅎ)

‘HashMap’ 을 사용할 때, 키로 사용되는 객체의 ‘hashCode()’ 메소드가 효율적이고 일관성 있는 값을 반환해야 합니다.
또한, ‘equalse()’ 메소드는 객체의 동등성을 정확하게 판단할 수 있어야 합니다.
이 두 메소드의 구현이 적절히 이루어져야 ‘HashMap’ 이 키의 중복 없이 정확하게 데이터를 관리할 수 있습니다.

예시 - String 객체를 키로 사용하는 ‘HashMap’
import java.util.HashMap;

public class Example {
    public static void main(String[] args) {
        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        map.put("one", 1);
        map.put("two", 2);
        map.put("three", 3);
        
        System.out.println(map.get("two")); // 출력: 2
    }
}



  위 예시에서 보듯, ‘String’ 외에도 사용자가 정의한 어떠한 객체든 ‘hashCode()’ 와 ‘equals()’ 가 적절히 구현되어 있다면 키로 사용할 수 있습니다.
    
      따라서 ‘int’ 만을 키로 사용해야 하는 것은 아닙니다.
    
  




1️⃣ 제네릭(Generic).
자바에서 ‘제네릭(Generic)’ 은 클래스, 인터페이스, 메소드를 정의할 때 타입(Type)을 하나의 매개변수처럼 취급하여, 다양한 데이터 타입을 사용할 수 있도록 하는 프로그래밍 기법입니다.

제네릭을 사용하면 컴파일 시점에 타입 안정성을 제공하고, 타입 캐스팅을 줄여 코드를 더 간결하고 읽기 쉽게 만들 수 있습니다.

제네릭 기본 문법.
제네릭은 타입 매개변수를 사용하여 구현됩니다.

타입 매개변수는 보통 한 글자로 표현되며, 일반적으로 다음과 같은 문자를 사용합니다.


  ‘E’ : Element(컬렉션에서 사용되는 요소)
  ‘K’ : Key(키)
  ‘V’ : Value(값)
  ‘T’ : Type(일반적인 타입)
  ‘S’, ‘U’, ‘V’ 등 - 두 번째, 세 번째, 네 번째 타입을 나타내기 위해 사용


예시: 제네릭을 사용한 클래스와 메소드
// 제네릭 클래스 예시
public class Box&lt;T&gt; {
    private T t; // T는 이 클래스가 다루는 객체의 타입을 매개변수화합니다.
    
    public void set(T t) {
        this.t = t;
    }
    
    public T get() {
        return t;
    }
}

// 제네릭 메소드 예시
public static &lt;T&gt; void printArray(T[] inputArray) {
    for (T element : inputArray) {
        System.out.print(element + " ");
    }
    System.out.println();
}


  위 예시에서 ‘Box’ 클래스는 타입 매개변수 ‘T’ 를 사용하여 다양한 타입을 저장하고 반환할 수 있는 범용 컨테이너로 사용됩니다.
  ‘printArray’ 메소드는 어떤 배열 타입도 받아들일 수 있으며, 그 요소들을 출력합니다.




2️⃣ Object 클래스.
자바 프로그래밍에서 ‘Object’ 클래스는 자바의 클래스 계층 구조에서 가장 상위에 위치하는 클래스입니다.

모든 자바 클래스는 직접적이거나 간접적으로 ‘Object’ 클래스를 상속받습니다.

이는 ‘Object’ 클래스가 자바에서 모든 클래스의 근본(base)이라는 의미 입니다.

‘Object’ 클래스는 자바의 ‘java.lang’ 패키지에 포함되어 있으며, 모든 객체에 공통적으로 필요한 메서드를 제공합니다.

Object 클래스의 의의.
‘Object’ 클래스의 메서드들은 자바의 모든 클래스에 기본적인 기능을 제공합니다.

이로 인해, 개발자는 어떤 클래스를 만들 때도 이러한 기본적인 메서드들을 새로 작성하지 않고도, 필요에 따라 이를 상속받아 확장하거나 재정의할 수 있습니다.

‘Object’ 클래스는 자바의 모든 클래스와 객체에 공통적인 근복적인 메커니즘을 제공하는 중추적인 역할을 합니다.



3️⃣ Object 클래스의 hashCode() 메소드.
자바의 ‘Object’ 클래스에서 ‘hashCode()’ 메소드는 객체의 메모리 주소를 기반으로 계산된 정수 값을 반환하는 메소드입니다.

이 메소드는 객체의 해시 코드를 제공하며, 해시 기반 컬렉션(예: ‘HashMap’, ‘HashSet’, ‘Hashtable’ 등)에서 객체를 효율적으로 관리하기 위해 사용됩니다.

hashCode() 메소드의 주요 용도

  1. 해시 테이블 사용 : ‘hashCode()’ 는 특히 해시 테이블을 사용하는 자료 구조에서 중요합니다.
    
      객체의 해시 코드를 사용하여, 해당 객체가 저장되거나 검색될 해시 버킷을 결정합니다.
        
          이로 인해 데이터의 삽입, 검색, 삭제 작업이 빠르게 수행될 수 있습니다.
        
      
    
  
  2. 객체의 동등성의 빠른 검증 : ‘hashCode()’ 메소드는 ‘equals()’ 메소드와 함께 사용되어 객체의 동등성을 검사합니다.
    
      두 객체가 같다면 반드시 같은 해시 코드를 반환해야 합니다.
        
          따라서, 해시 코드가 다른 두 객체는 결코 같을 수 없으므로, ‘equals()’ 호출 전에 해시 코드를 먼저 확인함으로써 불필요한 비교를 줄일 수 있습니다.
        
      
    
  




4️⃣ Object 클래스의 equals() 메소드.
자바 프로그래밍에서 ‘Object’ 클래스의 ‘equals()’ 메소드는 두 객체가 동등한지 비교하는데 사용됩니다.

이 메소드는 ‘Object’ 클래스에서 모든 클래스로 상속되며, 특히 객체의 동등성을 판단할 때 중요한 역할을 합니다.

기본적으로, ‘Object’ 클래스의 ‘equals()’ 메소드는 두 객체의 참조가 같은지 확인합니다.

즉, 두 객체가 메모리상에서 같은 위치를 가리키는지 검사합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-CollectionFramework.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-CollectionFramework.html"><h1 class="title_post">☕️[Java] 컬렉션 프레임워크</h1></a>
                        <a href="/Backend/Java/2024-05-13-CollectionFramework.html" class="txt_post">
                            1️⃣ 컬렉션 프레임워크

1. 컬렉션 프레임워크(Collection Framework)
자바 컬렉션 프레임워크는 자료 구조를 효율적으로 관리하고 조작할 수 있는 방법을 제공하는 통합 아키텍처입니다.
이 프레임워크는 다양한 인터페이스와 구현을 포함하며, 다양한 종류의 컬렉션들을 제어하고, 데이터 집합을 효율적으로 관리하기 위한 알고리즘을 제공합니다.

1.2 컬렉션 프레임워크의 구요 구성 요소.

  1. 인터페이스(Interface) : 컬렉션 프레임워크의 핵심 인터페이스로는 ‘Collection’, ‘List’, ‘Queue’ 등이 있으며 각각 다른 형태의 데이터 집합을 추상화합니다.
    
      예를 들어, ‘List’ 는 순서가 있는 데이터 집합을, ‘Set’ 은 중복을 허용하지 않는 데이터 집합을 나타냅니다.
    
  
  2. 구현(Implementation) : 이러한 인터페이스를 실제로 구현한 클래스들로, ‘ArrayList’, ‘LinkedList’, ‘HashSet’, ‘TreeSet’, ‘PriorityQueue’ 등이 포함됩니다.
    
      각 클래스는 컬렉션 인터페이스를 구현하며, 데이터의 특성에 따라 선택하여 사용할 수 있습니다.
    
  
  3. 알고리즘(Algorithm) : 컬렉션 데이터를 처리하는 데 필요한 다양한 알고리즘이 제공됩니다.
    
      이 알고리즘은 정렬, 검색, 순환 및 변환 등을 포함하며, 이들은 대부분 ‘Collections’ 클래스에 정적 메소드로 제공됩니다.
    
  


1.3 📝 정리.
컬렉션 프레임워크를 사용하면 데이터를 보다 효율적으로 처리할 수 있고, 기능의 재사용성 및 유지 보수성이 향상됩니다.
또한, 자바 개발자로서 다양한 데이터 컬렉션을 쉽게 처리하고, 표준화된 방법으로 데이터를 조작할 수 있는 능력을 갖추게 됩니다.



2. List 인터페이스.
자바 프로그래밍에서 ‘List’ 인터페이스는 ‘java.util’ 패키지의 일부로, 순서가 있는 컬렉션을 나타냅니다.
이 인터페이스를 사용하면 사용자가 목록의 특정 위치에 접근, 삽입, 삭제를 할 수 있는 동시에, 목록의 요소들이 입력된 순서대로 저장 및 관리됩니다.
‘List’ 는 중복된 요소의 저장을 허용하기 때문에, 같은 값을 가진 요소를 여러 개 포함할 수 있습니다.

2.1 List 인터페이스의 주요 메서드.

  add(E e) : 리스트의 끝에 요소를 추가합니다.
  add(int index, E element) : 리스트의 특정 위치에 요소를 삽입합니다.
  remove(Object o) : 리스트에서 지정된 요소를 삭제합니다.
  remove(int index) : 리스트에서 지정된 위치의 요소를 삭제합니다.
  get(int index) : 지정된 위치에 있는 요소를 반환합니다.
  set(int index, E element) : 리스트의 특정 위치에 요소를 설정(교체)합니다.
  indexOf(Object o) : 객체를 찾고, 리스트 내의 첫 번째 등장 위치를 반환합니다.
  size() : 리스트에 있는 요소의 수를 반환합니다.
  clear() : 리스트에서 모든 요소를 제거합니다.


2.3 가장 널리 사용되는 구현체.
‘List’ 인터페이스는 다양한 구현체를 가지고 있으며, 가장 널리 사용되는 구현체는 ‘ArrayList’, ‘LinkedList’ 그리고 ‘Vector’ 입니다.

각 구현체는 내부적인 데이터 관리 방식이 다르므로, 사용 상황에 따라 적합한 구현체를 선택할 수 있습니다.


  ‘ArrayList’ : 내부적으로 배열을 사용하여 요소들을 관리합니다. 인덱스를 통한 빠른 접근이 가능하지만, 크기 조정이 필요할 때 비용이 많이 들 수 있습니다.
  ‘LinkedList :’ 내부적으로 양방향 연결 리스트를 사용합니다. 데이터의 삽입과 삭제가 빈번하게 일어나는 경우 유용합니다.
  Vector : ‘ArrayList’ 와 비슷하지만, 모든 메소드가 동기화되어 있어 멀티스레드 환경에서 사용하기에 안전합니다.


2.4 📝 정리.
이러한 특성들로 인해 ‘List’ 인터페이스는 자바에서 데이터를 순차적으로 처리할 필요가 있는 다양한 애플리케이션에서 중요하게 사용됩니다.



3. Set 인터페이스.
자바 프로그래밍에서 ‘Set’ 인터페이스는 ‘java.util’ 패키지의 일부이며, 중복을 허용하지 않는 요소의 컬렉션을 나타냅니다.

‘Set’ 은 ‘Collection’ 인터페이스를 확장하는 인터페이스로서, 집합의 개념을 구현합니다.
이는 각 요소가 컬렉션 내에서 유일하게 존재해야 함을 의미합니다.

인덱스로 요소를 관리하는 ‘List’ 인터페이스와 달리, ‘Set’ 은 요소의 순서를 유지하지 않습니다.

3.1 Set의 주요 특징.

  중복 불허 : 같은 요소의 중복을 허용하지 않으며, 이미 ‘Set’ 에 존재하는 요소를 추가하려고 시도하면 그 요소는 컬렉션에 추가되지 않습니다.
  순서 보장 없음 : 대부분의 ‘Set’ 구현체는 요소의 저장 순서를 유지하지 않습니다. 그러나 ‘LinkedHashSet’ 과 같은 특정 구현체는 요소의 삽입 순서를 유지할 수 있습니다.
  값에 의한 접근 : ‘Set’ 은 인덱스를 사용하지 않고 값에 의해 요소에 접근합니다.


3.2 주요 메서드.
‘Set’ 인터페이스는 ‘Collection’ 인터페이스에서 상속받은 다양한 메소드를 포함합니다.
주요 메서드는 다음과 같습니다.


  add(E e): 요소 e를 Set에 추가합니다. 이미 존재하는 요소를 추가하려는 경우, 요소는 추가되지 않고 false를 반환합니다.
  remove(Object o): 지정된 객체 o를 Set에서 제거합니다.
  contains(Object o): Set이 지정된 객체 o를 포함하고 있는지 여부를 반환합니다.
  size(): Set의 요소 개수를 반환합니다.
  isEmpty(): Set이 비어 있는지 여부를 반환합니다.
  clear(): Set의 모든 요소를 제거합니다


3.3 주요 구현체.
‘Set’ 인터페이스는 여러 가지 방법으로 구현될 수 있으며, 각 구현체는 다른 특성을 가집니다.


  HashSet : 가장 널리 사용되는 ‘Set’ 구현체로, 해시 테이블을 사용하여 요소를 저장합니다. 요소의 삽입, 삭제, 검색 작업은 평균적으로 상수 시간(O(1))이 걸립니다.
  LinkedHashSet : ‘HashSet’ 의 확장으로, 요소의 삽입 순서를 유지합니다.
  TreeSet : 레드-블랙 트리 구조를 사용하여 요소를 저장합니다. 요소는 자연적 순서 또는 비교자에 의해 정렬됩니다.
    
      이로 인해 삽입, 삭제, 검색 작업에 로그 시간(O(log n))이 걸립니다.
    
  


3.4 📝 정리.
‘Set’ 인터페이스는 주로 중복을 허용하지 않는 데이터 컬렉션을 다루는 데 사용되며, 특히 요소의 유일성을 보장하는데 유용합니다.



4. Map 인터페이스.
자바에서 ‘Map’ 인터페이스는 ‘java.util’ 패키지에 속하며, 키(key)와 값(value) 쌍으로 이루어진 데이터를 저장하는 자료구조를 정의합니다.

‘Map’ 은 키의 중복을 허용하지 않으면서 각 키는 하나의 값에 매핑됩니다.

값은 중복될 수 있지만, 각 키는 유일해야 합니다.

이러한 특성 때문에 ‘Map’ 은 키를 통해 빠르게 데이터를 검색할 수 있는 효율적인 수단을 제공합니다.

4.1 Map의 주요 특징.

  키 기반 데이터 접근 : 키를 사용하여 데이터에 접근하므로, 키에 대한 빠른 검색, 삽입, 삭제가 가능합니다.
  키의 유일성 : 같은 키를 다시 ‘Map’ 에 추가하려고 하면 기존 키에 연결된 값이 새 값으로 대체됩니다.
  값의 중복 허용 : 같은 값을 가진 여러 키가 ‘Map’ 에 존재할 수 있습니다.


4.2 주요 메서드
‘Map’ 인터페이스는 데이터를 관리하기 위해 다음과 같은 주요 메소드를 제공합니다.


  put(K key, V value): 키와 값을 Map에 추가합니다. 이미 키가 존재하면, 해당 키의 값이 새로운 값으로 업데이트 됩니다.
  get(Object key): 지정된 키에 연결된 값을 반환합니다. 키가 존재하지 않는 경우, null을 반환합니다.
  remove(Object key): 지정된 키와 그 키에 매핑된 값을 Map에서 제거합니다.
  containsKey(Object key): Map에 특정 키가 있는지 검사합니다.
  containsValue(Object value): Map에 특정 값이 하나 이상 있는지 검사합니다.
  keySet(): Map의 모든 키를 Set 형태로 반환합니다.
  values(): Map의 모든 값을 컬렉션 형태로 반환합니다.
  entrySet(): Map의 모든 “키-값” 쌍을 Set 형태의 Map.Entry 객체로 반환합니다.
  size(): Map에 저장된 “키-값” 쌍의 개수를 반환합니다.
  clear(): Map의 모든 요소를 제거합니다.


4.3 주요 구현체
‘Map’ 인터페이스의 주요 구현체로는 다음과 같은 클래스들이 있습니다.

  HashMap : 가장 일반적으로 사용되는 ‘Map’ 구현체로, 해시 테이블을 사용합니다.
    
      요소의 순서를 보장하지 않으며, 키와 값에 ‘null’ 을 허용합니다.
    
  
  LinkedHashMap : ‘HashMap’ 을 상속받아 구현된 클래스로, 요소의 삽입 순서를 유지합니다.
    
      이는 순회 시 삽인된 순서대로 요소를 얻을 수 있게 해줍니다.
    
  
  TreeMap : 레드-블랙 트리를 기반으로 하는 ‘Map’ 구현체로, 모든 키가 자연적 순서대로 정렬됩니다.
    
      정렬된 순서로의 접근이 필요할 때 유용합니다.
    
  
  Hashtable : ‘HashMap’ 과 유사하지만, 모든 메소드가 동기화되어 있어 멀티스레드 환경에서 사용하기에 안전합니다.
    
      그러나 성능이 ‘HashMap’ 보다 느리고, 키와 값에 ‘null’ 을 허용하지 않습니다.
    
  


4.4 📝 정리.
‘Map’ 인터페이스는 다양한 애플리케이션에서 설정, 프로파일, 사용자 세션 등의 데이터를 키와 값의 형태로 관리할 때 유용하게 사용됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-12-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-12-TIL.html"><h1 class="title_post">📝 [TIL] 240512 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-12-TIL.html" class="txt_post">
                            
  입출력(2)
  예외 처리


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-12-ExceptionHandling.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-12-ExceptionHandling.html"><h1 class="title_post">☕️[Java] 예외 처리</h1></a>
                        <a href="/Backend/Java/2024-05-12-ExceptionHandling.html" class="txt_post">
                            1️⃣ 예외 처리

예외 처리가 무엇인지 이해하고, 예외 처리 방법에 대해 직접 구현

1. 예외(Exception)
자바 프로그래밍에서 “예외(Exception)” 란 프로그램 실행 중에 발생하는 비정상적인 조건 또는 오류를 의미합니다.
이는 프로그램의 정상적인 흐름을 방해하며, 적절히 처리하지 않으면 프로그램이 비정상적으로 종료될 수 있습니다.
자바에서는 이러한 예외를 효과적으로 처리하기 위해 강력한 예외 처리 메커니즘을 제공합니다.

1.2 예외의 유형.
자바에서 예외는 크게 두 가지 유형으로 나눌 수 있습니다.


  1. Checked Execptions
    
      컴파일 시간에 체크되는 예외로, 컴파일러가 해당 예외를 처리하도록 요구합니다.
      이 예외들은 주로 외부 시스템과의 상호 작요(파일 입출력, 네트워크 통신 등)에서 발생하며, 프로그래머가 이를 적절히 처리하도록 강제합니다.
    
  
  2. Unchecked Exceptions
    
      런타임에 발생하는 예외로, 주로 프로그래머의 실수로 인해 발생합니다.(예: 배령의 범위를 벗어나는 접근, null 참조 등.)
      이러한 예외는 컴파일러가 체크하지 않으므로, 개발자가 예측하고 적절히 처리할 필요가 있습니다.
    
  




2. 예외 처리(Exception Handling)
자바 프로그래밍에서 예외 처리는 프로그램 실행 중에 발생할 수 있는 예외적인 상황, 즉 오류나 문제를 안전하게 관리하고 대처하는 방법을 말합니다.
예외 처리를 통해 프로그램의 비정상적인 종료를 막고, 오류 발생 시 적절한 대응을 할 수 있도록 합니다.
이는 프로그램의 안정성과 신뢰성을 높이는 데 중요한 역할을 합니다.

2.1 예외 처리의 주요 구성 요소.


  1. try 블록
    
      예외가 발생할 가능성이 있는 코드를 이 블록 안에 넣습니다.
      만약 블록 안의 코드 실행 중에 예외가 발생하면, 즉시 해당 블록의 실행을 중단하고 ‘catch’ 블록으로 제어를 넘깁니다.
    
  
  2. catch 블록
    
      ‘try’ 블록에서 발생한 특정 유형의 예외를 처리합니다.
      프로그램이 예외를 안전하게 처리할 수 있도록 적절한 로직을 구현할 수 있습니다.
      하나의 ‘try’ 블록에 여러 ‘catch’ 블록을 사용하여 다양한 종류의 예외를 각각 다르게 처리할 수 있습니다.
    
  
  3. finally 블록
    
      이 블록은 예외의 발생 여부롸 관계없이 실행되는 코드를 포함합니다.
      주로 사용되는 목적은 자원 해제와 같은 정리 작업을 수행하기 위함입니다.
      예를 들어 파일이나 네트워크 자원을 닫거나 해제할 때 사용됩니다.
    
  
  4. throws 키워드
    
      메소드 선언 시 사용되며, 해당 메소드가 예외를 직접 처리하지 않고 호출한 메소드로 예외를 전파하겠다는 것을 나타냅니다.
      이를 통해 예외 처리의 책임을 메소드 호출자에게 넘길 수 있습니다.
    
  


2.2 예외 처리 예제.
public class ExceptionHandlingExample {
    public static void main(String[] args) {
        try {
            int result = divide(10, 0);
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            System.err.println("Arithmetic Exception: Division by zero is not allowed.");
        } finally {
            System.out.println("This block is always executed.");
        }
    }
    
    public static int divide(int numerator, in denominator) {
        return numerator / denominator; // This ca throw ArithmeticException if denominator is zero.
    }
}



  이 예제에서 ‘divide’ 메소드는 분모가 0일 때 ArithmeticException 을 발생시킬 수 있습니다.
    
      ‘try’ 블록 안에서 이 메소드를 호출하고, 예외가 발생하면 ‘catch’ 블록에서 이를 잡아서 적절한 오류 메시지를 출력합니다.
      또한, ‘finally’ 블록은 예외 발생 여부와 상관없이 실행되어 어떤 상황에서도 실행될 필요가 있는 코드를 포함할 수 있습니다.
    
  




3. throw 키워드.
자바 프로그래밍에서 ‘throw’ 키워드는 개발자가 의도적으로 예외를 발생시키기 위해 사용합니다.
이를 통해 특정 상황에서 프로그램의 흐름을 제어하거나, 특정 조건에서 오류를 발생시켜 예외 처리 메커니즘을 테스트하거나 강제할 수 있습니다.
‘throw’ 는 예외 객체를 생성하고 이를 던집니다(throw)
즉, 프로그램의 정상적인 실행 흐름을 중단하고 예외 처리 루틴으로 제어를 이동시킵니다.

3.1 ‘throw’ 사용법.
‘throw’ 를 사용할 때는 예외 객체를 생성해야 합니다.
이 객체는 ‘Throwable’ 클래스 또는 그 하위 클래스의 인스턴스여야 합니다.
자바에서는 대부분 ‘Exception’ 클래스 또는 그 서브클래스를 사용하여 예외를 생성하고 던집니다.

예제.
public class Main {
    public static void main(String[] args) {
        try {
            checkAge(17);
        } catch (Exception e) {
            System.out.println("Exception caught: " + e.getMessage());
        }
    }
    
    static void checkAge(int age) throws Execption {
        if (age &lt; 18) {
            throw new Exception("Access denied - You must be at least 18 years old.");
        }
        System.out.println("Access granted - You are old enough!");
    }
}


  이 예제에서 ‘checkAge’ 메소드는 나이를 확인하고, 18세 미만인 경우 예외를 던집니다.
    
      이 예외는 ‘throw new Exception(…)’ 을 통해 생성되고 던져집니다.
      메인 메소드에서는 이 메소드를 ‘try’ 블록 안에서 호출하고, ‘catch’ 블록을 통해 예외를 잡아서 처리합니다.
        
          결과적으로, 사용자가 18세 미만이면 “Access denided” 메시지를 포함하는 예외가 출력됩니다.
        
      
    
  


3.2 ‘throw’와 ‘throws’의 차이

  ‘throw’ : 예외를 실제로 발생시키는 행위입니다. 이는 메소드 내부에서 특정 조건에서 예외를 발생시킬 때 사용됩니다.
  ‘throws’ : 메소드 선언에 사용되며, 해당 메소드가 실행되는 동안 발생할 수 있는 예외를 명시적으로 선언합니다. 이는 호출자에게 해당 메소드를 사용할 때 적절한 예외 처리가 필요하다는 것을 알립니다.




4. throws 키워드.
자바 프로그래밍에서 ‘throws’ 키워드는 메소드 선언에 사용되며, 해당 메소드가 실행 도중 발생할 수 있는 특정 유형의 예외를 명시적으로 선언하는 데 사용됩니다.
‘throws’ 는 메소드가 예외를 직접 처리하지 않고, 대신 이를 호출한 메소드로 예외를 “던져”(전파하는) 사실을 알립니다.
이를 통해 예외 처리 책임을 메소드 호출자에게 넘기는 것입니다.

4.1 ‘throws’ 사용의 목적.

  명시성
    
      메소드가 발생시킬 수 있는 예외를 명시함으로써, 이 메소드를 사용하는 다른 개발자들에게 해당 메소드를 사용할 때 어떤 예외들을 처리해야 하는지 명확하게 알릴 수 있습니다.
    
  
  강제 예외 처리
    
      ‘throws’ 로 선언된 예외는 대부분 “checked exception” 이며, 이는 메소드를 호출하는 코드가 반드시 이 예외들을 처리하도록 강제합니다(try-catch 블록을 사용하거나, 또 다시 ‘throws’ 로 예외를 전파하도록 함).
    
  


4.2 ‘throws’ 사용법 예제.
아래 예제에서는 ‘throws’ 를 사용하여 ‘IOException’ 을 처리하는 방법을 보여줍니다.
이 예외는 파일 입출력 작업에서 자주 발생합니다.

import java.io.*;

public class Main {
    public static void main(String[] args) {
        try {
            readFile("example.txt");
        } catch (IOExecption e) {
            System.out.println("An error occurred: " + e.getMessage());
        }
    }
    
    public static void readFile(String filename) throws IOException {
        File file = new File(filename);
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(file);
            int content;
            while ((content = fis.read()) != -1) {
                // Process the content
                System.out.print((char) content);
            }
        } finally {
            if (fis != null) {
                fis.close();
            }
        }
    }
}



  이 예제에서 ‘readFile’ 메소드는 파일을 읽을 때 발생할 수 있는 IOException 을 처리하지 않고, 대신 ‘throws’ 키워드를 사용하여 이 예외를 메소드를 호출한 ‘main’ 메소드로 전달합니다.
    
      ‘main’ 메소드는 이 예외를 ‘catch’ 블록을 통해 처리합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-12-Input-Ouput-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-12-Input-Ouput-2.html"><h1 class="title_post">☕️[Java] 입출력(2)</h1></a>
                        <a href="/Backend/Java/2024-05-12-Input-Ouput-2.html" class="txt_post">
                            1️⃣ 입출력(2)

1. 파일 출력.
자바 프로그래밍에서 파일 출력은 프로그램이 데이터를 쓰는 과정을 말합니다.
이 과정을 통해 프로그램은 실행 결과를 저장하거나, 사용자가 입력한 정보를 파일에 기록하고, 다른 프로그램이나 나중에 프로그램 자체가 다시 사용할 수 있는 형태로 데이터를 출력할 수 있습니다.

2. 파일 출력을 수행하기 위한 기본 방법들.

  1. FileOutputStream 사용
    
      ‘FileOutputStream’ 클래스는 바이트 단위의 출력을 파일에 직접 쓸 때 사용됩니다.
      이 클래스를 사용하면 이미지, 비디오 파일, 이진 데이터 등을 파일로 저장할 수 있습니다.
```java
import java.io.FileOutputStream;
import java.io.IOException;
    
  


public class FileOutputExample {
    public static void main(String[] args) {
        String data = “Hello, this is a test.”;
        try (FileOutputStream out = new FileOutputStream(“output.txt”)) {
            out.write(data.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

- **2. PrintWriter 사용**
    - **'PrintWriter'** 는 문자 데이터를 출력할 때 사용됩니다.
    - 이 클래스는 파일에 텍스트를 쓸 때 편리하며, 자동 플러싱 기능, 줄 단위 출력 등의 메소드를 제공합니다.
```java
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class PrintWriteExample {
    public static void main(String[] args) {
        try (PrintWriter writer = new PrintWriter(new FileWriter("output.txt", true))) {
            writer.println("Hello, this is a test.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



  3. FileWriter 사용
    
      ‘FileWriter’ 는 자바에서 파일에 텍스트 데이터를 쓰기 위한 간편한 방법 중 하나입니다.
      이 클래스는 내부적으로 문자 데이터를 파일에 쓸 수 있도록 ‘OutputStreamWriter’ 를 사용하여 바이트 스트림을 문자 스트림으로 변환합니다.
      ‘FileWriter’ 는 텍스트 파일을 쉽게 작성할 수 있도록 해주며, 생성자를 통해 다양한 방식으로 파일을 열 수 있습니다.
```java
import java.io.FileWriter;
import java.io.IOException;
    
  


public class FileWriterExample {
    pulbic static void main(String[] args) {
        try (FileWriter writer = new FileWriter(“output.txt”, true)) {
            writer.write(“Hello, this is a test.”);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

- **4. BufferedWriter 사용**
    - **'BufferedWrite'** 는 버퍼링을 통해 효율적으로 파일에 문자 데이터를 쓸 수 있도록 합니다.
    - **'FileWriter'** 와 함께 사용되어, 더 큰 데이터를 처리할 때 성능을 개선합니다.
```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedWriterExample {
    public static void main(String[] args) {
        String content = "Hello, this is a test.";
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {
            writer.write(content);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



2. 파일 입력.

자바 프로그래밍에서 파일 입력은 프로그램이 파일로부터 데이터를 읽어들이는 과정을 말합니다.

이 데이터는 텍스트나 바이너리 형태일 수 있으며, 파일에서 데이터를 읽어 프로그램 내에서 사용할 수 있도록 만드는 것이 목적입니다.

파일 입력을 위해 자바는 다양한 입출력 클래스를 제공합니다.

2.1 주로 사용되는 파일 입력 방법.


  1. FileInputStream 사용
    
      ‘FileInputStream’ 은 바이트 단위로 파일에서 데이터를 읽는 데 사용됩니다.
      이 클래스는 이미지, 비디오 파일, 실행 파일등의 이진 데이터 처리에 주로 사용됩니다.
```java
import java.io.FileInputStream;
import java.io.IOException;
    
  


public class FileInputStreamExample {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream(“input.dat”)) {
            int content;
            while ((content = fis.read()) != -1) {
                // content 변수에 한 바이트씩 읽어들인 데이터를 저장
                System.out.print((char) content);
            }
        } catch (IOExecption e) {
            e.printStackTrace();
        }
    }
}

- **2. BufferedRead** 와 **FileReader 사용**
    - **'BufferedReader'** 와 **'FileReader'** 는 텍스트 데이터를 효과적으로 읽기 위해 함께 사용됩니다.
    - **'FileReader'** 는 파일에서 문자 데이터를 읽어들이며, **'BufferedReader'** 는 버퍼링을 통해 읽기 성능을 향상 시킵니다.
```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedReaderExample {
    public static void main(String[] args) {
        try (BufferedReader br new BufferedReader(new FileReader("input.txt"))) {
            String line;
            while ((line = br.readline()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



  3. Scanner 사용
    
      ‘Scanner’ 클래스는 텍스트 파일을 읽을 때 유용하며, 특히 토큰화(tokenizing)된 데이터를 처리할 때 편리합니다.
      ‘Scanner’ 는 정규식을 사용하여 입력을 구분자로 분리하고, 다양한 타입으로 데이터를 읽어들일 수 있습니다.
```java
import java.io.File;
import java.util.Scanner;
    
  


public class ScannerExample {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(new File(“input.txt”))) {
            while (scanner.hasNextLine()) {
                System.out.println(scanner.nextLine());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

2.2 📝 정리.
이렇게 다양한 방법을 통해 파일로부터 데이터를 읽을 수 있으며, 각 방법은 사용하는 데이터 타입과 처리할 데이터의 양에 따라 선택할 수 있습니다.
파일에서 데이터를 읽는 것은 데이터를 처리하거나, 설정 정보를 불러오거나, 사용자 데이터를 읽는 등 다양한 목적으로 활용됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html"><h1 class="title_post">📝[blog post] 프론트엔드와 백엔드는 무엇이 다를까?(+내가 백엔드 개발자가 되고 싶은 이유)</h1></a>
                        <a href="/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html" class="txt_post">
                            1️⃣ 프론트엔드와 백엔드?
처음 이 글의 여정을 함께하기에 앞서 프론트엔트가 무엇인가 백엔드가 무엇인지 알아야 할 것 같아요!

제가 아무것도 모르는 당시 저 두 단어 “프론트엔드”, “백엔드”를 듣고 느낀 것은

“프론트엔드”는 뭔가 프론트 데스크 같이 앞에서 누군가가 나를 반겨주는 느낌이였고, “백엔드”는 뒤쪽에서 나를 받쳐주는 든든한 느낌이랄까? 😆

그저 느낌으로는 알쏭달쏭하니 정확한 의미를 알아보는 여행을 떠나봅시다! 🙋‍♂️

2️⃣ 프론트엔드.
프론트엔드는 웹사이트에서 우리가 볼 수 있는 모든 것들을 만드는 일을 말해요 😆



예를 들어, 컴퓨터나 핸드폰으로 책을 보거나 게임을 할 때, 그 화면에 보이는 모든 것들이 바로 프론트엔드에서 만들어진 거예요.(존경합니다 프론트엔드 개발자님들🙇‍♂️)

이렇게 생각해 볼까요?



웹사이트를 마치 컬러링북처럼 생각한다면, 프론트엔드 개발자는 그림을 그리고 색칠하는 사람이에요 🧑‍🎨

프론트엔드 개발자들은 화면에 나타날 모양이나 색상을 정하고, 어디를 누르면 어떤일이 일어날지도 결정합니다.

예를 들어, ‘스타드’ 버튼을 누르면 게임이 시작되거나, 사진을 클릭하면 커지는 것처럼 말이에요.

즉, 프론트엔드는 우리가 웹사이트에서 보고 만지는 모든 것을 아름답고 재미있게 만들어 주는 중요한 일을 한답니다!

3️⃣ 백엔드.


백엔드는 웹사이트에서 우리가 눈에 보이지 않는 부분을 다루는 일을 해요.(그렇다고 뭐.. 해커 이런건 아닙니다.. 완전히 달라요…)



이것은 마치 마술사가 무대 뒤에서 마술을 준비하는 것과 비슷해요! 🪄

우리가 볼 수는 없지만, 마술이 멋기제 보이도록 도와주죠.

예를 들어, 우리가 컴퓨터로 쇼핑을 할 때, 옷이나 장난감을 고르고 주문 버튼을 눌러요. 이떄 백엔드는 주문한 것이 무엇인지 기억하고, 그 물건을 어디로 보내야 할지 알려줘요.

또한, 우리가 어떤 게임을 하거나 질문을 할 때도, 백엔드는 그 대답을 찾아서 화면에 보여주죠.

백엔드는 컴퓨터와 데이터베이스라는 큰 저장소를 사용해서, 우리가 웹사이트에서 필요한 모든 정보를 처리하고 저장하는 곳이에요.

우리가 보지 못하지만, 웹사이트가 잘 작동하도록 도와주는 매우 중요한 부분이랍니다!

4️⃣ 내가 백엔드 개발자가 되고 싶은 이유.

저는 어렸을 때 레고를 참 좋아했어요 :)



그 중에서도 테크닉 레고를 가장 좋아했었어요 :)

그 이유는 완성된 것을 보는 것도 좋았지만 조립해 나가면서 그 안에 중심이 되는 코어, 즉 움직임의 중앙부를 제가 직접 조립하고 움직임이 어디서부터 시작되는지를 직접 이해하는 것이 너무 재미있었거든요.

자동차 레고를 만들다보면 직접 엔진를 만들게 됩니다.

그러면 진짜 엔진이 어떻게 움직이고 이 엔진이 어떻게 동작하느냐에 따라 자동차의 다른 부품들이 맞물려 하나씩 동작하는지 상상되는게 너무 행복했었어요.

이런것들이 어렸을 때부터 너무 좋았답니다.

그리고나서 조금 커서는 루어 낚시를 좋아하게 되었어요.



이 루어 낚시는 “배스” 라는 어종을 대상으로 하는 낚시인데, 이 어종에 대한 여러가지 공부를 해야 했었어요.

먼저, 이 어종이 온도에 민감해 온도에 따라 공격 패턴이 달라요 그래서 그 패턴에 대한 데이터를 수집해야 했었어요.

두 번째, 이 어종은 수중 구조물에 굉장히 예민해요. 자신이 좋아하는 수중 구조물이 따로 있어서 그 수중 구조물을 따로 탐색하고 이해하는 법을 배워야 했었어요.

세 번째, 날씨에 영향을 많이 받는 어종이에요. 햇빛과 그늘 그리고 비가 오는 날과 안오는 날에 따라 먹이 사냥 패턴이 달라져요. 그에 따른 루어 선택과 패턴을 다르게 골라야 합니다.

네 번째, 피딩 타임이라는 이 어종의 먹이 사냥 시간이 있습니다. 이 시간에 따라 어종의 먹이 사냥 패턴이 매우 다양해요.

마지막, 계절에 따라 이 어종이 물 속이 바닥, 중층 또는 상층에 머무는지 이런 데이터가 달라요.

이렇게 이 어종을 낚기 위해서는 수 많은 변수와 데이터들을 조합하여 적절한 위치에 적합한 루어를 선택하여 공격 패턴에 맞는 액션을 주어야 배스가 물어 줍니다.

그럴때 “아 나의 데이터가 맞았구나!” 하는 희열감과 아드레날린 그리고 도파민이 폭발해버리죠.

이런 특성이 저는 백엔드에서도 비슷하게 적용되는 것 같아요.

레고는 백엔드에서의 중심 동작을 알아가는 과정과 직접 동작하는 로직을 만드는 부분에서의 즐거움을 찾아가는 과정에서 재미를 느끼고,

낚시는 백엔드에서 데이터를 찾고 뽑아내어 가공하고 내어주는 부분에서 희열을 느끼는 것 같습니다.

그래서 저의 적성과 맞는 것 같아요.

저는 이러한 부분에서 백엔드 개발자가 제가 즐길 수 있는 부분이 서로 맞기 때문에 백엔드 개발자가 되고 싶습니다 😆

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-11-Interface.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-11-Interface.html"><h1 class="title_post">☕️[Java] 인터페이스</h1></a>
                        <a href="/Backend/Java/2024-05-11-Interface.html" class="txt_post">
                            1️⃣ 인터페이스.

1. 인터페이스(Interface).
자바에서 인터페이스(Interface)는 메서드의 시그니처만을 정의하는 참조 타입입니다.

인터페이스는 클래스가 구현(implement) 해야 하는 동작의 설계를 제공하며, 구현하는 모든 클래스에 대해 특정 메소드들이 반드시 존재하도록 강제합니다.

이는 다형성을 지원하는 강력한 방법으로, 서로 다른 클래스들이 동일한 인터페이스를 구현함으로써 동일한 방식으로 처리될 수 있게 해 줍니다.

1.2 인터페이스의 주요 특징.

  1. 메소드 선언만 포함 : 인터페이스는 메소드의 구현을 포함하지 않습니다.(자바 8 이전까지는).
    
      메소드의 몸체는 인터페이스를 구현하는 클래스에서 제공됩니다.
    
  
  2. 상수만 포함 가능 : 인터페이스는 상수만을 멤버로 가질수 있습니다.
    
      모든 필드는 ‘public’, ‘static’, ‘final’ 로 선언됩니다.
    
  
  
    3. 다중 구현 지원 : 한 클래스는 여러 인터페이스를 구현할 수 있으며, 이를 통해 다중 상속의 이점을 얻을 수 있습니다.
  
  4. 디폴트 메소드와 정적 메소드 : 자바 8 이후부터는 인터페이스에 디폴트 메소드(구현을 포함하는 메소드)와 정적 메소드를 정의할 수 있게 되었습니다.
    
      이를 통해 더 유연한 설계가 가능해졌습니다.
    
  


1.3 인터페이스 정의 예시.
public interface Vehicle {
    void start();
    void stop();
}



  위 예제에서 ‘Vehicle’ 인터페이스는 ‘start’ 와 ‘stop’ 이라는 두 메소드를 정의합니다.
    
      이 인터페이스를 구현하는 모든 클래스는 이 두 메소드의 구체적인 구현을 제공해야 합니다.
    
  


1.4 인터페이스 구현 예.
public class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car starts.");
    }
    
    @Override
    public void stop() {
        System.out.println("Car stops.");
    }
}



  ‘Car’ 클래스는 ‘Vehicle’ 인터페이스를 구현합니다.
    
      이 클래스는 start 와 ‘stop’ 메소드를 구체적으로 구현해야 합니다.
    
  


1.5 결론.
인터페이스는 클래스와 다른 클래스 사이의 계약을 정의하고, 특정 작업을 수행하는 메소드의 시그니처를 강제합니다.
이는 코드의 상호 운용성을 높이고, 다형성을 통한 유연한 프로그래밍 설계를 가능하게 합니다.
인터페이스를 사용함으로써 다양한 구현체를 동일한 방식으로 처리할 수 있어, 코드의 유지보수성과 확장성이 향상됩니다.



2. 상수(constant).
자바 프로그래밍에서 상수(constant)는 값이 선언 후 변경될 수 없는 변수를 의미합니다.

상수는 일반적으로 프로그램 전체에서 변하지 않는 값에 사용되며, 이는 코드의 읽기 쉬움과 유지 관리를 돕습니다.

자바에서 상수를 선언하기 위해 ‘final’ 키워드를 변수 선언과 함께 사용합니다.

2.1 상수의 특징.

  1. 불변성 : 상수는 한 번 초기화되면 그 값이 변경될 수 없습니다.
  2. 명확성 : 코드 내에서 직접적인 값보다는 의미 있는 이름을 가진 상수를 사용함으로써 코드의 가독성과 유지보수성이 향상됩니다.
  3. 공용 사용 : 자주 사용되는 값이나 의미가 명확한 수치를 상수로 선언하여 코드 전바에 걸쳐 재사용할 수 있습니다.


2.2 상수 선언 예시.
상수를 선언하는 방법은 간단합니다.
‘final’ 키워드를 사용하여 변수를 선언하고, 초기화합니다.
일반적으로 상수의 이름은 대문자로 표기하며, 단어 간에는 언더스코어(‘_‘)를 사용합니다.
이는 상수임을 쉽게 식별할 수 있도록 도와줍니다.

public class Constants {
    public static final int MAX_WIDTH = 800;
    public static final int MAX_HEIGHT = 600;
    public static final String COMPANY_NAME = "MyCompany";
}


  위 예에서 ‘MAX_WIDTH’, ‘MAX_HEIGHT’, ‘COMPANY_NAME’ 은 모두 상수이며, 이들의 값은 선언된 후 변경될 수 없습니다.


2.3 상수 사용의 이점.

  오류 감소 : 값이 한 번 설정되면 변경되지 않기 때문에, 예상치 못한 곳에서 값이 변경되어 발생할 수 있는 버그를 줄일 수 있습니다.
  코드 재사용성 : 한 곳에서 값을 변경하면, 해당 상수를 사용하는 모든 위치에서 변경된 값이 적용됩니다. 이는 일관성 유지와 함께 코드 관리를 간소화합니다.
  컴파일 시간 최적화 : 상수 값은 컴파일 시간에 결정되므로, 런타임에 추가적인 계산 비용이 들지 않습니다.


2.4 결론.
상수는 프로그램 내에서 변하지 않는 값을 나타내며, 코드의 안정성과 유지보수성을 높이는 데 중요한 역할을 합니다.
자바에서는 ‘final’ 키워드를 사용하여 이러한 상수를 쉽게 생성할 수 있습니다.



3. 클래스의 상속과 인터페이스의 구현을 동시에 사용.
자바에서는 클래스의 상속과 인터페이스의 구현을 동시에 사용하여 “다중 상속“과 유사한 효과를 얻을 수 있습니다.

이는 자바의 설계에서 클래스는 단일 상속만을 허용하지만, 인터페이스는 다중으로 구현할 수 있게 함으로써 이루어집니다.

3.1 단일 상속과 다중 인터페이스 구현.

  단일 상속 : 자바에서 클래스는 단 하나의 상위 클래스만 상속받을 수 있습니다.
    
      이는 C++ 같은 언어에서 볼 수 있는 다중 상속의 복잡성과 관련된 문제(예: 다이아몬드 문제)를 피하기 위함입니다.
    
  
  다중 인터페이스 구현 : 한 클래스는 여러 인터페이스를 구현할 수 있습니다.
    
      이는 인터페이스가 구체적인 구현을 포함하지 않기 때문에(자바 8 이전까지, 자바 8 이후에는 디폴트 메소드를 통해 일부 구현을 포함할 수 있음), 클래스가 여러 인터페이스를 구현함으로써 다중 상속의 효과를 나타낼 수 있습니다.
    
  


3.2 예시.

  다음 예시에서 ‘Car’ 클래스는 ‘Vehicle’ 클래스를 상속받고, ‘Electric’ 및 ‘Autonomous’ 두 인터페이스를 구현하고 있습니다.
    
      이를 통해 ‘Car’ 클래스는 ‘Vehicle’ 클래스의 속성과 메소드를 상속받으며, 동시에 두 인터페이스의 메소드를 구현해야 합니다.
    
  


class Vehicle {
    void drive() {
        System.out.println("This vehicle is driving.");
    }
}

interface Electric {
    void charge();
}

interface Autonomous {
    void navigate();
}

class Car extends Vehicle implements Electric, Autonomous {
    @Override
    public void charge() {
        System.out.println("The car is charging.");
    }
    
    @Override
    public void navigate() {
        System.out.println("The car is navigating autonomously.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        myCar.drive();
        myCar.charge();
        myCar.navigate();
    }
}


3.4 결론.
자바에서는 한 클래스가 단일 상속을 통해 한 클래스의 기능을 상속받고, 동시에 여러 인터페이스를 구현함으로써 다중 상속의 효과를 얻을 수 있습니다.
이는 자바의 타입 시스템이 제공하는 유연성을 활용하는 좋은 예시로, 소프트웨어 설계에서 필요한 다양한 기능을 조합할 수 있게 해 줍니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-11-Input-Output-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-11-Input-Output-1.html"><h1 class="title_post">☕️[Java] 입출력(1)</h1></a>
                        <a href="/Backend/Java/2024-05-11-Input-Output-1.html" class="txt_post">
                            1️⃣ 입출력(1)

콘솔 입출력 방법에 대해 직접 구현

1. 콘솔 입력
자바에서 콘솔 입력을 받는 방법은 여러 가지가 있습니다.

주로 사용되는 몇 가지 방법들을 소개하겠습니다.


  1. Scanner 클래스 사용
    
      ‘Scanner’ 클래스는 자바의 ‘java.util’ 패키지에 포함되어 있으며, 다양한 타입의 입력을 콘솔에서 받기 위해 널리 사용됩니다.
      ‘System.in’ 을 ‘Scanner’ 객체에 연결하여 사용자로부터 입력을 받을 수 있습니다.
```java
import java.util.Scanner;
    
  


public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println(“Enter your name: “);
        String name = scanner.nextLine();
        System.out.println(“Hello, “ + name);
        scanner.close();
    }
}

- **2. BufferedReader** 와 **InputStreamReader 사용**
    - 이 방법은 **'java.io'** 패키지를 사용합니다.
    - **'InputStreamReader'** 는 바이트 스트림을 문자 스트림으로 변환하는데 사용되고, **'BufferedReader'** 는 텍스트 읽기를 효율적으로 할 수 있게 해 줍니다.
        - 이 방법은 예외 처리를 필요로하며, 라인 단위로 입력을 받습니다.
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
            System.out.println("Enter your name: ");
            String name = reader.readLine();
            System.out.println("Hello, " + name);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



  3. Console 클래스 사용
    
      ‘Console’ 클래스는 자바 6 이상에서 사용할 수 있으며, 콘솔에서 비밀번호와 같은 민감한 데이터를 읽을 때 유용합니다.
      ‘System.console()’ 메소드를 통해 ‘Console’ 객체를 얻을 수 있으나, 이 방법은 IDE에서는 작동하지 않을 수 있습니다.(콘솔 환경에서만 사용 가능.)
```java
import java.io.Console;
    
  


public class Main {
    public static void main(String[] args) {
        Console console = System.console();
        if (console != null) {
            String name = console.readLine(“Enter your name: “);
            char[] password = console.readPassword(“Enter your password: “);
            console.printf(“Hello, %s\n”, name);
        } else {
            System.out.println(“No console available”);
        }
    }
}
```

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-11-InnerClass.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-11-InnerClass.html"><h1 class="title_post">☕️[Java] 내부 클래스</h1></a>
                        <a href="/Backend/Java/2024-05-11-InnerClass.html" class="txt_post">
                            1️⃣ 내부 클래스.
내부 클래스의 개념과 종류 이해
익명 클래스 직접 구현

1. 내부 클래스(Inner Class).
자바 프로그래밍에서 내부 클래스(Inner Class)는 다른 클래스의 내부에 정의된 클래스를 말합니다.

내부 클래스는 주로 외부 클래스와 밀접한 관련이 있으며, 외부 클래스의 멤버들에 대한 접근을 용이하게 하기 위해 사용됩니다.

1.1 내부 클래스의 특징.
자바의 내부 클래스에는 몇 가지 특징이 있습니다.
이 특징들은 내부 클래스가 어떻게 사용되고, 그들이 주는 이점과 한계를 이해하는 데 도움이 됩니다.


  1. 접근성과 밀접성 : 내부 클래스는 외부 클래스의 모든 필드와 메소드(프라이빗 포함)에 접근할 수 있습니다. 이는 내부 클래스가 외부 클래스와 밀접한 작업을 수행할 때 매우 유용합니다.
    
      이러한 접근은 내부 클래스가 외부 클래스의 구현 세부사항에 깊이 연결될 수 있게 합니다.
    
  
  2. 캠슐화 증가 : 내부 클래스를 사용하면 관련 있는 부분만을 그룹화하여 외부에 불필요한 정보를 노출하지 않고도 복잡한 코드를 더 잘 구조화할 수 있습니다.
    
      이는 코드의 유지보수성과 가독성을 높이는 데 도움이 됩니다.
    
  
  
    3. 코드의 응집성 : 내부 클래스는 특정 외부 클래스와 매우 강하게 연결되어 있기 때문에, 그 기능이 외부 클래스와 밀접하게 관련된 기능을 수행할 때 코드의 응집력을 높일 수 있습니다.
  
  4. 더 나은 논리적 그룹핑 : 특정 기능을 내부 클래스에 구현함으로써, 관련 기능과 데이터를 함께 논리적으로 그룹화할 수 있습니다.
    
      이는 전체 코드베이스를 통해 일관성을 유지하고, 기능별로 코드를 정리하는 데 도움이 됩니다.
    
  
  
    5. 명시적인 컨텍스트 연결 : 내부 클래스는 명시적으로 그들의 외부 클래스의 인스턴스와 연결됩니다. 이는 그들이 외부 클래스의 상태와 행동에 따라 다르게 작동할 수 있음을 의미합니다.
  
  
    6. 다중 상속의 일종의 구현 : 자바는 다중 상속을 지원하지 않지만, 내부 클래스를 통해 비슷한 효과를 낼 수 있습니다. 외부 클래스가 하나 이상의 내부 클래스를 가질 수 있고, 각 내부 클래스는 다른 클래스를 상속받을 수 있으므로 다양한 기능을 조합할 수 있습니다.
  
  7. 메모리 및 성능 고려사항 : 내부 클래스는 외부 클래스의 인스턴스와 연결되어 있기 때문에, 외부 클래스의 인스턴스가 메모리에 남아 있는 동안에는 가비지 컬렉션에서 제거되지 않습니다. 이는 메모리 관리 측면에서 고려해야 할 사항입니다.


1.2 내부 클래스의 네 가지 유형.

  
    1. 비정적 중첩 클래스(Non-static Nested Class) 또는 내부 클래스(Inner Class) : 이 클래스는 외부 클래스의 인스턴스 멤버처럼 동작하며, 외부 클래스의 인스턴스에 대한 참조를 가지고 있습니다. 외부 클래스의 인스턴스 멤버와 메소드에 접근할 수 있습니다.
  
  
    2. 정적 중첩 클래스(Static Nested Class) : 이 클래스는 외부 클래스의 정적 멤버처럼 동작하며, 외부 클래스의 인스턴스 멤버에는 접근할 수 없지만, 정적 멤버에는 접근할 수 있습니다.
  
  
    3. 지역 클래스(Local Class) : 특정 메소드 또는 초기화 블록 내부에 정의된 클래스로, 선언된 영역 내에서만 사용할 수 있습니다. 지역 클래스는 해당 메소드 내에서만 사용되므로, 외부로 노출되지 않습니다.
  
  
    4. 익명 클래스(Anonymous Class) : 이름이 없는 클래스로, 일반적으로 단 한 번만 사용되며 주로 리스너(listener) 또는 작은 델리게이션 클래스로 사용됩니다. 클래스 선언과 인스턴스 생성이 동시에 이루어집니다.
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-11-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-11-TIL.html"><h1 class="title_post">📝 [TIL] 240511 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-11-TIL.html" class="txt_post">
                            
  인터페이스
  내부 클래스
  입출력(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-10-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-10-TIL.html"><h1 class="title_post">📝 [TIL] 240510 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-10-TIL.html" class="txt_post">
                            
  다형성
  추상클래스


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-10-polymorphism.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-10-polymorphism.html"><h1 class="title_post">☕️[Java] 다형성</h1></a>
                        <a href="/Backend/Java/2024-05-10-polymorphism.html" class="txt_post">
                            1️⃣ 다형성.

1. 다형성(Polymorphism)
자바에서 말하는 다형성(Polymorphism)은 객체가 여러 형태를 취할 수 있는 능력을 말합니다.

이는 같은 이름의 메소드 호출이 객체의 타입에 따라 다은 동작을 수행할 수 있게 해 주어 코드의 유연성과 재사용성을 증가시킵니다.

자바에서는 주로 두 가지 형태의 다형성을 지원하는데, 이는 컴파일 시간 다형성과 런타임 다형성입니다.

1.2. 컴파일 시간 다형성(정적 다형성).
컴파일 시간 다형성은 주로 메소드 오버로딩을 통해 구현됩니다.
메소드 오버로딩은 동일한 메소드 이름을 가지면서 매개변수 타입, 순서, 개수가 다른 여러 메소드를 같은 클래스 내에 선언하는 것을 의미합니다.
이러한 메소드들은 컴파일 시에 그 타입에 따라 구별되어 처리됩니다.

1.3 컴파일 시간 다형성 예시.
public class Display {
    public void print(int num) {
        System.out.println("Printing integer: " + num);
    }
    
    public void print(String str) {
        System.out.println("Printing string: " + str);
    }
}


1.4 런타임 다형성(동적 다형성).
런타임 다형성은 메소드 오버라이딩을 통해 구현됩니다.
이 경우 서브클래스에서 상속받은 부모 클래스의 메소드를 재정의하여 동일한 메소드 호출이 서로 다른 클래스 객체에 대해 다른 동작을 할 수 있도록 합니다.
이는 실행 중에 결정되므로 동적 다형성이라고 합니다.

1.5 런타임 다형성 예시.
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    void sound() {
        System.out.println("Cat meows");
    }
}

public class TestPolymorphism {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        myAnimal.sound(); // 출력: Dog barks
        
        myAnimal = new Cat();
        myAnimal.sound(); // 출력: Cat meows
    }
}


  여기서 ‘Animal’ 클래스의 ‘sound()’ 메소드는 ‘Dog’ 와 Cat 클래스에서 오버라이딩되었습니다.
    
      ‘myAnimal’ 참조 변수는 ‘Animal’ 타입이지만, 참조하는 객체의 실제 타입에 따라 적절한 ‘sound()’ 메소드가 호출됩니다.
    
  


1.6 다형성의 장점.

  유연성 : 다형성을 사용하면 프로그램을 더 유연하게 설계할 수 있습니다.
    
      예를 들어, 다양한 지식 클래스의 객체들을 부모 클래스 타입의 컬렉션에 저장하고, 각 객체에 대해 공통된 인터페이스를 통해 작업을 수행할 수 있습니다.
    
  
  코드 재사용과 유지 보수의 향상 : 공통 인터페이스를 사용함으로써 코드를 재사용하고, 새로운 클래스 타입을 추가하거나 기존 클래스를 수정할 때 유지 보수가 용이해집니다.


📝 정리.
이렇게 다형성은 객체 지향 프로그래밍의 중요한 특성 중 하나로, 프로그램의 다양한 부분에서 유용하게 활용됩니다.



2. instanceof
자바 프로그래밍에서 ‘instanceof’ 연산자는 특정 객체가 지정한 타입의 인스턴스인지를 검사하는 데 사용됩니다.
이 연산자는 객체의 타입을 확인할 때 유용하게 쓰이며, 주로 객체의 실제 타입을 판별하여 안전하게 형 변환을 하기 전이나 특정 타입에 따른 조건 분기를 실행할 때 사용됩니다.

2.1 instanceof 연산자의 사용법.
‘instanceof’ 는 구 개의 피 연산자를 비교합니다.

  왼쪽 피연산자는 객체를 나타내며, 오른쪽 피연산자는 타입(클래스나 인터페이스)을 나타냅니다.
  연산의 결과는 불리언 값입니다.
    
      만약 왼쪽 피연산자가 오른쪽 피연산자가 지정하는 타입의 인스턴스면 ‘true’ 를, 그렇지 않으면 ‘false’ 를 반환합니다.
    
  


기본 구조
if (object instanceof ClassName) {
    // 조건이 참일 때 실행될 코드
}


예시
class Animal {}
class Dog extends Animal {}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Dog dog = new Dog();
        Animal animalDog = new Dog();
        
        System.out.println(animal instanceof Animal); // true
        System.out.println(dog instanceof Animal); // true
        System.out.println(animalDog instanceof Animal); // true
        System.out.println(animal instanceof Dog); // false
    }
}



  이 예시에서 ‘dog instanceof Animal’ 은 ‘true’ 를 반환합니다.
    
      왜냐하면 ‘Dog’ 클래스가 ‘Animal’ 클래스의 서브클래스이기 때문입니다.
      하지만 ‘animal instanceof Dog’ 은 ‘false’ 를 반환하는데, 이는 ‘Animal’ 인스턴스가 ‘Dog’ 타입이 아니기 때문입니다.
    
  


2.2 instanceof의 주의점

  1. null 검사 : ‘instanceof’ 는 객체 참조가 ‘null’ 일 때 항상 ‘false’ 를 반환합니다.
    
      따라서 ‘null’ 값에 대한 추가적인 검사 없이도 안전하게 사용할 수 있습니다.
    
  
  2. 다운캐스팅 검증 : 객체를 하위 클래스 타입으로 다운캐스팅하기 전에 ‘instanceof’ 를 사용하여 해당 객체가 실제로 해당 하위 클래스의 인스턴스인지를 확인하는 것이 안전합니다.
    
      이를 통해 ‘ClassCastException’ 을 예발할 수 있습니다.
    
  
  3. 인터페이스 검사 : ‘instanceof’ 는 클래스 뿐만 아니라 인터페이스 타입에 대해서도 사용할 수 있습니다. 객체가 특정 인터페이스를 구현하는지 여부를 검사할 수 있습니다.


📝 정리.
‘instanceof’ 는 다형성을 사용하는 객체 지향 프로그램에서 객체의 타입을 안전하게 확인하고, 타입에 맞는 적절한 동작을 수행하도록 도와주는 중요한 도구입니다.



3. 업캐스팅(Upcasting).
자바 프로그래밍에서 업캐스팅(Upcasting)은 서브클래스의 객체를 슈퍼클래스 타입의 참조로 변환하는 과정을 말합니다.
이는 일반적으로 자동으로 수행되며, 명시적으로 타입을 지정할 필요가 없습니다.
업캐스팅은 객체 지향 프로그래밍의 다형성을 활용하는 데 핵심적인 역할을 합니다.

3.1 업캐스팅의 특징과 이점.

  1. 자동 형 변환 : 자바에서는 서브클래스의 객체를 슈퍼클래스 타입의 탐조 변수에 할당할 때 자동으로 업캐스팅이 발생합니다.
  2. 안전성 : 업캐스팅은 항상 안전하며, 데이터 손실이나 오류 없이 수행됩니다. 이는 서브클래스가 슈퍼클래스의 모든 특성을 상속받기 때문입니다.
  3. 다형적 행동 : 업캐스팅을 통해 서브클래스의 객체들을 슈퍼클래스 타입으로 다룰 수 있어, 다양한 타입의 객체들을 일관된 방식으로 처리할 수 있습니다. 이를 통해 코드의 유연성과 재사용성이 향상됩니다.


3.2 예시.
아래는 업캐스팅을 사용한 자바 코드 예시입니다.
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        Animal myAnimal = myDog; // Dog 객체를 Animal 타입으로 업캐스팅
        
        myAnimal.eat(); // 호출 가능
        // myAnimal.bark(); // 컴파일 에러, Animal 타입은 bark 메소드를 알지 못함
    }
}



  이 예시에서 ‘Dog’ 객체가 ‘Animal’ 타입으로 업캐스팅 되었습니다.
    
      ‘myAnimal’ 변수는 ‘Animal’ 클래스의 메소드만 호출할 수 있으며, ‘Dog’ 클래스의 ‘bark()’ 메소드는 호출할 수 없습니다.
    
  


3.3 업캐스팅 후의 제한사항.
업캐스팅을 한 후에는 원래 서브클래스의 특정 메소드나 속성에 접근할 수 없게 됩니다.
즉, 업캐스팅된 객체는 슈퍼클래스의 필드와 메소드만 사용할 수 있으며, 추가된 서브클래스의 특성은 사용할 수 없습니다.
이는 다형성의 한 예로서, 슈퍼 클래스 타입을 통해 다양한 서브클래스의 객체들을 통합적으로 다룰 수 있도록 해주며, 프로그램을 더 유연하고 확장 가능하게 만듭니다.



4. 다운캐스팅(Downcasting).
자바 프로그래밍에서 다운캐스팅(Downcasting)은 슈퍼클래스 타입의 객체 참조를 서브클래스 타입의 참조로 변환하는 과정을 말합니다.
다운캐스팅은 업캐스팅의 반대 과정으로, 업캐스팅된 객체를 다시 원래의 서브클래스 타입으로 변환할 때 사용됩니다.
다운캐스팅은 명시적으로 수행되어야 하며, 자바에서는 이 과정이 자동으로 이루어지지 않습니다.

4.1 다운캐스팅의 필요성.
업캐스팅을 통해 객체가 슈퍼클래스 타입으로 변환되면, 해당 객체는 슈퍼클래스의 메소드와 필드만 접근 가능합니다.
서브클래스에만 있는 메소드나 필드에 접근하려면 다운캐스팅을 사용하여 해당 객체를 다시 서브클래스 타입으로 변환해야 합니다.

4.2 다운캐스팅의 사용법과 주의사항.
다운캐스팅은 타입 캐스팅 연산자를 사용하여 수행되며, 반드시 ‘instanceof’ 연산자로 타입 체크를 먼저 수행하는 것이 안전합니다.
이는 변환하려는 객체가 실제로 해당 서브클래스의 인스턴스인지 확인하여 ‘ClassCastExecption’ 을 방지하기 위함입니다.

4.3 예시.
다운캐스팅을 사용하는 자바 코드 예시입니다.
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // 업캐스팅
        myAnimal.eat();
        
        // 다운캐스팅 전에 instanceof로 체크
        if (myAnimal instanceof Dog) {
            Dog myDog = (Dog) myAnimal; // 다운캐스팅
            myDog.bark(); // 이제 서브클래스의 메소드 호출 가능
        }
    }
}



  이 예시에서 ‘Animal’ 타입의 ‘myAnimal’ 객체는 ‘Dog’ 클래스의 인스턴스입니다.
    
      ‘myAnimal’ 을 ‘Dog’ 타입으로 다운캐스팅하여 ‘Dog’ 클래스의 ‘bark()’ 메소드에 접근할 수 있습니다.
      다운캐스팅을 수행하기 전에 ‘instanceof’ 를 사용해 ‘myAnimal’ 이 실제로 ‘Dog’ 의 인스턴스인지 확인함으로써 안정을 확보합니다.
    
  


4.4 주의사항.

  다운캐스팅은 객체의 실제 타입이 캐스팅하려는 클래스 타입과 일치할 때만 안전하게 수행됩니다.
  잘못된 다운캐스팅은 런타임에 ‘ClassCastException’ 을 발생시킬 수 있습니다.


📝 정리.
다운캐스팅은 특정 상황에서 필수적이며, 객체의 모든 기능을 활용하기 위해 사용되지만, 항상 타입 검사를 수행하고 신중하게 사용해야 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-10-abstractClass.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-10-abstractClass.html"><h1 class="title_post">☕️[Java] 추상클래스</h1></a>
                        <a href="/Backend/Java/2024-05-10-abstractClass.html" class="txt_post">
                            1️⃣ 추상클래스.
추상 클래스가 무엇인지 설명할 수 있음
abstract를 이용하여 추상 클래스 구현

1. 추상 메소드(Abstract Method)
자바 프로그래밍에서 추상 메소드(abstract method)는 선언만 있고 구현은 없는 메소드입니다.
이러한 메소드는 추상 클래스(abstract class)나 인터페이스(interface) 내부에서 선언될 수 있으며, 구체적인 행동은 하위 클래스에서 구현됩니다.

추상 메소드를 사용하는 주된 목적은 하위 클래스가 특정 메소드를 반드시 구현하도록 강제하는 것입니다.
이는 코드의 일관성을 유지하고, 다형성을 통한 유연한 프로그래밍 설계를 가능하게 합니다.

1.2 추상 메소드의 특징.

  선언만 있고 구현이 없음 : 메소드 본체가 없으며, 메소드 선언은 세미콜론(’;’) 으로 끝납니다.
  하위 클래스에서의 구현 필수 : 추상 메소드를 포함하는 클래스를 상속받는 모든 하위 클래스는 해당 메소드를 구현해야만 인스턴스 생성이 가능합니다.
  ‘abstract’ 키워드 사용 : 메소드 앞에 ‘abstract’ 키워드를 명시하여 추상 메소드임을 표시합니다.


1.3 추상 메소드 예시
다음은 추상 클래스와 추상 메소드의 간단한 예시입니다.
abstract class Animal {
    // 추상 메소드
    abstract void makeSound();
    
    void breathe() {
        System.out.println("Btrathing...");
    }
}

class Dog extends Animal {
    // 추상 메소드 구현
    void makeSound() {
        System.out.println("Bark!");
    }
}

class Cat extends Animal {
    // 추상 메소드 구현
    void makeSound() {
        System.out.println("Meow!");
    }
}



  위 예에서 ‘Animal’ 클래스는 ‘makeSound’ 라는 추상 메소드를 포함하고 있습니다.
  ‘Dog’ 와 ‘Cat’ 클래스는 ‘Animal’ 클래스를 상속받고 ‘makeSound’ 메소드를 각각 다르게 구현하고 있습니다.
    
      이는 다형성의 좋은 예로, ‘Animal’ 타입의 참조를 사용하여 각각의 하위 클래스 객체를 다룰 때 동일한 메소드(‘makeSound’)를 호출하더라도 서로 다른 행동(개는 짖고, 고양이는 울음)을 보여줍니다.
    
  


1.4 결론.
추상 메소드는 프로그램의 확장성과 유지보수성을 향상시키는 객체 지향 설계의 핵심 요소입니다.
다양한 상황에 맞춰 동일한 인터페이스에 여러 구현을 제공할 수 있어 유연한 코드 작성이 가능합니다.



2. 추상 클래스(abstract class)
자바에서 추상 클래스(abstract class)는 완전하지 않은 클래스로, 추상 클래스 자체로는 인스턴스를 생성할 수 없습니다.
추상 클래스의 주요 목적은 다른 클래스들의 기본이 되는 클래스를 제공하여 코드의 재사용성을 높이고, 일관된 설계를 유도하는 것입니다.
추상 클래스는 하나 이상의 추상 메소드를 포함할 수 있으며, 또한 구현된 메소드도 포함할 수 있습니다.

2.1 추상 클래스의 특징.

  1. 인스턴스 생성 불가 : 추상 클래스는 직접적으로 인스턴스를 생성할 수 없습니다. 반드시 상속을 통해 그 기능을 확장하고 구체적인 클래스에서 인스턴스를 생성해야 합니다.
  2. 추상 메소드 포함 가능 : 추상 클래스는 하나 이상의 메소드를 포함할 수 있습니다. 추상 메소드는 선언만 있고 구현은 없으며, 이를 상속받은 구체적인 클래스에서 구현해야 합니다.
  3. 구현된 메소드 포함 가능 : 추상 클래스는 구현된 메소드도 포함할 수 있어, 자식 클래스들이 이 메소드를 재사용하거나 오버라이드 할 수 있습니다.
  4. 생성자 및 필드 포함 가능 : 추상 클래스는 자신의 생성자와 필드(변수)를 가질 수 있으며, 이는 상속받은 클래스에서 사용할 수 있습니다.


2.2 추상 클래스의 사용 예시.
abstract class Animal {
    abstract void makeSound();
    
    void eat() {
        System.out.println("This animal is eating.");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark!");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow!");
    }
}



  이 예에서 ‘Animal’ 은 추상 클래스로, ‘makeSound()’ 메소드를 추상 메소드로 포함하고 있습니다.
    
      ‘Dog’ 와 ‘Cat’ 은 ‘Animal’ 클래스를 상속받아 ‘makeSound()’ 메소드를 각각 구현합니다.
      추상 클래스 ‘Animal’ 의 ‘eat()’ 메소드는 모든 동물이 공통적으로 사용할 수 있는 구현된 메소드입니다.
    
  


2.3 결론.
추상 클래스는 공통적인 특징을 가진 클래스들 사이의 일반적인 행동을 정의하고, 이를 상속받는 구체적인 클래스들이 이를 구현하도록 하는 데에 주로 사용됩니다.

이를 통해 코드의 재사용성과 유지보수성을 향상시키며, 객체 지향 설계의 일관성과 안정성을 보장할 수 있습니다.



3. 익명 클래스(anonymous class).
자바에서 익명 클래스(anonymous class)는 이름이 없는 클래스입니다.

이들은 주로 일회성 사용 목적으로 설계되며, 인터페이스나 추상 클래스를 간편하게 구현하거나, 기존 클래스를 임시로 확장하기 위해 사용됩니다.

익명 클래스는 일반적으로 이벤트 리스너나 작은 콜백 객체 같이 간단한 기능을 수행하는 데에 활용됩니다.

3.1 익명 클래스의 특징.

  1. 이름이 없음 : 익명 클래스는 이름을 가지지 않습니다. 인스턴스 생성 시점에 정의됩니다.
  2. 즉석에서 정의 및 사용 : 익명 클래스는 즉석에서 정의되어 바로 인스턴스가 생성됩니다. 보통 이들은 한 번만 사용되고 재사용되지 않습니다.
  3. 상속 및 구현 : 익명 클래스는 상쉬 클래스를 상속하거나 인터페이스를 구현할 수 있습니다. 그러나 다중 상속은 지원하지 않습니다.
  4. 오직 하나의 인스턴스만 생성 가능 : 익명 클래스로부터 직접적으로 두 개 이상의 객체를 생성할 수는 없습니다. 다시 사용하려면 클래스 정의를 반복해야 합니다.
  5. 지역 클래스 비슷 : 지역 변수처럼 동작하여 주변 스코프의 변수를 참조할 수 있습니다. 자바 8 이전에는 final 변수만 참조 가능했으나, 자바 8부터는 effectively final(명시적으로 final로 선언되지 않았어도 값이 변경되지 않는 변수) 변수도 참조할 수 있습니다.


3.2 익명 클래스의 사용 예.
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        System.out.println("버튼이 클릭되었습니다!");
    }
});


  위 예제에서 ‘ActionListener’ 인터페이스는 익명 클래스를 통해 구현되었습니다.
    
      ‘button.addActionListener’ 메소드에 직접 전달되면서 버튼 클릭 시 “버튼이 클릭되었습니다!”를 출력하는 ‘actionPerformed’ 메소드를 포함하고 있습니다.
    
  


3.3 결론.
익명 클래스는 특정 인터페이스나 상위 클래스의 메소드를 구현하거나 오버라이드할 때 사용됩니다.
짧고 간단한 기능을 구현하는 데 유용하며, 코드의 간결성을 유지할 수 있게 도와줍니다.
하지만 복잡한 로직이나 반복적으로 사용될 기능에 대해서는 일반 클래스나 지역 클래스를 사용하는 것이 더 적합할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-09-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-09-TIL.html"><h1 class="title_post">📝 [TIL] 240509 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-09-TIL.html" class="txt_post">
                            
  상속


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-09-Inheritance.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-09-Inheritance.html"><h1 class="title_post">☕️[Java] 상속</h1></a>
                        <a href="/Backend/Java/2024-05-09-Inheritance.html" class="txt_post">
                            1️⃣ 상속.



1. 상속(Inheritance)
자바 프로그래밍에서의 상속(Inheritance)은 한 클래스가 다른 클래스의 속성과 메소드를 물려받는 기능을 말합니다.

상속을 사용하면 기존 코드를 재사용하고 확장하는 것이 용이해져, 소프트웨어의 설계와 유지 보수가 효율적으로 이루어질 수 있습니다.

1.2 상속의 주요 개념.

  1. 슈퍼클래스(부모 클래스) : 기능이 상속되는 클래스입니다.
    
      예를 들어, ‘Vehicle’ 클래스가 있을 때 클래스의 속성(예: 속도)과 메소드(예: start, stop)를 다른 클래스가 상속받을 수 있습니다.
    
  
  2. 서브클래스(자식 클래스) : 슈퍼클래스의 속성과 메소드를 상속받는 클래스입니다.
    
      서브클래스는 메소드를 그대로 사용할 수도 있고, 필요에 따라 재정의(오버라이드)할 수도 있습니다.
        
          예를 들어, ‘Car’ 클래스가 ‘Vehicle’ 클래스를 상속받는 경우, ‘Car’ 는 ‘Vehicle’ 의 모든 속성과 메소드를 사용할 수 있으며 추가적인 기능(예: 4륜 구동 기능)을 더할 수 있습니다.
        
      
    
  
  3. 메소드 오버라이딩(Method Overriding) : 서브클래스가 슈퍼클래스에서 상속받은 메소드를 재정의하여 사용하는 것 입니다.
    
      서브클래스는 상속받은 메소드를 자신의 필요에 맞게 변경할 수 있습니다.
    
  
  4. 생성자 상속 : 자바에서 생성자는 상속되지 않습니다. 서브클래스의 생성자가 호출될 때, 슈퍼클래스의 생성자도 자동으로 호출되어야 하는데, 이는 ‘super()’ 키워드를 통해 명시적으로 호출해야 합니다.


📝 정리.
상속을 사용하면 코드의 중복을 줄이고, 각 클래스의 기능을 명확하게 구분지어 설계할 수 있어 프로그램 전체의 구조가 개선됩니다.





class 자식 클래스명 extends 부모 클래스명 { // 다중 상속 불가능
    필드;
    메소드;
    ...
}


2. 상속과 접근제어자와의 관계.
자바에서 상속과 접근 제어자(Access modifiers)는 클래스와 클래스 멤버(필드, 메소드)의 접근성을 결정하는 데 중요한 역할을 합니다.
접근 제어자는 클래스의 데이터를 보호하고, 코드의 유지 보수를 용이하게 하며, 외부로부터의 불필요한 접근을 막는 기능을 합니다.

상속에서 접근 제어자는 어떤 멤버가 서브클래스에게 상속될 수 있는지, 그리고 상속받은 멤버를 서브클래스가 어떻게 활용할 수 있는지 결정짓는 요소입니다.

2.1 주요 네 가지 접근 제어자.

  1. private : 멤버가 선언된 클래스 내에서만 접근 가능합니다.
    
      ‘private’ 접근 제어자가 지정된 멤버는 상속되지 않습니다.
    
  
  2. default(package-private) : 접근 제어자를 명시하지 않으면, 기본적으로 ‘default’ 접근이 적용됩니다.
    
      이러한 멤버들은 같은 패키지 내의 다른 클래스에서 접근할 수 있지만, 다른 패키지의 서브클래스에서는 접근할 수 없습니다.
    
  
  3. protected : ‘protected’ 멤버는 같은 패키지 내의 모든 클래스와 다른 패키지의 서브클래스에서 접근할 수 있습니다.
    
      이 접근 제어자는 상속을 사용할 때 특히 유용하며, 서브클래스가 슈퍼클래스의 멤버를 활용하거나 수정할 수 있게 합니다.
    
  
  4, public : ‘public’ 멤버는 모든 클래스에서 접근할 수 있습니다.
    
      상속과 관련하여, ‘public’ 멤버는 서브클래스에 의해 자유롭게 상속되고 사용될 수 있습니다.
    
  


📝 정리.

  상속과 접근 제어자의 관계에서 중요한 점은, 서브클래스가 상속받은 멤버에 접근할 수 있는 권한은 슈퍼클래스에서 해당 멤버에 지정된 접근 제어자에 의해 결정된다는 것 입니다.
    
      예를 들어, 슈퍼클래스에서 ‘protected’ 로 선언된 메소드는 서브클래스에서 접근 가능하고 필요에 따라 오버라이딩할 수 있지만, ‘private’ 으로 선언된 메소드는 서브클래스에서 직접접으로 접근하거나 사용할 수 없습니다.
        
          이러한 제한은 객체 지향 프로그래밍에서 캡슐화와 정보 은닉을 강화하는 데 도움을 줍니다.
        
      
    
  




3. super와 super().

자바에서 ‘super’ 키워드와 ‘super()’ 생성자 호출은 상속을 사용할 때 매우 중요한 역할을 합니다.
이들은 서브클래스가 슈퍼클래스와 상호작용할 수 있게 해 줍니다.

3.1 super와 super() 키워드의 사용 방식.

3.1.1 super 키워드.

  ‘super’ 키워드는 슈퍼 클래스의 필드나 메소드에 접근할 때 사용됩니다.
    
      서브클래스에서 메소드를 어버라이드 했을 때, 슈퍼클래스의 버전을 호출하고 싶은 경우에 유용하게 사용할 수 있습니다.
      이는 슈퍼클래스의 구현을 활용하면서 추가적인 기능을 서브클래스에 구현할 때 필요합니다.
        
          예를 들어, 슈퍼클래스 ‘Vehicle’ 의 메소드 ‘start()’ 를 서브클래스 ‘Car’ 에서 오버라이드한 후, ‘Car’ 의 ‘start()’ 메소드에서 ‘super.start()’ 를 호출하면, ‘Vehicle’ 클래스의 ‘start()’ 메소드가 실행됩니다.
        
      
    
  


3.1.2 super() 생성자 호출.

  ‘super()’ 는 서브클래스의 생성자에서 슈퍼클래스의 생성자를 호출할 때 사용됩니다.
    
      자바에서는 모든 클래스가 생성자를 가지며, 서브클래스의 생성자가 호출될 때 슈퍼클래스의 생성자도 자동으로 호출됩니다.
      명시적으로 슈퍼클래스의 생성자를 호출하고자 할 때 ‘super()’ 를 사용합니다.
    
  
  이 호출은 서브클래스의 생성자의 첫 번째 명령어로 위치해야 합니다.
    
      슈퍼클래스의 생성자를 호출함으로써, 슈퍼 클래스의 인스턴스 변수들이 적절히 초기화될 수 있습니다.
    
  
  예를 들어, 슈퍼클래스 ‘Vehicle’ 에 ‘Vehicle(int speed)’ 라는 생성자가 있고, 서브클래스 ‘Car’ 에서 이를 상속 받을 때, ‘Car’ 의 생성자에서 ‘super(100)’ 을 호출하면 ‘Vehicle’ 의 생성자가 호출죄어 ‘speed’ 변수가 ‘100’ 으로 초기화됩니다.


📝 정리.
이 두 사용법은 객체지향 프로그래밍에서 클래스의 계층을 통해 기능을 확장하고 관리하는 데 필수적입니다.
‘super’ 의 사용은 상속 관계에 있는 클래스 간의 코드를 재사용하고, 유지 관리를 쉽게 하며, 다형성을 구현하는 데 중요한 역할을 합니다.



4. 오버라이딩(Overriding)
자바 프로그래밍에서 오버라이딩(Overriding)은 서브클래스가 상속받은 슈퍼클래스의 메소드를 자신의 요구에 맞게 재정의하는 과정을 말합니다.

오버라이딩은 객체 지향 프로그래밍의 핵심 개념 중 하나로, 다형성을 가능하게 하며, 상속 받은 메소드를 서브클래스에서 새로운 방식으로 구현할 수 있도록 해줍니다.

4.1 오버라이딩 규칙.
오버라이딩을 할 때는 몇 가지 규칙을 따라야 합니다.


  1. 메소드 이름과 시그니처 일치 : 오버라이딩할 메소드는 슈퍼클래스의 메소드와 동일한 이름, 매개변수 목록, 반환 타입을 가져야 합니다.
  2. 접근 제어 : 오버라이딩하는 메소드는 슈퍼클래스의 메소드보다 더 제한적인 접근 제어를 가질 수 없습니다.
    
      예를 들어, 슈퍼클래스의 메소드가 ‘public’ 이라면 서브클래스의 오버라이딩 메소드도 적어도 ‘public’ 이어야 합니다.
    
  
  3. 반환 타입 : 오버라이딩하는 메소드의 반환 타입은 슈퍼클래스의 메소드 반환 타입과 같거나 그 하위 타입이어야 합니다.(이것은 공변 반환 타입이라고 함.)


4.2 오버라이딩의 예.
슈퍼클래스 ‘Animal’ 에 다음과 같은 메소드가 있다고 가정해 봅시다.
public class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
}


이제 ‘Dog’ 클래스가 ‘Animal’ 클래스를 상속받고 ‘makeSound()’ 메소드를 오버라이드하여 다음과 같이 구현할 수 있습니다.
public class Dog extends Animal {
    @Override // 이 어노테이션은 선택적이지만, 오버라이딩임을 명시적으로 나타냅니다.
    public void makeSound() {
        System.out.println("Dog barks");
    }
}



  이 예에서 ‘Dog’ 클래스의 ‘makeSound()’ 메소드는 ‘Animal’ 의 makeSound() 메소드를 오버라이드하여 “Dog barks”를 출력하도록 재정의합니다.


4.3 오버라이딩의 중요성.
오버라이딩은 다음과 같은 이점을 제공합니다.

  유연성 : 같은 메소드 호출이지만, 다양한 서브클래스에서 서로 다른 동작을 구현할 수 있습니다.
  재사용성 : 기존의 코드를 변경하지 않고도, 상속받은 메소드를 새로운 요구에 맞게 확장할 수 있습니다.
  유지보수 : 코드의 중복을 줄이고, 유지보수를 간편하게 할 수 있습니다.


📝 정리.
오버라이딩은 프로그램의 다형성을 구현하는 데 필수적인 기능으로, 상속받은 메소드를 사용하는 대신 서브클래스에 맞게 특화된 기능을 구현할 수 있도록 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-08-ClassesAndObjects-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-08-ClassesAndObjects-2.html"><h1 class="title_post">☕️[Java] 클래스와 객체(2)</h1></a>
                        <a href="/Backend/Java/2024-05-08-ClassesAndObjects-2.html" class="txt_post">
                            1️⃣ 클래스와 객체(2)

1. 오버로딩(Overloading).
자바 프로그래밍에서 오버로딩(Overloading)은 같은 클래스 내에서 메소드 이름이 같지만 매개변수의 타입이나 개수가 다른 여러 메소드를 정의하는 것을 의미합니다.

오버로딩을 사용하면 같은 기능을 하는 메소드라도 다양한 입력에 대응하여 유연하게 메소드를 호출할 수 있습니다.

오버로딩은 메소드만 가능하며, 생성자에도 적용될 수 있습니다.

1.2. 오버로딩의 규칙.

  1. 메소드 이름이 같아야 합니다 : 오버로딩된 메소드들은 같은 이름을 공유합니다.
  2. 매개변수 목록이 달라야 합니다 : 매개변수의 개수나 타입, 혹은 그 순서가 달라야 합니다. 매개변수의 차이를 통해 자바 컴파일러는 호출할 적절한 메소드를 결정합니다.
  3. 반환 타입은 오버로딩을 구분하는 데 사용되지 않습니다 : 오버로딩된 메소드는 반환 타입이 다르더라도, 이는 오버로딩을 구분하는 데 사용되지 않습니다.
    
      즉, 반환 타입만 다른 메소드는 오버로딩이 아닙니다.
    
  
  4. 접근 제어자와 예외는 오버로딩을 구분하는 데 사용되지 않습니다 : 이 역시 메소드를 구별하는 데 사용되지 않습니다.


1.3. 오버로딩의 예.
public class Print {
    // 오버로딩 예제: 같은 메소드 이름, 다른 매개변수 타입
    public void display(int a) {
        System.out.println("Integer: " + a);
    }
    
    public void display(String a) {
        System.out.println("String: " + a);
    }
    
    // 오버로딩 예제: 같은 메소드 이름, 다른 매개변수 개수
    public void display(int a, int b) {
        System.out.println("Two integers: " + a + ", " + b);
    }
    
    // 오버로딩 예제: 같은 메소드 이름, 매개변수의 순서가 다름
    public void display(String a, int b) {
        System.out.println("String and integer: " + a + ", " + b);
    }
}

public class Test {
    public static void main(String[] args) {
        Print prt = new Print();
        prt.display(1); // 출력: Integer: 1
        prt.display("Hello"); // 출력: String: Hello
        prt.display(1, 2); // 출력: Two integers: 1, 2
        prt.display("Age", 30); // 출력: String and integer: Age, 30
    }
}



  이 예제에서 ‘Print’ 클래스는 ‘display’ 라는 메소드를 여러 번 오버로딩했습니다.
    
      매개변수의 타입, 개수, 순서에 따라 다른 메소드가 호출됩니다.
        
          이를 통해 다양한 타입과 개수의 입력을 유연하게 처리할 수 있습니다.
        
      
    
  


📝 정리.
오버로딩을 통해 프로그램의 가독성을 향상시키고, 유사한 기능을 하는 메소드들을 하나의 이름으로 그룹화함으로써 프로그램을 더욱 직관적으로 만들 수 있습니다.

이러한 방식은 프로그래밍의 복잡성을 줄이고, 코드의 유지보수를 용이하게 합니다.



2. 접근제어자(Access Modifiers).
자바 프로그래밍에서 접근 재어자(Access Modifiers)는 클래스, 메서드, 변수 등과 같은 멤버들에 대한 접근 권한을 제어하는 키워드입니다.

이러한 접근 제어자를 사용함으로써 클래스의 캡슐화를 강화할 수 있으며, 객체의 데이터와 메서드를 외부에서 직접접으로 접근하거나 수정하는 것을 제한할 수 있습니다.

접근 제어자는 클래스의 멤버(변수, 메서드, 생성자 등)와 클래스 자체에 적용될 수 있습니다.

2.1 자바에서 사용하는 주요 접근 제어자


  1. public : 어떤 클래스에서든 접근할 수 있도록 허용합니다.
    
      public으로 선언됩 멤버는 어디서든 접근이 가능합니다.
    
  




  2. protected : 같은 패키지 내의 클래스 또는 다른 패키지의 서브 클래스에서 접근할 수 있습니다.




  3. default(package-private) : 접근 제어자를 명시하지 않은 경우, 같은 패키지 냐의 클래스들만 접근할 수 있습니다. 이를 종종 package-private라고도 합니다.




  private : 해당 멤보를 선언한 클래스 내에서만 접근할 수 있습니다. 외부 클래스에서는 접근할 수 없어, 클래스 내부 구현을 숨기는 데 유용합니다.


2.2 접근 제어자의 사용 예제.

public class AccessExample {
    public int publicVar = 10; // 어디서든 접근 가능
    protected int protectedVar = 20; // 같은 패키지 또는 상속 받은 클래스에서 접근 가능
    int defaultVar = 30; // 같은 패키지 내에서만 접근 가능
    private int privateVar = 40; // 이 클래스 내에서만 접근 가능
    
    public void show() {
        System.out.println("publicVar: " + publicVar);
        System.out.println("protectedVar: " + pretectedVar);
        System.out.println("defaultVar: " + defaultVar);
        System.out.println("privateVar: " + privateVar);
    }
}

public class Test {
    public static void main(String[] args) {
        AccessExample example = new AccessExample();
        System.out.println(example.publicVar); // 접근 가능
        System.out.println(example.protectedVar); // 다른 패키지에 있지 않은 이상 접근 가능
        System.out.println(example.defaultVar); // 같은 패키지에 있을 경우 접근 가능
        // System.out.println(example.privateVar); // 컴파일 에러 발생, 접근 불가능
        example.show(); // 모든 변수 출력 가능
            
    }
}


  위 예제에서는 다양한 접근 제어자가 적용된 변수들을 선언하고, 이에 대한 접근 가능성을 보여줍니다.
  ‘publicVar’ 은 어디서든 접근할 수 있지만, ‘privateVar’ 는 오직 선언된 클래스 내부에서만 접근할 수 있습니다.
  ‘protectedVar’ 과 ‘defaultVar’ 는 좀 더 제한적인 접근을 허용합니다.


📝 정리.
이렇게 접근 제어자를 통해 자바에서는 데이터 보호 및 캡슐화, 객체의 정확한 사용을 보장하여 프로그램의 안정성과 유지보수성을 향상시킬 수 있습니다.



3. static 키워드.
자바 프로그래밍에서 ‘static’ 키워드는 클래스의 멤버(필드, 메서드, 블록 또는 내부 클래스)를 클래스 레벨에 소속 시키는 역할을 합니다.

이는 특정 인스턴스에 속하기보다는 클래스 자체에 속한다는 의미입니다.

‘static’ 멤버는 클래스의 모든 인스턴스에 의해 공유되며, 클래스가 메모리에 로드될 때 생성되고, 클래스가 언로드될 때 소멸됩니다.

3.1 static의 특징.

  1. 클래스 레벨에서 공유 : ‘static’ 필드는 클래스의 모든 인스턴스 간에 공유됩니다.
    
      이는 특정 데이터를 모든 객체가 공유해야 할 필요가 있을 때 유용합니다.
    
  
  2. 인스턴스 생성 없이 접근 기는 : ‘static’ 메서드나 필드는 객체의 인스턴스를 생성하지 않고도 클래스 이름을 통해 직접 접근할 수 있습니다.
  3. 정적 초기화 블록 : ‘static’ 키워드를 사용한 블록(정적 블록)은 클래스가 처음 메모리에 로그 될 때 단 한 번 실행됩니다.
    
      이는 ‘static’ 필드의 초기화에 사용할 수 있습니다.
    
  


3.2 static 필드와 메서드 사용 예.
public class Calculator {
    // 정적 필드
    public static int calculatorCount = 0;
    
    // 정적 블록
    static {
        System.out.println("Calculator 클래스 로딩!");
    }
    
    // 생성자
    public Calculator() {
        calculatorCount++; // 생성될 때마다 계산기의 수를 증가
    }
    
    // 정적 메서드
    public static int add(int a, int b) {
        return a + b;
    }
}

public class Test {
    public static void main(String[] args) {
        Calculator c1 = new Calculator();
        Calculator c2 = new Calculator();
        
        System.out.println("Created Calculators: " + Calculator.calculatorCount); // 2 출력
        System.out.println("Sum: " + Calculator.add(5,3)); // 8 출력
    }
}



  이 예제에서는 ‘Calculator’ 클래스의 인스턴스 생성 횟수를 추적하는 ‘static’ 필드 ‘calculatorCount’ 와 정적 메서드 ‘add’ 를 사용합니다.
    
      ‘calculatorCount’ 는 ‘Calculator’ 의 모든 인스턴스에 의해 공유되며, ‘add’ 메서드는 인스턴스를 생성하지 않고도 호출할 수 있습니다.
    
  


3.3 static 사용 시 주의점

  ‘static’ 메서드 내에서는 인스턴스 변수나 메서드를 직접 사용할 수 없습니다.
  ‘static’ 은 남용하면 객체지향의 원칙을 해칠 수 있습니다.
    
      예를 들어, 객체 간의 상태 공유가 과도하게 이루어져 객체 간의 결합도가 높아질 수 있습니다.
    
  
  ‘static’ 변수는 프로그램의 실행이 끝날 때까지 메모리에 남아 있으므로 메모리 사용에 주의해야 합니다.


3.4 static 메소드와 static 변수와의 관계성.
자바 프로그래밍에서 ‘static’ 메소드와 ‘static’ 변수는 두 가지 공통점을 가지고 있습니다.

둘 다 클래스 레벨에서 정의되며, 클래스의 모든 인스턴스 간에 공유됩니다.

이런 공통점 때문에, ‘static’ 메소드는 ‘static’ 변수에 직접 접근할 수 있지만, 일반 인스턴스 변수에는 접근할 수 없습니다.

3.5 static 변수.
‘static’ 변수는 클래스 변수라고도 하며, 특정 클래스의 모든 인스턴스에 의해 공유됩니다.
이 변수는 클래스가 메모리에 로드될 때 생성되고, 클래스가 언로드될 때까지 메모리에 존재합니다.
‘static’ 변수는 특히 클래스의 인스턴스들이 공통적으로 사용해야 하는 데이터를 저장하는데 유용합니다.
예를 들어, 모든 계산기 객체가 공유해야 하는 ‘calculatorCount’ 와 같은 경우에 사용됩니다.

3.6 static 메소드
‘static’ 메소드 역시 클래스 레벨에 정의되며, 이 메소드는 인스턴스 생성 없이 클래스 이름을 통해 직접 호출할 수 있습니다.

‘static’ 메소드는 인스턴스 필드나 메소드에 접근할 수 없습니다.

그 이유는 ‘static’ 메소드가 호출될 때 해당 클래스의 인스턴스가 존재하지 않을 수 있기 때문입니다.
따라서 ‘static’ 메소드는 오로지 ‘static’ 변수나 다른 ‘static’ 메소드에만 접근할 수 있습니다.

3.7 두 요소의 상호작용.
‘static’ 메소드에는 ‘static’ 변수에 자유롭게 접근하고 수정할 수 있습니다.
이는 ‘static’ 변수가 클래스에 속하고 메소드도 클래스 레벨에서 실행되기 때문입니다.
예를 들어, 어떤 클래스의 모든 인스턴스가 사용할 설정 값을 ‘static’ 변수에 저장하고, 이 값을 설정하거나 조회하는 ‘static’ 메소드를 제공할 수 있습니다.

3.8 예제
public class Counter {
    public static int count = 0; // 'static' 변수
    
    public static void increment() { // 'static' 메소드
        count++; // 'static' 변수에 접근하여 값을 증가
    }
    
    public static void displayCount() {
        System.out.println("Count: " + count); // 'static' 변수의 현재 값을 출력
    }
}

public class Test {
    public static void main(String[] args) {
        Counter.increment();
        Counter.increment();
        Countet.displayCount(); // 출력: Count: 2
    }
}



  
    이 예제에서 ‘Counter’ 클래스는 ‘static’ 변수 ‘count’ 를 가지고 있으며, increment 메소드를 통해 이 변수의 값을 증가시키고, ‘displayCount’ 메소드를 통해 값을 출력합니다.
  
  
    모든 ‘Counter’ 객체가 ‘count’ 값을 공유하며, ‘static’ 메소드를 통해 이 값을 조작할 수 있습니다.
  


📝 정리.
‘static’ 은 전역 변수나 전역 메서드와 유사한 효과를 제공하지만, 자바의 객체지향적 특성과 일관성을 유지하기 위해 적절히 사용되어야 합니다.

‘static’ 메소드와 ‘static’ 변수는 클래스 레벨에서 관리되어 클래스의 모든 인스턴스에 의해 공유되는 특성을 가지고 있습니다.

이를 통해 클래스 전체에 영향을 미치는 작업을 수행할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-08-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-08-TIL.html"><h1 class="title_post">📝 [TIL] 240508 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-08-TIL.html" class="txt_post">
                            
  클래스와 객체(2)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-07-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-07-TIL.html"><h1 class="title_post">📝 [TIL] 240507 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-07-TIL.html" class="txt_post">
                            
  다차원 배열
  클래스와 객체(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-07-MultidimensionalArray.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-07-MultidimensionalArray.html"><h1 class="title_post">☕️[Java] 다차원 배열</h1></a>
                        <a href="/Backend/Java/2024-05-07-MultidimensionalArray.html" class="txt_post">
                            1️⃣ 다차원 배열.
자바 프로그래밍에서 다차원 배열이란, 배열의 배열을 의미합니다.
이는 데이터를 행렬이나 그리드 형태로 구성할 수 있게 해주며, 주로 2차원 이상의 데이터 구조를 필요로 할 때 사용됩니다.
가장 흔한 형태는 2차원 배열이지만, 3차원 이상의 배열도 만들 수 있습니다.

1. 2차원 배열.
2차원 배열은 행렬과 비슷하게 생각할 수 있으며, 각 행과 열에 데이터를 저장합니다.

  예를 들어, 숫자로 이루어진 표를 저장하거나 정보를 격자 형태로 관리할 때 유용합니다.


1.2 2차원 배열의 초기화
자바에서 이차원 배열을 초기화하는 방법은 크게 세 가지로 나눌 수 있습니다.
배열을 선언할 때 크기만 지정해 두거나, 선언과 동시에 특정 값을 사용하여 초기화하거나, 나중에 각 요소에 값을 할당할 수 있습니다.

아래는 각 방법에 대한 설명과 예제입니다.

1.1.1 크기만 지정하여 배열 선언하기.
이 방법은 배열의 행과 열의 크기를 지정해 초기화하지만, 배열의 각 요소는 자동으로 기본 값으로 설정됩니다.(예: int의 경우 0).

inu[][] array = new int[3][4]; // 3행 4열의 배열 생성


  이렇게 선언된 배열은 모든 요소가 0으로 초기화됩니다.


1.1.2 선언과 동시에 초기값을 제공하여 배열 초기화하기.
배열을 선언하면서 동시에 초기값을 제공할 수 있습니다.
이 방법은 배열의 내용을 명확히 알고 있을 때 유용합니다.
int[][] array = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
}; // 각 행에 대한 값들을 중괄호로 묶어서 초기화


  이 예제에서 배열은 3행 4열의 구조로, 각 행의 값이 명시적으로 초기화되어 있습니다.


1.1.3 반복문을 사용하여 배열 초기화하기.
반복문을 사용하면 배열의 각 요소를 동적으로 초기화할 수 있습니다.
이 방법은 런타임에 따라 배열 값을 설정해야 할 때 유용합니다.
int[][] array = new int[3][4];
for (int i = 0; i &lt; array.length; i++) {
    for (int j = 0; j &lt; array[i].length; j++) {
        array[i][j] = (i + 1) * (j + 1); // 각 요소를 행 인덱스와 열 인덱스의 곱으로 초기화
    }
}



  이 방법은 배열의 각 위치에 i와 j 인덱스에 의존하는 계산 결과를 저장합니다.


📝 정리.
이 세 가지 방법은 상황에 따라 각기 다른 이점을 제공하므로, 요구 사항에 맞게 선택하여 사용할 수 있습니다.

2. 3차원 배열.
3차원 배열은 데이터를 3차원 공간으로 구성하여 저장합니다.
이는 비디오 게임의 공간 데이터, 과학 실험 데이터 등 복잡한 정보를 구조화하는 데 사용될 수 있습니다.

2.1. 3차원 배열의 초기화.
자바에서 3차원 배열을 초기화하는 방법은 2차원 배열과 유사합니다.
크게 세 가지 방법으로 나눌 수 있습니다.


  크기만 지정하여 선언하기.
  선언과 동시에 구체적인 값으로 초기화하기
  반복문을 사용하여 동적으로 초기화하기


아해는 각 방법에 대한 설명과 예시입니다.

2.1.1. 크기만 지정하여 배열 선언하기.
이 방법은 삼차원 배열의 각 차원의 크기를 지정합니다.
각 요소는 자동으로 기본값으로 설정됩니다.(예: ‘int’ 의 경우 0).

int[][][] array = new int[3][4][5] // 3개의 4x5 행렬을 갖는 삼차원 배열



  이 배열은 3개의 2차원 배열을 가지며, 각 2차원 배열은 4행 5열 구조입니다.


2.1.2. 선언과 동시에 초기값을 제공하여 배열 초기화하기.
삼차원 배열을 선언하면서 바로 값을 지정할 수 있습니다.
이 방법은 각 요소의 초기값을 명확히 알고 있을 때 매우 유용합니다.
int [][][] array = {
    {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15},
        {16, 17, 18, 19, 20}  
    },
    {
        {21, 22, 23, 24, 25},
        {26, 27, 28, 29, 30},
        {31, 32, 33, 34, 35},
        {36, 37, 38, 39, 40}
    },
    {
        {41, 42, 43, 44, 45},
        {46, 47, 48, 49, 50},
        {51, 52, 53, 54, 55},
        {56, 57, 58, 59, 60}
    }
}; // 각 행렬 및 행에 대한 값들을 중괄호로 묶어서 초기화


2.1.3. 반복문을 사용하여 배열 초기화하기
반복문을 사용해 삼차원 배열의 각 요소를 동적으로 초기화할 수 있습니다.
이 방법은 프로그램 실행 중에 배열 값을 설정해야 할 때 매우 유용합니다.
int[][][] array = new int[3][4][5];

for (int i = 0; i &lt; array.length; i++) {
    for (int j = 0; j &lt; array[i].length; j++) {
        for (int k = 0; k &lt; array[i][j].length; k++) {
            array[i][j][k] = (i + 1) * (j + 1) * (k + 1) // 각 요소를 i, j, k 인덱스의 곱으로 초기화
        }
    }
}



  이 예제에서는 각 위치에 해당하는 인덱스의 곱을 저장하여 배열을 초기화하고 있습니다.
    
      이러한 초기화 방법은 특히 배열의 구조가 복잡할 때 배열을 효과적으로 관리할 수 있게 도와줍니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-07-ClassesAndObjects-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-07-ClassesAndObjects-1.html"><h1 class="title_post">☕️[Java] 클래스와 객체(1)</h1></a>
                        <a href="/Backend/Java/2024-05-07-ClassesAndObjects-1.html" class="txt_post">
                            1️⃣ 클래스와 객체(1)

1. 클래스(Class)
자바 프로그래밍 언어에서 클래스는 객체를 생성하기 위한 설계도 혹은 템플릿입니다.
클래스는 객체의 상태를 정의하는 필드(변수)와 객체의 행동을 정의하는 메서드(함수)로 구성됩니다.

클래스를 사용하는 주된 목적은 데이터와 그 데이터를 조작하는 방법들은 하나의 장소에 묶어 관리하기 위함입니다.
이를 통해 데이터 추상화, 캡슐화, 상속, 다형성 등의 객체지향 프로그래밍의 주요 개념들을 구현할 수 있습니다.

1.2 클래스의 구성 요소.

  1. 필드(Field) : 객체의 데이터 또는 상태를 저장하는 변수입니다.
  2. 메서드(Method) : 객체가 수행할 수 있는 행동을 정의한 코드 블록입니다.
    
      메서드는 필드의 값을 처리하거나 다른 메서드를 호출할 수 있습니다.
    
  
  3. 생성자(Constructor) : 클래스로부터 객체를 생성할 때 초기화를 담당하는 특별한 종류의 메서드입니다.
    
      생성자는 클래스 이름과 같은 이름을 가집니다.
    
  


1.3 클래스 예제
자바에서의 간단한 클래스 예제를 살펴보겠습니다.
public class Car {
    // 필드(변수)
    private String color;
    private String model;
    
    // 생성자
    public Car(String color, String model) {
        this.color = color;
        this.model = model;
    }
    
    // 메서드
    public void drive() {
        System.out.println(model + " 색상의 " + color + " 자동차가 주행 중입니다.");
    
    }
}

// 객체 생성 및 사용
public class Test {
    public static void main(String[] args) {
        Car myCar = new Car("레드", "테슬라");
        myCar.drive();
    }
}



  위의 예제에서 ‘Car’ 클래스는 ‘color’와 ‘model’이라는 두 개의 필드를 가지며, 이는 각각 자동차의 색상과 모델을 나타냅니다.
  ‘Car’ 클래스의 객체를 생성할 때는 ‘new’ 키워드와 함께 생성자를 호출하여 초기 상태를 설정합니다.
  ‘drive’ 메서드는 자동차가 주행하고 있음을 시뮬레이션하는 기능을 합니다.


📝 정리.
클래스를 사용함으로써 코드의 재사용성, 관리성 및 확장성이 향상되며, 대규모 소프트웨어 개발에서 필수적인 요소가 됩니다.



2. 객체(Object)와 인스턴스(Instance).
자바 프로그래밍에서 “객체(Object)”와 “인스턴스(Instance)”는 매우 중요한 개념입니다.
이 두 용어는 종종 서로 바꿔 쓰이지만, 각각의 의미에는 약간의 차이가 있습니다.

2.1 객체(Object).
객체는 소프트웨어 세계의 구성 요소로, 실제 세계의 객체를 모방한 것입니다.
객체는 데이터(속성)와 그 데이터를 조작할 수 있는 함수(메서드)를 캡슐화합니다.
객체는 클래스에 정의된 속성과 기능을 실제로 사용할 수 있도록 메모리상에 할당된 구조입니다.
객체의 개념은 클래스의 특성을 실제로 구현하는 것입니다.

2.2 인스턴스(Instance).
인스턴스는 클래스 타입에 따라 생성된 객체를 의미합니다.
예를 들어, ‘Car’ 클래스의 구체적인 객체(예: 빨간색 테슬라 자동차, 파란색 현대 자동차 등)는 모두 ‘Car’ 클래스의 인스턴스입니다.
즉, 인스턴스는 특정 클래스의 구현체입니다.
인스턴스라는 용어는 주로 객체가 메모리에 할당되어 실제로 생성되었음을 강조할 때 사용됩니다.

2.3 객체와 인스턴스의 관계.
간단히 말해, 모든 인스턴스는 객체입니다, 하지만 사용된 맥락에 따라 ‘인스턴스’라는 용어는 그 객체가 특정 클래스의 구현체임을 명시적으로 나타낼 때 사용됩니다.
예를 들어, 우리가 ‘new Car(“blue”, “Hyundai”)’ 를 통해 생성한 객체는 ‘Car’ 클래스의 인스턴스입니다.

2.4 예제 코드.
public class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void speak() {
        System.out.println(name + " makes a noise.");
    }
}

public class Test {
    public static void main(String[] args) {
        // 여기서 'dog'는 Animal 클래스의 객체이자 인스턴스입니다.
        Animal dog = new Animal("Dog");
        dog.speak();
    }
}



  위 예제에서 ‘Animal’ 클래스가 있고, ‘main’ 메서드에서 ‘Animal’ 클래스의 새 객체를 생성합니다.
    
      여기서 ‘dog’ 는 ‘Animal’ 클래스의 인스턴스이며 객체입니다.
        
          ‘dog’ 는 ‘Animal’ 클래스에 정의된 메서드와 필드를 사용할 수 있습니다.
        
      
    
  


📝 정리.
요약하면, 객체는 속성과 메서드를 갖는 소프트웨어의 기본 구성 단위이고, 인스턴스는 그 객체가 특정 클래스의 실제 구현체임을 의미합니다.
이 두 용어는 프로그래밍에서 클래스 기반의 객체를 생성하고 다룰 때 핵심적인 역할을 합니다.

클래스와 객체의 관계를 이해
기본 사용 방법과 생성자 및 this의



3. 메소드(Method).
자바 프로그래밍에서 메소드(Method)는 클래스에 속한 함수로서, 특정 작업을 수행하는 코드 블록입니다.
메소드는 객체의 행동을 정의하며, 클래스 내에서 정의된 데이터나 상태(필드)를 조작하는 데 사용됩니다.

메소드를 통해 객체지향 프로그래밍의 중요한 특징인 캡슐화와 추상화를 구현할 수 있습니다.

3.1 메소드의 주요 특징.

  1. 재사용성 : 메소드는 코드의 재사용성을 증가시킵니다. 한 번 정의된 메소드는 여러 위치에서 호출되어 사용될 수 있습니다.
  2. 모듈성 : 메소드를 사용함으로써 큰 프로그램을 작은 단위로 나누어 관리할 수 있습니다. 이는 코드의 가독성과 유지보수성을 향상시킵니다.
  3. 정보 은닉 : 메소드를 통해 구현 세부사항을 숨기고 사용자에게 필요한 기능만을 제공할 수 있습니다.


3.2 메소드의 구성 요소.

  1. 메소드 이름 : 메소드를 식별하는 데 사용되며, 메소드가 수행하는 작업을 설명하는 명확한 이름을 가집니다.
  2. 매개변수 목록(Parameter List) : 메소드에 전달되는 인자의 타입, 순서, 그리고 개수를 정의합니다. 매개변수는 선택적일 수 있습니다.
  3. 반환 타입 : 메소드가 작업을 수행한 후 반환하는 데이터의 타입입니다. 반환할 데이터가 없으면 ‘void’ 로 지정됩니다.
  4. 메소드 바디 : 실제로 메소드가 수행할 작업을 구현하는 코드 블록입니다.


3.3 예제.
자바에서 간단한 메소드 예제를 보여드리겠습니다.
public class Calculator {
    // 메소드 정의: 두 정수의 합을 반환
    public int add(int num1, int num2) {
        return num1 + num2;
    }
    
    // 메소드 정의: 두 정수의 차를 반환
    public int subtract(int num1, int num2) {
        return num1 - num2;
    }
}

public class Test {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        int result1 = calc.add(5, 3); // 8 반환
        int result2 = calc.subtract(5, 3); // 2 반환
        System.out.println("Addition Result: " + result1);
        System.out.println("Subtraction Result: " + result2);
    }
}



  이 예제에서 ‘Calculator’ 클래스는 두 개의 메소드 ‘add’ 와 ‘subtract’ 를 가지고 있습니다.
    
      각각의 메소드는 두 개의 정수를 받아 그 결과를 반환합니다.
        
          이렇게 메소드를 사용하면 코드를 효율적으로 관리할 수 있으며, 필요에 따라 재사용할 수 있습니다.
        
      
    
  


📝 정리.
메소드는 자바 프로그래밍에서 기능을 모듈화하고 코드의 재사용을 가능하게 하는 핵심 요소입니다.



4. 접근 제어자(Access Modifiers)
자바 프로그래밍에서 접근 제어자(Access Modifiers)는 클래스, 메서드, 변수 등과 같은 멤버들에 대한 접근 권한을 제어하는 키워드입니다.

이러한 접근 제어자를 사용함으로써 클래스의 캡슐화를 강화할 수 있으며, 객체의 데이터와 메서드를 외부에서 직접적으로 접근하거나 수정하는 것을 제한할 수 있습니다.

접근 제어자는 클래스의 멤버(변수, 메서드, 생성자 등)와 클래스 자체에 적용될 수 있습니다.

4.1 자바에서 사용하는 주요 접근 제어자.

  1. public : 어떤 클래스에서든 접근할 수 있도록 허용합니다.
    
      public으로 선언된 멤버는 어디서든 접근이 가능합니다.
    
  
  
    2. protected : 같은 패키지 내의 클래스 또는 다른 패키지의 서브 클래스에서 접근할 수 있습니다.
  
  3. default(package-private) : 접근 제어자를 명시하지 않은 경우, 같은 패키지 내의 클래스들만 접근할 수 있습니다.
    
      이를 종종 package-private라고도 합니다.
    
  
  4. private : 해당 멤버를 선언한 클래스 내에서만 접근할 수 있습니다.
    
      외부 클래스에서는 접근할 수 없어, 클래스 내부 구현을 숨기는 데 유용합니다.
    
  


4.2 접근 제어자의 사용 예제.
public class AccessExample {
    public int publicVar = 10; // 어디서든 접근 가능
    protexted int protectedVar = 20; // 같은 패키지 또는 상속받은 클래스에서 접근 가능
    int defaultVar = 30; // 같은 패키지 내에서만 접근 가능
    private int privateVar = 40; // 이 클래스 내에서만 접근 가능
    
    public void show() {
        System.out.println("publicVar: " + publicVar);
        System.out.println("protectedVar: " + protectedVar);
        System.out.println("defaultVar: " + defaultVar);
        System.out.println("privateVar: " + privateVar);
    }
}

public class Test {
    public static void main(String[] args) {
        AccessExample example = new AccessExample();
        System.out.println(example.publicVar); // 접근 가능
        System.out.println(example.protectedVar); // 다른 패키지에 있지 않은 이상 접근 가능
        System.out.println(example.defaultVar); // 같은 패키지에 있을 경우 접근 가능
        // System.out.println(example.privateVar); // 컴파일 에러 발생, 접근 불가능
        example.show(); // 모든 변수 출력 가능
    }
}



  위 예제에서는 다양한 접근 제어자가 적용된 변수들을 선언하고, 이에 대한 접근 가능성을 보여줍니다.
    
      ‘publicVar’ 은 어디서든 접근할 수 있지만, ‘privateVar’ 는 오직 선언된 클래스 내부에서만 접근할 수 있습니다.
      ‘protectedVar’ 과 ‘defaultVar’ 는 좀 더 제한적인 접근을 허용합니다.
    
  


📝 정리.
이렇게 접근 제어자를 통해 자바에서는 데이터 보호 및 캡슐화, 객체의 정확한 사용을 보장하여 프로그램의 안정성과 유지보수성을 향상시킬 수 있습니다.



5. static 키워드.
자바 프로그래밍에서 ‘static’ 키워드는 특정 필드나 메소드, 또는 중첩 클래스를 클래스의 인스턴스가 아닌 클래스 자체에 소속되게 합니다.

이를 사용함으로써 해당 멤버는 클래스의 모든 인스턴스에 걸쳐 공유되며, 인스턴스 생성 없이 클래스 이름을 통해 직접 접근할 수 있습니다.

5.1 static의 주요 사용 사례.

  1. 정적 필드(Static Fields) : 모든 인스턴스에 의해 공유되는 클래스 변수입니다.
    
      예를 들어, 회사의 모든 직원이 같은 회사 이름을 공유할 때 사용할 수 있습니다.
    
  
  2. 정적 메소드(Static Methods) : 인스턴스 변수에 접근할 필요 없이, 클래스 이름을 통해 직접 호출할 수 있는 메소드입니다.
    
      유틸리티 함수나 핼퍼 함수를 작성할 때 자주 사용됩니다.
    
  
  
    3. 정적 초기화 블록(Static Initialization Blocks) : 클래스가 처음 로딩될 때 한 번 실행되며, 정적 변수를 초기화하는 데 사용됩니다.
  
  4. 정적 중첩 클래스(Static Nested Classes) : 다른 클래스 내부에 위치하면서도 독립적으로 사용될 수 있는 클래스입니다.


5.2 static 키워드의 장점과 단점.
장점.

  메모리 효율성 : static 멤버는 클래스 로드 시 메모리에 한 번만 할당되고 모든 인스턴스가 공유하기 때문에 메모리 사용을 최소화할 수 있습니다.
  편리성 : 객체 생성 없이 바로 접근할 수 있어, 유틸리티 함수 같은 공통 기능 구현에 유용합니다.


단점.

  과도한 사용은 객체지향 원칙에 어긋남 : 객체 간의 결합도가 높아지고, 객체의 상태 관리가 어려워질 수 있습니다.
  테스트가 어려워질 수 있슴 : static 메소드는 오버라이드가 불가능하며, 상태를 공유하기 때문에 병렬 테스트 환경에서 문제를 일으킬 수 있습니다.


5.3 예제.
public class Company {
    // 정적 필드
    public static String companyName = "Global Tech";
    
    // 정적 메소드
    public static void printCompanyName() {
        System.out.println("Company Name: " + companyName);
    }
}

public class Test {
    public static void main(String[] args) {
        // 객체 생성 없이 정적 메소드 호출
        Company.printCompanyName();
    }
}



  이 예제에서 ‘Company’ 클래스에는 정적 필드 ‘companyName’ 과 정적 메소드 ‘printCompanyName()’ 이 있습니다.
    
      ‘main’ 메소드에서는 ‘Company’ 클래스의 객체를 생성하지 않고도 ‘printCompanyName()’ 메소드를 호출하려 회사 이름을 출력합니다.
    
  


📝 정리.
정적 멤버는 클래스와 관련된, 변하지 않는 값이나, 모든 인스턴스가 공유해야 하는 정보를 관리할 때 유용하게 사용됩니다.



6. 생성자(Constructor)
자바 프로그래밍에서 생성자(Constructor)는 클래스로부터 객체가 생성될 때 호출되는 특별한 유형의 메서드입니다.
생성자의 주요 목적은 새로 생성된 객체를 초기화하는 것으로, 객체의 기본 상태를 설정하는 데 사용됩니다.

생성자는 메서드처럼 보일 수 있지만, 리턴 타입이 없고 클래스 이름과 동일한 이름을 가집니다.

6.1 생성자 특징.

  1. 클래스 이름과 동일 : 생성자의 이름은 항상 선언된 클래스의 이름과 동일해야 합니다.
  2. 리턴 타입 없음 : 생성자는 값을 반환하지 않으며, 리턴 타입도 선언하지 않습니다.
  3. 자동 호출 : 객체가 생성될 때 자동으로 호출됩니다.
    
      이는 객체의 필드를 초기화하거나, 객체 생성 시 실행해야 할 다른 시작 루틴을 실행하는 데 사용할 수 있습니다.
    
  
  4. 오버로딩 가능 : 하나의 클래스에 여러 생성자를 정의할 수 있습니다.
    
      이를 생성자 오버로딩이라고 하며, 파라미터의 수나 타입에 따라 다른 생성자를 호출할 수 있습니다.
    
  


6.2 생성자의 유형.

  1. 기본 생성자(Default Constructor) : 개발자가 명시적으로 생성자를 정의하지 않으면, 자바 컴파일러는 매개변수가 없는 기본 생성자를 제공합니다.
    
      이 기본 생성자는 객체의 필드를 기본값으로 초기화합니다.
    
  
  2. 매개변수가 있는 생성자(Parameterized Constructor) : 하나 이상의 매개변수를 받아 객체의 초기 상태를 세팅 할 수 있도록 해줍니다.


6.3 예제.
public class Person {
    private String name;
    private int age;
    
    // 기본 생성자
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }
    
    // 매개변수가 있는 생성자
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void displayInfo() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}

public class Test {
    public static void main(String[] args) {
        // 기본 생성자를 사용하여 객체 생성
        Person person1 = new Person();
        person1.displayInfo(); // 출력: Name: Unknown, Age: 0
        
        // 매개변수가 있는 생성자를 사용하여 객체 생성
        Person person2 = new Person("Jhon", 25);
        person2.displayInfo(); // 출력: Name: Jhon, Age: 25
    }
}


  이 예제에서 ‘Person’ 클래스는 두 가지 유형의 생성자를 가집니다.
    
      하나는 매개변수가 없어 기본값으로 객체를 초기화하고, 다른 하나는 이름과 나이를 받아 객체를 초기화합니다.
    
  


📝 정리.
생성자를 사용함으로써 클래스의 인스턴스가 유효한 상태로 시작될 수 있도록 보장하며, 필요한 초기 설정을 자동으로 수행할 수 있습니다.
이는 객체 지향 프로그래밍에서 객체의 무결성을 유지하는 중요한 방법입니다.



7. this 키워드와 this() 생성자 호출.
자바에서 ‘this’ 키워드와 ‘this()’ 생성자 호출은 객체 자신을 참조하고 객체의 생성자를 호출하는 데 사용되는 중요한 요소입니다.

이들은 객체 내부에서 사용되며, 클래스의 멤버(필드, 메서드, 생성자)와 관련된 동작을 명확히 하는 데 유용합니다.

7.1 this 키워드.
‘this’ 키워드는 현재 객체, 즉 메서드나 생성자를 호출하는 인스턴스를 참조하는 데 사용됩니다.

주로 다음과 같은 상황에서 사용됩니다.


  
    1. 필드와 매개변수 이름이 같을 때 구분 : 메서드나 생성자의 매개변수와 클래스의 필드 이름이 같을 때, 필드와 매개변수를 구분하기 위해 사용됩니다.
  
  
    2. 메서드 체이닝 : 객체의 메서드를 연속적으로 호출할 때 ‘this’ 를 반환함으로써 메서드 체이닝을 구현할 수 있습니다.
  
  
    3. 현재 객체를 다른 메서드에 전달 : 현재 객체의 참조를 다른 메서드에 전달할 때 사용됩니다.
  


7.2 this() 생성자 호출.
‘this()’ 는 같은 클래스의 다른 생성자를 호출하는 데 사용됩니다.
주로 생성자 오버로딩이 있을 때, 중복 코드를 최소화하고, 하나의 생성자에서 다른 생성자를 호출하여 필드 초기화 등의 공통 작업을 중앙집중적으로 관리할 수 있게 해줍니다.


  
    1. 생성자 오버로딩 처리 : 클래스에 여러 생성자가 있을 때,  ‘this()’ 를 사용하여 한 생성자에서 다른 생성자를 호출함으로써 공통 코드를 재사용할 수 있습니다.
  
  
    2. 코드 간결성 유지 : 필수적인 초기화 작업을 주 생성자에만 명시하고, 나머지 생성자는 이 주 생성자를 호출하게 함으로써 코드의 간결성을 유지합니다.
  


7.3 예제.
public class Rectangle {
    private int width;
    private int height;
    
    // 주 생성자
    public Rectangle(int width, int height) {
        this.width = width; // 'this'로 필드와 매개변수 구분
        this.height = height;
    }
    
    // 부 생성자
    public Rectangle() {
        this(10, 10) // 'this()' 로 다른 생성자 호출
    }
    
    public void displaySize() {
        System.out.println("Width: " + this.width + ", Height: " + this.height);
    }
}

public class Test {
    public static void main(String[] args) {
        Rectangle rect1 = new Rectangle(30, 40);
        rect1.displaySize(); // 출력: Width: 30, Height: 40
        
        Rectangle rect2 = new Rectangle();
        rect2.displaySize(); // 출력: Width: 10, Height: 10
    }
}



  이 예제에서 ‘Rectangle’ 클래스는 두 개의 생성자를 가지고 있습니다.
    
      기본 생성자는 ‘this()’ 를 사용하여 주 생성자를 호출하고, 주 생성자에서는 ‘this’ 키워드를 사용하여 클래스 필드와 생성자 매개변수를 구분합니다.
        
          이렇게 ‘this’ 와 ‘this()’ 를 사용함으로써 코드의 중복을 줄이고, 초기화 로직을 하나의 생성자에 집중할 수 있습니다.
        
      
    
  


📝 정리.
이처럼 ‘this’ 와 ‘this()’ 는 자바에서 클래스의 인스턴스 자신을 참조하거나 클래스 내 다른 생성자를 호출하는 데 매우 유용한 도구입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-06-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-06-TIL.html"><h1 class="title_post">📝 [TIL] 240506 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-06-TIL.html" class="txt_post">
                            
  반복문


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-06-loopStatement.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-06-loopStatement.html"><h1 class="title_post">☕️[Java] 반복문</h1></a>
                        <a href="/Backend/Java/2024-05-06-loopStatement.html" class="txt_post">
                            1️⃣ 반복문

1. for 반복문.
자바 프로그래밍에서 ‘for’ 반복문은 특정 조건을 만족하는 동안 코드 블록을 반복해서 실행하도록 설계된 제어 구조입니다.
‘for’ 문은 초기화, 조건 검사, 반복 후 실행할 작업(일반적으로 증감)을 한 줄에 명시하여 코드의 가독성과 관리를 용이하게 합니다.
이는 반복 실행이 필요한 많은 상황에서 유용하게 사용됩니다.

1.2 for 반복문의 기본 구조.
‘for’ 문의 기본 구조는 다음과 같습니다.

for (초기화; 조건; 증감) {
    // 반복해서 실행할 코드
}


  초기화 : 반복문이 시작할 때 한 번 실행되는 부분으로, 반복문의 제어 변수를 초기 설정합니다.
  조건 : 이 조건이 참(‘true’) 인 동안 반복문 내의 코드가 실행 됩니다. 조건이 거짓(‘false’)이 되면 반복문은 종료됩니다.
  증감 : 각 반복의 끝에서 실행되며, 주로 제어 변수의 값을 증가시키거나 감소시키는데 사용됩니다.


1.3 for 반복문의 예시
기본 예시

for (int i = 0; i &lt; 5; i++) {
    System.out.println("i의 값은: " + i);
}



  이 예제에서는 ‘i’ 를 0부터 시작하여 ‘i’ 가 5미만일 동안 반복하여, 매 반복마다 ‘i’ 를 1씩 증가시킵니다.
    
      따라서 “i의 값은: 0” 부터 “i의 값은: 4” 까지 총 다섯 번의 출력을 하게 됩니다.
    
  


확장된 예시: 다중 제어 변수
for (int i = 0, j = 10; i &lt; j; i++, j--) {
    System.out.println("i = " + i + ". j = " + j);
}



  이 예제에서는 두 개의 제어 변수 ‘i’ 와 ‘j’ 를 사용합니다.
    
      ‘i’ 는 증가하고 ‘j’ 는 감소하며, ‘i’ 가 ‘j’ 와 같거나 ‘j’ 보다 크게 되면 반복이 종료됩니다.
        
          이런 패턴은 복잡한 반복 조건이 필요한 경우 유용하게 사용됩니다.
        
      
    
  


1.4 사용 사례
‘for’ 반복문은 배열이나 컬렉션과 같은 데이터 구조를 순회할 때 매우 유용합니다.
예를 들어, 배열의 모든 요소를 처리하거나 조작할 때 자주 사용됩니다.
int[] numbers = {1,2,3,4,5};
for (int i = 0; i &lt; numbers.length; i++) {
    System.out.println("배열 요소: " + numbers[i]);
}



  여기서 ‘numbers.length’ 는 배열의 길이를 반환하며, ‘i’ 는 0에서 시작하여 배열의 크기 미만이 될 때까지 증가하면서 배열의 각 요소에 접근합니다.


📝 정리
‘for’ 반복문은 코드를 간결하게 하면서 반복적인 작업을 효과적으로 처리할 수 있도록 도와줍니다.



2. while 반복문.
자바 프로그래밍에서 ‘while’ 반복문은 특정 조건이 참(‘true’)인 동간 주어진 코드 블록을 반복적으로 실행하는 구조 입니다.
‘while’ 문은 주로 반복 횟수가 불확실할 때 또는 반복 횟수를 사전에 정확히 알 수 없을 때 사용됩니다.

2.1 while 반복문의 기본 구조.
‘while’ 문의 기본 구조는 다음과 같습니다.

while (조건) {
    // 조건이 참인 동안 반복 실행될 코드
}


  여기서 ‘조건’ 은 각 반복 이전에 평가되며, 이 조건이 참(‘true’)일 때 반복 블록 내의 코드가 실행됩니다. 조건이 거짓(‘false’)이 되면 반복문은 종료됩니다.


2.2 while 반복문 예시.
간단한 예
int i = 0;
while (i &lt; 5) {
    System.out.println("i의 값은: " + i);
    i++; // i 값을 증가시켜 조건이 eventually 거짓이 되도록 함
}



  이 예제에서는 ‘i’ 가 0부터 시작하여 5미만인 동안 반복문을 실행합니다.
    
      반복문 내에서 ‘i’ 를 1씩 증가시켜 eventually 조건이 거짓이 되도록 합니다.
        
          결과적으로 ‘i’ 의 값은 0부터 4까지 콘솔에 출력됩니다.
        
      
    
  


사용자 입력 받기
‘while’ 문은 사용자 입력을 받고, 그 입력에 따라 반복을 계속할지 여부를 결정할 때 유용하게 사용될 수 있습니다.
예를 들어, 사용자가 특정 문자를 입력할 때까지 입력을 계속 받는 프로그램은 다음과 같이 작성할 수 있습니다.
Scanner scanner = new Scanner(System.in);
String input = "";
while (!input.equals("종료")) {
    System.out.println("문자열을 입력하세요. 종료하려면 '종료'를 입력하세요: ");
    input = scanner.nextLine();
}
scanner.close();


2.3 주의사항.
‘while’ 반복문을 사용할 때는 반복문 내에서 조건이 eventually(결국) 거짓이 될 수 있도록 조치를 취해야 합니다.
그렇지 않으면, 조건이 항상 참으로 평가될 경우 무한 후프에 빠질 수 있습니다.
따라서 조건 변수를 적절히 조작하거나 적절한 로직을 구현하여 반복문이 적절한 시점에 종료될 수 있도록 해야 합니다.

📝 정리.
‘while’ 문은 그 구조가 간단하고 유연하여, 특정 조건 하에 반복 실행을 해야 할 때 매우 유용한 프로그래밍 도구입니다.



3. do-while 반복문.
자바 프로그래밍에서 ‘do-while’ 반복문은 조건을 검사하기 전에 최소 한 번은 코드 블록을 실행하는 반복문입니다.
이 구조는 ‘while’ 반복문과 비슷하지만, 조건의 참/거짓 여부에 관계없이 최소한 처음에는 반복문 내의 코드를 실행한다는 점이 다릅니다.
‘do-while’ 문은 주로 사용자 입력을 처리하거나, 조건이 반복문의 실행 후에 결정되어야 할 때 유용합니다.

3.1 do-while 반복문의 기본 구조.
‘do-while’ 문의 기본 구조는 다음과 같습니다.
do {
    // 최소 한 번은 실행될 코드
} while (조건);



  여기서 ‘조건’ 은 반복문의 끝에서 평가됩니다.
    
      조건이 참(‘true’)이면, 코드 블록이 반복적으로 실행됩니다. 조건이 거짓(‘false’)이면, 반복이 종료됩니다.
    
  


3.2 do-while 반복문의 예시.
기본 예
int i = 0;
do {
    System.out.println("i의 값은: " + i);
    i++;
} while (i &lt; 5);



  이 예제에서는 ‘i’ 가 0부터 시작하여 ‘i &lt; 5’ 인 동안 반복합니다.
    
      ‘do-while’ 문은 ‘i’ 의 초기 값에 상관없이 최소 한 번은 “i의 값은: 0”을 출력하고 시작합니다. 그 후 ‘i’ 가 5미만인 동안 계속해서 반복됩니다.
    
  


사용자 입력 받기
사용자로부터 입력을 받고, 특정 조겅(“종료” 문자열 입력)을 만족할 때까지 계속 입력을 받는 프로그램을 구현할 때 ‘do-while’ 문이 유용하게 사용됩니다.

Scanner scanner = new Scanner(System.in);
String input;
do {
    System.out.println("문자열을 입력하세요. 종료하려면 '종료'를 입력하세요:");
    input = scanner.nextLine();
} while (!input.equals("종료"));
scanner.close();


  이 코드는 사용자가 “종료”를 입력할 때까지 계속해서 입력을 받습니다.
    
      입력을 받는 동작은 최소 한 번은 실행되며, 이는 ‘do-while’ 문이 최조 실행을 보장하기 때문입니다.
    
  


3.3 주의사항.
‘do-while’ 반복문을 사용할 때, 조건을 적절히 설정하여 반복문이 적절한 시점에 종료되도록 해야 합니다. 그렇지 않으면 무한 루프에 빠질 수 있습니다.
또한, 조건 검사가 반복문의 끝에서 이루어지므로, 조건이 매우 빨리 거짓이 되어도 코드 블록이 한 번은 실행됨을 기억해야 합니다.

📝 정리.
‘do-while’ 문은 조건이 반복 블록 실행 후에만 알 수 있거나, 반복 블록을 적어도 한 번은 실행해야 하는 경우 특히 유용한 도구입니다.



4. continue.
자바 프로그래밍에서 ‘continue’ 문은 반복문 내에서 사용되며, 그것이 실행될 때 현재 반복의 나머지 부분을 건너뛰고 즉시 다음 반복으로 넘어가도록 합니다.
이를 통해 특정 조건에서 반복문의 다음 순환을 즉시 시작할 수 있게 해줍니다.
‘continue’ 는 주로 반복문 내에서 특정 조건에 대한 예외 처리나 불필요한 처리를 건너뛰기 위해 사용됩니다.

4.1 continue 기본 사용법
‘continue’ 문은 주로 ‘for’, ‘while’, 또는 ‘do-while’ 반복문 내에서 사용됩니다.
간단하게는 ‘continue’ 를 실행하면 반복문의 현재 순회에서 남은 코드를 실행하기 않고, 다음 반복으로 진행합니다.

4.2 continue 예시
‘for’ 반복문에서의 사용
for (int i = 0; i &lt; 10; i++) {
    if (i % 2 == 0) {
        continue; // 짝수인 경우, 출력을 건너뛰고 다음 반복으로 넘어감
    }
    System.out.println(i); // 홀수만 출력
}



  이 코드는 0부터 9까지의 숫자 중에서 홀수만 출력합니다.
    
      ‘i’ 가 짝수일 경우, ‘continue’ 문이 실행되어 ‘System.out.println(i);’ 줄을 건너뛰고 다음 반복으로 넘어갑니다.
    
  


‘while’ 반복문에서의 사용
int i = 0;
while (i &lt; 10) {
    i++;
    if (i % 2 == 0) {
        continue; // 짝수인 경우, 아래의 출력을 건너뛰고 다음 반복으로 넘어감
    }
    System.out.println(i); // 홀수만 출력
}



  이 예제에서도 ‘continue’ 는 짝수를 확인하는 조건에서 참일 경우 나머지 코드를 건너뛰고 다음 반복을 계속 진행하도록 합니다.


4.3 continue 특징 및 주의사항.

  ‘continue’ 문은 현재 수행 중인 반복의 나머지 부분을 건너뛰고, 반복문의 조건 검사로 직접 이동하여 다음 반복을 시작합니다.
  ‘continue’ 문을 사용할 때는 반복문이 무한 루프에 빠지지 않도록 주의해야 합니다.
    
      예를 들어, ‘continue’ 문이 반복문의 변수 값을 변경하는 코드를 건너뛰면 그 변수의 값이 업데이트되지 않아 무한 루프가 발생할 수 있습니다.
    
  
  ‘continue’ 는 루프의 흐름을 제어하고, 코드의 읽기 어려움을 증가시킬 수 있으므로, 사용할 때는 명확한 이유가 있어야 합니다.


📝 정리.
‘continue’ 문은 코드를 보다 효율적으로 만들고, 필요 없는 조건을 빠르게 건너뛸 수 있게 도와줍니다.
그러나 코드의 가독성과 유지 관리에 영향을 줄 수 있으므로 신중하게 사용해야 합니다.



5. break문.
자바 프로그래밍에서 ‘break’ 문은 반복문(‘for’, ‘while’, ‘do-while’) 또는 ‘switch’ 문에서 현재 블록의 실행을 즉시 종료하고, 해당 블록의 바깥으로 제어를 이동시키는 역할을 합니다.

이는 반복문 또는 ‘switch’ 문 내에서 특정 조건을 만족할 때 추가적인 처리 없이 루프나 선택 구조를 벗어나기 위해 사용됩니다.

5.1 break 기본 사용법.

  반복문에서의 사용 : ‘break’ 를 사용하여 무한 루프를 종료하거나 특정 조건이 만족될 때 반복문을 조기에 종료할 수 있습니다.
  ‘switch’ 문에서의 사용 : 각 ‘case’ 블록 뒤에 ‘break’ 를 사용하여 ‘switch’ 문을 종료하고, 다음 ‘case’ 로 넘어가지 않도록 합니다.


5.2 break 예시
반복문에서의 ‘break’
for (int i = 0; i &lt; 10; i++) {
    if (i == 5) {
        break; // i가 5가 되면 for 루프를 종료
    }
    System.out.println(i);
}


  이 코드에서는 ‘i’ 가 5에 도달하면 ‘break’ 문이 실행되어 ‘for’ 루프가 즉시 종료됩니다.
    
      결과적으로, 0부터 4까지의 숫자만 출력됩니다.
    
  


‘while’ 반복문에서의 ‘break’
int i = 0;
while (true) { // 무한 루프
    if (i == 5) {
        break; // i가 5가 되면 while 루프를 종료
    }
    System.out.println(i);
    i++;
}


  이 예제에서도 ‘i’ 가 5일 때 ‘break’ 문을 사용하여 무한 루프를 종료합니다.


‘switch’ 문에서의 ‘break’
int number = 2;
switch (number) {
    case 1:
        System.out.println("Number is 1");
        break;
    case 2:
        System.out.println("Number is 2");
        break;
    case 3:
        System.out.println("Number is 3");
        break;
    default:
        System.out.println("Number is not 1, 2, or 3");
}



  ‘switch’ 문에서 ‘number’ 가 2일 때 해당하는 ‘case’ 블록이 실행되고, ‘break’ 문으로 인해 ‘switch’ 문을 벗어나게 됩니다.


5.3 break문 특징 및 주의사항

  ‘break’ 문은 코드 실행을 즉시 중단시키므로, 효과적인 프로그램 흐름 제어를 가능하게 합니다.
  반복문이나 ‘switch’ 문 내에서만 ‘break’ 문을 사용할 수 있습니다.
  ‘break’ 문을 사용할 때는 코드의 흐름을 명확히 이해하고 있어야 하며, 무분별한 사용은 코드의 가독성과 유지보수를 어렵게 만들 수 있습니다.


📝 정리.
‘break’ 는 코드의 복잡성을 줄이고 특정 조건에서 즉시 반복문을 종료할 수 있는 강력한 도구입니다.
그러나 그 사용은 코드의 구조를 명확하게 유지하는 방식으로 신중하게 이루어져야 합니다.



6. for-each문.
자바 프로그래밍에서 ‘for-each’ 문, 또는 강화된 ‘for’ 문(enhanced for loop)은 배열이나 컬렉션 프레임워크에 저장된 각 요소를 순회하기 위해 사용되는 구문입니다.

기존의 ‘for’ 문보다 간결하며, 코드를 읽고 작성하기가 더 쉬워 배열이나 컬렉션의 모든 요소에 접근할 때 일반적으로 권장되는 방식입니다.

6.1 for-each문 기본 구조.
‘for-each’ 문의 기본 구조는 다음과 같습니다.
for (타입 변수명 : 배열 또는 컬렉션) {
    // 변수명을 사용한 코드
}



  여기서 ‘타입’ 은 배열 또는 컬렉션에 저장된 요소의 타입을 말하고, ‘변수명’ 은 반복되는 각 요소를 참조하는 데 사용되는 변수 이름입니다.
  ‘배열 또는 컬렉션’ 은 순회할 배열이나 컬렉션 객체를 지정합니다.


6.2 for-each문 예시
배열 사용 예
int[] numbers = {1,2,3,4,5};
for(int number: numbers) {
    System.out.println(number);
}


  이 코드에서 ‘for-each’ 문은 ‘numbers’ 배열의 모든 요소를 순회합니다.
    
      각 반복에서 ‘number’ 변수에 배열의 요소가 할당되며, 그 값을 출력합니다.
    
  


컬렉션 사용 예
List&lt;String&gt; names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name);
}


  이 예에서는 ‘names’ 리스트의 모든 요소를 순회합니다.
    
      각 요소는 ‘name’ 변수에 할당되고, ‘System.out.println’ 을 통해 출력됩니다.
    
  


6.3 for-each문의 장점.

  가독성 향상: ‘for-each’ 문은 간결하고 이해하기 쉬워, 코드의 가독성을 크게 향상시킵니다.
  오류 감소: 전통적인 ‘for’ 문에서 발생할 수 있는 인덱스 관련 실수나 경계 조건 오류를 방지할 수 있습니다.
  향상된 추상화: 컬렉션의 내부 구조나 크기를 몰라도 각 요소에 접근할 수 있습니다.


6.4 for-each문의 제한사항.

  컬렉션 수정 불가: ‘for-each’ 문을 사용하는 동안 컬렉션을 수정할 수 없습니다.
    
      예를 들어, 순회 중인 컬렉션에서 요소를 추가하거나 제거할 수 없습니다.
    
  
  인덱스 접근 불가: ‘for-each’ 문은 각 요소에 대한 인덱스를 제공하지 않습니다.
    
      특정 인덱스의 요소에 접근하거나 인덱스를 활용한 복잡한 로직이 필요한 경우에는 전통적인 ‘for’ 문을 사용해야 합니다.
    
  


📝 정리.
‘for-each’ 문은 자바에서 컬렉션과 배열을 효율적으로 처리할 수 있는 강력하고 사용하기 쉬운 도구입니다.
이를 통해 코드를 더욱 간결하고 안전하게 만들 수 있습니다.



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-05-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-05-TIL.html"><h1 class="title_post">📝 [TIL] 240505 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-05-TIL.html" class="txt_post">
                            
  여러가지 연산자(1)
  여러가지 연산자(2)
  조건문


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-05-conditionalStatement.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-05-conditionalStatement.html"><h1 class="title_post">☕️[Java] 조건문</h1></a>
                        <a href="/Backend/Java/2024-05-05-conditionalStatement.html" class="txt_post">
                            1️⃣ 조건문

1. if문.
자바 프로그래밍에서 ‘if’ 문은 조건부 실행을 제어하는 기본적인 제어 구문입니다.
이를 통해 프로그램은 주어진 조건이 참(‘true’)인지 거짓(‘false’)인지에 따라 다른 행동을 취할 수 있습니다.

1.1 if문 기본 구조.
‘if’ 문의 기본 구조는 다음과 같습니다.
if (조건) {
    // 조건이 참일 때 실행될 코드
}


  여기서 ‘조건’ 은 boolean 타입의 표현식으로, 평가 결과가 ‘true’ 또는 ‘false’ 가 됩니다.
    
      조건이 ‘true’ 일 때만 중괄호 ’{}’ 내부의 코드가 실행됩니다.
    
  


1.2 예시
예를 들어, 사용자의 나이가 성인 기준을 만족하는지를 확인하는 코드는 다음과 같습니다.
int age = 20;
if (age &gt;= 18) {
    System.out.println("성인입니다.");
}


  이 코드에서 ‘age &gt;= 18’ 이라는 조건이 참이면 “성인입니다.” 라는 메시지를 출력합니다.


1.3 ‘else’와 ‘else if’ 확장
‘if’ 문은 종종 ‘else’ 와 ‘else if’ 와 함께 사용되어 보다 복잡한 조건 로직을 구현할 수 있습니다.
if (조건1) {
    // 조건1이 참일 때 실행될 코드
} else if (조건2) {
    // 조건1이 거짓이고 조건2가 참일 때 실행될 코드
} else {
    // 위의 모든 조건이 거짓일 때 실행될 코드
}


예를 들어, 점수에 따라 학점을 출력하는 코드는 다음과 같습니다.

int score = 85;
if (score &gt;= 90) {
    System.out.println("학점 A");
} else if (score &gt;= 80) {
    System.out.println("학점 B");
} else if (score &gt;= 70) {
    System.out.println("학점 C");
} else {
    System.out.println("학점 D");
}



  이 예제에서 ‘score’ 변수의 값에 따른 다른 학점을 출력합니다.
    
      ‘if’, ‘else if’, ‘else’ 구문은 점수 범위에 따라 조건적으로 실행되며, 가장 먼저 만족하는 조건의 블록만 실행됩니다.
    
  


📝 정리.
‘if’ 문은 프로그래밍에서 결정을 내리는 데 필수적인 구조이며, 다양한 조건에 따라 코드의 실행 흐름을 제어하는 데 사용됩니다.



2. switch문.
자바 프로그래밍에서 ‘switch’ 문은 다수의 조건 중 하나를 선택해 실행할 때 사용하는 조건문입니다.
이는 ‘if-else’ 조건문의 대안으로, 변수의 값에 따라 여러 실행 경로 중 하나를 선택할 수 있도록 해줍니다.
‘switch’ 문은 특히 특정 변수가 취할 수 있는 명확한 값들을 기반으로 다양한 케이스를 처리할 때 유용하게 사용됩니다.

2.1 switch문의 기본 구조.
‘switch’ 문의 기본 구조는 다음과 같습니다.
switch (표현식) {
    case 값1:
        // 표현식 결과가 값1과 일치할 때 실행할 코드
        break;
    case 값2:
        // 표현식 결과가 값2와 일치할 때 실행할 코드
        break;
    // 추가적인 case들을 더 정의할 수 있습니다.
    default:
        // 어떤 case도 일치하지 않을 때 실행할 코드
}


2.2 switch 문의 주요 특징.

  1. 표현식 은 주로 정수, 문자형 또는 열거형(enum) 데이터를 사용합니다. 자바 7 이상에서는 문자열(String)도 지원합니다.
  2. case 라벨은 ‘switch’ 문 내에서 표현식의 결과와 일치하는 값을 가지며, 해당 값에 대한 실행 코드를 포함합니다.
  3. break 문은 ‘switch’ 문을 종료하고 다음 코드로 넘어가도록 합니다. ‘break’ 가 없으면 다음 ‘case’ 로 계속 진행되어 “fall-through” 현상이 발생합니다.
  4. default 섹션은 선택적으로 사용되며, 어떤 ‘case’ 도 일치하지 않을 때 실행됩니다.


2.3 switch 문 예시.
학생의 점수에 따라 학점을 부여하는 간단한 예를 들어보겠습니다.
int score = 92;
String grade;

switch (score / 10) {
    case 10:
    case 9:
        grade = "A";
        break;
    case 8:
        grade = "B";
        break;
    case 7:
        grade = "C";
        break;
    case 6:
        grade = "D";
        break;
    default:
        greade = F;
}

System.out.println("학점: " + grade);



  이 코드에서 ‘score / 10’ 의 결과값에 따라 다른 ‘case’ 블록이 실행됩니다.
  ‘92/10’ 은 ‘9’ 이므로, ‘grade’ 는 “A” 가 됩니다.
  각 ‘case’ 는 ‘break’ 문으로 종료되므로, 해당 ‘case’ 실행 후, ‘switch’ 문을 벗어납니다.


📝 정리.
‘switch’ 문은 코드의 가독성을 높이고, 많은 조건 분기를 간결하게 처리할 수 있는 방법을 제공합니다.
이는 특히 각 조건이 명확할 때 더욱 유용하며, 코드의 구조를 명확하게 표현할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-05-VariousOperator-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-05-VariousOperator-2.html"><h1 class="title_post">☕️[Java] 여러가지 연산자(2)</h1></a>
                        <a href="/Backend/Java/2024-05-05-VariousOperator-2.html" class="txt_post">
                            1️⃣ 비트 연산자에 대한 이해

1. 2진법.
자바 프로그래밍에서의 이진법은 컴퓨터의 지본 숫자 시스템을 참조하는 것입니다.
컴퓨터는 데이터를 0과 1의 형태, 즉 이진수로 처리합니다.
자바에서도 이러한 이진법을 사용하여 데이터를 저장, 처리하며 다양한 연산을 수행할 수 있습니다.

1.1 자바에서 2진법을 사용하는 예.

  1. 이진 리터럴 : 자바 7 이상부터는 정수를 이진 리터럴로 직접 표현할 수 있습니다.
    
      예를 들어, ‘int x = 0b1010;’ 은 이진수 ‘1010’ 이고, 십진수로 10입니다.
    
  
  2. 비트 연산자 : 자바는 비트 연산을 수행할 수 있는 여러 연산자를 제공합니다.
    
      예를 들어, 다음과 같습니다.
        
          '&amp;' (AND 연산자)
          '|' (OR 연산자)
          '^' (XOR 연산자)
          '~' (NOT 연산자)
          '&lt;&lt;' (왼쪽 시프트)
          '&gt;&gt;' (오른쪽 시프트)
          '&gt;&gt;&gt;' (부호 없는 오른쪽 시프트)
            
              이들 연산자는 주로 효율적인 수치 계산, 저수준 프로그래밍, 암호와 작업 등에 사용됩니다.
            
          
        
      
    
  
  3. 이진 데이터 조작 : 파일이나 네트워크를 통해 바이트 단위로 데이터를 읽고 쓸 때, 이진 형식으로 데이터를 처리합니다.
    
      자바에서는 'byte' 자료형을 이용하여 이진 데이터를 직접 다룰 수 있습니다.
    
  


📝 정리
이진법을 사용하는 주된 이유는 컴퓨터 하드웨어가 전기 신호로 작동하기 때문에 0과 1, 즉 이진 상태를 나타내는 전기의 켜짐과 꺼짐 상태로 모든 데이터를 표현하기 편리하기 때문입니다.
이렇게 함으로써, 프로그래밍에서 더욱 직접적이고 효율적인 하드웨어 조작이 가능해집니다.



2. 2의 보수.
자바 프로그래밍에서의 2의 보수(2’s complement)는 음수를 표현하기 위한 방법입니다.
컴퓨터 시스템은 보통 이진법을 사용하여 데이터를 저장하고 처리하는데, 이진법에서 음수를 표현하기 위해 가장 널리 사용되는 방법이 2의 보수입니다.

2.1 2의 보수 생성 과정.

  1. 원래 숫자의 이진 표현을 얻습니다.
    
      예를 들어, 5의 이진 표현은 ‘0101’ 입니다.
    
  
  2. 이진 표현의 모든 비트를 반전시킵니다.
    
      즉, 0은 1로, 1은 0으로 변경합니다.
      5의 경우 ‘0101’ 이 ‘1010’ 이 됩니다.
    
  
  3. 반전된 값에 1을 더합니다.
    
      이렇게 하면 ‘1011’ 이됩니다.
    
  


이렇게 생성된 ‘1011’ 은 -5를 나타냅니다.
이 방법은 자바를 포함한 대부분의 프로그래밍 언어와 컴퓨터 시스템에서 음수를 표현하는 표준 방법입니다.

2.2 2의 보수의 장점.

  덧셈 연산만으로 뺄셈을 할 수 있습니다.
    
      예를 들어, 5-5를 계산하려면 5와 -5의 2의 보수를 더하면 됩니다.
        
          이진법으로는 ‘1010 + 1011 = 10000’ 이고, 최상위 비트(캐리 비트)는 무시합니다.
            
              따라서 결과는 ‘0000’ 이 됩니다.
            
          
        
      
    
  
  오버플로 처리가 간단합니다.
    
      캐리 비트는 무시하면서 자연스럽게 오버플로를 처리할 수 있습니다.
    
  


2.3 자바에서의 활용.
자바에서는 정수형 타입(‘int’, ‘long’, ‘short’, ‘byte’) 이 이진법으로 2의 보수 형태로 저장되고 처리됩니다.
이는 자바의 모든 정수 연산에 내장된 메커니즘입니다.
예를 들어, 자바에서 ‘-5’ 를 선언하면 내부적으로는 ‘5’ 의 2의 보수인 ‘111…11011’ (32비트 시스템에서의 표현)으로 저장됩니다.

📝 정리
2의 보수 방식은 음수를 다루기 위한 효과적인 방법이며, 프로그래머가 별도의 조치를 취하지 않아도 시스템이 자동으로 처리해 주기 때문에 매우 편리합니다.



3. 비트 논리연산자.
자바 프로그래밍에서 비트 논리연산자는 비트 단위로 논리 연산을 수행하는 연산자입니다.
이들 연산자는 주로 정수 타입의 변수에 사용되며, 각 비트를 독립적으로 비교하여 결과를 반환합니다.
비트 논리연산자는 주로 저수준 프로그래밍, 효율적인 데이터 처리, 상태 플래그 관리, 암호화 등의 작업에 활용됩니다.

자바에서 사용되는 주요 비트 논리 연산자는 다음과 같습니다.


  1. AND 연산자(‘&amp;’) : 두 피연산자의 비트가 모두 1일 경우에만 결과의 해당 비트를 1로 설정합니다.
    
      예를 들어, ‘5 &amp; 3’ 은 이진수로 ‘0101 &amp; 0011’ 을 계산하여 ‘0001’ 이 되므로, 결과는 ‘1’ 입니다.
    
  
  
    
      
        
          **2. OR 연산자(‘
          ’) :** 두 피연산자 중 하나라도 비트가 1이면 결과의 해당 비트를 1로 설정합니다.
        
      
    
    
      
        
          
            
              예를 들어, **‘5
              3’** 은 이진수로 **‘0101
              0011’** 을 계산하여 ‘0111’ 이 되므로, 결과는 ‘7’ 입니다.
            
          
        
      
    
  
  3. XOR 연산자(‘^’) : 두 피연산자의 비트가 서로 다를 경우 결과의 해당 비트를 1로 설정합니다.
    
      예를 들어, ‘5 ^ 3’ 은 이진수로 ‘0101 ^ 0011’ 을 계산하여 ‘0110’ 이 되므로, 결과는 ‘6’ 입니다.
    
  
  4. NOT 연산자(‘~’) : 피연산자의 모든 비트를 반전시킵니다.(1은 0으로, 0은 1로).
    
      예를 들어, ‘~5’ 는 이진수로 ‘~0101’ 을 계산하여 ‘…1010’(무한히 많은 1 다음에 1010)이 되고, 이는 보통 32비트 시스템에서 ‘-6’ 으로 해석됩니다.
    
  
  5. 왼쪽 시프트(‘«’) : 모든 비트를 왼쪽으로 지정된 수만틈 이동시키고, 오른쪽은 0으로 채웁니다.
    
      예를 들어.‘3 « 2’ 는 ‘0011’ 을 왼쪽으로 2비트 이동하여 ‘1100’ 이 되므로, 결과는 ‘12’ 입니다.
    
  
  6. 오른쪽 시프트(‘»’) : 모든 비트를 오른쪽으로 지정된 수만큼 이동시키고, 왼쪽은 최상위 비트(부호 비트)의 값으로 채웁니다.
    
      예를 들어, ‘-8 » 2’ 는 ‘11111000’ 을 오른쪽으로 2비트 이동하여 ‘11111110’ 이 되므로, 결과는 ‘-2’ 입니다.
    
  
  7. 부호 없는 오른쪽 시프트(‘»&gt;’) : 모든 비트를 오른쪽으로 지정된 수만큼 이동시키고, 왼쪽은 0으로 채웁니다. 이는 부호 비트를 무시하고, 순수하게 비트를 오른쪽으로 이동시키기 때문에 음수에 사용했을 때 결과가 달라집니다.


📝 정리

이러한 비트 논리 연산자들은 데이터의 특정 비트를 직접 조작할 필요가 있는 경우에 유용하며, 자바 프로그래밍에서 중요한 도구입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-05-VariousOperators-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-05-VariousOperators-1.html"><h1 class="title_post">☕️[Java] 여러가지 연산자(1)</h1></a>
                        <a href="/Backend/Java/2024-05-05-VariousOperators-1.html" class="txt_post">
                            1️⃣ 각각의 연산자에 대한 이해

1. 항과 연산자.

1.1 단항 연산자(Unary Operator).
자바 프로그래밍에서 단항 연산자(Unary Operator)는 오직 한 개의 피연산자(operand)를 가지고 연산을 수행하는 연산자를 말합니다.

이들은 변수나 값에 직접 적용되며, 표현식의 결과를 반환합니다.

단항 연산자는 특히 간단한 수학 연산, 값의 부정, 또는 값의 증감 등에서 유용하게 사용됩니다.

1.2 자바에서 사용되는 주요 단항 연산자.

  1. 부정 연산자('!')
    
      불리언 값을 반전시킵니다.
        
          예를 들어, '!true' 는 'false' 가 됩니다.
        
      
    
  
  2. 단항 플러스 및 마이너스 연산자('+', '-')
    
      '+' 는 일반적으로 숫자의 부호를 그대로 두지만, 명시적으로 사용할 수 있습니다.
      '-' 는 숫자의 부호를 반전시킵니다.
        
          예를 들어, '-5' 는 양수 '5' 를 음수로 변환합니다.
        
      
    
  
  3. 증가 및 감소 연산자('++', '--')
    
      '++' 연산자는 변수의 값을 1만큼 증가시킵니다.
      '--' 연산자는 변수의 값을 1만틈 감소시킵니다.
      이 연산자들은 전위(prefix) 형태(예: '++x')와 후위(postfix) 형태(예: 'x++')로 사용될 수 있습니다.
        
          전위 형태는 변수를 증가시키고 표현식의 값을 반환하기 전에 증가된 값을 사용하고, 후위 형태는 표현식의 값을 반환한 후 변수를 증가시킵니다.
        
      
    
  
  4. 비트 반전 연산자('~')
    
      정수형 변수는 모든 비트를 반전시킵니다.
        
          예를 들어, '~00000000' 은 '11111111' 이 됩니다.
            
              이는 정수에 대해 비트 단위 NOT 연산을 수행합니다.
            
          
        
      
    
  


1.3 예제 사용.

public class UnaryDemo {
    public static void main(String[] args) {
        boolean a = false;
        System.out.println(!a); // true

        int num = 5;
        System.out.println(-num); // -5
        System.out.println(++num); // 6
        System.out.println(num++); // 6, 그리고 num이 7이 됨
        System.out.println(--num); // 6
        System.out.println(num--); // 6, 그리고 num이 5가 됨

        int b = 0b00000000; // 이진수로 0
        System.out.println(~b); // 모든 비트가 1로 반전
    }
}



  이 예제에서는 다양한 단항 연산자들의 사용 방법과 그 효과를 보여줍니다.
    
      단항 연산자들은 자바 프로그래밍에서 변수를 조작하거나 특정 연산을 더 간결하게 수행하는데 매우 유용합니다.
    
  




2.1 이항 연산자(Binary Operator)
자바 프로그래밍에서 이항 연산자(Binary Operator)는 두 개의 피연산자(operand)를 취해 연산을 수행하고 결과를 반환하는 연산자를 말합니다.

이항 연산자는 수학적 계산, 논리 비교, 값의 할당 등 다양한 작업에 사용됩니다.

2.2 자바에서 사용되는 주요 이항 연산자의 종류.

  1. 산술 연산자.
    
      ’+’ (덧셈)
      ’-‘ (뺄셈)
      ‘*‘ (곱셈)
      ’/’ (나눗셈)
      ’%’ (나머지)
    
  
  2. 비교 연산자.
    
      ’==’ (동등)
      ’!=’ (부등)
      ’&gt;’ (크다)
      ’&lt;’ (작다)
      ’&gt;=’ (크거나 같다)
      ’&lt;=’ (작거나 같다)
    
  
  3. 논리 연산자.
    
      ‘&amp;&amp;’ (논리적 AND)
      
        
          
            
              **’
               
              ‘** (논리적 OR)
            
          
        
      
    
  
  4. 비트 연산자
    
      ‘&amp;’ (비트 AND)
      
        
          
            
              **’
              ‘** (비트 OR)
            
          
        
      
      ’^’ (비트 XOR)
    
  
  5. 할당 연산자
    
      ’=’ (기본 할당)
      ’+=’, ‘-=’, ‘*=’, ‘/=’, ‘%=’ (복합 할당 연산자)
      
        
          
            
              **‘&amp;=’, ‘
              =’, ‘^=’, ‘«=’, ‘»=’, ‘»&gt;=’** (비트 복합 할당 연산자)
            
          
        
      
    
  
  6. 시프트 연산자
    
      ’«‘ (왼쪽 시프트)
      ’»‘ (오른쪽 시프트, 부호 유지)
      ’»&gt;’ (오른쪽 시프트, 부호 비트 없음)
    
  


2.3 예제 코드

public class BinaryOperatorsExample {
    public static void main(String[] args) {
        int a = 10, b = 5;
        int sum = a + b; // 15
        int difference = a - b; // 5
        boolean isEqual = (a == b); // false
        boolean isGreater = (a &gt; b); // true

        int bitAnd = a &amp; b; // 비트 AND 연산
        int shiftedLeft = a &lt;&lt; 2; // 왼쪽으로 2 비트 시프트

        System.out.println("Sum: " + sum);
        System.out.println("Difference: " + difference);
        System.out.println("Is Equal: " + isEqual);
        System.out.println("Is Greater: " + isGreater);
        System.out.println("Bitwise AND: " + bitAnd);
        System.out.println("Left Shifted: " + shiftedLeft);
    }
}


  이항 연산자들은 기본적인 산술 연산부터 복잡한 논리 연산에 이르기까지 프로그래밍에서 광범위하게 사용됩니다.
    
      이를 통해 효과적으로 데이터를 조작하고, 조건을 평가하며, 복잡한 문제를 해결할 수 있습니다.
    
  




3.1 삼항 연산자(Ternary Operator).
자바 프로그래밍에서 삼항 연산자(Ternary Operator), 또는 조건 연산자(Conditional Operator)라고 불리는 ’?:’ 는 세 개의 피연산자를 사용하는 유일한 연산자입니다.

이 연산자는 간결한 조건문을 구현할 때 사용되며, 간단한 조건식을 기반으로 두 가지 선택지 중 하나를 반환합니다.

3.2 삼항 연산자의 구조.

조건식 ? 값1 : 값2



  1. 조건식 : 이 부분은 ‘true’ 또는 ‘false’ 를 반환하는 불리언 식입니다.
  2. 값2 : 조건식이 ‘true’ 일 때 반환됩니다.
  3. 값3 : 조건식이 ‘false’ 일 때 반환됩니다.


조건식의 평가 결과에 따라 ‘값1’ 또는 값2 중 하나가 결과값으로 선택되어 반환됩니다.

이 연산자는 일반적으로 간단한 조건에 따라 변수에 값을 할당하거나 특정 표현식의 결과를 결정할 때 유용하게 사용됩니다.

3.3 예제 사용.

public class TernaryExample {
    public static void main(String[] args) {
        int a = 10, b = 5;
        int max = (a &gt; b) ? a : b; // a와 b 중 큰 값을 max에 할당.
        System.out.println("Max value: " + max);
        
        String response = (a &gt; b) ? "a is greater than b" : " b is greater or equal to a";
        System.out.println(response);
    }
}


  이 예제에서 삼항 연산자를 사용하여 두 숫자 중 더 큰 숫자를 결정하고, 문자열 메시지도 조건에 따라 선택합니다.
    
      이러한 사용은 코드를 더 간결하게 만들고, ‘if-else’ 구조를 보다 간단하게 대체할 수 있게 해 줍니다.
    
  
  삼항 연산자는 그 효율성과 간결함 때문에 자바 프로그래밍에서 자주 사용되는 유용한 도구입니다.
    
      그러나 복잡한 로직이나 여러 조건이 연속적으로 필요한 경우에는 가독성을 위해 전통적인 ‘if-else’ 문을 사용하는 것이 더 나을 수 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html"><h1 class="title_post">☕️[Java] 변수와 자료형(4)</h1></a>
                        <a href="/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html" class="txt_post">
                            변수와 자료형(4)

1️⃣ 자료형에 대한 이해

1. List
자바 프로그래밍에서 List 는 일련의 요소를 저장하는 데 사용되는 순차적인 컬렉션을 나타냅니다.
이는 자바의 java.util.List 인터페이스를 통해 제공되며, 이는 주문된 컬렉션을 관리하기 위한 다양한 메소드를 제공합니다.
List 는 중복된 요소를 포함할 수 있고, 각 요소는 리스트 내에서 특정 위치를 가집니다.
사용자는 이 위치를 인덱스로 사용하여 리스트의 요소에 접근할 수 있습니다.

List 인터페이스의 주요 특징은 다음과 같습니다.


  1. 순서 보장 : 리스트는 요소들이 추가된 순서를 유지하며, 각 요소는 특정 인덱스를 통해 접근할 수 있습니다.
  2. 요소의 중복 허용 : 같은 값을 가진 요소를 여러 개 포함할 수 있습니다.
  3. 동적 배열 : 리스트의 크기는 고정되어 있지 않고, 요소를 추가하거나 삭제함에 따라 동적으로 조절됩니다.


자바에서는 List 인터페이스를 구현하는 몇 가지 클래스가 있습니다.
가장 흔히 사용되는 구현체는 다음과 같습니다.


  'ArrayList' : 내부적으로 배열을 사용하여 요소를 저장합니다.
    
      요소의 추가와 인덱스를 통한 접근이 매우 빠르지만, 크기 조절이 필요할 때는 비용이 많이 들 수 있습니다.
    
  
  'LinkedList' : 각 요소가 다음 요소에 대한 참조와 함께 저장되는 연결 리스트를 사용합니다.
    
      요소의 추가와 삭제는 빠르지만, 인덱스를 통한 요소 접근은 시작부터 요소를 찾을 때까지 순차적으로 검색해야 하므로 시간이 더 걸립니다.
    
  
  'Vector' : 'ArrayList' 와 비슷하지만, 다중 스레드 환경에서 안전하게 사용할 수 있도록 동기화된 메소드를 제공합니다.


📝 정리.
'List' 는 자바 컬렉션 프레임워크의 일부이며, 데이터를 관리하고 처리하는 데 매우 유용합니다.
프로그래머는 이러한 컬렉션을 사용하여 데이터를 유연하게 조작할 수 있습니다.

1.2 List의 주요 메서드.
자바의 'List' 인터페이스에는 여러 가지 중요한 메서드들이 포함되어 있으며, 이를 통해 리스트 내의 요소들을 조작하고 접근할 수 있습니다.

다음은 'List' 인터체이스에서 제공하는 몇 가지 주요 메서드들입니다.


  'add(E e)': 리스트의 끝에 요소를 추가합니다.
  'add(int index, E element)': 지정된 위치에 요소를 삽입합니다.
  'addAll(Collection&lt;? extends E&gt; c)': 지정된 컬렉션의 모든 요소를 리스트의 끝에 추가합니다.
  'addAll(int index, Collection&lt;? extends E&gt; c)': 지정된 위치부터 컬렉션의 모든 요소를 리스트에 추가합니다.
  'clear()': 리스트에서 모든 요소를 제거합니다.
  'contains(Object o)': 리스트가 특정 요소를 포함하고 있는지 확인합니다.
  'get(int index)': 지정된 위치의 요소를 반환합니다.
  'indexOf(Object o)': 주어진 요소의 첫 번째 인덱스를 반환합니다. 요소가 리스트에 없는 경우 -1을 반환합니다.
  'lastIndexOf(Object o)': 주어진 요소의 마지막 인덱스를 반환합니다. 요소가 리스트에 없는 경우 -1을 반환합니다.
  'isEmpty()': 리스트가 비어 있는지 확인합니다.
  'iterator()': 리스트의 요소에 대한 반복자를 반환합니다.
  'listIterator()': 리스트의 요소를 리스트 순서대로 반복하는 리스트 반복자를 반환합니다.
  'remove(Object o)': 주어진 요소를 리스트에서 처음 발견되는 위치에서 제거하고, 그 결과를 반환합니다.
  'remove(int index)': 지정된 위치에 있는 요소를 리스트에서 제거하고, 그 요소를 반환합니다.
  'replaceAll(UnaryOperator&lt;E&gt; operator)': 주어진 연산자를 사용하여 리스트의 모든 요소를 대체합니다.
  'size()': 리스트에 있는 요소의 수를 반환합니다.
  'sort(Comparator&lt;? super E&gt; c)': 주어진 비교자를 사용하여 리스트를 정렬합니다.
  'subList(int fromIndex, int toIndex)': 지정된 범위의 부분 리스트를 반환합니다.
  'toArray()': 리스트 요소를 배열로 반환합니다.


📝 정리.
이 메서드들을 통해 리스트를 생성, 조회, 수정 및 관리하는 다양한 작업을 수행할 수 있습니다.
List 인터페이스를 사용함으로써 데이터를 효율적으로 처리하고 구조화할 수 있습니다.



2. Map
자바 프로그래밍에서 'Map' 은 키(key)와 값(value)의 쌍을 저장하는 객체입니다.
이는 키를 기반으로 빠르게 값을 검색할 수 있게 해주는 데이터 구조로, 각 키는 고유해야 합니다.(즉, 중복된 키를 가질 수 없습니다.)
'Map' 은 'java.util.Map' 인터페이스를 통해 정의되며, ‘HashMap‘, ‘TreeMap‘, ‘LinkedHashMap‘ 등 다양한 구현체를 가집니다.

자바의 ‘Map‘ 인터페이스는 키-값 쌍으로 데이터를 저장하고 관리하는 데 중점을 두는 데이터 구조로서, 특히 다음과 같은 주요 특징을 가지고 있습니다.


  1. 키에 의한 값 접근 : ‘Map‘ 은 각 값에 고유한 키를 할당하며, 이 키를 사용하여 빠르게 해당 값을 검색할 수 있습니다.
    
      이는 데이터베이스의 인덱스와 유사한 방식으로 작동합니다.
    
  
  2. 키의 유일성 : 맵 내에서 모든 키는 고유해야 합니다.
    
      즉, 같은 키가 두 번 이상 존재할 수 없으며, 새로운 키-값 쌍을 추가할 때 이미 존재하는 키를 사용하면 기존의 값이 새 값으로 대체됩니다.
    
  
  3. 값의 중복 허용 : 키는 유일해야 하지만 값은 중복될 수 있습니다.
    
      다른 키가 동일한 값을 가리킬 수 있습니다.
    
  
  4. 순서의 유무 : 일반적인 ‘Map‘ 구현체들은 키-값 쌍의 순서를 보장하지 않습니다.
    
      그러나 ‘LinkedHashMap‘ 과 같은 일부 구현체는 요소가 추가된 순서대로 반복할 수 있는 기능을 제공합니다.
      ‘TreeMap‘ 은 키에 따라 정렬된 순서를 유지합니다.
    
  
  5. 비동기화 및 동기화 : 기본적으로 대부분의 ‘Map‘ 구현체는 동기화되지 않습니다.(‘HashMap‘). 이는 멀티 스레드 환경에서 동시 수정이 발생할 경우 안전하지 않을 수 있음을 의미합니다.
    
      반면에 ‘Hashtable‘ 과 같은 구현체는 기본적으로 동기화가 되어 있어 멀티 스레드 환경에서 안전합니다.
      또한, ‘Collections.synchronizeMap‘ 메소드를 사용하여 맵을 동기화된 맵으로 변환할 수 있습니다.
    
  
  6. Null 허용 : 대부분의 ‘Map‘ 구현체는 키와 값으로 ‘null‘ 을 허용합니다.(‘HashMap‘, ‘LinkeHashMap‘).
    
      하지만 ‘Hashtable‘ 은 ‘null‘ 키나 값을 허용하지 않으며, ‘TreeMap‘ 은 자연 정렬 또는 ‘Comparator‘ 가 ‘null‘ 을 처리할 수 있는 경우에만 ‘null‘ 키를 허용합니다.
    
  


📝 정리.
이러한 특징들로 인해 ‘Map‘ 은 다양한 애플리케이션에서 유연하고 효율적인 데이터 관리를 가능하게 합니다.
데이터를 쉽게 추가, 검색, 삭제할 수 있어 데이터 관리의 복잡성을 줄이고 성능을 최적화하는 데 기여합니다.



3. Generics.
자바 프로그래밍에서 제네릭스(Generics)는 클래스나 메소드에서 사용될 데이터 타입을 추상화하여 코드 작성 시점에는 구체적인 타입을 명시하지 않고, 객체 생성이나 메소드 호출 시점에 실제 사용할 타입을 지정할 수 있도록 하는 프로그래밍 기법입니다.

제네릭스(Generics)는 코드의 재사용성을 높이고, 타입 안정성을 강화하며, 캐스팅에 대한 오류 가능성을 줄이는 데 도움을 줍니다.

3.1 제네릭스(Generics)의 주요 특징.

  
    1. 타입 안전성(Type Safety) : 제네릭스를 사용하면 컴파일 시점에 타입 체크가 가능하여, 실행 시점에서 발생할 수 있는 'ClassCastException' 과 같은 오류를 사전에 방지할 수 있습니다.
  
  2. 재사용성(Reusability) : 하나의 코드를 다양한 타입에 대해 재사용할 수 있습니다.
    
      예를 들어, 제네릭 클래스나 메소드를 정의하면, 다양한 타입의 객체를 저장하거나 처리하는 로직을 단 한번만 작성하여 여러 타입에 걸쳐 사용할 수 있습니다.
    
  
  3. 코드 간결성(Code Clarity) : 캐스팅을 줄여 코드가 더욱 간결하고 읽기 쉬워집니다.


3.2 제네릭스의 기본 문법.

  클래스 선언 : 클래스 이름 뒤에 '&lt;T&gt;' 를 추가하여 제네릭 클래스를 선언합니다.
    
      ‘T’ 는 타입 파라미터를 나타내며, 이는 클래스 내에서 사용될 데이터 타입을 대체하는 플레이스홀더 역할을 합니다.
    
  


public class Box&lt;T&gt; {
    private T t; // T 타입의 객체를 위한 변수
    
    public void set(T t) {
        this.t = t;
    }
    
    public T get() {
        return t;
    }
}



  메소드 선언 : 메소드 반환 타입 앞에 ’&lt;T&gt;‘ 를 추가하여 제네릭 메소드를 선언합니다.


public &lt;T&gt; T genericMethod(T t) {
    return t;
}



  제네릭 타입 제한(Bounded Type Parameters) : 특정 클래스의 하위 클래스만 타입 파라미터로 받도록 제한할 수 있습니다.
    
      이는 'extends' 키워드를 사용하여 지정합니다.
    
  


public class Box&lt;T extends Number&gt; {
    private T t;
    
    public void set(T t) {
        this.t = t;
    }
    
    public T get() {
        return t;
    }
}


📝 정리.
제네릭스(Generics)를 사용함으로써 개발자는 보다 타입-안전하고 유지보수가 용이한 코드를 작성할 수 있으며, 실행 시 타입 관련 문제를 효과적으로 줄일 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-04-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-04-TIL.html"><h1 class="title_post">📝 [TIL] 240504 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-04-TIL.html" class="txt_post">
                            
  자바 - 변수와 자료형(4)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-03-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-03-TIL.html"><h1 class="title_post">📝 [TIL] 240503 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-03-TIL.html" class="txt_post">
                            
  자바 - 변수와 자료형(2)
  자바 - 타입 비교
  자바 - 변수와 자료형(3)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html"><h1 class="title_post">☕️[Java] 변수와 자료형(3)</h1></a>
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html" class="txt_post">
                            변수와 자료형(3).

1️⃣ 자료형에 대한 이해.

1. String.
String 클래스는 불변(immutable)의 문자열을 다룹니다.

  이는 한 번 생성된 String 객체의 내용이 변경될 수 없다는 것을 의미합니다.
  문자열을 변경하려고 할 때마다 실제로 새로운 String 객체가 생성되고, 기존 객체는 변경되지 않습니다.


1.1 String의 주요 메소드.

  charAt(int index) : 지정된 위치의 문자를 반환합니다.
  concat(String str) : 현재 문자열의 끝에 지정된 문자열을 붙여 새로운 문자열을 반환합니다.
  contains(CharSequence s) : 특정 문자열이 포함되어 있는지 확인합니다.
  startsWith(String prefix) : 문자열이 특정 문자열로 시작하는지 확인합니다.
  endsWith(String suffix) : 문자열이 특정 문자열로 끝나는지 확인합니다.
  equals(Object anObject) : 문자열이 주어진 객체와 동일한지 비교합니다.
  indexOf(int ch), indexOf(String str) : 주어진 문자 또는 문자열의 위치를 찾습니다.
  length() : 문자열의 길이를 반환합니다.
  replace(char oldChar, char newChar) : 문자열 중 일부 문자를 다른 문자로 대체합니다.
  substring(int beginIndex, int endIndex) : 문자열의 부분을 추출합니다.
  toLowerCase(), toUpperCase() : 문자열을 소문자 또는 대문자로 변환합니다.
  trim() : 문자열의 앞뒤 공백을 제거합니다.


2. StringBuffer.
StringBuffer 클래스는 가변(mutable)의 문자열을 다루며, 문자열 변경 작업이 빈번할 때 사용하면 효율적입니다.

  StringBuffer 객체는 내용을 직접 변경할 수 있어, 새로운 객체를 계속 생성하지 않아도 됩니다.


2.1 StringBuffer의 주요 메소드.

  append(String str): 문자열의 끝에 주어진 문자열을 추가합니다.
  delete(int start, int end): 문자열의 시작 인덱스부터 종료 인덱스 전까지의 부분을 삭제합니다.
  deleteCharAt(int index): 지정된 위치의 문자를 삭제합니다.
  insert(int offset, String str): 지정된 위치에 문자열을 삽입합니다.
  replace(int start, int end, String str): 시작 인덱스부터 종료 인덱스 전까지의 문자열을 새로운 문자열로 대체합니다.
  reverse(): 문자열의 순서를 뒤집습니다.
  length(): 문자열의 길이를 반환합니다.
  capacity(): 현재 버퍼의 크기를 반환합니다.
  setCharAt(int index, char ch): 지정된 위치의 문자를 다른 문자로 설정합니다.


📝 정리.
StringBuffer 는 스레드에 안전(thread-safe)합니다, 즉 멀티스레드 환경에서 동시에 접근해도 안전하게 사용할 수 있습니다.

  이는 내부적으로 메소드들이 동기화되어 있기 때문입니다.


반면, StringBuilder 는 StringBuffer 와 유사하지만 멀티스레드 환경에서의 동기화 자원이 없어 단일 스레드에서 더 빠르게 작동합니다.

이처럼 String 과 StringBuffer 는 각각의 특성에 맞게 선택하여 사용할 수 있으며, 성능과 사용상황에 따라 적절히 활용하면 됩니다.



3. Array.
자바 프로그래밍에서 배열(Array)은 동일한 타입의 여러 데이터를 연속적인 메모리 위치에 저장하기 위한 자료구조입니다.
배열은 고정된 크기를 가지며, 배열의 각 요소는 같은 데이터 타입을 가집니다.
배열을 사용하면 여러 데이터를 하나의 변수 이름으로 관리할 수 있어 코드를 간결하게 작성할 수 있습니다.

3.1 배열의 특징.

  고정된 크기 : 배열은 생성 시 지정된 크기를 변경할 수 없습니다.
    
      배열의 크기는 프로그램 실행 도중에 변경할 수 없으며, 더 많은 데이터를 저장해야 할 경우 새로운 배열을 생성하고 데이터를 복사해야 합니다.
    
  
  인덱스 접근 : 배열의 각 요소는 인덱스를 통해 접근할 수 있습니다.
    
      인덱스는 0부터 시작하여 배열의 크기 -1까지 번호가 할당됩니다.
    
  
  동일 타입 : 모든 배열 요소는 동일한 데이터 타입을 가져야 합니다.
    
      예를 들어, int 타입의 배열은 int 타입의 값만을 요소로 가질 수 있습니다.
    
  


3.2 배열의 선언과 초기화.
배열을 선언하고 사용하기 위해서는 다음 단계를 따라야 합니다.


  1. 배열 선언 : 데이터 타입 뒤에 대괄호 [] 를 사용하여 배열을 선언합니다.


int[] myArray;
String[] stringArray;



  2. 배열 생성 : new 키워드를 사용하여 배열을 생성하고, 배열의 크기를 지정합니다.


myArray = new int[10]; // 10개의 정수를 저장할 수 있는 배열
stringArray = new String[5]; // 5개의 문자열을 저장할 수 있는 배열



  3. 배열 초기화 : 배열의 각 요소에 값을 할당합니다.
    
      인덱스를 사용하여 접근할 수 있습니다.
    
  


myArray[0] = 50;
myArray[1] = 100;
stringArray[0] = "Hello";
stringArray[1] = "World";


3.3 배열 사용 예.
다음은 자바에서 int 배열을 선언, 생성, 초기화하는 예제 코드입니다.

public class ArrayExample {
    public static void main(Stringp[] args) {
        // 배열 선언과 동시에 생성
        int[] numbers = new int[3];
        
        // 배열 초기화
        numbers[0] = 7;
        numbers[1] = 20;
        numbers[2] = 33;
        
        // 배열 사용
        System.out.println("첫 번째 숫자: " + numbers[0]);
        System.out.println("두 번째 숫자: " + numbers[1]);
        System.out.println("세 번째 숫자: " + numbers[2]);
    }
}

📝 정리
이 예제에서는 numbers 라는 이름의 int 배열을 생성하고, 세 개의 정수를 저장한 후 출력합니다.
배열을 사용하는 이점 중 하나는 이처럼 단일한 이름으로 여러 데이터를 효율적으로 관리할 수 있다는 것입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html"><h1 class="title_post">☕️[Java] 자바 - 변수와 자료형(2)</h1></a>
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html" class="txt_post">
                            ☕️ 자바 - 변수와 자료형(2)

1. 자료형에 대한 이해
자바 프로그래밍에서 사용되는 자료형은 크게 기본형(Primitive types) 과 참조형(Reference types) 두 가지로 나눌 수 있습니다.
각각의 자료형에 대해 설명드리겠습니다.

1️⃣ 기본형(Primitive types)
기본형 자료형은 실제 값을 저장하는 타입으로, 총 8가지가 있습니다.


  정수형
    
      byte : 8비트 정수형, 값의 범위는 -128에서 127까지.
      short : 16비트 정수형, 값의 범위는 -32,768에서 32,767까지.
      int : 32비트 정수형, 값의 범위는 약 -2.14억에서 2.14억까지.
      long : 64비트 정수형, 값의 범위는 약 -9.22경에서 9.22경까지
    
  
  실수형
    
      float : 32비트 부동 소수점 형. 부정확할 수 있으며, 대략 6~7 자리의 정밀도를 가짐.
      double : 64비트 부동 소수점 형. float보다 더 정밀하며, 대략 15자리의 정밀도를 가짐.
    
  
  문자형
    
      char : 단일 16비트 유니코드 문자를 저장.
    
  
  논리형
    
      boolean : true 또는 false 값만을 가짐.
    
  


2️⃣ 참조형(Reference types)
참조형 자료형은 객체의 참조(메모리 주소)를 저장합니다.
기본형과 달리 메모리의 특정 위치를 가리키는 포인터를 저장하므로, 객체의 크기에 관계없이 참조 변수 크기는 항상 일정합니다.
참조형의 예를 들면 다음과 같습니다.


  클래스(Class)
    
      예: String, Integer, File 등
    
  
  인터페이스(Interface)
    
      예: List, Map, Serializable 등
    
  
  배열(Array)
    
      예: int[], double[], String[] 등
    
  




1.1 인터페이스(Interface)?
자바에서 인터페이스(Interface)는 특정 클래스가 구현해야 할 메소드를 정의하는 “계약”의 역할을 합니다.
이는 클래스가 인터페이스에 정의된 모든 메소드를 반드시 구현하도록 강제합니다.
인터페이스는 메소드의 실제 구현을 포함하지 않고, 메소드의 시그니처(이름, 매개변수 리스트, 반환 유형)만을 정의합니다.
인터페이스를 사용하는 주된 목적은 다음과 같습니다.


  1. 추상화(Abstraction) : 인터페이스를 통해 구현의 세부 사항을 숨기고, 사용자에게 필요한 기능만을 제공할 수 있습니다.
    
      이렇게 함으로써 코드의 복잡성을 줄이고, 유지 관리가 쉬워집니다.
    
  
  2. 다형성(Polymorphism) : 다양한 클래스들이 동일한 인터페이스를 구현함으로써, 다양한 타입의 객체를 동일한 방식으로 처리할 수 있습니다.
    
      이는 코드의 유연성과 재사용성을 높입니다.
    
  
  3. 결합도 감소(Decoupling) : 인터페이스를 통해 서로 다른 코드 부분 간의 결합도를 낮추어, 각 부분을 독립적으로 개발하고 테스트할 수 있게 합니다.


👉 인터페이스 예시

  예를 들어, List 인터페이스는 add ,remove, get, size 등의 메소드를 정의하며, 이 인터페이스를 구현하는 ArrayList, LinkedList 등의 클래스는 이 메소드들을 실제로 구현해야 합니다.
    
      이를 통해 사용자는 구체적인 리스트의 구현 방법을 몰라도 이 인터페이스를 통해 리스트를 사용할 수 있습니다.
        
          이런 방식으로 인터페이스는 참조형 자료형 중 하나로서, 객체의 행동을 정의하고 다양한 구현을 가능하게 합니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-03-TypeComparison.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-03-TypeComparison.html"><h1 class="title_post">☕️[Java] 타입 비교.</h1></a>
                        <a href="/Backend/Java/2024-05-03-TypeComparison.html" class="txt_post">
                            타입 비교.
자바 프로그래밍에서 두 변수의 타입이 같은지 비교하는 방법은 몇 가지 상황에 따라 다릅니다.
여기서는 변수가 기본형(Primitive types) 인 경우와 참조형(Reference types) 인 경우로 나누어 설명하겠습니다.

1️⃣ 기본형 변수의 타입 비교.
기본형 변수의 경우, 자바는 정적 타입 언어이기 때문에 변수의 타입이 코드 작성 시 결정됩니다.
두 변수가 같은 기본형 타입인지 비교하는 일반적인 상황은 적으며, 주로 타입을 확인하거나 변환할 때 컴파일러가 자동으로 처리합니다.
그러나 명시적으로 확인하고 싶다면, 두 변수의 타입을 직접 코드에서 확인할 수 있습니다.
이는 일반적인 코딩 상황보다는 주로 제네릭 코드나 리플렉션을 사용할 때 발생합니다.

2️⃣ 참조형 변수의 타입 비교.
참조형 변수의 경우 타입 비교는 다음 두 가지 방법으로 이루어질 수 있습니다.

2.1 instanceof 연산자 사용.
instanceof 연산자는 특정 객체가 지정된 클래스의 인스턴스이거나 그 서브클래스의 인스턴스인지를 검사합니다.

  이 방법은 주로 객체의 타입을 확인할 때 사용됩니다.


Object a = "Hello";
Object b = new String("Hello");

if (a instanceof String &amp;&amp; b instanceof String) {
    System.out.println("두 객체는 같은 타입입니다.");
}


2.2 getClass() 메서드 사용.
객체의 정확한 클래스를 알고 싶을 때 getClass() 메서드를 사용할 수 있습니다.
이 메서드는 객체의 런타임 클래스를 리턴합니다.

  두 객체의 클래스가 정확히 같은지 비교할 때 유용합니다.


Object a = new Integer(5);
Object b = new Double(5.0);

if (a.getClass().equals(b.getClass())) {
    System.out.println("두 객체는 같은 클래스입니다.")
} else {
    System.out.println("두 객체는 다른 클래스입니다.")
}


📝 마무리.
이 방법들은 객체의 타입을 정확히 확인할 수 있으며, 특히 다형석을 활용하는 객체지향 프로그래밍에서 유용하게 사용됩니다.
또한, 테스트 코드나 동적 타입 처리가 필요한 상황에서 자주 사용됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-02-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-02-TIL.html"><h1 class="title_post">📝 [TIL] 240502 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-02-TIL.html" class="txt_post">
                            
  기초수학 - 소개(수학과 자바 프로그래밍, 자료구조, 알고리즘의 관계)
  코테 맛보기(1) - 코테를 위한 자바 프로그래밍 언어 사용 숙련도
  코테 맛보기(2) - 코테를 위한 자료구조와 알고리즘 개념 구현 방법 숙지
  자바 - 소개
  자바 - 변수와 자료형(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-05-02-Math.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-05-02-Math.html"><h1 class="title_post">[Math] 기초수학 - 소개</h1></a>
                        <a href="/Backend/Math/2024-05-02-Math.html" class="txt_post">
                            자바 프로그래밍, 수학, 자료구조 / 알고리즘

수학은 자바 프로그래밍과 자료구조 / 알고리즘 사이의 “중간 다리 역할”을 합니다.

자바 프로그래밍, 수학, 자료구조 그리고 알고리즘은 컴퓨터 과학과 소프트웨어 개발의 중요한 구성 요소들이며 서로 긴밀하게 연결되어 있습니다.

각각의 분야가 어떻게 상호작용하는지 살펴봅시다.

1. 수학과 프로그래밍.

🙋‍♂️ 수학과 자바 프로그래밍 사이의 상관관계는 매우 밀접하며, 효과적인 프로그래밍 기술과 문제 해결 능력을 개발하는 데 중요한 역할을 합니다. 수학은 프로그래밍의 논리적 사고, 구조적 접근, 그리고 복잡한 문제의 해결에 기초를 제공합니다.

  다음은 수학이 자바 프로그래밍과 어떻게 연결되는지에 대한 몇 가지 주요 포인트입니다.
    
      1. 논리적 사고와 알고리즘 개발 : 수학은 논리적이고 체계적인 사고를 필요로 합니다. 자바 프로그래밍에서도 마찬가지로, 문제를 분석하고 효과적인 알고리즘을 설계하는 데 이러한 사고방식이 요구됩니다.
        
          예를 들어, 조건문, 반복문, 함수 등의 기본적인 프로그래밍 구조는 수학적 조작과 비슷한 추론을 통해 최적화될 수 있습니다.
        
      
      2. 복잡도 분석 : 프로그램의 성능을 평가하고 최적화하기 위해 수학적인 복잡도 분석이 사용됩니다.
        
          빅 오 표기법 같은 수학적 도구는 알고리즘의 실행 시간과 필요한 메모리 곤간을 예측하는 데 도움을 줍니다.
            
              이는 효율적인 자바 프로그램을 작성하는 데 필수적인 요소입니다.
            
          
        
      
      3. 문제 해결 : 수학적 모델링과 이론은 자바 프로그래밍에서 복잡한 문제를 단순화하고 구조화하는데 사용됩니다.
        
          예를 들어, 경로 찾기, 스케줄링 문제, 최적화 문제 등을 해결할 때 수학적 기법이 프로그래밍 로직의 기반을 형성합니다.
        
      
      4. 데이터 구조 : 수학적 개념, 특히 집합론은 자바에서 사용되는 다양한 데이터 구조의 이해를 돕습니다.
        
          배열, 리스트, 스택, 큐, 트리, 그래프 등의 자료구조는 모두 수학적 원리에 기반을 두고 있으며, 이를 이해하고 활용하는 것은 효율적인 프로그래밍에 직결됩니다.
        
      
      5. 인공 지능과 머신 러닝 : 자바 프로그래밍에서 머신 러닝과 인공 지능 애플리케이션을 개발할 때, 선형대수학, 확률론, 통계학 등의 수학적 분야가 필수적입니다.
        
          이러한 수학적 지식은 데이터를 분석하고, 알고리즘을 구현하는 데 필요합니다.
        
      
      6. 암호화와 보안 : 암호화 알고리즘과 보안 기술의 개발에도 수학이 깊숙이 관련되어 있습니다.
        
          예를 들어, 공개 키 암호화 같은 기술은 수학적 난제에 기반을 두고 있으며, 이는 자바 보안 기능의 핵심 부분입니다.
        
      
    
  


👉 이처럼 수학은 자바 프로그래밍에서 논리적 구조, 효율성, 그리고 문제 해결 능력을 개발하는 데 필수적인 도구입니다.
👉 수학적 사고방식은 효과적인 소프트웨어 개발을 위한 기초적인 스킬로, 프로그래머가 보다 복잡한 문제에 접근하고 해결하는 데 큰 도움을 줍니다.

2. 수학과 자료구조.

🙋‍♂️ 수학과 자료구조 간의 상관관계는 컴퓨터 과학의 깊은 수학적 기반을 통해 잘 드러납니다.

  다음은 수학과 자료구조 간의 몇 가지 중요한 상호작용을 설명합니다.
    
      1. 이론적 기반 제공 : 수학은 자료구조를 이해하고 분석하는 데 필요한 이론적 지반을 제공합니다.
        
          예를 들어, 집합 이론은 자료구조 설계의 기본이 되며, 다양한 자료구조들이 데이터의 집합을 어떻게 조직화하고 관리하는지 이해하는 데 도움을 줍니다.
        
      
      2. 복잡도 분석 : 자료구조의 효율성을 평가하기 위해 수학적 도구가 필요합니다.
        
          빅 오 표기법(O notation)은 알고리즘과 자료구조의 시간 복잡도와 공간 복잡도를 표현하는 데 사용되며, 이는 수학적 함수로 표현됩니다.
            
              이를 통해 개발자들은 자료구조의 성능을 정량적으로 비교하고 분석할 수 있습니다.
            
          
        
      
      3. 그래프 이론 : 그래프 이론은 네트워크, 소셜 미디어, 경로 탐색 등 다양한 문제를 모델링하는 데 사용되는 자료구조인 그래프의 분석과 최적화에 사용됩니다.
        
          이는 컴퓨터 네트워크, 최단 경로 문제, 최소 스패닝 트리 등의 문제 해결에 필수적입니다.
        
      
      4. 논리와 증명 : 수학적 논리와 증명 기법은 자료구조의 올바른 작동을 보장하는 데 중요합니다.
        
          예를 들어, 자료구조릐 구현을 검증하거나, 특정 알고리즘이 주어진 자료구조에서 올바르게 작동함을 증명할 때 사용됩니다.
          또한, 재귀적 자료구조와 알고리의 증명에도 수학적 귀납법이 활용됩니다.
        
      
      5. 최적화 문제 : 다양한 자료구조는 종종 최적화 문제를 해결하는 데 사용됩니다.
        
          예를 들어, 트리 구조를 사용하여 데이터베이스 쿼리의 응답 시간을 최소화하거나, 해시 테이블을 사용하여 데이터 접근 시간을 최적화할 수 있습니다.
            
              이러한 최적화 문제는 수학적 모델링과 알고리즘을 통해 접근됩니다.
            
          
        
      
      6. 확률론과 통계 : 일부 자료구조는 확률론과 통계적 방법에 기반을 둔 설계가 필요합니다.
        
          예를 들어, 블룸 필터와 같은 확률적 자료구조는 데이터의 존재를 빠르게 검사하면서 오차를 허용하는 구조입니다.
            
              이러한 자료구조는 확률론적 모델을 사용하여 성능과 오차 확률을 예측합니다.
            
          
        
      
    
  


👉 이처럼 수학은 자료구조의 설계, 분석, 최적화 및 검증에 깊이 관여하여, 효율적인 소프트웨어 시스템과 알고리즘의 개발을 가능하게 합니다.
👉 수학적 사고는 컴퓨터 과학에서 중요한 문제 해결 도구로 활용되며, 이를 통해 보다 정교하고 효율적인 프로그래밍이 이루어집니다.

3. 수학과 알고리즘.

🙋‍♂️ 수학과 알고리즘 사이의 상관관계는 컴퓨터 과학에서 매우 깊고 중요합니다. 수학은 알고리즘의 기초를 제공하며, 효율적인 알고리즘 설계와 분석을 위해 필수적인 도구와 개념들을 제공합니다.

  다음은 수학이 알고리즘과 어떻게 연결되는지에 대한 몇 가지 주요 사례입니다.
    
      1. 알고리즘 분석 : 알고리즘의 효율성을 평가하기 위해 수학적 도구가 필수적입니다. 시간 복잡도와 공간 복잡도를 정량화하기 위해 빅 오 표기법(O-notation), 빅 세타 표기법(Θ-notation), 빅 오메가 표기법(Ω-notation)등이 사용됩니다.
        
          이러한 복잡도 분석은 알고리즘을 선택하고 최적화하는 데 중요한 기준을 제공합니다.
        
      
      2. 최적화 : 수학적 최적화 기법은 알고리즘에서 특정 목표(예: 최소 비용, 최대 이익, 최소 시간)를 달성하기 위해 사용됩니다.
        
          선형 프로그래밍, 정수 프로그래밍. 동적 프로그래밍 등의 방법이 알고리즘 설계에 자주 사용됩니다.
            
              이러한 방법들은 복잡한 문제를 더 효율적으로 해결할 수 있도록 도와줍니다.
            
          
        
      
      3. 그래프 이론 : 그래프 이론은 네트워크 경로, 소셜 네트워크, 웹 페이지 링크 구조와 같은 다양한 알고리즘 문제를 표현하고 해결하는 데 사용됩니다.
        
          최단 경로 찾기(다익스트라 알고리즘, 벨만-포드 알고리즘), 최소 신장 트리(프림 알고리즘, 크루스칼 알고리즘)와 같은 알고리즘은 모두 그래프 이론을 기반으로 합니다.
        
      
      4. 확률론과 통계 : 확률론은 불확실성 하에서 문제 해결과 의사 결정에 중요한 역할을 합니다.
        
          예를 들어, 랜덤화 알고리즘, 몬테 카를로 방법, 라스베가스 알고리즘과 같은 확률적 알고리즘은 이론적 분석과 함께 실제 응용에서도 중요합니다.
          또한, 기계 학습 알고리즘의 기초로서 확률 모델을 사용합니다.
        
      
      5. 논리학 : 수학적 논리는 알고리즘의 정확성을 증명하는 데 필요합니다.
        
          증명 기법, 예를 들어 귀납법과 수학적 귀납법은 알고리즘의 정확성을 보장하며, 특정 조건에서의 알고리즘의 동작을 증명하는 데 사용됩니다.
        
      
      6. 기하학과 알고리즘 : 기하학은 컴퓨터 그래픽, 로봇 공학, 컴퓨터 비전 들에서 중요한 알고리즘을 제공합니다.
        
          예를 즐어, 충돌 감지, 물체 인식, 경로 계획 등에 사용되는 계산 기하학은 복잡한 기하학적 구조를 효율적으로 계산하는 알고리즘을 개발하는 데 필요합니다.
        
      
    
  


👉 이와 같이, 수학은 알고리즘을 설계하고 분석하는 데 필수적인 도구이며, 효율적이고 신뢰할 수 있는 소프트웨어 시스템을 개발하는 데 중요한 역할을 합니다.
👉 수학적 사고는 알고리즘의 성능을 최적화하고 문제 해결과정을 체계화 하는 데 큰 도움이 됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html"><h1 class="title_post">☕️[Java] 자바 - 변수와 자료형(1)</h1></a>
                        <a href="/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html" class="txt_post">
                            변수와 자료형(1)

🙋‍♂️ 변수 이름 규칙
자바 프로그래밍에서 변수를 명명할 때 따라야 할 몇 가지 기본적인 규칙과 관례가 있습니다.
이러한 규칙을 준수하는 것은 코드의 가독성과 유지보수성을 높이는 데 중요합니다.
다음은 자바에서 변수 이름을 지정할 때 고려해야 할 주요 규칙들 입니다.

1️⃣ 기본 규칙.

  **문자와 숫자, (Underscore), $ 사용가능 :** 변수 이름은 문자(letter) 나 밑줄(, Underscore) 또는 $(달러 기호)로 시작할 수 있습니다.
    
      그러나 숫자로 시작할 수는 없습니다.
    
  
  숫자로 시작할 수 없다 : 첫 글자로는 숫자로 변수 이름을 시작할 수 없습니다.
    
      그러나 첫 글자 이후에는 숫자가 포함될 수 있습니다.
    
  
  대문자와 소문자를 구분함 : 변수 이름을 명명시, 대문자와 소문자를 구분합니다.
    
      예를 들어 int apple = 1;, int Apple = 2;, int APPLE = 3;은 모두 다른 변수로 취급됩니다.
    
  
  공백을 허용하지 않음 : 변수 이름을 명명시 공백이 들어가서는 않됩니다.
    
      예를 들어 int my friends = 7;과 같이 공백이 들어가서는 안됩니다.
    
  
  특수 문자 제한 : ‘_(underscore)’와 ‘$’를 제외한 특수 문자는 변수명으로 사용할 수 없습니다.
    
      예를 들어 ‘@’, ‘#’, ‘%’ 등은 변수 이름으로 사용할 수 없습니다.
    
  
  자바 예약어 사용 금지 : int, class, static 등 자바에서 이미 의미를 갖는 예약어는 변수 이름으로 사용할 수 없습니다.


2️⃣ 표기법 및 관례(컨벤션)

  카멜 케이스 : 첫 단어는 소문자로 시작하고, 이어지는 각 단어의 첫 글자는 대문자로 시작합니다.
    
      예를 들어, firstName, totalAmount 등 입니다.
    
  
  파스칼 케이스 : 각 문자의 첫 문자를 대문자로 표기합니다.
    
      예를 들어, MyFriends, ToTalCount 등 입니다.
    
  
  의미 있는 이름 : 변수 이름은 그 변수가 무엇을 의미하는지 명확하게 표현해야 합니다.
    
      예를 들어, numberOfStudents 는 학생 수를, temperature는 온도를 나타내는 등의 명확한 이름을 사용하는 것이 좋습니다.
    
  
  상수 이름 규칙 : 상수(변하지 않는 값)는 모두 대문자를 사용하며, 단어 사이는 밑줄(‘_‘)로 구분합니다.
    
      예를 들어 MAX_HEIGHT, TOTAL_COUNT 등 입니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-2.html"><h1 class="title_post">☕️[Java] 코테 맛보기(2) - 코테를 위한 자료구조와 알고리즘 개념 구현 방법 숙지</h1></a>
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-2.html" class="txt_post">
                            😋 코테 맛보기.

코딩 테스트를 준비하기 위해서 자료구조와 알고리즘은 매우 중요한 영역입니다.
이 분야들에 대한 깊이 있는 이해와 숙지는 테스트에서 성공적인 성과를 내는 데 결정적인 역할을 합니다.
다음은 코딩 테스트를 위해 필요한 자료구조와 알고리즘의 개념 및 구현 방법에 대한 가이드입니다.

1️⃣ 자료구조.

  기본 자료구조 : 배열, 스택, 큐, 링크드 리스트.
    
      이러한 자료구조들은 다양한 문제에서 데이터를 효율적으로 관리하는 기본적인 방법을 제공합니다.
    
  
  고급 자료구조 : 트리(특히 이진 검색 트리), 힙, 그래프, 해시 테이블, 집합 등
    
      이들은 보다 복잡한 데이터 관계를 다루는 데 사용되며, 특정 유형의 문제를 해결하는 데 특화되어 있습니다.
    
  
  응용 자료구조 : 트라이, 세그먼트 트리, 유니온 파인드, 비트마스크 등.
    
      이들은 특정 알고리즘 문제에 최적화된 솔루션을 제공합니다.
    
  


2️⃣ 알고리즘.

  정렬 알고리즘 : 버블 정렬, 삽입 정렬, 선택 정렬, 퀵 정렬, 병합 정렬 등.
    
      정렬은 많은 문제에서 데이터를 조작하는 기본적인 방법입니다.
    
  
  검색 알고리즘 : 선형 검색, 이진 검색 등
    
      데이터 내에서 특정 항목을 찾는 방법입니다.
    
  
  재귀 알고리즘과 백트래킹 : 문제를 더 작은 문제로 나누어 해결하는 기법입니다.
  동적 프로그래밍 : 복잡한 문제를 간단한 하위 문제로 나누어 해결하고, 그 결과를 저장하여 효율적으로 최종 결과를 도출합니다.
  그래프 알고리즘 : 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS), 최단 경로 문제(다익스트라, 플로이드-워셜), 최소 신장 트리(크루스칼, 프림) 등을 포함합니다.


3️⃣ 코테 준비 방법.

  이론 학습 : 자료구조와 알고리즘의 이론을 철저히 학습합니다.
    
      이론적인 이해는 효과적인 구현의 기초가 됩니다.
    
  
  실습 연습 : 이론을 바탕으로 다양한 문제를 실제로 코딩해 봄으로써 실력을 키웁니다.
    
      LeetCode, HackerRank, Codeforces, 백준, 프로그래머스 등의 플랫폼에서 문제를 풀어봅니다.
    
  
  알고리즘 패턴 학습 : 자주 출제되는 문제 유형과 그에 대한 표준적인 해결 방법을 익힙니다.
  시간 관리 연습 : 코딩 테스트에서는 제한된 시간 내에 문제를 해결해야 하므로, 시간 관리 능력을 향상시킬 필요가 있습니다.


📝 정리.
코테를 위한 준비 과정에서 이러한 자료구조와 알고리즘에 대한 이해와 숙련도는 문제를 정확하고 효율적으로 해결할 수 있는 능력을 직접적으로 높여 줍니다.
따라서, 이 분야에 대한 철저한 준비와 연습을 통해 자신감을 갖고 테스트에 임할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-1.html"><h1 class="title_post">☕️[Java] 코테 맛보기(1) - 코테를 위한 자바 프로그래밍 언어 사용 숙련도</h1></a>
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-1.html" class="txt_post">
                            😋 코테 맛보기.

코딩 테스트를 위해 자바 프로그래밍 언어를 사용하려면 몇 가지 중요한 요소에 숙력도를 갖추어야 합니다.
자바는 많은 기업들이 코딩 테스트에 사용하는 언어 중 하나이며, 효과적인 문제 해결을 위해 다음과 같은 능력을 개발하는 것이 중요합니다.
효과적인 문제 해결을 위해 다음과 같은 능력을 개발하는 것이 중요합니다.

1️⃣ 기본 문법 숙지.

  자바의 기본 문법과 프로그래밍 구조에 익숙해져야 합니다.
    
      변수, 데이터 타입, 연산자, 제어문(if, for, while 등), 메소드 호출 등 기본적인 구성 요소를 이해하고 사용할 수 있어야 합니다.
    
  


2️⃣ 객체 지향 프로그래밍(OOP)이해.

  자바는 객체 지향 프로그래밍 언어입니다.
    
      클래스, 객체, 상속, 다형성, 캡슐화 등의 객체 지향 개념을 이해하고 이를 문제 해결에 적절히 적용할 수 있어야 합니다.
      OOP 개념은 코드의 재사용성과 모듈성을 높여줘 효율적인 프로그래밍을 가능하게 합니다.
    
  


3️⃣ 표준 라이브러리 사용.

  자바의 표준 라이브러리에는 다양한 자료구조와 알고리즘이 구현되어 있습니다.
    
      java.util 패키지 내의 컬렉션 프레임워크(리스트, 맵, 셋 등)를 비롯해, 유용한 유틸리티 클래스들을 활용할 줄 알아야 합니다.
        
          이러한 라이브러리들은 코딩 테스트에서 효율적인 코드 작성을 돕습니다.
        
      
    
  


4️⃣ 알고리즘과 자료구조.

  다양한 알고리즘과 자료구조에 대한 이해가 중요합니다.
    
      정렬, 탐색, 그래프 이론, 동적 프로그래밍 등의 알고리즘과 배열, 스택, 큐, 링크드 리스트, 트리 등의 자료구조에 대한 깊은 이해가 필요합니다.
        
          이는 문제를 효과적으로 분석하고 최적의 해결책을 구현하는 데 결정적입니다.
        
      
    
  


5️⃣ 문제 해결 능력.

  실제 코딩 테스트에서는 다양한 유형의 문제가 제시됩니다.
    
      문제를 빠르게 이해하고 효과적인 해결책을 설계할 수 있는 능력이 필요합니다.
        
          이는 실전 연습을 통해 향상시킬 수 있으며, 온라인 코딩 플랫폼에서 다양한 문제를 풀어 보는 것이 좋습니다.
        
      
    
  


6️⃣ 테스트와 디버깅

  코드가 예상대로 동작하는지 검증하고, 오류를 찾아 수정할 수 있는 능력도 중요합니다.
    
      자바에서 제공하는 디버깅 도구를 사용하여 코드를 단계별로 실행하고, 변순의 상태를 확인하며 문제를 진단할 수 있어야 합니다.
    
  


📝 정리.
코딩 테스트를 위한 자바 숙련도는 이론적 지식과 실제 적용 능력의 조합을 요구합니다.
이를 위해 개념 학습과 함께 많은 실습을 병행하는 것이 중요합니다.
시간을 정해두고 실전처럼 문제를 풀어보는 연습을 꾸준히 하면, 효과적으로 자바를 활용하여 코딩 테스트에서 좋은 성과를 낼 수 있을 것입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-IntroJava.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-IntroJava.html"><h1 class="title_post">☕️[Java] 자바 - 소개</h1></a>
                        <a href="/Backend/Java/2024-05-02-IntroJava.html" class="txt_post">
                            자바 - 소개

🙋‍♂️ 1. 자바의 특징.
자바는 세계적으로 널리 사용되는 프로그래밍 언어로, 웹 개발, 모바일 애플리케이션, 대규모 시스템 구축 등 다양한 분야에 활용됩니다.
자바의 주요 특징들은 다음과 같습니다.

1️⃣ 플랫폼 독립성.

  “Write Once, Run Anywhere”(WORA) : 자바 프로그램은 자바 가상 머신(JVM) 위에서 실행되기 때문에, 한 번 작성하면 어떤 플랫폼에서도 실행할 수 있습니다.
    
      이는 자바 컴파일러가 소스 코드를 플랫폼 독립적인 바이트코드로 변환하기 때문입니다.
    
  


2️⃣ 객체 지향 프로그래밍(OOP).

  자바는 객체 지향 프로그래밍 언어로, 캡슐화, 상속, 다형성 등을 완전히 지원합니다.
    
      이는 코드 재사용, 유지 관리의 용이성 및 시스템 모듈화를 가능하게 합니다.
    
  


3️⃣ 강력한 표준 라이브러리.

  자바는 방대한 표준 라이브러리를 제공하여, 네트워킹, 파일 시스템 접근, 그래픽 인터페이스 제작 등 다양한 작업을 쉽게 처리할 수 있도록 돕습니다.


4️⃣ 메모리 관리.

  자동 가비지 컬렉션
    
      자바는 사용하지 않는 객체를 자동으로 감지하고 메모리에서 제거하는 가비지 컬렉터를 내장하고 있습니다. 이는 개발자가 메모리 누수에 대해 걱정할 필요가 적어지게 해줍니다.
    
  


5️⃣ 보안.

  자바는 샌드박스 환경에서 애플리케이션을 실행하여 시스템 리소스에 대한 무단 접근을 방지합니다.
    
      또한, 클래스 로더, 바이트코드 검증기 등을 통해 애플리케이션이 안전하게 실행될 수 있도록 합니다.
    
  


6️⃣ 멀티스레딩.

  자바는 내장된 멀티스레딩 기능을 지원하여, 여러 스레드가 동시에 실행되도록 하여 애플리케이션의 효율성을 높입니다.
    
      이는 특히 네트워크 서버와 실시간 시스템에서 큰 장점입니다.
    
  


7️⃣ 로버스트와 포터빌리티.

  자바 프로그램은 다른 플랫폼으로의 이동성이 뛰어나며, 높은 수준의 안정성을 제공합니다.
    
      예외 처리 기능을 통해 오류를 쉽게 관리하고, 시스템의 안정성을 높일 수 있습니다.
    
  


📝 마무리.
자바의 이러한 특징들은 그것을 매우 유연하고, 다양한 애플리케이션 개발에 적합하게 만듭니다.
이로 인해 자바는 세계적으로 인기 있는 프로그래밍 언어 중 하나로 자리 잡게 되었습니다.



🙋‍♂️ 2. 자바 프로그램의 작성과 실행과정.



1️⃣ 소스 코드 작성.

  개발자는 자바의 문법에 맞추어 .java 확장자 파일에 소스 코드를 작성합니다.
    
      이 파일에는 하나 이상의 클래스가 포함되며, 각 클래스는 데이터와 메서드를 정의합니다.
    
  


2️⃣ 컴파일.

  소스 코드 파일을 자바 컴파일러(javac)를 사용하여 컴파일합니다.
    
      컴파일러는 소스 코드를 읽고, 문법 오류를 검사한 후, 바이트코드라는 중간 형태의 코드로 변환합니다.
        
          이 바이트 코드는 .class 파일로 저장됩니다.
        
      
    
  
  바이트코드는 플랫폼 독립적이기 때문에, 한 번 컴파일된 .class 파일은 다양한 운영 체제에서 실행될 수 있습니다.


3️⃣ 로딩.

  자바 가상 머신(JVM)은 .class 파일을 로드합니다.
    
      클래스 로더(component of JVM)가 이 작업을 수행하며, 필요한 클래스 파일들을 메모리에 로드합니다.
    
  


4️⃣ 링킹.

  로드된 클래스 파일들은 링킹 과정을 거칩니다. 링킹은 검증, 준비, 그리고(선택적으로) 해석 단계를 포함합니다.
    
      검증 : 로드된 바이트코드가 올바르게 포맷되었는지, 안전한지 검사합니다.
      준비 : 클래스 변수와 기본값을 위한 메모리를 할당합니다.
      해석 : 심볼릭 메모리 참조를 직접 참조로 변환합니다(선택적).
    
  


5️⃣ 초기화.

  클래스 초기화 단계에서 정적 변수들에 대한 초기화가 수행되며, 정적 블록이 실행됩니다.


6️⃣ 실행.

  프로그램 실행 동안 JVM 내부에서 가비지 컬렉터가 사용되지 않는 객체를 자동으로 감지하고, 할당된 메모리를 해제하여 메모리를 관리합니다.


📝 마무리.
자바의 이러한 실행 과정은 코드의 플랫폼 독립성을 보장하고, 안정적이며 보안적인 실행 환경을 제공합니다.
이 모든 과정은 개발자로부터 대부분 숨겨져 있으며, 개발자는 주로 소스 코드 작성과 일부 디버깅에 집중할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-01-AboutJava.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-01-AboutJava.html"><h1 class="title_post">☕️[Java] 자바란?</h1></a>
                        <a href="/Backend/Java/2024-05-01-AboutJava.html" class="txt_post">
                            자바란?
자바 언어 특징.

1. 타 언어에 비해 배우기 쉽습니다.
2. 플랫폼에 독립적입니다.
- 자바 언어가 플랫폼에 독립적인 이유는 그 설계 철학과 메커니즘에 근거합니다.
- 자바는 "한 번 작성하면, 어디서든 실행된다(Write Once, Run Anywhere, WORA)" 라는 철학을 실현하기 위해 개발되었습니다.
    - 이를 가능하게 하는 핵심 요소는 자바 가상 머신(Java Virtual Machine, JVM)과 자바 바이트코드의 도입입니다.


자바의 플랫폼 독립성의 주요 요인
1. 자바 가상 머선(JVM)

  JVM은 자바 바이트 코드를 실행할 수 있는 런타임 환경을 제공합니다. 자바 프로그램이 컴파일되면, 플랫폼에 독립적인 바이트코드로 변환됩니다.
    
      이 바이트코드는 어떤 특정 하드웨어나 운영 체제의 기계어 코드가 아닌, JVM이 이해할 수 있는 중간 형태의 코드입니다.
    
  
  JVM은 바이트코드를 받아 각 플랫폼에 맞는 기계어 코드로 변환하고 실행합니다.
    
      따라서, 자바 애플리케이션은 다양한 운영 체제에서 JVM만 설치되어 있으면 실행될 수 있습니다.
2. 컴파일과 실행의 분리
    
  
  자바 프로그램은 소스 코드(.java 파일)에서 바이트코드(.class 파일)로 컴파일되는 과정과, 실행 시 바이트 코드가 실제로 실행되는 과정으로 나누어집니다. 이 두 단계의 분리는 프로그램을 한 번 컴파일하면, 그 컴파일된 코드가 다양한 환경의 JVM에서 실행될 수 있게 합니다.
3. 표준화된 API
  자바는 풍부하고 표준화된 API를 제공합니다. 이 API들은 플랫폼에 관계없이 일관된 방식으로 작동하므로, 개발자는 운영 체제의 특징을 신경 쓰지 않고도 애플리케이션을 개발할 수 있습니다. 예를 들어, 파일 시스템 접근, 네트워크 프로그래밍 등의 기능은 모든 플랫폼에서 동일한 자바 코드로 작동합니다.
4. 언어와 라이브러리의 독립성
  자바 언어와 표준 라이브러리는 플랫폼에 특화된 구현으로부터 독립적입니다.
    
      즉, 자바의 표준 라이브러리 구현은 다양한 하드웨어와 운영 체제에서 동일하게 작동하도록 설계되었습니다.
    
  


3. 객체지향 프로그래밍입니다.

  객체지향 프로그래밍?
    
      자바에서의 객체지향 프로그래밍(Object-Oriented Programming, OOP)은 소프트웨어를 설계하고 구현할 때 객체라는 개념을 중심으로 프로그래밍하는 방식을 말합니다.
        
          객체지향 프로그래밍은 코드의 재사용성, 확장성 및 관리 용이성을 높이는 데 도움이 됩니다.
          자바는 객체지향 언어의 특징을 강하게 반영하고 있으며, 다음과 같은 기본 원칙에 따라 프로그래밍 됩니다.
            
              1. 캡슐화(Encapsulation)
                
                  객체의 데이터(속성)와 그 데이터를 조작하는 메소드를 하나의 단위로 묶는 것을 말합니다.
                  캡슐화를 사용하면 객체의 세부 구현 내용을 외부에서 알 필요 없이 객체가 제공하는 기능만을 사용할 수 있으며, 이는 코드의 유지보수를 용이하게 합니다.
                
              
              2. 상속(Inheritance)
                
                  한 클래스가 다른 클래스의 특성을 상속 받아 사용할 수 있게 하는 것입니다.
                  이를 통해(상속을 통해) 기존 코드를 재사용하면서 확장할 수 있고, 코드의 중복을 줄이며 유지 보수가 쉬워집니다.
                
              
              3. 다형성(Polymorphism)
                
                  같은 이름의 메소드가 다른 작업을 수행할 수 있도록 하여 메소드의 오버라이딩(Overriding)이나 오버로딩(Overloading)을 가능하게 합니다.
                    
                      오버라이딩(Overriding) : 자식 클래스가 상속 받은 부모 클래스의 메소드를 재정의 하는 행위를 말합니다. 오버라이딩을 통해 자식 클래스는 상속 받은 메소드와 동일한 시그니처(메소드 이름, 매개변수 리스트)를 가지지만, 그 내용을 자신의 특정한 요구에 맞게 새롭게 구현할 수 있습니다. 오버라이딩된 메소드는 실행 시 다형성을 활용하여 해당 객체의 실제 타입에 따라 적절한 메소드가 호출됩니다.
                        
                          예시 코드
  java
      class Animal {
          void display() {
              System.out.println("This is an animal.");
          }
      }
      class Cat extends Animal {
          @Override
          void display() {
              System.out.println("This is a cat.")
          }
      }
     
                        
                      
                      오버로딩(Overloading) : 같은 클래스 내에서 같은 이름의 메소드를 여러 개 정의할 수 있도록 하지만, 매개변수의 타입, 개수 또는 순서가 달라야 합니다. 이를 통해 메소드에 다양한 입력 파라미터를 제공할 수 있으며, 프로그래머가 같은 동작을 하는 메소드에 대해 다양한 옵션을 제공할 수 있습니다. 오버로딩은 컴파일 시간에 결정되며, 메소드 호출 시 전달된 매개변수에 따라 적절한 메소드가 선택됩니다.
                        
                          예시 코드
                                  class Display {
          void show(int a) {
              System.out.println("Number: " + a);
          }
                                    
          void show(String a) {
              System.out.println("String: " + a);
          }
                                    
          void show(int a, int b) {
              System.out.println("Two numbers: " + a + ", " + b);
          }
      }
                            
                          
                          이처럼 오버라이딩과 오버로딩은 자바 프로그래밍에서 메소드의 기능을 확장하거나 변경할 때 유용하게 쓰이는 기법입니다.
                          오버라이딩은 주로 다형성을 활용한 동적 바인딩을 목적으로 하며, 오버로딩은 같은 이름의 메소드에 여러 입력 형태를 제공하기 위해 사용됩니다.
                        
                      
                    
                  
                
              
              4. 추상화(Abstraction)
                
                  복잡한 실제 상황을 단순화하는 과정에서 중요한 특징만을 추출하여 프로그램 코드에 반영하는 것을 의미합니다.
                  추상 클래스와 인터페이스를 통해 구현될 수 있습니다.
                    
                      이러한 원칙들은 자바를 사용하여 복잡한 시스템을 개발할 때 코드의 모듈화를 가능하게 하고, 이로 인해 대규모 소프트웨어 개발과 프로젝트 관리가 용이해집니다.
                        
                          코드의 모듈화(Modularization): 큰 프로그램을 작은 세부 모듈로 나누는 프로세스를 의미합니다. 이러한 모듈은 각각 독립적인 기능을 수행하며, 전체 시스템의 한 부분으로 기능합니다. 모듈화의 주요 목적은 프로그램의 관리를 용이하게 하고, 개발을 효율적으로 만들며, 코드의 재사용성을 높이는 것입니다.
                          모듈화의 주요 이점은 다음과 같습니다.
                            
                              1. 유지보수성
                                
                                  모듈화된 코드는 각 모듈이 분리되어 있기 때문에, 하나의 모듈에서 발생한 문제가 다른 모듈에 미치는 영향을 최소화할 수 있습니다. 따라서 개별 모듈을 독립적으로 수정, 업데이트, 테스트할 수 있어 전체 코드베이스의 유지보수가 더 쉬워 집니다.
                                    
                                      모듈(Module): 소프트웨어 설계에서 사용되는 기본 개념 중 하나로, 관련된 기능들을 논리적으로 그룹화하고 독립적으로 사용할 수 있는 코드의 단위를 의미합니다. 모듈은 프로그램의 특정 기능을 담당하며, 독립적인 개발, 테스트, 재사용이 가능하도록 설계됩니다. 모듈화된 코드는 대체로 명확하고 관리하기 쉬운 구조를 갖습니다.
                                      모듈의 특징으로는 다음과 같습니다.
                                        
                                          1. 독립성
                                            
                                              모듈은 가능한 한 다른 모듈과 독립적으로 동작할 수 있어야 하며, 이를 통해 시스템의 복잡성을 줄이고, 각 모듈의 재사용성을 높일 수 있습니다.
                                            
                                          
                                          2. 캡슐화
                                            
                                              모듈은 자신의 구현 세부사항을 숨기고, 필요한 기능만을 외부에 제공하는 인터페이스를 통해 상호작용합니다. 이로 인해 모듈 간의 상호 의존성이 줄어들고, 변경 관리가 용이해집니다.
                                            
                                          
                                          3. 인터페이스
                                            
                                              모듈은 정의된 인터페이스를 통해 외부와 통신합니다. 인터페이스는 모듈이 제공하는 기능과 해당 기능을 어떻게 접근할 수 있는지를 명시합니다.
                                            
                                          
                                        
                                      
                                      모듈의 예로는 다음으로 들 수 있습니다.
                                        
                                          라이브러리
                                            
                                              특정 기능을 제공하는 함수나 데이터 구조를 모아 놓은 코드 집합. 예를 들어, 수학 연산을 위한 수학 라이브러리, 데이터베이스 작업을 위한 데이터베이스 접근 라이브러리 등이 있습니다.
                                            
                                          
                                          클래스
                                            
                                              객체지향 프로그래밍에서 클래스는 속성(데이터)과 메소드(함수)를 캡슐화하여 모듈을 형성합니다. 클래스는 독립적으로 사용될 수 있으며, 다른 클래스와 상호작용할 수 있습니다.
                                            
                                          
                                          패키지
                                            
                                              관련된 여러 클래스나 모듈을 하나의 더 큰 단위로 그룹화한 것 입니다. 예를 들어, Java에서는 java.util 패키지가 여러 유틸리티 클래스와 인터페이스를 제공합니다.
                                                
                                                  모듈은 개발 과정을 체계화하고, 코드의 재사용성을 증가시키며, 유지 관리를 용이하게 하는 중요한 역할을 합니다.
                                                  모듈은 크기가 클 수도 있고 작을 수도 있으며, 프로젝트의 요구와 설계에 따라 그 범위와 기능이 결정됩니다.
                                                
                                              
                                            
                                          
                                        
                                      
                                    
                                  
                                
                              
                              2. 재사용성
                                
                                  잘 설계된 모듈은 다른 프로그램에서도 재사용할 수 있습니다. 이는 소프트웨어 개발 시간과 비용을 줄이는 데 도움이 되며, 일관된 기능을 여러 프로젝트에 걸쳐 사용할 수 있습니다.
                                
                              
                              3. 확장성
                                
                                  모듈화는 시스템의 확장성을 향상시킵니다. 새로운 기능이 필요할 때 기존 모듈을 수정하거나 새로운 모듈을 추가하기가 더 쉬워집니다. 이는 시스템의 유연성을 증가시키고, 변화하는 요구사항에 더 잘 대응할 수 있게 합니다.
                                
                              
                              4. 가독성
                                
                                  작은 모듈로 나뉘어진 코드는 각각의 모듈이 명확한 기능을 수행하기 때문에, 전체 코드의 구조를 이해하기가 더 쉽습니다. 개발자가 프로그램의 특정 부분만을 이해하고도 효과적으로 작업할 수 있습니다.
                                
                              
                              5. 팀 협업 향상
                                
                                  모듈화는 여러 개발자가 동시에 다른 모듈에서 작업할 수 있게 함으로써 팀 작업을 용이하게 합니다. 각 팀원이 특정 모듈에 집중할 수 있으며, 전체 프로젝트에 대한 의존성을 줄이면서 협업을 효율적으로 진행할 수 있습니다.
                                    
                                      이처럼 코드의 모듈화는 소프트웨어 개발 과정에서 중요한 역할을 하며, 특히 대규모 프로젝트나 복잡한 시스템 개발에 있어 필수적인 접근 방식입니다.
                                    
                                  
                                
                              
                            
                          
                        
                      
                    
                  
                
              
            
          
        
      
    
  


4. Garbage Collector로 사용되지 않는 메모리를 자동적으로 정리해줍니다.

  Garbage Collector(GC): 프로그램이 동적으로 할당한 메모리 영역 중에서 더 이상 사용하지 않는 부분을 자동으로 찾아서 해제하는 시스템을 말합니다. 이 과정을 통해 프로그램에서 발생할 수 있는 메모리 누수를 방지하고, 사용 가능한 메모리 리소스를 최적화합니다.
    
      프로그램이 동적으로 할당한 메모리 영역 : 프로그램 실행 중에 필요에 따라 할당되고 해제되는 메모리를 말합니다. 이는 프로그램의 런타임 중에 사용자의 요구나 데이터의 양에 따라 변화하는 메모리 요구 사항을 수용하기 위해 사용됩니다. 동적 메모리 할당은 프로그램이 시작할 때 필요한 메모리 양을 미리 알 수 없는 경우나, 실행 도중에 메모리 사용량이 변할 때 유용합니다.
        
          동적 메모리 할당의 특징은 아래와 같습니다.
            
              1. 유연성 : 동적 메모리 할당은 프로그램 실행 중에 필요한 메모리 크기를 조정할 수 있게 해줍니다. 이로 인해 프로그램은 사용자의 입력, 파일 크기, 또는 다른 실행 시 요소들에 따라 메모리 사용을 최적화할 수 있습니다.
              2. 효율성 : 필요할 때만 메모리를 할당하고, 더 이상 사용하지 않는 메모리를 해제함으로써 시스템 리소스를 보다 효율적으로 사용할 수 있습니다.
              3. 메모리 관리 : 동적 메모리는 일반적으로 힙(Heap) 영역에서 관리됩니다. 힙은 프로그램의 데이터 영역 중 하나로, 동적으로 할당되는 객체와 데이터에 사용됩니다. 힙 영역의 크기는 프로그램 실행 도중에 확장되거나 축소될 수 있습니다.
                
                  동적 메모리 할당의 예는 다음과 같습니다.
                    
                      자바에서는 new 키워드를 사용하여 객체를 생성할 때 동적 메모리 할당이 일어납니다. 예를 들어, new ArrayList() 를 호출하면, 자바 런타입은 필요한 메모리를 힙에서 할당하여 ArrayList 객체를 저장합니다.
                      객체 사용이 끝나면 자바의 GC가 더 이상 참조되지 않는 객체가 사용하던 메모리를 자동으로 해제합니다.
                        
                          동적 메모리 할당은 프로그램이 더 유연하고 효율적으로 동작하도록 돕지만, 관리가 제대로 이루어지지 않을 경우 메모리 누수나 성능 저하 같은 문제를 초래할 수 있습니다. 따라서 프로그래머는 동적 메모리 관리를 신중하게 수행해야 합니다.
                        
                      
                    
                  
                  GC의 주요 기능은 다음과 같습니다.
                    
                      1. 메모리 관리 자동화 : 프로그래머가 메모리 할당 및 해제를 직접 관리하는 대신 자바 런타입이 이를 자동으로 처리합니다. 이로 인해 개발자는 메모리 관리에 신경 쓰지 않고, 애플리케이션 로직 개발에 더 집중할 수 있습니다.
                      2. 메모리 누수 방지 : GC는 참조되지 않는 객체들을 정기적으로 청소하여 메모리 누수를 방지합니다. 객체가 더 이상 필요 없을 때 자동으로 메모리에서 제거됩니다.
                      3. 효율적인 메모리 사용 : 사용되지 않는 객체들을 정리함으로써 메모리를 효율적으로 사용하고, 애플리케이션의 성능을 유지할 수 있도록 도와줍니다.
                    
                  
                  GC의 작동 원리는 다음과 같습니다.
                    
                      GC은 크게 두 단계로 진행됩니다.
                        
                          1. 객체 탐지 : GC는 더 이상 어떤 객체에도 참조되지 않는 객체들을 탐지합니다. 이러한 객체들은 프로그램에서 더 이상 사용되지 않는 것으로 간주됩니다.
                          2. 메모리 회수 : 탐지된 객체들이 차지하고 있는 메모리를 해제합니다. 이 메모리는 다시 사용 가능한 상태가 되어, 새로운 객체를 위해 재할당될 수 있습니다.
                        
                      
                    
                  
                  GC 알고리즘
                    
                      자바는 다양한 GC 알고리즘을 제공합니다. 대표적인 몇 가지는 다음과 같습니다.
                        
                          Mark-and-Sweep : 사용 중인 객체를 “표시(mark)”하고, 표시되지 않은 객체를 “쓸어내는(sweep)” 방식입니다.
                          Generational GC : 객체를 세대별로 분류하여, 생성된지 얼마 되지 않은 객체들(Young Generation)과 오래된 객체들(Old Generation)을 다르게 관리합니다. 이 방식은 대부분의 객체가 생성 후 짧은 시간 내에 소멸된다는 관찰에 기반합니다.
                          Compacting : 사용 중인 객체들을 메모리의 한쪽으로 몰아넣어(Compact), 메모리의 연속성을 높이고, 메모리 단편화를 방지합니다.
                            
                              GC은 메모리 관리를 자동화하지만, 때로는 성능 저하를 일으킬 수 있습니다. 특히 GC가 실행되는 동안에는 프로그램의 다른 모든 작업이 일시적으로 중단(Stopping the world)될 수 있기 때문에, GC 동작 방식과 설정을 잘 이해하고 조절하는 것이 중요합니다.
                            
                          
                        
                      
                    
                  
                
              
            
          
        
      
    
  




JVM(Java Virtual Machine)
JVM은 자바 애플리케이션을 실행하기 위한 가상 머신으로, 자바 바이트코드를 로컬 기계 코드로 변환하여 실행하는 역할을 합니다.

  자바 바이트코드(Java Bytecode) : 자바 소스 코드가 컴파일된 후의 중간 형태입니다.
    
      자바 소스 파일(.java 파일)을 자바 컴파일러가 컴파일하면, 결과적으로 생성되는 것이 .class 파일로 저장되는 자바 바이트코드입니다.
      이 바이트코드는 기계어 코드는 아니지만, CPU가 직접 실행할 수는 없고, JVM이 이해하고 실행할 수 있는 명령어 세트로 구성되어 있습니다.
      바이트코드는 플랫폼에 독립적이기 때문에, 한 번 컴파일된 자바 프로램은 어떤 JVM이 설치된 시스템에서든 실행할 수 있습니다.
        
          이는 자바의 “한 번 작성하면, 어디서든 실행된다”라는 이점을 제공합니다.
        
      
    
  
  로컬 기계 코드(Local Machine Code) : 로컬 기계 코드는 특정 하드웨어 플랫폼의 CPU가 직접 이해하고 실행할 수 있는 명령어 코드입니다.
    
      이 코드는 플랫폼에 종속적이며, 다양한 운영 체제와 하드웨어 아키텍처는 각각의 기계어 코드를 가지고 있습니다.
      자바 바이트코드는 JVM을 통해 실행될 때, 두 가지 방법 중 하나로 실행될 수 있습니다.
        
          1. 인터프리터 : JVM은 바이트코드를 한 줄씩 읽고, 각 명령을 로컬 기계 코드로 변환하면서 실행합니다. 이 방법은 간단하지만, 실행 속도가 느릴 수 있습니다.
          2. JIT 컴파일러(Just-In-Time Compiler) : 이 방식에서는 JVM이 바이트코드 전체 또는 핵심 부분을 분석하여, 실행 전에 전체 코드를 로컬 기계 코드로 한번에 변환합니다. 이렇게 하면 프로그램의 실행 속도가 크게 향상됩니다.
            
              결국, 자바 바이트코드는 플랫폼 독립적인 중간 코드로서의 역할을 하며, 로컬 기계 코드는 실제 하드웨어에서 실행되기 위한 최종적인 코드 형태입니다. 이 두 코드의 변환과 실행은 JVM 내에서 처리되며, 사용자는 이 과정을 명시적으로 관리할 필요가 없습니다. 이것이 자바가 제공하는 큰 이점 중 하나입니다.
            
          
        
      
    
  


JVM은 자바의 “한 번 작성하면, 어디서든 실행된다(Write Once, Run Anywhere, WORA)” 라는 철학을 가능하게 하는 중요한 구성 요소입니다.

JVM 덕분에 자바 애플리케이션은 운영 체제나 하드웨어 플랫폼에 구애받지 않고 동일하게 실행될 수 있습니다.

JVM의 주요 기능.
1. 플랫폼 독립성 : 자바 프로그램은 JVM 위에서 실행되므로, JVM이 설치되어 있는 모든 운영 체제에서 같은 자바 프로그램을 실행할 수 있습니다.

  이는 JVM이 플랫폼에 특화된 코드로 바이트 코드를 변환하기 때문입니다.


2. 메모리 관리 : JVM은 자동 메모리 관리 기능을 제공합니다. 이는 GC를 통해 메모리 할당과 해제를 관리하여, 프로그래머가 메모리 누수 없이 효율적인 메모리 사용을 할 수 있도록 돕습니다.

3. 보안 : 자바 바이트코드는 JVM에 의해 검증되며 실행되기 전에 다양한 검사를 통해 안전성이 확보됩니다.

  이는 악의적인 코드 실행과 시스템 오류를 방지하는 데 도움이 됩니다.


4. 실행 환경 : JVM은 자바 애플리케이션에 필요한 실행 환경을 제공합니다.

  이 환경은 클래스 로더, 바이트코드 실행 엔진, 쓰레드 관리 등을 포함합니다.


JVM의 구성 요소.
1. 클래스 로더(Class Loader) : 클래스 파일들을 읽고 바이트코드를 JVM 메모리에 로드하는 역할을 합니다.
2. 실행 엔진(Excution Engine) : 로드된 클래스 파일의 바이트코드를 실행합니다. 이 엔진은 바이트코드를 해것하거나 필요에 따라 JTI(Just-In-Time) 컴파일러를 사용하여 바이트코드를 직접 기계 코드로 변환하여 실행 속도를 높일 수 있습니다.
3. 가비지 컬렉터(Garbage Collector) : JVM이 사용하지 않는 메모리 자원을 자동으로 회수합니다.
4. 메모리(Runtime Data Area) : JVM은 프로그램 실행을 위해 필요한 다양한 메모리 영역을 관리합니다. 이는 힙(Heap), 스택(Stack), 메소드 영역(Method Area), 프로그램 카운터(Program Counter) 등이 포함됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AnD/2024-05-01-AnD-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/AnD.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AnD/2024-05-01-AnD-1.html"><h1 class="title_post">[AnD] 두 수의 합.</h1></a>
                        <a href="/Backend/AnD/2024-05-01-AnD-1.html" class="txt_post">
                            문제 설명 🤓

0 이상의 두 정수가 문자열 a, b로 주어질 때, a + b의 값을 문자열로 return 하는 solution 함수를 작성해 주세요.

솔루션 📝

import java.math.BigInteger;

class Solution {
    public String solution(String a, String b) {
        String answer = "";

        BigInteger bigNumberA = new BigInteger(a);
        BigInteger bigNumberB = new BigInteger(b);

        answer = bigNumberA.add(bigNumberB).toString();

        return answer;
    }
}


트러블슈팅 🏀

1. NumberFormatException 에러(1).

입출력의 예시 중 가장 긴 입력 예시인 a : “18446744073709551615”, b : “305793246910280479981” 에서 에러가 발생 했습니다.

1️⃣ 콘솔에 나타난 에러 메시지

콘솔에 나타난 에러 메시지는 아래와 같았습니다.

Exception in thread "main" java.lang.NumberFormatException: For input string: "18446744073709551615"
	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)
	at java.base/java.lang.Integer.parseInt(Integer.java:662)
	at java.base/java.lang.Integer.valueOf(Integer.java:989)
	at programmers.test1.Solution.solution(Solution.java:8)
	at programmers.test1.SolutionMain.main(SolutionMain.java:7)

Process finished with exit code 1


2️⃣ 본격적인 트러블슈팅

이 메시지를 하나씩 해석하고 트러블슈팅을 이어갔습니다.

먼저 이 오류 메시지는 NumberFormatException 이 발생했다는 것을 나타냅니다.

  특히 “For input string: “18446744073709551615”는 Java에서 정수로 변환하려는 문자열이 정부 범위를 벗어났음을 의미합니다.


Java의 Integer.parseInt() 메소드는 문자열을 정수(Int)로 변환할 때 사용됩니다.

  그러나 Int 자료형은 -2,147,483,648,648 부터 2,147,483,648,647까지의 값을 저정할 수 있습니다.
    
      제공된 문자열 “18446744073709551615”는 이 범위를 훨씬 초과합니다.
    
  


3️⃣ 해결 방법

이 문제를 해결하려면 다음과 같은 방법을 고려할 수 있습니다.

1. 타입 변경

  int 대신 long 타입을 사용하거나, 이보다 더 큰 범위가 필요하다면, BigInteger 클래스를 사용할 수 있습니다.
  long 의 범위는 -9,223,372,036,854,775,808부터 9,223,372,036,854,775,807 까지입니다.


2. 입력 검증

  입력 값이 정수 타입으로 변환 가능한지, 그리고 해당 타입의 범위 내에 있는지 검증하는 로직을 추가합니다.



  코드를 수정할 때는 적절한 데이터 타입을 사용하도록 주의해야 합니다.
예를 들어, long 으로 변경하려면 Long.parseLong() 을 사용할 수 있습니다.


2. NumberFormatException 에러(2)

이번에는 위의 트러블슈팅을 활용하여 코드를 만든 결과 NumberFormatException 에러를 다시 발생 시킨 케이스 입니다.

  이번에는 Long.parseLong() 메소드를 사용하면서 발생했습니다.
    
      문자열 “18446744073709551615”는 이번에도 범위를 벗어난 값으로 처리되었습니다.
    
  


long 자료형의 최대값은 9,223,372,036,854,775,807dlqslek.

  제공된 값 “18446744073709551615”는 이 최대값을 초과합니다.
    
      따라서, long 으로도 처리할 수 없으며, Java에서 이러한 큰 숫자를 다루려면 BigInteger 클래스를 사용해야 합니다.
        
          BigInteger 는 사실상 제한 없는 정밀도의 정수를 다룰 수 있어 이와 같은 큰 숫자를 취급할 때 유용합니다.
        
      
    
  


BigInteger를 사용하는 예시 코드.
import java.math.BigInteger;

public class Solution {
    public void solution(String input) {
        BigInteger bigNumber = new BigInteger(input);
        // bigNumber를 사용한 다른 로직
    }
}

public class SolutionMain {
    public static void main(String[] args) {
        new Solution().solution("18446744073709551615");
    }
}


  이 코드는 BigInteger 를 사용하여 입력된 숫자를 처리하고, 필요한 로직을 수행할 수 있도록 구성되어 있습니다.


3. BigInteger 클래스를 사용하여 두 큰 정수를 더하는 방법.
두 문자열을 받아 큰 범위의 문자열을 BigInteger 클래스를 사용하여 받아오고 변환하는 데 까지는 성공하였으나 입력된 두 개의 큰 범위 값의 BigInteger 를 어떻게 합쳐야 할지를 몰라 검색해 봤습니다.

1️⃣ Java에서 BigInteger 클래스를 사용하여 두 큰 정수를 더하는 방법

  BigInteger 클래스는 불변(immutable) 객체 이므로 두 BigInteger 인스턴스를 더할 때, 새로운 BigInteger 객체가 반환됩니다.


2️⃣ BigInteger 객체를 더하는 방법 예시 코드
import java.math.BigInteger;

public class Main {
    public static void main(String[] args) {
        // 두 큰 수를 BigInteger로 생성
        BigInteger number1 = new BigInteger("12345678901234567890");
        BigInteger number2 = new BigInteger("98765432109876543210");
        
        // 두 수를 더함
        BigInteger sum = number1.add(number2);
        
        // 결과 출력
        System.out.println("Sum: " + sum.toSting())
    }
}


이 코드는 다음과 같은 단계를 거칩니다.

1. 두 개의 BigInteger 인스턴스 number1 과 number2 를 생성합니다.

  이들은 문자열로부터 생성되며, 매우 큰 수를 나타낼 수 있습니다.


2. add 메소드를 사용하여 number1 과 number2 를 더합니다.

  이 메소드는 두 수의 합을 나타내는 새로운 BigInteger 객체를 반환합니다.


3. 덧셈 결과를 출력합니다.


  BigInteger 를 사용하면 정수의 범위에 제한 없이 수학적 연산을 수행할 수 있어, 매우 큰 수를 처리해야 할 때 유용합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        </ul>
    
</div>
<div class="pagination">
    <nav class="pagination-container">
        <button class="pagination-button" id="prev-button" aria-label="Previous page" title="Previous page">
            &lt;
        </button>
    
        <div id="pagination-numbers"></div>
      
        <button class="pagination-button" id="next-button" aria-label="Next page" title="Next page">
            &gt;
        </button>
    </nav>
</div>
                
            </div>
        </div>
        <div id="search">
    <div class="wave"></div>
    <div class="wave"></div>
    <div class="wave"></div>

    <div class="search-box">
        <mark>Touch background to close</mark>
        <div class="input-box">
            <input id="search-input" type="search" tabindex="1" spellcheck="false" placeholder="Search...">
            <button id="btn-clear">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"></path></svg>
            </button>
        </div>
        <ul id="search-result"></ul>
    </div>
</div>
    </body>
    <script defer src="/assets/js/background.js"></script>
<script defer src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }

    gtag('js', new Date());
    gtag('config', '');
</script>
    
        <script src="/assets/js/subject.js"></script>
    
    <script src="/assets/js/common.js"></script>
    <script defer>
    var posts = [];

    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > AWS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/AWS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > CPP_DS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/CPP_DS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > CS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/CS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > DataStructure",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/DataStructure/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Database",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Database/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > HackTheSwift",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/HackTheSwift/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Leet-Code",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Leet-Code/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > MySQL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/MySQL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Network",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Network/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > OS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/OS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Read English Book",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Read%20English%20Book/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > SQL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/SQL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > TIL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/TIL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Web",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Web/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > AWS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/AWS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > AnD",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/AnD/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > CS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/CS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > DB",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/DB/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > ENG",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/ENG/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Java多識",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Java%E5%A4%9A%E8%AD%98/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Math",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Math/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Network",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Network/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Post",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Post/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > TIL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/TIL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Metacognition > Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Metacognition/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Metacognition",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Metacognition/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "👾 Day 1 - Variables",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift",
            'url'      : "/2024/HackTheSwift/2024-01-14-Variables.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-15"
        });
    

        posts.push({
            'title'    : "📝 스위프트에 왜 변수가 있을까?",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift, Article",
            'url'      : "/2024/HackTheSwift/2024-01-14-WhyDoseSwiftHaveVariables.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-15"
        });
    

        posts.push({
            'title'    : "📝 배열의 용량 vs 배열의 길이",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-16-ArrayCapacity-VS-Length.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-18"
        });
    

        posts.push({
            'title'    : "👾 Day 2 - String And Integers",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift, Programming",
            'url'      : "/2024/HackTheSwift/2024-01-18-StringAndIntegers.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-18"
        });
    

        posts.push({
            'title'    : "👾 Day 2 - Multi-line String",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift",
            'url'      : "/2024/HackTheSwift/2024-01-18-Multi-line-String.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 기본 배열 작업",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-BasicArrayOperations.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 1(배열의 끝에 삽입하기-Inserting at the End of an Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAtTheEndOfAnArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 2(배열의 시작 부분에 삽입하기 - Inserting at the Start of an Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAtTheStartOfAnArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 3(배열의 아무 곳에나 삽입하기 - Inserting Anywhere in the Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAnywhereInTheArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "🆙 [LeetCode] 1089.Duplicate Zeros.",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-20-DuplicateZeros.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-20"
        });
    

        posts.push({
            'title'    : "🆙 [LeetCode] 88.Merge Sorted Array.",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-22-MergeSortedArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-21"
        });
    

        posts.push({
            'title'    : "👾[Day 3] Doubles and Booleans",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "swift, programming",
            'url'      : "/2024/HackTheSwift/2024-01-22-DoubleAndBool.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-22"
        });
    

        posts.push({
            'title'    : "🌐[Network] 웹소켓(WebSocket)",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Server, Back-end",
            'url'      : "/2024/Network/2024-01-22-webSocket.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "🌐[Network] HTTP 통신.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, HTTP",
            'url'      : "/2024/Network/2024-01-23-HTTP.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "🌐[Network] 패킷(Packet)",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-01-23-Packet.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea.",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-25-TheOldManAndTheSea.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-25"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (2).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-26-TheOldManAndTheSea2.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-26"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (3).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-27-TheOldManAndTheSea3.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-26"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (5).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-29-TheOldManAndTheSea5.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-28"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (4).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-28-TheOldManAndTheSea4.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수 선언.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java",
            'url'      : "/2024/Java/2024-02-01-VariableDeclaration.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-01"
        });
    

        posts.push({
            'title'    : "🌐 [AWS] IAM이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Cloud platform",
            'url'      : "/2024/AWS/post-01.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [AWS] VPC?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "VPC",
            'url'      : "/2024/AWS/post-04.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [Network, AWS] Subnet이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/2024/AWS/post-03.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [Network, AWS] Routing Table이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "Network, AWS",
            'url'      : "/2024/AWS/post-02.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (6).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-02-03-TheOldManAndTheSea6.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-03"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크 기초 용어.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-03-networkBasicTerm1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-04"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 컬럼명 변경, 순서변경, 타입변경, 추가.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-05-COLUMN1.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-05"
        });
    

        posts.push({
            'title'    : "🌐[Network] 시스템(System).",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-05-system.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "🌐[Network] 인터페이스(Interface).",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-05-interface.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (7).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-02-06-TheOldMadAndTheSea7.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "☕️[JAVA] Packaing 옵션.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "JAVA, Programming language",
            'url'      : "/2024/Java/2024-02-06-JavaFormat.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "☕️[JAVA] while문과 for문.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, programming language",
            'url'      : "/2024/Java/2024-02-07-loop.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스코프 존재 이유 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming language",
            'url'      : "/2024/Java/2024-02-07-scope1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-07"
        });
    

        posts.push({
            'title'    : "🌐[Network] 전송매체.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-08-TransmissionMedia.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 형변환 정리.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-09-typecasting.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-09"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 라이브러리 살펴보기",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framwork",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-09-springFramework1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-09"
        });
    

        posts.push({
            'title'    : "🌐[Network] 프로토콜.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-10-protocol.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 향상된 for문",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-11-foreach.html",
            'image'    : "/assets/img/thumbnail/forloop.jpeg",
            'date'     : "2024-02-11"
        });
    

        posts.push({
            'title'    : "🍃[Spring Boot] 스프링?",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring Boot, Framework, Spring",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-13-Spring.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드(2)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-method2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드정의",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-method3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 반환타입.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-methodReturnType.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-methodStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 리펙토링 - 입.출금",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-14-JavaRefAccount1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-14"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-14-aboutNetwork.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-14"
        });
    

        posts.push({
            'title'    : "💾[Database] DBMS의 분류",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/2024/Database/2024-02-15-classificationOfDBMS.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "💾[Database] 데이터베이스의 정의와 특징",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/2024/Database/2024-02-15-databaseDefinition.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 파트 정리.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-15-methodSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스가 필요한 이유.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-15-whyWeNeedClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 인터넷",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Internet",
            'url'      : "/2024/Network/2024-02-15-internet.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 표준화",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Standardization",
            'url'      : "/2024/Network/2024-02-15-standardization.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Route 53에 등록된 서브도메인 github page에 연결하기",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/2024/AWS/post-05.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "💾[Database] SQL의 개요",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database, SQL",
            'url'      : "/2024/Database/2024-02-16-IntroSQL.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-classIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스, 객체, 인스턴스 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-termSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 사용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-useObject.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] MySQL Server Start/Stop",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-16-trobleshootingMysql1.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 배열 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-17-arrayIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🍃[Spring] MVC와 템플릿 엔진",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-17-mvcAndTemplateEngine.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 정적 컨텐츠",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-17-staticContent.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 테이블에 데이터 입력 INSERT INTO",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-InsertInto.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] null 컬럼 변경하기.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-nullColumn.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] SELECT 조회 결과 LIMIT 1000 ROW 해제하기.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-selectAndLimit.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 테이블 삭제하기",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-19-drop.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🍃[Spring] API",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-18-apiSummary.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 배열 도입 - 리팩토링",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-19-arrayIntro-refactoring.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(1)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-20-referenceAndPrimitive.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(2) - 변수 대입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-20-referenceAndPrimitive2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] null",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-null.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(3) - 메서드 호출",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-referenceAndPrimitive3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 참조형과 메서드 호출 - 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-referenceTypesAndMethodCalls.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 초기화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-variableAndInit.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "🌐[Network] 시스템의 구분",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-21-systemClassification.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "🍃[Spring] Gradle과 Maven",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework, Build System",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-21-buildSystem.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] NullPointerException",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-22-NullPointerException.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(1)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-22-procedure-oriented-programming(1).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 지향 프로그래밍 vs 절차 지향 프로그래밍",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-OOPvsPOPsummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 메서드",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-classAndMethod.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 지향 프로그래밍",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-object-oriented-programming.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(2)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-procedure-oriented-programming(2).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(3)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-procedure-oriented-programming(3).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 필요한 이유",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-init(1).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-init(2).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] this",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-this.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본 생성자",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-init(3).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 오버로딩 this()",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-initOverloadingAndThis.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 - import",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-packageImport.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 - 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-packageStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 규칙",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-26-ruleOfpackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-26"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-26-usesOfPackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-26"
        });
    

        posts.push({
            'title'    : "🆙[Cpp DataStructure] 교환(Swap)과 정렬(Sort)",
            'path'     : "2024 > CPP_DS",
            'type'     : "post",
            'tags'     : "Cpp, DataStructure",
            'url'      : "/2024/CPP_DS/2024-02-27-SwapAndSort.html",
            'image'    : "/assets/img/thumbnail/cpp.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자 이해 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-27-accessModifier-1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자 이해 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-27-accessModifier-2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 종류",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 사용 - 필드, 메서드",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-4.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 사용 - 클래스 레벨",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-5.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터의 구성",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-02-29-cs.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-02-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] 캡슐화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-01-Encapsulation.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 메모리 구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-JavaMemoryStructure.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택 영역",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-Stack.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택 영역과 힙 영역",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-StackAndHeap.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택과 큐 자료구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-StackAndQueue.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-04-static1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-04-staticVariable1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticMethod1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticMethod2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticVariable2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticVariable3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-06-staticMethod3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-06"
        });
    

        posts.push({
            'title'    : "🆙[Cpp DataStructure] 안정성(stability) 확인",
            'path'     : "2024 > CPP_DS",
            'type'     : "post",
            'tags'     : "Cpp, DataStructure",
            'url'      : "/2024/CPP_DS/2024-03-07-stableAndUnstable.html",
            'image'    : "/assets/img/thumbnail/cpp.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 상수 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndConstant1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 상수 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndConstant2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 참조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndReference.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 기능 추가",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-InheritanceAndAddingFeatures.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 메모리 구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-InheritanceAndMemoryStructure.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속관계",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-extendRelationship.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속 - 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-extendStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 메서드 오버라이딩",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-09-InheritanceAndMethodOverriding.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 접근 제어",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-10-inheritanceAndAccessControl.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 메서드에 사용되는 final",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-finalUsedInClassesAndMethods.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] super - 부모 참조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-super.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] super - 생성자",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-super2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 구조를 알아야 하는 이유",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-14-WhyYouNeedToKnowComputerArchitecture.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "💾 [CS] 패턴 매칭(Pattern Matching)과 표현 매칭(Expression Matching)",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-14-patternMatchingAndExpressionMatching.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성과 캐스팅",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-14-polymorphismAndCasting.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성(Polymorphism) 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-14-polymorphismStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다운캐스팅과 주의점",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-DowncastingAndPrecaution.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 캐스팅의 종류",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-TypesOfCasting.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] instanceof",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-instanceof.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성과 메서드 오버라이딩",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-17-polymorphismAndMethodOverriding.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-17"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 구조의 큰 그림",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-18-TheBigPictureOfComputerArchitecture.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-19-TakeAdvantageOfPolymorphism3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상 클래스 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-20-AbstractClass1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상 클래스 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-20-AbstractClass2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-20"
        });
    

        posts.push({
            'title'    : "💾 [CS] 0과 1로 숫자를 표현하는 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-21-HowToRepresentNumbersWithZeroAndOne.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 메모리를 16진수로 표시하는 이유",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-21-whyIsComputerMemoryExpressedInhex.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-21-Interface.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스 - 다중구현",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-22-Interface-MultipleImplementation.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 인터페이스 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-22-UsingClassesAndInterfaces.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-23-Polymorphism-RoleImplementatioonExample1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 좋은 객체 지향 프로그래밍이란?",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-23-WhatIsGoodOOP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-24-Polymorphism-RoleImplementatioonExample2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-24"
        });
    

        posts.push({
            'title'    : "💾 [CS] 0과 1로 문자를 표현하는 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-25-HowToRepresentCharactersWithZeroAndOne.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] OCP(Open-Closed Principle) 원칙",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-25-OCP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-25-Polymorphism-RoleImplementatioonExample3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "💉[SQL] 데이터베이스 모델링",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-27-DatabaseModeling.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "💉[SQL] 테이블과 컬럼, SQL",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-27-TableColumnsAndSQL.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "🌐[Web] 웹 브라우저 작동 원리",
            'path'     : "2024 > Web",
            'type'     : "post",
            'tags'     : "Web",
            'url'      : "/2024/Web/2024-03-27-HowWebBrowsersWork.html",
            'image'    : "/assets/img/thumbnail/sparta.jpg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-28-ObjectClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] java.lang 패키지 소개",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-28-java-langPackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 배열",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-ObjectArray.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 다형성",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-ObjectPolymorphism.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] toString()",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-toString.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "💉[SQL] WHERE란?",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-29-WHERE.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "💉[SQL] AND, OR, NOT",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-30-ANDORNOT.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-30"
        });
    

        posts.push({
            'title'    : "💉[SQL] BETWEEN, IN, LIKE",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-30-BETWEENINLIKE.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-30"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object와 OCP",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-31-ObjectAndOCP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] equals() - 1.동일성과 동등성",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-31-equals1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "💉[SQL] SQL 문의 기본 구조, SQL",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-31-sql.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "💾 [CS] 소스코드와 명령어",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-01-SourceCodeAndCommands.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] equals() - 2. 구현",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-01-equals2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "💉[SQL] SUM, AVG, COUNT, MIN, MAX",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-01-SUMAVGCOUNTMINMAX.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "💉[SQL] Query 작성시 플로우",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-01-sqlFlow.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형의 공유",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-02-SharingOfBasicTypesAndReferenceTypes.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "💉[SQL] GROUP BY",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-02-GROUPBY.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "💉[SQL] ORDER BY",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-02-ORDERBY.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-03-ImmutableObjectsIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 공유 참조와 사이드 이펙트",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-03-SharedReferencesAndSideEffects.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-03"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어의 구조",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-04-commandStructure.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 예제",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-04-ImmutableObjectExample.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "💉[SQL] REPLACE, SUBSTRING, CONCAT",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-04-ReplaceSubstringConcat.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 값 변경",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-05-ImmutableObjectChangeValue.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-05-ImmutableObjectSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 기본",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-06-StringClassBasic.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-06"
        });
    

        posts.push({
            'title'    : "💾 [CS] ALU와 제어장치",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-08-ALUandControlUnit.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 비교",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-08-StringClassComparison.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 불변객체",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-09-StringClassImmutableObject.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 주요 메서드 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-09-StringClassMethod-1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] StringBuilder - 가변 String",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-10-StringBuilder.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 주요 메서드 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-10-StringClassMethod2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-10"
        });
    

        posts.push({
            'title'    : "💾 [CS] 레지스터",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-11-register.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 체이닝 - Method Chaining",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-11-MethodChaining.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 최적화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-11-StringOptimization.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-14-StringClassSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-14"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어 사이클과 인터럽트",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-15-InstructionCycleAndIntrrupts.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 기본형의 한계 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-15-WrapperClass-LimitationsOfBaseTypes1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240415 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-15-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 오토 박싱",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-AutoBoxing.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 자바 래퍼 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-JavaWrapperClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 기본형의 한계 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-LimitationOfBaseTypes2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240417 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 주요 메서드와 성능",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-18-WrapperClass-MainMethodsAndPerformance.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240418 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-18"
        });
    

        posts.push({
            'title'    : "💾 [CS] 빠른 CPU를 위한 설계 기법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-19-DesignTechniquesForFastCPUs.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어 병렬 처리 기법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-19-InstructionParallelProcessingTechnique.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] Class 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-19-Class.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] System 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-19-SystemClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240419 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-19-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 변수",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 복합 자료 구조",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 배열",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure3.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 문자열",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-22-DataStructure-2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 삽입 정렬",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-22-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "💻[Operating System] 커널(kernel)이란?",
            'path'     : "2024 > OS",
            'type'     : "post",
            'tags'     : "Operating System",
            'url'      : "/2024/OS/2024-04-22-OS-2.html",
            'image'    : "/assets/img/thumbnail/os.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "💻[Operating System] 리눅스와 우분투의 차이점",
            'path'     : "2024 > OS",
            'type'     : "post",
            'tags'     : "Operating System",
            'url'      : "/2024/OS/2024-04-22-OS.html",
            'image'    : "/assets/img/thumbnail/os.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240422 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-22-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 문제 정의와 선형 스캔",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-23-DataStructure-2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-23"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 변수와 배열이 중요한 이유와 이진 탐색",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-23-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-23"
        });
    

        posts.push({
            'title'    : "💾 [CS] CISC와 RISC",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-25-CISCandRISC.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] Math, Random 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-26-MathAndRandomClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-26"
        });
    

        posts.push({
            'title'    : "[AnD] 두 수의 합.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "Algorithm, DataStructure",
            'url'      : "/Backend/AnD/2024-05-01-AnD-1.html",
            'image'    : "/assets/img/thumbnail/AnD.jpeg",
            'date'     : "2024-05-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바란?",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-01-AboutJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 소개",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-IntroJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 코테 맛보기(1) - 코테를 위한 자바 프로그래밍 언어 사용 숙련도",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-TasteTheCodingTest-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 코테 맛보기(2) - 코테를 위한 자료구조와 알고리즘 개념 구현 방법 숙지",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-TasteTheCodingTest-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 변수와 자료형(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "[Math] 기초수학 - 소개",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-02-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240502 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-02-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 타입 비교.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-03-TypeComparison.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 변수와 자료형(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 자료형(3)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240503 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-03-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 자료형(4)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-04"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240504 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-04-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 여러가지 연산자(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-05-VariousOperator-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 여러가지 연산자(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-05-VariousOperators-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 조건문",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-05-conditionalStatement.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240505 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-05-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "💾 [CS] 메모리의 주소 공간",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-06-addressSpaceInMemory.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "☕️[Java] 반복문",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-06-loopStatement.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240506 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-06-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 객체(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-07-ClassesAndObjects-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다차원 배열",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-07-MultidimensionalArray.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240507 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-07-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 객체(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-08-ClassesAndObjects-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-08"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240508 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-08-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-09-Inheritance.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-09"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240509 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-09-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상클래스",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-10-abstractClass.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-10-polymorphism.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240510 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-10-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 내부 클래스",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-11-InnerClass.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 입출력(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-11-Input-Output-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-11-Interface.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "📝[blog post] 프론트엔드와 백엔드는 무엇이 다를까?(+내가 백엔드 개발자가 되고 싶은 이유)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "제로베이스, 백엔드, Java, Spring, 개발자, 백엔드공부, 백엔드스쿨",
            'url'      : "/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240511 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-11-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 예외 처리",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-12-ExceptionHandling.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 입출력(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-12-Input-Ouput-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240512 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-12-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 컬렉션 프레임워크",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-CollectionFramework.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] HashMap에 key 값은 항상 int 여야 할까요?",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 람다식",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-lambda.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 람다식은 하나만!",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-lambdaIsOnlyOne.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240513 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-13-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스트림",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-14-Stream.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-14"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240514 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-14-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-14"
        });
    

        posts.push({
            'title'    : "📝[blog post] 연습 문제 풀이 정리(1)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging",
            'url'      : "/Backend/Post/2024-05-16-PracticeSummary-1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-16"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240516 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-16-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 예외 처리 - 트러블슈팅",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "📝[blog post] 연습 문제 풀이 정리(2)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging",
            'url'      : "/Backend/Post/2024-05-17-PracticeSummary-2.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240517 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 문자열 비교 - 트러블슈팅",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-18-Troubleshooting-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-18-Math-1.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "[Math] 수학적 귀납법",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-18-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "📝[blog post] 나는 어떤 백엔드 개발자가 되고 싶은걸까?",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "제로베이스, 백엔드, Java, Spring, 개발자, 백엔드공부, 백엔드스쿨",
            'url'      : "/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240518 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "💾 [CS] RAID의 정의와 종류",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-21-RAID.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 자료구조 소개",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-21-IntroDataStructureAndAlgorithm.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 선형 자료구조 - 배열",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-21-linearDS-Array.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240521 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-21-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "💾 [CS] 다양한 보조기억장치",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-22-VariousAuxiliaryMemoryDevices.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-22"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240522 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-22-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-22"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 큐(Queue)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-23-Queue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 원형 큐(Circular Queue)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-23-circularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240523 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-23-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 해시(Hash)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-24-Hash.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-24"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240524 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-24-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-24"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 해시 테이블(Hash Table)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-25-HashTable.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-25"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240525 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-25-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-25"
        });
    

        posts.push({
            'title'    : "💾 [CS] 장치 컨트롤러와 장치 드라이버",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-27-dviceControllerAndDeviceDriver.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 이진 트리(Binary Tree)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-BinaryTree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 완전 이진 트리(Complete Binary Tree)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-CompleteBinaryTree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 노드(Node)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-Node.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 트리(Tree)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-Tree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240527 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-27-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 스택(Stack)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-28-Stack.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-28"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240528 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-28-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-28"
        });
    

        posts.push({
            'title'    : "💾 [CS] 다양한 입출력 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-30-VariousInputOutputMethods.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-29"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240529 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-29-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-29"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 큐(Queue)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-30-Queue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-30"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240530 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-30-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-30"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 배열에서 특정 인덱스의 요소를 삭제하기.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-01-RemoveSpecificIndexFromArray.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-01"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240601 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-01-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-01"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Java의 배열.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-02-ArrayOfJava.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "📝[blog post] Java Docs 보는 방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging, Documentation",
            'url'      : "/Backend/Post/2024-06-02-HowToReadJavaDocs.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240602 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-02-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] IntStream",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-03-IntStream.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-03"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240603 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-03-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-03"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Deque(데크, 덱)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-05-Deque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-05"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240605 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-05-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-05"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] ArrayDeque",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-06-ArrayDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-06"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240606 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-06-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-06"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] LinkedList를 사용한 Deque.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-07-LinkedListDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-07"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240607 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-07-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 제네릭(Generic)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-08-Generic.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] Primitive Type과 Wrapper Class.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-08-PrimitiveAndWrapper.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240608 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-08-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)란?",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-09-CircularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성(Polymorphism)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-09-polymorphism.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240609 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-09-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Deque에서의 front와 rear의 변화.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-10-ChangeBetweenFrontAndRearInDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-10"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240610 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-10-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-10"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240611 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-11-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-11"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)의 중간 지점 찾기.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-12-CircularQueueFindMiddleIndex.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-12"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240612 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-12-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-12"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 알고리즘(Algorithm)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-13-AboutAlgorithm.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)를 배열로 구현시 rear를 -1으로 설정하지 않는 이유.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-13-ReasonOfRearIsntSetToMinusOneInCircularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240613 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-13-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📚[ENG] 240616 Studing English through Newsletters",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study, Newsletters",
            'url'      : "/Backend/ENG/240616-ENG-STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-16"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240616 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-16-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-16"
        });
    

        posts.push({
            'title'    : "💭 [Metacognition] 240616 JAVA의 정석",
            'path'     : "Metacognition > Java",
            'type'     : "post",
            'tags'     : "Metacognition, Java",
            'url'      : "/Metacognition/Java/2024-06-16-Meta-Java-PrimitiveType.html",
            'image'    : "/assets/img/thumbnail/META.jpg",
            'date'     : "2024-06-16"
        });
    

        posts.push({
            'title'    : "[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-06-17-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-06-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240617 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-17"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 클라우드 컴퓨팅의 유형",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240615_Types_of_Clould_Computing.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📚[ENG] 제목만 해석하는 영어 공부 :) ",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study",
            'url'      : "/Backend/ENG/240618_ENG_STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240618 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📚[ENG][240621] 제목만 해석하는 영어 공부 :)",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study",
            'url'      : "/Backend/ENG/240621-ENG-STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 프로그래밍 언어와 자바",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-24"
        });
    

        posts.push({
            'title'    : "📝[Post] 서버와 클라이언트의 개념(1)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-06-27-ServerAndClient-1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-06-27"
        });
    

        posts.push({
            'title'    : "☁️[AWS] HOSTNAME 바꾸는 방법",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240709_AWS_HOSTNAME.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-09"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023 플랫폼에 MySQL 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240710_AWS_MYSQL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-10"
        });
    

        posts.push({
            'title'    : "📝[Post] Spring과 SpringBoot의 개념.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-07-11-SpringAndSpringBoot.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-11"
        });
    

        posts.push({
            'title'    : "☁️[AWS] .gradlew 빌드 실패시 확인해야 할 것들",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240714_AWS_GRADLEW.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-14"
        });
    

        posts.push({
            'title'    : "💾[Database] 데이터베이스의 정의와 특징.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-07-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 프로그래밍 언어와 자바",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-16-Variable.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-16"
        });
    

        posts.push({
            'title'    : "📝[Post] 자바다식(Java多識) - 1",
            'path'     : "Backend > Java多識",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-19"
        });
    

        posts.push({
            'title'    : "📝[Post] 자바다식(Java多識) - 2",
            'path'     : "Backend > Java多識",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no2.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023에 Java8 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240726_AWS_JAVA_INSTALL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-26"
        });
    

        posts.push({
            'title'    : "💾[Database] MySQL DB에 한글 삽입.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database, MySQL",
            'url'      : "/Backend/DB/2024-07-26-korean-mysql.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-07-26"
        });
    

        posts.push({
            'title'    : "📝[Post] 아이피와 포트",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-07-28-ipAndport.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] @EntityListeners 어노테이션.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-31-EntityListeners.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] Main 클래스 생성 후 오류 대처.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-31-MainBuildFail.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] attribute의 의미와 역할",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-31-attribute.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "💾[Database] 트랜잭션의 의미와 역할.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/Backend/DB/2024-08-01-Transaction.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-08-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] ObjectMapper 클래스, 직렬화와 역직렬화",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-08-01-SerializationAndDeserialization.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] @Transactional의 역할과 의미.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-08-02-Transactional.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-02"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2에 Java8 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240804_AWS_JAVA8_INSTALL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] @RequiredArgsConstructor의 역할.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-08-05-RequiredArgsConstructor.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-05"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 클라우드(Cloud)란?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240807_AWS_CLOUD.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 온프레미스(on-premise)란?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240807_AWS_ON-PREMISE.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "📝[Post] 정적 웹사이트와 동적 웹사이트.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-07-webpage.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 로컬 파일을 EC2 서버에 올리는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240809_AWS_EC2_UPLOAD.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-09"
        });
    

        posts.push({
            'title'    : "🌐[Network] CIDR이란?",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-09-network-cidr.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-09"
        });
    

        posts.push({
            'title'    : "📝[Post] Nginx 설치방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-11-Nginx.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-11"
        });
    

        posts.push({
            'title'    : "🌐[Network] IP주소(Address)는 네트워크의 번지(주소)",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-14-network-ip.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-14"
        });
    

    searchPost(posts);

    
</script>
</html>

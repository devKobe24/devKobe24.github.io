<!DOCTYPE html>
<html lang="en">
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
    
        Backend
    
</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Index | devkobe24.com</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="Index">
<meta property="og:locale" content="en_US">
<meta name="description" content="Kobe - Developer blog">
<meta property="og:description" content="Kobe - Developer blog">
<meta property="og:site_name" content="devkobe24.com">
<meta property="og:type" content="article">
<meta property="article:published_time" content="1900-01-01T00:00:00+09:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Index">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"1900-01-01T00:00:00+09:00","datePublished":"1900-01-01T00:00:00+09:00","description":"Kobe - Developer blog","headline":"Index","mainEntityOfPage":{"@type":"WebPage","@id":"/Backend/"},"url":"/Backend/"}</script>
<!-- End Jekyll SEO tag -->


<link rel="shortcut icon" type="image/png" href="/assets/img/favicon.webp">
<style>
@font-face {
    font-family: 'Nunito Sans';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Nunito Sans'),
         url("/assets/fonts/NunitoSans-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Righteous';
    font-style: normal;
    font-weight: 600;
    font-display: optional;
    src: local('Righteous'),
         url("/assets/fonts/Righteous-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Lato';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Lato'),
         url("/assets/fonts/Lato-Regular.woff2") format("woff2");
}
</style>

<script src="/assets/js/fontfaceobserver.js" type="text/javascript"></script>
<script type="text/javascript">
    const nunitoObserver = new FontFaceObserver('Nunito Sans');
    const righteousObserver = new FontFaceObserver('Righteous');
    const latoObserver = new FontFaceObserver('Lato');
  
    Promise.all([
        nunitoObserver.load(),
        righteousObserver.load(),
        latoObserver.load(),
    ]).then(function(){
        document.documentElement.className += " fonts-loaded";
    });
</script>

<meta name="baseurl" content="">
<meta name="description" content="Kobe - Developer blog">
        <link rel="preload" href="/assets/img/profile.jpg" as="image">
        <link rel="stylesheet" href="/assets/css/style.css">
        
    </head>
    <body>
        <script type="text/javascript">
            let currentTheme = localStorage.getItem('theme');
        
            document.body.classList[currentTheme === 'dark' ? 'add' : 'remove']('dark-theme');
        </script>
        <canvas id="stars" width="100%" height="100%"></canvas>
        <div class="sidebar sidebar-left">
    <div class="side-banner">
        <h1 class="site-tab">
            <a href="/" class="site-name">
                <img src="/assets/img/icon/house.webp" alt="" loading="lazy">
                <mark>devkobe24.com</mark>
            </a>
            <button id="btn-brightness" aria-label="brightness-button">
                <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
                <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
            </button>
            <button id="btn-search" aria-label="search-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
            </button>
            <button id="btn-nav" aria-pressed="false" aria-label="menu-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"></path></svg>
            </button>
        </h1>
        <a href="/" class="site-avatar" aria-label="site-avatar">
            <img src="/assets/img/profile.jpg" loading="lazy" alt="homepage" aria-label="homepage-button">
        </a>
    </div>
    <div class="side-info">
        <nav id="navigation">
    
    
    

    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

    
    
    

    <ul class="nav-list">
<li id="nav-first" aria-label="2024">
            <div class="nav-item">
                <a href="/2024/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>2024</span>
                </a><button class="nav-list-expander" aria-label="toggle items in 2024 category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="AWS">
                    <div class="nav-item">
                        <a href="/2024/AWS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>AWS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CPP_DS">
                    <div class="nav-item">
                        <a href="/2024/CPP_DS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CPP_DS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CS">
                    <div class="nav-item">
                        <a href="/2024/CS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="DataStructure">
                    <div class="nav-item">
                        <a href="/2024/DataStructure/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>DataStructure</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Database">
                    <div class="nav-item">
                        <a href="/2024/Database/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Database</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="HackTheSwift">
                    <div class="nav-item">
                        <a href="/2024/HackTheSwift/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>HackTheSwift</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/2024/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Leet-Code">
                    <div class="nav-item">
                        <a href="/2024/Leet-Code/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Leet-Code</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="MySQL">
                    <div class="nav-item">
                        <a href="/2024/MySQL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>MySQL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Network">
                    <div class="nav-item">
                        <a href="/2024/Network/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Network</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="OS">
                    <div class="nav-item">
                        <a href="/2024/OS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>OS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Read English Book">
                    <div class="nav-item">
                        <a href="/2024/Read%20English%20Book/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Read English Book</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="SQL">
                    <div class="nav-item">
                        <a href="/2024/SQL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>SQL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Spring &amp; Spring Boots">
                    <div class="nav-item">
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Spring &amp; Spring Boots</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="TIL">
                    <div class="nav-item">
                        <a href="/2024/TIL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>TIL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Web">
                    <div class="nav-item">
                        <a href="/2024/Web/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Web</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="2024">
                    <div class="nav-item">
                        <a href="/Algorithm/2024/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>2024</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="2024">
                    <div class="nav-item">
                        <a href="/SQL/2024/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>2024</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Algorithm">
            <div class="nav-item">
                <a href="/Algorithm/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Algorithm</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Algorithm category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list"><li id="nav-second" aria-label="2024">
                    <div class="nav-item">
                        <a href="/Algorithm/2024/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>2024</span>
                        </a>
</div>
</li></ul>
</li>
<li id="nav-first" aria-label="Backend">
            <div class="nav-item">
                <a href="/Backend/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Backend</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Backend category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="AWS">
                    <div class="nav-item">
                        <a href="/Backend/AWS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>AWS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CS">
                    <div class="nav-item">
                        <a href="/Backend/CS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="DB">
                    <div class="nav-item">
                        <a href="/Backend/DB/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>DB</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="ENG">
                    <div class="nav-item">
                        <a href="/Backend/ENG/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>ENG</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Math">
                    <div class="nav-item">
                        <a href="/Backend/Math/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Math</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Network">
                    <div class="nav-item">
                        <a href="/Backend/Network/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Network</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Post">
                    <div class="nav-item">
                        <a href="/Backend/Post/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Post</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Spring">
                    <div class="nav-item">
                        <a href="/Backend/Spring/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Spring</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="TIL">
                    <div class="nav-item">
                        <a href="/Backend/TIL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>TIL</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Java">
            <div class="nav-item">
                <a href="/Java/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Java</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Java category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/2024/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java多識">
                    <div class="nav-item">
                        <a href="/Java/Java%E5%A4%9A%E8%AD%98/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java多識</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/Java/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="SQL">
            <div class="nav-item">
                <a href="/SQL/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>SQL</span>
                </a><button class="nav-list-expander" aria-label="toggle items in SQL category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="SQL">
                    <div class="nav-item">
                        <a href="/2024/SQL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>SQL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="2024">
                    <div class="nav-item">
                        <a href="/SQL/2024/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>2024</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Home">
            <div class="nav-item">
                <a href="/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Home</span>
                </a>
</div>
</li>
</ul>
</nav>
        <div id="contact">
            <hr>
            <h3>Contact</h3>
            <ul class="contact-list">
                
                    <li><a aria-label="My Github" href="https://github.com/devKobe24">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Email" href="mailto:dev.skyachieve91@gmail.com">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48H48zM0 176V384c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V176L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"></path></svg>
                    </a></li>
                
                <!-- 
                    <li><a aria-label="My Twitter" href="https://twitter.com/twitter">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.4 151.7c.3 4.5 .3 9.1 .3 13.6 0 138.7-105.6 298.6-298.6 298.6-59.5 0-114.7-17.2-161.1-47.1 8.4 1 16.6 1.3 25.3 1.3 49.1 0 94.2-16.6 130.3-44.8-46.1-1-84.8-31.2-98.1-72.8 6.5 1 13 1.6 19.8 1.6 9.4 0 18.8-1.3 27.6-3.6-48.1-9.7-84.1-52-84.1-103v-1.3c14 7.8 30.2 12.7 47.4 13.3-28.3-18.8-46.8-51-46.8-87.4 0-19.5 5.2-37.4 14.3-53 51.7 63.7 129.3 105.3 216.4 109.8-1.6-7.8-2.6-15.9-2.6-24 0-57.8 46.8-104.9 104.9-104.9 30.2 0 57.5 12.7 76.7 33.1 23.7-4.5 46.5-13.3 66.6-25.3-7.8 24.4-24.4 44.8-46.1 57.8 21.1-2.3 41.6-8.1 60.4-16.2-14.3 20.8-32.2 39.3-52.6 54.3z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Instagram" href="https://www.instagram.com/instagram">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Facebook" href="https://www.facebook.com/facebook">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M512 256C512 114.6 397.4 0 256 0S0 114.6 0 256C0 376 82.7 476.8 194.2 504.5V334.2H141.4V256h52.8V222.3c0-87.1 39.4-127.5 125-127.5c16.2 0 44.2 3.2 55.7 6.4V172c-6-.6-16.5-1-29.6-1c-42 0-58.2 15.9-58.2 57.2V256h83.6l-14.4 78.2H287V510.1C413.8 494.8 512 386.9 512 256h0z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My LinkedIn" href="https://www.linkedin.com/in/linkedin">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
                    </a></li>
                 -->
            </ul>
            <hr>
            <span>
                Copyright © 2024 | <a href="https://github.com/byanko55/jekyll-theme-satellite">Yankos</a>
            </span>
        </div>
    </div>
</div>
<div class="sidebar sidebar-right">
    <div class="tools">
        <button id="btn-brightness" aria-label="brightness-button">
            <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
            <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
        </button>
        <button id="btn-search" aria-label="search-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
        </button>
    </div>
</div>

        <div id="post">
            <div class="inner-header">
                <span class="dot" style="background-color: #F86158;"></span>
                <span class="dot" style="background-color: #FBBF2D;"></span>
                <span class="dot" style="background-color: #2ACB45;"></span>
            </div>
            <div class="inner-content">
                <div class="category-tree">
<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 576 512"><path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"></path></svg>
    <p>
                <a href="/">Home</a>
                &gt;
            
                
                    Backend
                
            </p>
</div>
                
                    <div id="loading">
    <div class="loading_box">
        <img src="/assets/img/loading.webp" loading="lazy">
        <p>Now Loading ...</p>
    </div>
</div>
                    <h1 class="category-header">
    
        Backend
    
</h1>
<div id="category-list">
    <ul class="paginated-list" data-current-page="1" aria-live="polite">
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/CS/2024-09-11-proxy-pattern-and-server-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/CS/2024-09-11-proxy-pattern-and-server-2.html"><h1 class="title_post">💾 [CS] 프록시 패턴과 프록시 서버 - 2</h1></a>
                        <a href="/Backend/CS/2024-09-11-proxy-pattern-and-server-2.html" class="txt_post">
                            💾 [CS] 프록시 패턴과 프록시 서버 - 2

1️⃣ 프록시 패턴(Proxy Pattern).

  프록시 패턴(Proxy Pattern)은 객체 지향 프로그래밍에서 사용되는 디자인 패턴 중 하나로, 어떤 객체에 대한 접근을 제어하기 위해 그 객체의 대리인 역할을 하는 별도의 객체(프록시, Proxy)를 제공하는 패턴입니다.
    
      이 패턴을 통해 클라이언트는 원래의 객체 대신 프록시 객체를 통해 간접적으로 원래의 객체에 접근할 수 있습니다.
    
  


1️⃣ 프록시 패턴의 주요 목적.

  1. 접근 제어 : 클라이언트가 실제 객체에 직접 접근하는 것을 제한하거나 제어할 수 있습니다.
  2. 지연 초기화(Lazy Initialization) : 실제 객체의 생성과 초기화를 필요할 때까지 미룰 수 있습니다.
    
      예를 들어, 메모리나 리소스 소모가 큰 객체를 사용하는 경우 성능을 최적화할 수 있습니다.
    
  
  3. 보호(Protection) : 특정 조건에서만 실제 객체에 접근할 수 있도록 보안을 강화할 수 있습니다.
  4. 원격 접근 : 원격 객체에 로컬 객체처럼 접근할 수 있도록 도와줍니다.


2️⃣ 프록시 패턴의 유형.

  1. 가상 프록시(Virtual Proxy)
    
      실제 객체의 생성을 지연시켜 성능을 최적화합니다.
        
          예를 들어, 이미지 로딩을 지연시켜 필요할 때만 로드할 수 있습니다.
        
      
    
  
  2. 보호 프록시(Protection Proxy)
    
      접근 권한이 없는 사용자나 클라이언트가 객체에 접근하는 것을 방지합니다.
        
          예를 들어, 특정 사용자만 큭정 기능을 사용할 수 있도록 제한할 수 있습니다.
        
      
    
  
  3. 원격 프록시(Remote Proxy)
    
      원격 서버에 위치한 객체를 로컬에서 사용하는 것처럼 보이도록 합니다.
        
          예를 들어, 분산 시스템에서 원격 메서드를 호출할 때 사용할 수 있습니다.
        
      
    
  
  4. 스마트 참조 프록시(Smart Reference Proxy)
    
      실제 객체에 대한 추가적인 행동을 수행합니다.
        
          예를 들어, 참조 횟수를 기록하거나, 객체에 접근할 때마다 로그를 남길 수 있습니다.
        
      
    
  


3️⃣ 프록시 패턴의 구조.

  프록시 패턴은 다음과 같은 구성 요소로 이루어집니다.
    
      Subject(주제) : 프록시와 실제 객체가 구현하는 인터페이스로, 공통된 메서드를 정의합니다.
      RealSubject(실제 주제) : 실제로 작업을 수행하는 객체입니다. 클라이언트가 원래 접근하고자 하는 대상입니다.
      Proxy(프록시) : RealSubject에 대한 참조를 가지고 있으며, RealSubject의 메서드를 호출하거나 접근을 제어하는 역할을 합니다.
    
  


4️⃣ 예제.

  예를 들어, 이미지를 로딩하는 프로그램이 있다고 가정해봅시다.
  이미지를 로드하는 작업은 시간이 오래 걸릴 수 있으므로, 이미지가 실제로 필요할 때까지 로딩을 지연시키고 싶습니다.
    
      이때 가상 프록시를 사용할 수 있습니다.
    
  


interface Image {
    void display();
}

class RealImage implements Image {
    private String filename;
    
    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();
    }
    
    private void loadFromDisk() {
        System.out.println("Loading " + filename);
    }
    
    @Override
    public void display() {
        System.out.println("Displaying " + filename);
    }
}

class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;
    
    public ProxyImage(String filename) {
        this.filename = filename;
    }
    
    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}

public class ProxyPatternExample {
    public static void main(String[] args) {
        Image image = new ProxyImage("test.jpg");
        
        // 실제로 이미지가 필요할 때만 로드합니다.
        image.display(); // Loading test.jpg, Displaying test.jpg
        image.display(); // Displaying test.jpg (이미 로드되었으므로 다시 로드하지 않습니다.)
    }
}



  위 코드에서 ProxyImage는 RealImage에 대한 프록시 역할을 합니다.
    
      ProxyImage를 통해 이미지를 로드할 때, 이미지를 실제로 필요할 때만 로드하도록 지연시킬 수 있습니다.
      두 번째 display() 호출에서는 이미 로드된 이미지가 있기 때문에 다시 로드하지 않습니다.
    
  
  이렇게 프록시 패턴은 클라이언트의 코드 변경 없이 실제 객체의 접근 방식이나 동작을 변경하거나 확장하는 데 유용하게 사용할 수 있습니다.


5️⃣ Java에서의 프록시 패턴.

  프록시 패턴(Proxy Pattern)은 Java에서도 매우 자주 사용되는 디자인 패턴 중 하나입니다.
    
      프록시 패턴은 어떤 객체에 대한 접근을 제어하기 위해 그 객체의 대리인 역할을 하는 별도의 객체(프록시 객체)를 제공하는 패턴입니다.
    
  
  Java에서 프록시 패턴은 다양한 상황에서 사용될 수 있으며, 대표적인 예시는 다음과 같습니다.
    
      1. 가상 프록시(Virtual Proxy)
        
          실제 객체의 생성을 지연시키고, 필요할 때에만 객체를 생성하도록합니다.
            
              예를 들어, 메모리나 리소스가 큰 객체의 생성을 지연시켜 성능을 향상시킬 수 있습니다.
            
          
        
      
      2. 보안 프록시(Protectioon Proxy)
        
          객체에 대한 접근을 제어하여, 특정 사용자나 조건에 따라 접근 권한을 부여하거나 제한할 수 있습니다.
            
              예를 들어, 사용자 인증이 필요한 시스템에서 특정 서비스나 자원에 접근할 때 사용됩니다.
            
          
        
      
      3. 원격 프록시(Remote Proxy)
        
          원격 서버에 위치한 객체를 로컬에서 사용하는 것처럼 보이도록 하는 패턴입니다.
            
              Java RMI(Remote Method Invocation)가 대표적인 예입니다.
            
          
        
      
      4. 캐싱 프록시(Caching Proxy)
        
          반복적으로 호출되는 메서드나 객체의 결과를 캐싱하여 성능을 최적화합니다.
        
      
    
  


6️⃣ Java에서 프록시 패턴을 구현하는 방법.

  프록시 클래스를 직접 구현
    
      인터페이스를 구현하는 프록시 클래스를 생성하여, 실제 객체에 대한 접근을 제어합니다.
    
  
  Java Dynamic Proxy
    
      Java의 java.lang.reflect.Proxy 클래스를 이용하여 런타임에 동적으로 프록시 객체를 생성할 수 있습니다.
        
          이 방법은 인터페이스 기반의 프록시 생성에 유용합니다.
        
      
    
  
  CGLIB
    
      인터페이스가 없는 클래스에 대해서도 프록시를 생성할 수 있도록 지원하는 라이브러리입니다.
        
          Spring 프레임워크에서는 주로 AOP(Aspect-Oriented Programming) 기능을 구현할 때 CGLIB을 활용합니다.
        
      
    
  
  프록시 패턴은 특히 Spring 프레임워크에서 AOP를 구현하거나, 트랜잭션 관리와 같은 크로스컷팅(Cross-cutting) 관심사를 처리할 때 널리 사용됩니다.


2️⃣ 프록시 서버(Proxy Server).

  프록시 서버(Proxy Server)는 컴퓨터 네트워크에서 클라이언트와 서버 간의 중계자 역할을 하는 서버입니다.
  프록시 서버는 클라이언트가 요청한 리소스(웹페이지, 파일 등)를 대신 받아서 클라이언트에게 전달하거나, 클라이언트의 요청을 다른 서버로 전달합니다.
    
      이를 통해 여러 가지 중요한 기능을 수행할 수 있습니다.
    
  


1️⃣ 프록시 서버의 주요 기능.

  1. 익명성 제공 : 클라이언트의 IP 주소를 숨기고, 대신 프록시 서버의 IP 주소로 서버에 접근합니다. 이를 통해 클라이언트는 익명성을 유지할 수 있으며, 서버는 클라이언트의 실제 IP 주소를 알지 못합니다.
  2. 보안 강화 : 프록시 서버는 클라이언트와 서버 간의 트래픽을 모니터링하고 제어할 수 있습니다. 이를 통해 불필요한 요청을 차단하거나, 특정 웹사이트 접근을 제한할 수 있습니다. 또한, 악성 트래픽을 필터링하여 네트워크 보안을 강화할 수 있습니다.
  3. 캐싱(Caching) : 프록시 서버는 자주 요청되는 리소스를 캐싱하여 서버의 부하를 줄이고, 클라이언트의 요청에 빠르게 응답할 수 있습니다. 예를 들어, 동일한 웹페이지가 여러 번 요청되는 경우, 프록시 서버는 이 페이지를 캐시에 저장해 두고, 이후 요청에 대해 캐시에서 직접 응답합니다.
  4. 콘텐츠 필터링 : 프록시 서버는 특정 콘텐츠에 대한 접근을 제한하거나 차단할 수 있습니다. 이는 학교, 기업 또는 가정에서 특정 웹사이트나 콘텐츠에 대한 접근을 제어하는 데 유용합니다.
  5. 로드 밸런싱 : 프록시 서버는 여러 서버에 걸쳐 트래픽을 분산시켜 로드 밸런싱을 할 수 있습니다. 이를 통해 서버의 부하를 균등하게 나누고, 시스템의 성능과 안정성을 향상시킬 수 있습니다.
  6. 데이터 압축 : 프록시 서버는 클라이언트와 서버 간에 주고받는 데이터를 압축하여 네트워크 트래픽을 줄이고, 응답 속도를 향상시킬 수 있습니다.


2️⃣ 프록시 서버의 유형.

  1. 정방향 프록시(Forward Proxy)
    
      클라이언트와 서버 사이에서 클라이언트의 요청을 대신 서버로 전달합니다.
      주로 클라이언트가 프록시 서버를 통해 외부 네트워크에 접근할 때 사용됩니다.
        
          예를 들어, 웹 브라우저 설정에서 프록시 서버를 저장하면, 모든 웹 트래픽이 이 프록시 서버를 통해 전달됩니다.
        
      
    
  
  2. 리버스 프록시(Reverse Proxy)
    
      서버와 클라이언트 사이에서 서버를 대신하여 클라이언트의 요청을 처리합니다.
      주로 웹 서버 앞단에 위치하여 서버의 부하를 줄이고, 보안을 강화하며, 로드 밸런싱을 수행합니다.
      리버스 프록시는 클라이언트가 실제 서버의 위치를 알지 못하게 하여 보안을 강화할 수 있습니다.
    
  
  3. 웹 프록시(Web Proxy)
    
      웹 브라우저를 통해 특정 웹사이트에 접근할 때 사용하는 프록시 서버입니다.
      사용자는 웹 프록시 사이트를 통해 차단된 웹사이트에 접근하거나, 익명으로 웹을 탐색할 수 있습니다.
    
  
  4. 트랜스페어런트 프록시(Transparent Proxy)
    
      클라이언트가 프록시 서버를 사용하고 있다는 사실을 모르게 하면서 트래픽을 중계하는 프록시 서버입니다.
      주로 ISP(인터넷 서비스 제공자)나 기업 네트워크에서 트레픽을 모니터링하거나 필터링하는 데 사용됩니다.
    
  


3️⃣ 프록시 서버의 예.

  회사 네트워크에서의 프록시 서버
    
      회사는 직원들이 인터넷에 접근할 때 프록시 서버를 통해 접근하도록 설정할 수 있습니다.
      이 프록시 서버는 직원들이 어떤 웹사이트에 접근하는지 모니터링하고, 필요에 따라 특정 사이트에 대한 접근을 차단할 수 있습니다.
    
  
  공공 Wi-Fi의 프록시 서버
    
      공공 Wi-Fi 네트워크는 프록시 서버를 통해 사용자 트래픽을 모니터링하고, 보안을 강화할 수 있습니다.
      이를 통해 악성 사이트에 대한 접근을 차단하거나, 네트워크를 통해 전송되는 데이터를 암호화할 수 있습니다.
    
  
  프록시 서버는 네트워크의 성능, 보안, 그리고 사용자 경험을 개선하기 위한 강력한 도구로 사용됩니다.


4️⃣ Java에서의 프록시 서버(Proxy Server) 사용 사례.

  프록시 서버는 네트워크 환경에서 클라이턴트와 서버 간의 중계자 역할을 하는 서버입니다.
    
      Java에서는 다양한 상황에서 프록시 서버를 사용할 수 있으며, 그 활용 방법도 매우 다양합니다.
    
  
  1. HTTP/HTTPS 프록시
    
      Java 애플리케이션이 외부 네트워크에 요청을 보내야 할 때, 프록시 서버를 통해 트래픽을 중계할 수 있습니다.
      이를 통해 보안, 로깅, 캐싱, IP 마스킹 등을 수행할 수 있습니다.
        System.setProperty("http.proxyHost", "proxy.example.com");
System.setProperty("http.proxyPort", "8080");
System.setProperty("https.proxyHost", "proxy.example.com");
System.setProperty("https.proxyPort", "8080");
        
      
    
  
  
    위와 같이 시스템 프로퍼티를 설정하여 Java 애플리케이션이 HTTP 및 HTTPS 요청을 보낼 때 프록시 서버를 사용하도록 할 수 있습니다.
  
  2. SOCKS 프록시
    
      Java에서는 SOCKS 프록시를 사용하여 TCP/IP 기반의 모든 연결을 프록시 서버를 통해 중계할 수 있습니다.
      SOCKS 프록시는 HTTP/HTTPS 프록시보다 더 일반적인 트래픽을 처리할 수 있습니다.
        System.setProperty("socksProxyHost", "proxy.example.com");
System.setProperty("socksProxyPort", "1080");
        
      
    
  
  
    이렇게 설정하면 Java 애플리케이션이 TCP/IP 연결을 시도할 때 SOCKS 프록시 서버를 통해 연결을 시도합니다.
  
  3. RMI(Remote Method Invocation) 프록시
    
      Java RMI는 분산 애플리케이션을 구현하기 위해 원격 메서드 호출을 가능하게 하는 기술입니다.
      RMI에서 프록시를 사용하여 클라이언트가 원격 객체에 접근할 때 로컬 객체처럼 접근할 수 있도록 합니다.
    
  
  4. Spring Clould Gateway
    
      마이크로서비스 아키텍처에서 Java로 개발된 서비스들을 연결하고 API 게이트웨이 역할을 수행하는 데 Spring Clould Gateway와 같은 프록시 서버 역할을 하는 프레임워크를 사용할 수 있습니다.
      이는 마이크로서비스 간의 통신을 관리하고, 보안, 로깅, 인증/인가를 담당하는 데 사용됩니다.
    
  
  5. Reverse Proxy
    
      Java 웹 애플리케이션 서버는 리버스 프록시 서버 뒤에서 실행될 수 있습니다.
      예를 들어, Nginx나 Apache HTTP Server를 프록시로 설정하여 클라이언트의 요청을 Java 웹 애플리케이션으로 전달할 수 있습니다.
    
  


5️⃣ 프록시 서버 사용의 장점.

  보안 강화
    
      클라이언트와 서버 사이의 트래픽을 모니터링하고, 특정 요청을 차단하거나 허용할 수 있습니다.
    
  
  캐싱
    
      프록시 서버는 자주 요청되는 데이터를 캐시하여 서버 부하를 줄이고 응답 속도를 향상시킬 수 있습니다.
    
  
  트래픽 관리
    
      프록시 서버는 네트워크 트래픽을 관리하고, 로드 밸런싱과 같은 기능을 통해 시스템의 성능을 최적화할 수 있습니다.
    
  
  IP 마스킹
    
      클라이언트의 IP 주소를 숨기고, 프록시 서버의 IP 주소를 대신 사용할 수 있습니다.
    
  
  Java 애플리케이션에서 프록시 서버를 사용하는 것은 네트워크 환경을 제어하고 보안을 강화하며 성능을 최적화하는데 매우 유용합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-09-07-understand-of-protocol.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-09-07-understand-of-protocol.html"><h1 class="title_post">🌐[Network] 네트워크 개념 - 프로토콜의 이해</h1></a>
                        <a href="/Backend/Network/2024-09-07-understand-of-protocol.html" class="txt_post">
                            🌐[Network] 네트워크 개념 - 프로토콜의 이해

Preview

  데이터 통신의 개념과 프로토콜의 동작 원리를 이해하는 데 스마트폰은 많은 도움을 줍니다.
    
      스마트폰으로 전화를 거는 사람(송신자)과 받는 사람(수신자)은 서로 합의하여 통화 연결을 설정합니다
      데이터 전송 단계인 통화 과정에서는 묵시적인 규칙에 따라 대화를 주고받는 일련의 절차가 진행됩니다.
      스마트폰은 양쪽이 동시에 말할 수 있는 양방향 통신기능을 지원하지만, 실제로 두 사람이 동시에 말하는 경우는 거의 없고, 느낌이나 말의 내용 등에 따라 번갈아가며 대화합니다.
      상대방이 한 말을 이해하지 못했거나 제대로 듣지 못한 경우에는 다시 묻는 방식을 통하여 오류를 바로 잡기도 합니다.
      이와 같은 대화 과정의 절차나 대화 내용을 올바르게 이해하는 과정이 모두 프로토콜의 기능에 포함됩니다.
    
  
  네트워크에서 데이터 전송 원리도 이와 비슷합니다.
    
      통신 프로토콜에서 중심적으로 다루는 내용은 주소 개념을 포함하여 데이터 전송 오류에 관한 오류 복구 기능, 전송 속도 조절에 관한 흐름 제어 기능, 데이터의 전달 경로에 관한 라우팅 기능입니다.
      스마트폰을 사용한 대화 과정에서 사람들이 무의식적으로 행하는 통화 기법이 통신 프로토콜의 설계 과정에 그대로 반영되어 있습니다.
        
          그러나 통화 과정은 간단해 보여도 이를 통신 프로토콜로 작성하는 일은 생각보다 쉽지 않습니다.
        
      
    
  
  인터넷의 동작 원리를 이해하려면 계층 구조로 설계된 OSI 7계층 모델에 대한 할습이 선행되어야 합니다.
    
      특히, 모듈화 설계 개념의 원리와 상하 계층의 역할 분담에 대한 학습을 통하여 계층별 프로토콜의 역할을 이해해야 합니다.
      인터넷에서 사용되는 데이터 전송 프로토콜인 TCP, UDP, IP 프로토콜은 계층 구조 모델의 원리에 따라 설계되었으며, 기타 제어 프로토콜의 동작도 계층 구조의 원리에 따라 이루어집니다.
    
  


1️⃣ 프로토콜의 이해

  네트워크에 연결된 시스템이 통신하려면 정해진 규칙에 따라 순차적으로 데이터를 주고 받아야 하는데, 이러한 일련의 규칙을 “프로토콜(Protocol)” 이라 합니다.
  프로토콜의 동작 과정은 전송 오류 여부, 데이터 전달 경로, 전송 속도 등 다양한 외부 요인의 영향을 받습니다.
    
      따라서 적절한 대응 방안을 마련해 효율적으로 관리해야 하는데, 프로토콜의 설계 과정은 모듈(Module)화를 통하여 이루어집니다.
        
          이렇게 함으로써 시스템의 복잡성을 단순화하고, 사용자에게 더 편리하고 간편한 통신 기능을 제공할 수 있습니다.
        
      
    
  


1️⃣ 계층적 모듈 구조

  일반적으로 복잡하고 큰 시스템의 기능은 특정 단위의 모듈로 나누어 설계합니다.
    
      각각의 모듈은 독립적으로 동작하면서도 상호 유기적으로 통합될 수 있어야 합니다.
        
          그러므로 모듈과 모듈을 서로 연동해 동작시키는 적절한 인터페이스가 필요합니다.
        
      
    
  


모듈화

  컴퓨터를 하드웨어 측면에서 보면 CPU, 메모리, 하드디스크, LAN 카드 등과 같은 작은 부품들이 모여 하나의 시스템을 구성합니다.
    
      복잡한 시스템을 기능별로 모듈화하면 시스템 구조가 단순해져서 전체 시스템을 이해하기 쉽습니다.
        
          또한 각 단위 모듈이 독립적인 기능을 수행하기 때문에 고장이나 업그레이드 등의 상황에 손쉽게 대처할 수 있습니다.
        
      
    
  
  소프트웨어 측명에서 보면, 일반 프로그래밍 언어에서는 함수의 개념을 사용해 전체 프로그램을 모듈화할 수 있습니다.
    
      함수별로 특정 기능을 독립적으로 수행하도록 함으로써, 각 함수가 개별적으로 설계되고 구현된다는 장점이 있습니다.
        
          함수 사이의 인터페이스는 함수의 매개변수에 의해서만 이루어지므로 전체 시스템을 이해하기가 훨씬 쉽습니다.
            
              즉, 함수의 역할이 매개변수로 추상화되므로 내부 구조를 이해하지 않고도 함수들을 이해할 수 있고, 이들의 모임인 전체 시스템도 쉽게 이해할 수 있습니다.
            
          
        
      
    
  





  위 그림은 시스템 모듈화의 장점을 보여줍니다.
    
      (a)처럼 전체 시스템을 기능에 따라 세 부분으로 나누어 설계할 수 있는데, 이때 각 모듈은 정해진 인터페이스에 맞게 유기적으로 연결되어야 합니다.
      B 모듈은 A 모듈과 곡선 모양의 인터페이스로 연결되고, C 모듈과는 톱니 모양의 인터페이스로 연결됩니다.
      A와 C 모듈은 직접 연결되는 인터페이스가 없으며, B 모듈을 통해 간접적인 관계를 유지합니다.
    
  
  위 그림의 시스템을 모듈화하지 않았다면 한 부분만 고장나도 전체 시스템을 교체해야 합니다.
    
      반면 모듈화하여 설계하면 B 모듈에 대하여 (a)의 버전 1을 (b)의 버전 2로 교체하면 됩니다.
      그림에서 설명한 것과 같이 B 모듈의 동작에 오류가 확인되었거나 기능이 개선된 경우 A 모듈이나 B 모듈과 관계없이 B 모듈만 수정하는 방식입니다.
        
          이때 모듈 내부의 처리 과정은 임의로 개선할 수 있으나, A와 C 모듈 간 인터페이스는 동일하게 유지해야 전체 시스템 동작에 영향을 주지 않습니다.
        
      
    
  


계층 구조

  분할된 모듈들은 협력 관계를 유지하면서 유기적으로 동작합니다.
  모듈 구조는 서로 동등한 위치에서 서비스를 주고받을 수도 있고 특정 모듈이 다른 모듈에 서비스를 제공하는 형식의 계층 구조를 이루기도 합니다.
  네트워크에서는 독립적인 고유 기능을 수행하는 모듈들이 상하 계층 구조로 연결되어 동작합니다.





  계층 구조에서는 위 그림에서처럼 상위 계층이 하위 계층에 특정 서비스를 요청하는 방식으로 동작합니다(1).
  요청을 받은 하위 계층은 해당 서비스를 실행하여 그 결과를 상위 계층에 돌려줍니다(2).
  하위 계층의 실행 결과는 상위 계층에 결과 값을 직접 전달하는 방식이 될 수도 있고, 주변 환경 값을 변경하는 부수 효과(Side Effect) 방식일 수도 있습니다.
  자동차의 경우를 예로 들어봅시다.
    
      운전자가 자동차의 속도를 줄이려면 브레이크를 밟아야 하고 브레이크를 누르는 정도에 따라 속도가 줄어듭니다.
        
          이 구조에서 운전자는 상위 계층에 해당되며, 자동차 내부에서 속도를 줄이는 기능은 하위 계층의 모듈이 됩니다.
            
              운전자와 감속 모듈 사이에는 브레이크라는 인터페이스가 존재합니다.
                
                  브레이크 인터페이스가 정의되면 상위 계층의 운전자가 바뀌거나 하위 계층의 자동차가 바뀌어도 둘 사이의 서비스 개념을 유지할 수 있습니다.
                
              
            
          
        
      
    
  
  네트워크에서 통신하는 시스템들은 계층 구조로 모듈화된 기능이 각각 동작하며, 둘 사이의 같은 계층끼리 데이터를 전달합니다.
    
      이때 데이터를 전달하는 규칙을 프로토콜이라 합니다.
    
  
  모듈화된 계층 구조 프로토콜에는 다양한 장점이 있지만, 대표적인 장점 몇 가지를 정리하면 다음과 같습니다.
    
      
        
          복잡하고 큰 시스템을 기능별로 작게 분류해서 간단하고 작은 시스템으로 재구성할 수 있습니다.
            
              따라서 전체 시스템을 이해하기 쉽고, 시스템을 설계하고 구현하기도 편리합니다.
            
          
        
      
      
        
          상하 계층에 인접한 모듈 사이의 인터페이스를 포함하여 분할된 모듈이 연동할 수 있는 표준 인터페이스를 제공합니다.
            
              모듈 인터페이스는 가능하면 단순하게 구현하여 모듈들이 최대한 독립적으로 동작하도록 해야합니다.
              모듈의 독립성은 전체 시스템의 구조를 단순하게 만들어줍니다.
            
          
        
      
      
        
          전송 매체 양단에 있는 호스트가 수행하는 프로토콜들은 좌우 대칭 구조입니다.
            
              대칭 구조에서는 통신 양단에 위치하는 동일 계층 사이의 프로토콜을 단순화할 수 있습니다.
            
          
        
      
      
        
          각 계층의 기능 오류를 수정하거나 향상시켜야 하는 경우에 전체 시스템을 재작성하지 않고 해당 계층의 모듈만 교체하면 됩니다.
            
              즉, 상하 혹은 좌우 계층 간의 인터페이스를 유지하면 특정 계층의 내부 변경이 다른 모듈의 동작에 영향을 미치지 않습니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/CS/2024-09-07-proxy-pattern-and-server.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/CS/2024-09-07-proxy-pattern-and-server.html"><h1 class="title_post">💾 [CS] 프록시 패턴과 프록시 서버</h1></a>
                        <a href="/Backend/CS/2024-09-07-proxy-pattern-and-server.html" class="txt_post">
                            💾 [CS] 프록시 패턴과 프록시 서버

1️⃣ 프록시 패턴

  프록시 패턴(proxy pattern)은 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층에 있는 디자인 패턴입니다.





  이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용합니다.
    
      이는 앞서 설명한 프록시 객체로 쓰이기도 하지만 프록시 서버로도 활용됩니다.
    
  



  용어: 프록시 서버에서의 캐싱
캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 저 멀리 있는 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것을 말합니다.
이를 통해 불필요하게 외부와 연결하지 않기 때문에 트래픽을 줄일 수 있다는 장점이 있습니다.


2️⃣ 프록시 서버

  프록시 서버(proxy server)는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킵니다.


프록시 서버로 쓰는 nginx

  nginx는 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버이며, 주로 Node.js 서버 앞단의 프록시 서버로 활용됩니다.
  Node.js의 창시자 라인언 달은 다음과 같이 말했습니다 “Node.js의 버퍼 오버플로우 취약점을 예방하기 위해서는 nginx를 프록시 서버로 앞단에 놓고 Node.js를 뒤쪽에 놓는 것이 좋다.”라고 한 것입니다.
    
      이러한 말은 Node.js 서버를 운영할 때 교과서처럼 참고되어 많은 사람이 이렇게 구축하고 있습니다.
        
          Node.js 서버를 구축할 때 앞단에 nginx를 두는 것이죠.
            
              이를 통해 익명 사용자가 직접적으로 서버에 접근하는 것을 차단하고, 간접적으로 한 단계를 더 거치게 만들어서 보안을 강화할 수 있습니다.
            
          
        
      
    
  





  위의 그림처럼 nginx를 프록시 서버로 뒤서 실제 포트를 숨길 수 있고 정적 자원을 gzip 압축하거나, 메인 서버 앞단에서의 로깅을 할 수도 있습니다.



  용어: 버퍼 오버플로우
버퍼는 보통 데이터가 저장되는 메모리 공간으로, 메모리 공간을 벗어나는 경우를 말합니다. 이때 사용되지 않아야 할 영역에 데이터가 덮어씌어져 주소, 값을 바꾸는 공격이 발생하기도 합니다.



  용어: gzip 압축
LZ77과 Huffman 코딩의 조합인 DEFLATE 알고리즘을 기반으로 한 압축 기술입니다.
gzip 압축을 하면 데이터 전송량을 줄일 수 있지만, 압축을 해제했을 때 서버에서의 CPU 오버 헤드도 생각해서 gzip 압축 사용 유무를 결정해야 합니다.


프록시 서버로 쓰는 CloudFlare

  CloudFlare는 전 세계적으로 분산된 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스입니다.
  CloudFlare는 웹 서버 앞단에 프록시 서버로 두어 DDOS 공격 방어나 HTTPS 구축에 쓰입니다.
    
      또한, 서비스를 배포한 이후에 해외에서 무안가 의심스러운 트래픽이 많이 발생하면 이 떄문에 많은 클라우드 서비스 비용이 발생할 수도 있는데, 이때 CloudFlare가 의심스러운 트래픽인지를 먼저 판단해 CAPTCHA 등을 기반으로 이를 일정부분 막아주는 역할도 수행합니다.
    
  





  위의 그림처럼 사용자, 크롤러, 공격자가 자신의 웹 사이트에 접속하게 될 텐데, 이때 CloudFlare를 통해 공격자로부터 보호할 수 있습니다.


DDOS 공격 방어

  DDOS는 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형입니다.
  CloudFlare는 의심스러운 트래픽, 특히 사용자가 접속하는 것이 하닌 시스템을 통해 오는 트래픽을 자동으로 차단해서 DDOS 공격으로부터 보호합니다.
  CloudFlare의 거대한 네트워크 용량과 캐싱 전략으로 소규모 DDOS 공격은 쉽게 막아낼 수 있으며 이러한 공격에 대한 방화벽 대시보드도 제공합니다.


HTTPS 구축

  서버에서 HTTPS를 구축할 때 인증서를 기반으로 구축할 수도 있습니다.
    
      하지만 CloudFlare를 사용하면 별도의 인증서 설치 없이 좀 더 손쉽게 HTTPS를 구축할 수 있습니다.
    
  



  용어: CDN(Content Delivery Network)
각 사용자가 인터넷에서 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 말합니다.
이를 통해 사용자가 웹 서버로부터 콘텐츠를 다운로드하는 시간을 줄일 수 있습니다.


CORS와 프런트엔트의 프록시 서버

  CORS(Cross-Origin Resource Sharing)는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘입니다.





  프런트엔드 개발 시 프런트엔드 서버를 만들어서 백엔드 서버와 통신할 때 주로 CROS 에러를 마주치는데, 이를 해결하기 위해 프런트엔트에서 프록시 서버를 만들기도 합니다.



  용어: 오리진
프로토콜과 호스트 이름, 포트의 조합을 말합니다.
예를 들어 https://devkobe24.com:12010/test라는 주소에서 오리진은 https://devkobe24.com:12010을 뜻합니다.



  예를 들어 프런트엔드에서는 127.0.0.1:3000으로 테스팅을 하는데 백엔드 서버는 127.0.0.1:12010이라면 포트 번호가 다르기 때문에 CROS 에러가 나타납니다.
    
      이때 프록시 서버를 둬서 프런트엔드 서버에서 요청되는 오리진을 127.0.0.1:12010으로 바꾸는 것입니다.
    
  
  참고로 127.0.0.1이란 루프백(loopback) IP로, 본인 IP 서버의 IP를 뜻합니다.
    
      localhost나 127.0.0.1을 주소창에 입력하면 DNS를 거치지 않고 바로 본인 PC 서버로 연결됩니다.
    
  





  위의 그림처럼 프런트엔드 서버 앞단에 프록시 서버를 놓아 /api 요청은 user API, /api2 요청은 user API2에 요청할 수 있습니다.
    
      자연스레 CORS 에러 해결은 물론이며 다양한 API 서버와의 통신도 매끄럽게 할 수 있는 것입니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-09-05-network-basic-summary.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-09-05-network-basic-summary.html"><h1 class="title_post">🌐[Network] 네트워크 기초 - Summary</h1></a>
                        <a href="/Backend/Network/2024-09-05-network-basic-summary.html" class="txt_post">
                            🌐[Network] 네트워크 기초 - Summary.

1️⃣ 네트워크 기초 용어.

  “네트워크” 는 전송 매체를 매개로 데이터를 교환하는 시스템의 모음입니다.
  시스템과 전송 매체의 연결 지점에 대한 규격이 “인터페이스” 입니다.
  시스템이 데이터를 교환할 때는 통신 규칙인 “프로토콜” 이 필요합니다.
  “인터페이스” 와 “프로토콜” 은 서로 다른 시스템을 상호 연동해 동작시키기 위함이므로 반드시 “연동 형식의 통일” 이 필요하고, 이를 “표준화” 라 합니다.
  “인터넷” 은 “IP” 라는 네트워크 프로토콜이 핵심적인 역할을 하는 “네트워크 집합체” 입니다.


2️⃣ 프로토콜.

  상호 연동되는 시스템이 데이터를 교환할 때 사용하는 표준화된 규칙을 “프로토콜” 이라 합니다.
  일반적으로 “프로토콜” 은 “동등한 위치에 있는 시스템 사이의 규칙이라는 측면이 강조” 되어 인터페이스와 구분 됩니다.
    
      즉, 7계층 모델에서 프로토콜은 같은 계층 사이의 관계를 다루기 때문에 각각의 계층마다 서로 다른 프로토콜이 존재합니다.
    
  
  일반적으로 프로토콜은 주고받은 데이터의 형식과 그 과정에서 발생하는 일련의 절차적 순서를 규정하고 있습니다.


3️⃣ 클라이언트와 서버.

  “클라이언트와 서버” 의 개념은 “인터넷 서비스를 기준” 으로 “구분” 됩니다.
    
      그 차이가 “서비스 단위” 로 이루어지므로 “임의의 호스트가 클라이언트나 서버로 고정”되지는 않습니다.
        
          서비스를 제공하면 서버가 되고 이 서비스를 이용하면 클라이언트가 되므로 특정 서비스를 기준으로 상대적인 관점에서 클라이언트와 서버를 사용합니다.
            
              다양한 서비스 제공을 목적으로 하는 특화된 호스트인 경우는 호스트 자체를 서버라 부르기도 합니다.
            
          
        
      
    
  
  서버는 클라이언트보다 먼저 실행 상태가 되어 클라이언트의 요청에 대기해야 합니다.


4️⃣ OSI 7계층 모델.

  다수의 시스템을 서로 연결해서 통신하려면 선행적으로 전체 시스템 구조를 표준화해야 합니다.
  국제 표준화 단체인 ISO에서는 OSI 7계층 모델을 제안하여, 네트워크에 연결된 시스템이 갖추어야 할 기본 구조와 기능을 정의하고 있습니다.
    
      응용 계층
      표현 계층
      세션 계층
      전송 계층
      네트워크 계층
      데이터 링크 계층
      물리 계층
        
          이런 계층적인 구조로 기능을 세분화하였습니다.
        
      
    
  
  일반 사용자는 응용 계층을 통해 데이터 전송을 요청하며, 이 요청은 물리 계층까지 순차적으로 전달되어 상대 호스트에 전송됩니다.
    
      전송된 데이터는 물리 계층에서 순차적으로 응용 계층까지 전달됩니다.
    
  


5️⃣ 인터네트워킹.

  네트워크와 네트워크의 연결을 인터네트워킹이라고 합니다.
  인터네트워킹 기능을 수행하는 시스템을 일반적으로 게이트웨이 라 부릅니다.
  게이트웨이 는 기능에 따라 종류가 다양하지만
    
      리피터
      브리지
      라우터
      등등..
        
          가장 일반적인 구분 방식입니다.
        
      
    
  
  리피터는 물리 계층의 기능을 지원하며, 브리지는 리피터 기능에 데이터 링크 계층의 기능이 추가된 것으로 물리 계층에서 발생한 오류를 해결해줍니다.
  라우터는 물리 계층, 데이터 링크 계층, 네트워크 계층의 기능을 지원하므로 경로 선택 기능이 존재합니다.


6️⃣ 데이터 단위.

  네트워크 프로토콜을 사용해 데이터를 교환할 때는 먼저 데이터를 특정 형태로 규격화하는 작업이 필요합니다.
    
      이와 같은 한 단위의 규격으로 묶인 전송 데이터를 데이터 단위라 하며, 계층에 상관없이 호칭할 때는 통칭하여 PDU라 부릅니다.
      특별히 네트워크 계층에서는 패킷, 데이터 링크 계층에서는 프레임이라는 용어가 중요하게 사용됩니다.
    
  


7️⃣ 주소의 표현.

  주소의 개념은 단순히 서로를 구분한다는 고유의 목적을 넘어 주소가 가리키는 대상의 특징을 표현할 수 있습니다.
  사람들은 문자로 된 이름에 익숙하지만, 0과 1로 디지털화된 환경에서는 구분자를 숫자로 된 주소로 표현할 수밖에 없습니다.
  숫자로 된 주소 표현 방식은 일반 사용자에게 불편하므로 외우기 쉬운 문자 형식의 이름을 추가로 사용합니다.
  인터넷에서 일반 사용자는 문자로 된 이름을 사용하고, 인터넷 내부는 숫자로 된 주소를 사용하므로 둘 사이의 변환 기능이 필요합니다.
  주소에서 구분자는 유일성, 확장성, 편리성, 정보의 함축이라는 네 가지 특징을 갖습니다.


8️⃣ IP 주소.

  IP 주소는 네트워크 계층의 기능을 수행하는 IP 프로토콜이 호스트를 구분하기 위하여 사용하는 주소 체계입니다.
  임의의 호스트를 인터넷에 연결하려면 반드시 IP 주소를 할당받아야 합니다.
  IP 주소는 32비트의 이진 숫자로 구성되는데, 보통 8비트씩 네 부분으로 나누어 십진수로 표현합니다.
  IP 주소는 유일성을 보장하기 위해서 국제 표준화 기구가 전체 주소를 관리하고 할당하기 때문에 중복 주소의 사용을 원천적으로 차단합니다.
  IP 주소는 임의로 할당되는 것이 아니라, 특정 규칙에 따라 인접한 주소들을 그룹으로 묶어 관리합니다.
    
      따라서 IP 주소는 네트워크 계층에서 경로를 선택할 때 중요한 기준이 됩니다.
    
  


9️⃣ DNS 서비스

  인터넷에서 호스트와 연결하려면 해당 호스트의 IP 주소를 알아야합니다.
    
      그런데 숫자로 된 IP 주소는 기억하기 힘들어서 의미 파악이 쉬운 문자로 된 호스트 이름을 사용하는 것이 일반적입니다.
        
          따라서 가장 먼저 수행할 작업은 DNS라는 이름과 주소 변환 기능을 이용해서 IP 주소를 얻는 것입니다.
        
      
    
  
  DNS는 주소와 이름 정보를 자동으로 유지하고 관리하는 분산 데이터베이스 시스템입니다.
    
      호스트 주소와 이름 정보는 네임 서버라는 특정한 관리 호스트가 유지하고, 주소 변환 작업이 필요한 클라이언트는 네임 서버에 요청해서 IP 주소를 얻습니다.
    
  


1️⃣0️⃣ 다양한 주소의 종류

  네트워크에서 사용하는 주소는 이를 사용하는 환경에 따라 다양합니다.
  OSI 7계층 모델의 각 계층에서도 목적에 따라 여러 형탱의 주소가 사용됩니다.
  MAC 주소는 계층 2의 MAC 계층에서 사용하며, 일반적으로 LAN 카드에 내장되어 있습니다.
    
      물리 계층을 통해 데이터를 전송할 때는 MAC 주소를 이용해서 호스트를 구분합니다.
    
  
  IP 주소는 네트워크 계층의 기능을 수행하는 IP 프로토콜에서 사용되며, IP 패킷이 지나가는 경로를 결정하는 라우팅의 기준이 됩니다.
  포트 주소는 전송 계층에서 사용하며, 호스트에서 실행되는 프로세스를 구분해줍니다.
  메일 주소는 응용 계층의 메일 시스템에서 사용자를 구분하려고 사용합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-09-05-address-info-management.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-09-05-address-info-management.html"><h1 class="title_post">🌐[Network] 주소 정보의 관리</h1></a>
                        <a href="/Backend/Network/2024-09-05-address-info-management.html" class="txt_post">
                            🌐[Network] 주소 정보의 관리.

  일반 사용자가 호스트를 지칭할 때 사용하는 호스트 이름을 도메인 이름(Domain Name)이라 하며, 인터넷에서는 www.korea.co.kr과 같은 도메인 이름을 IP 주소로 변환하는 작업이 필요합니다.
  초기 인터넷에서는 아주 간단한 방법으로 호스트 이름과 IP 주소를 변환하였으나, 지금은 DNS라는 분산 데이터베이스 시스템을 사용해서 보다 체계적인 방법으로 관리하고 있습니다.


1️⃣ 호스트 파일.

  호스트 이름과 IP 주소를 변환하는 간단한 방법은 특정 파일(예: UNIX 시스템의 /etc/hosts)에 호스트 이름과 IP 주소의 조합을 기록하여 관리하는 것입니다.
  네트워크 응용 프로그램에서는 사용자가 입력한 호스트 이름을 이 파일에서 검색하여 일대일로 대응된 IP 주소 정보를 쉽게 얻을 수 있습니다.
  호스트 파일은 한 줄에 하나의 호스트 정보가 기록되며, 일반 텍스트 문서 형식으로 보관됩니다.
    
      즉, 아래의 그림을 예로 들면 호스트 이름이 white.korea.co.kr인 시스템의 IP 주소는 211.223.201.27입니다.
    
  





  네트워크 관리자는 관리 대상이 되는 모든 호스트의 이름, 주소 정보를 주기적으로 갱신하고, 이 정보를 네트워크에 연결된 모든 호스트가 복사하도록 함으로써 정보의 일관성을 유지해야 합니다.
  위 그림은 네트워크 관리자가 white.korea.co.kr 에서 호스트 정보를 갱신할 때 갱신된 정보를 다른 4개의 호스트가 복사하여 저장하는 모습을 보여줍니다.
  소스트 파일을 갱신하고 복사하는 작업은 보통 시스템 관리자가 수작업으로 했었습니다.
  호스트가 추가되거나 삭제되면 먼저 네트워크 관리자의 호스트에서 갱신 작업이 이루어집니다
    
      그런데 인터넷이 처음 보급되던 시기에는 호스트 파일 갱신이 생각보다 자주 발생하지 않았기 때문에 호스트 파일을 복사하는 작업도 흔하지 않았습니다.
        
          또한 시스템 관리자가 잦은 변경을 원하지 않아서 급하지 않은 갱신은 부분적으로 늦추기도 했습니다.
            
              하지만 지금은 DNS 서비스가 보편적으로 사용되고 있어 이처럼 호스트 파일로 관리하는 방식은 보조적으로만 사용되고 있습니다.
            
          
        
      
    
  


2️⃣ DNS

  호스트 파일로 주소와 이름 정보를 관리하는 것은 간단하지만 대부분 수동으로 작업해야 한다는 단점이 있습니다.
  인터넷이 확산되면서 호스트 수가 증가할수록 네트워크 관리자가 호스트 파일을 갱신하고 복사하는 작업에 많은 시간과 노력을 들여야 합니다.
  특히 지금과 같이 전 세계 컴퓨터가 연결된 네트워크 환경에서는 호스트 파일로 주소와 이름을 변환하는 작업이 사실상 불가능하다고 볼 수 있습니다.
  DNS(Domain Name System)는 이러한 문제점을 해결하기 위하여 고안된 것으로, 주소와 이름 정보를 자동으로 유지하고 관리하는 분산 데이터베이스 시스템입니다.
    
      호스트 주소와 이름 정보는 네임 서버(Name Server)라는 특정한 관리 호스트가 유지하고, 주소 변환 작업이 필요한 클라이언트 네입 서버에서 요청해서 IP 주소를 얻습니다.
    
  
  네트워크가 커지면 네임 서버에 보관되는 정보의 양도 자연스럽게 많아집니다.
  DNS는 하나의 집중화된 네임 서버가 전체 호스트의 정보를 관리하지 않고, 여러 네임 서버에 분산하여 관리하도록 설계되었습니다.
    
      계층 구조로 연결된 네임 서버는 자신이 관리하는 영역에 위치한 호스트 정보만 관리하며, 정보를 상호 교환하는 협력 관계를 통해서 전체 호스트 정보를 일관성 있게 유지합니다.
    
  


3️⃣ 기타 주소

  네트워크에서 사용하는 주소는 이를 사용하는 환경에 따라 다양합니다.
  OSI 7계층 모델의 각 계층에서도 목적에 따라 여러 형태의 주소가 사용됩니다.


인터넷에서 일반 사용자가 접할 수 있는 대표적인 주소들.

  MAC 주소
    
      MAC 주소는 계층 2의 MAC(Medium Access Protocol) 계층에서 사용하며, 일반적으로 LAN 카드에 내장되어 있습니다.
      물리 계층을 통해 데이터를 전송할 때는 MAC 주소를 이용해서 호스트를 구분합니다.
        
          따라서 네트워크 계층이 하위의 데이터 링크 계층에 데이터 전송을 요청하면 먼저 IP 주소를 MAC 주소로 변환하는 작업이 이루어지고, 이후 MAC 계층이 상대방 MAC 계층에 데이터를 전송할 수 있습니다.
        
      
    
  
  IP 주소
    
      IP 주소는 인터넷에서 네트워크 계층의 기능을 수행하는 IP 프로토콜에서 사용되며, 송신자 IP 주소와 수신자 IP 주소로 구분됩니다.
        
          수신자 IP 주소는 IP 패킷이 지나가는 경로를 결정하는 라우팅의 기준이 됩니다.
        
      
    
  
  포트 주소
    
      포트 주소(Port Address)는 전송 계층에서 사용하며, 호스트에서 실행되는 프로세스를 구분해줍니다.
      인터넷에서 연결의 완성은 호스트와 호스트 사이가 아닌, 네트워크 응용 프로세스와 네트워크 응용 프로세스 사이입니다.
        
          예를 들어, 내 스마트폰의 메신저 앱과 상대방 스마트폰의 메신저 앱 사이의 연결이 필요하다.
            
              이때, 하나의 IP 주소를 갖는 스마트폰에서 실행되는 여러 네트워크 응용 앱들을 구분하는 주소가 포트 주소입니다.
                
                  인터넷의 전송 계층 프로토콜인 TCP와 UDP가 독립적으로 포트 주소를 관리하며, 포트 번호 또는 소켓 주소라는 용어를 사용하기도 합니다.
                
              
            
          
        
      
    
  
  메일 주소
    
      메일 주소는 응용 계층의 메일 시스템에서 사용자를 구분하려고 사용합니다.
        
          kobe@korea.co.kr 처럼 사용자 이름과 호스트 이름을 @ 문자로 구분해 표기합니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/CS/2024-09-05-observer-pattern.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/CS/2024-09-05-observer-pattern.html"><h1 class="title_post">💾 [CS] 옵저버 패턴(Observer pattern)</h1></a>
                        <a href="/Backend/CS/2024-09-05-observer-pattern.html" class="txt_post">
                            💾 [CS] 옵저버 패턴(Observer pattern).

  옵저버 패턴(observer pattern)은 주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴입니다.





  여기서 주체란 객체의 상태 변화를 보고 있는 관찰자이며, 옵저버들이란 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 ‘추가 변화 사항’이 생기는 객체들을 의미합니다.





  또한, 위의 그림처럼 주체와 객체를 따로 두지 않고 상태가 변경되는 객체를 기반으로 구축하기도 합니다.
  옵저버 패턴을 활용한 서비스로는 트위터가 있습니다.





  위의 그림처럼 내가 어떤 사람인 주체를 ‘팔로우’ 했다면 주체가 포스팅을 올리게 되면 알림이 ‘팔로워’에게 가야합니다.





  또한, 옵저버 패턴은 주로 이벤트 기반 시스템에 사용하며 MVC(Model-View-Controller) 패턴에도 사용됩니다.
    
      예를 들어 주체라고 볼 수 있는 모델(model)에서 변경 사항이 생겨 update() 메서드로 옵저버인 뷰에 알려주고 이를 기반으로 컨트롤러(controller) 등이 작동하는 것입니다.
    
  


1️⃣ 자바에서의 옵저버 패턴.

// Observer
public interface Observer {
    void update();
}

// Subject
public interface Subject {
    void register(Observer obj);
    void unregister(Observer obj);
    void notifyObservers();
    Object getUpdate(Observer obj);
}

// Topic
import java.util.ArrayList;
import java.util.List;

public class Topic implements Subject {
    private List&lt;Observer&gt; observers;
    private String message;

    public Topic() {
        this.observers = new ArrayList&lt;&gt;();
        this.message = "";
    }
    @Override
    public void register(Observer obj) {
        if (!observers.contains(obj)) {
            observers.add(obj);
        }
    }

    @Override
    public void unregister(Observer obj) {
        observers.remove(obj);
    }

    @Override
    public void notifyObservers() {
        this.observers.forEach(Observer::update);
    }

    @Override
    public Object getUpdate(Observer obj) {
        return this.message;
    }

    public void postMessage(String msg) {
        System.out.println("Message sended to Topic: " + msg);
        this.message = msg;
        notifyObservers();
    }
}

// TopicSubscriber
public class TopicSubscriber implements Observer {

	private String name;
	private Subject topic;

	public TopicSubscriber(String name, Subject topic) {
		this.name = name;
		this.topic = topic;
	}

	@Override
	public void update() {
		String msg = (String) topic.getUpdate(this);
		System.out.println(name + ":: got message &gt;&gt; " + msg);
	}
}

// Main
public class Main {

	public static void main(String[] args) {
		Topic topic = new Topic();
		Observer a = new TopicSubscriber("a", topic);
		Observer b = new TopicSubscriber("b", topic);
		Observer c = new TopicSubscriber("c", topic);
		topic.register(a);
		topic.register(b);
		topic.register(c);

		topic.postMessage("nice to meet you");
	}
}


실행 결과
Message sended to Topic: nice to meet you
a:: got message &gt;&gt; nice to meet you
b:: got message &gt;&gt; nice to meet you
c:: got message &gt;&gt; nice to meet you



  topic을 기반으로 옵저버 패턴을 구현했습니다.
    
      여기서 topic은 주체이자 객체가 됩니다.
        
          class Topic implements Subject를 통해 Subject interface를 구현했고 Observer a = new TopicSubscriber("a", topic); 으로 옵저버를 선언할 때 해당 이름과 어떠한 토픽의 옵저버가 될 것인지를 정했습니다.
        
      
    
  


자바: 상속과 구현

  위의 코드에 나온 implements 등 자바의 상속과 구현의 특징과 차이에 대해 알아보겠습니다.
    
      상속(extends)
        
          자식 클래스가 부모 클래스의 메서드 등을 상속받아 사용하며 자식 클래스에서 추가 및 확장을 할 수 있는 것을 말합니다.
            
              이로 인해 재사용성, 중복성의 최소화가 이루어집니다.
            
          
        
      
      구현(Implements)
        
          부모 인터페이스(Interface)를 자식 클래스에서 재정의하여 구현하는 것을 말합니다.
            
              상속과는 달리 반드시 부모 클래스의 메서드를 재정의하여 구현해야 합니다.
            
          
        
      
      상속과 구현의 차이
        
          상속은 일반 클래스, abstract 클래스를 기반으로 구현하며, 구현은 인터페이스를 기반으로 구현합니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-09-04-Transactional-Annotation.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-09-04-Transactional-Annotation.html"><h1 class="title_post">🍃[Spring] `@Transactional` 애노테이션</h1></a>
                        <a href="/Backend/Spring/2024-09-04-Transactional-Annotation.html" class="txt_post">
                            🍃[Spring] @Transactional 애노테이션.

  @Transactional 애노테이션은 Spring Framework에서 제공하는 애노테이션으로, 메서드나 클래스에 적용하여 해당 범위 내의 데이터베이스 작업을 하나의 트랜잭션으로 관리할 수 있도록 해줍니다.
    
      즉, @Transactional을 사용하면 지정된 메서드 또는 클래스 내의 데이터베이스 작업이 모두 성공해야만 커밋(commit)되고, 그렇지 않으면 롤백(rollback)됩니다.
    
  


1️⃣ 주요 기능.

  1. 트랜잭션 관리.
    
      @Transactional 애노테이션이 적용된 메서드 내에서 수행되는 모든 데이터베이스 작업(예: INSERT, UPDATE, DELETE)은 하나의 트랜잭션으로 관리됩니다.
        
          만약 메서드 실행 중 예외가 발생하면, 해당 트랜잭션 내의 모든 변경 사항이 롤백됩니다.
        
      
    
  
  2. 적용 범위.
    
      @Transactional은 클래스나 메서드에 적용할 수 있습니다.
      클래스에 적용하면 해당 클래스의 모든 메서드가 트랜잭션 내에서 실행됩니다.
      메스트에 적용되면 해당 메서드만 트랜잭션으로 관리됩니다.
    
  
  3. 트랜잭션 전파(Propagation)
    
      @Transactional은 여러 전파(Propagation) 옵션을 제공하여 트랜잭션이 다른 트랜잭션과 어떻게 상호작용할지를 정의할 수 있습니다.
        
          REQUIRED : 기본값으로, 현재 트랜잭션이 존재하면 이를 사용하고, 없으면 새로운 트랜잭션을 생성합니다.
          REQUIRES_NEW : 항상 새로운 트랜잭션을 생성하고, 기존 트랜잭션을 일시 정지합니다.
          MANDATORY : 현재 트랜잭션이 반드시 존재해야 하며, 없으면 예외가 발생합니다.
          SUPPORT : 현재 트랜잭션이 있으면 이를 사용하고, 없으면 트랜잭션 없이 실행합니다.
          기타 : NOT_SUPPORT, NEVER, NESTED 등.
        
      
    
  
  4. 트랜잭션 격리 수준(Isolation Level)
    
      데이터베이스 트랜잭션의 격리 수준을 설정할 수 있습니다.
        
          이는 동시에 실행되는 여러 트랜잭션 간의 상호작용 방식을 정의합니다.
            
              READ_UNCOMMITTED : 다른 트랜잭션의 미완료 변경 사항을 읽을 수 있습니다.
              READ_COMMITED : 다른 트랜잭션의 커밋된 변경 사항만 읽을 수 있습니다.
              REPEATABLE_READ : 트랜잭션 동안 동일한 데이터를 반복적으로 읽어도 동일한 결과를 보장합니다.
              SERIALIZABLE : 가장 엄격한 격리 수준으로, 트랜잭션이 완전히 순차적으로 실행되도록 보장합니다.
            
          
        
      
    
  
  5. 롤백 규칙(Rollback Rules)
    
      기본적으로 @Transactional 은 RuntimeException 또는 Error 가 발생하면 트랜잭션을 롤백합니다.
        
          특정 예외에 대해 롤백을 강제하거나, 롤백을 방지하도록 설정할 수 있습니다.
        
      
      rollbackFor 또는 noRollbackFor 속성을 사용하여 이 동작을 커스터마이징할 수 있습니다.
    
  
  6. 읽기 전용(Read-Only)
    
      @Transactional(readOnly = true)로 설정하면 트랜잭션이 데이터 읽기 전용으로 동작하며, 이 경우 데이터 수정 작업이 최적화될 수 있습니다.
        
          주로 SELECT 쿼리에서 사용됩니다.
            2️⃣ 예시 코드
          
        
      
    
  


@Service
public class MyService {
    
    @Autowired
    private MyRepository myRepository;
    
    @Transactional
    public void performTransaction() {
        // 데이터베이스에 새로운 엔티티 추가
        myRepository.save(new MyEntity("Data1"));
        
        // 다른 데이터베이스 작업 수행
        myRepository.updateEntity(1L, "UpdatedData");
        
        // 예외 발생 시, 위의 모든 작업이 롤백됨
        if (someConditionFails()) {
            throw new RuntimeException("Transaction failed, rolling back...");
        }
    }
    
    @Transactional(readOnly = true)
    public List&lt;MyEntity&gt; getEntities() {
        return myRepository.findAll();
    }
}


3️⃣ 요약.

  @Transactional 은 데이터베이스 트랜잭션을 쉽게 관리할 수 있도록 해주는 Spring의 핵심 애노테이션입니다.
    
      이 애노테이션을 사용하면 메서드나 클래스의 데이터베이스 작업을 하나의 트랜잭션으로 처리하며, 실패 시 자동으로 롤백됩니다.
        
          또한, 트랜잭션 전파, 격리 수준, 롤백 규칙 등을 통해 세부적으로 트랜잭션의 동작을 제어할 수 있습니다.
        
      
    
  


이러한 기능 덕분에 @Transactional은 Spring 애플리케이션에서 데이터 일관성과 무결성을 유지하는 데 중요한 역할을 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-09-04-SpringBootTest-Annotation,md.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-09-04-SpringBootTest-Annotation,md.html"><h1 class="title_post">🍃[Spring] `@SpringBootTest` 애노테이션</h1></a>
                        <a href="/Backend/Spring/2024-09-04-SpringBootTest-Annotation,md.html" class="txt_post">
                            🍃[Spring] @SpringBootTest 애노테이션.

  @SpringBootTest 애노테이션은 Spring Boot 애플리케이션에서 통합 테스트를 수행하기 위해 사용하는 애너테이션입니다.
    
      이 애노테이션은 테스트 클래스에서 Spring Application Context를 로드하고, 실제 애플리케이션의 전체 또는 부분적인 환경을 시뮬레이션하여 테스트할 수 있게 합니다.
      주로 애플리케이션의 전반적인 기능을 테스트하거나 여러 레이어(예: 서비스, 레포지토리 등) 간의 상호작용을 검증할 때 사용됩니다.
    
  


1️⃣ 주요 기능 및 사용 방식.

  1. Spring Application Context 로드
    
      @SpringBootTest 는 기본적으로 애플리케이션의 전체 컨텍스트를 로드합니다.
        
          이 컨텍스트는 실제 애플리케이션을 구동할 때와 동일하게 설정되어, 테스트 환경에서 애플리케이션이 어떻게 동작하는지 검증할 수 있습니다.
        
      
    
  
  2. 테스트 환경 설정
    
      @SpringBootTest 애노테이션은 다양한 속성을 통해 테스트 환경을 설정할 수 있습니다.
        
          예를 들어, 특정 프로파일을 활성화하거나, 테스트용 설정 파일을 사용할 수 있습니다.
        
      
      @SpringBootTest(properties = "spring.config.name=test-application")와 같이 속성을 지정할 수 있습니다.
    
  
  3. 웹 환경 설정
    
      @SpringBootTest는 다양한 웹 환경 모드를 지원합니다.
        
          WebEnviroment.MOCK : 기본값으로, 웹 환경 없이 MockMvc를 사용해 서블릿 환경을 모킹합니다.
          WebEnviroment.RANDOM_PORT : 테스트에 임의의 포트를 사용하여 내장 서버를 시작합니다.
          WebEnviroment.DEFINED_PORT : 애플리케이션이 구성된 기본 포트를 사용합니다.
          WebEnviroment.NONE : 웹 환경 없이 애플리케이션 컨텍스트만 로드합니다.
        
      
    
  


예시
@SpringBootTest(webEnvironment = SpringBootTest.WebEnviroment.RANDOM_PORT)



  4. 통합 테스트
    
      이 애노테이션은 단위 테스트와 달리, 애플리케이션의 여러 계층이 통합된 상태에서 테스트를 수행합니다.
        
          이는 데이터베이스, 웹 서버, 서비스 레이어 등이 실제로 어떻게 상호작용하는지를 확인할 수 있게 해줍니다.
        
      
    
  
  5. TestConfiguration 클래스 사용 가능
    
      @SpringBootTest 와 함께 @TestConfiguration 을 사용하여 테스트를 위해 특별히 구성된 빈(Bean)이나 설정을 정의할 수 있습니다.
    
  


2️⃣ 예시 코드

@SpringBootTest
public class MyServiceIntegrationTest {
    
    @Autowired
    private MyService myService;
    
    @Test
    public void testServiceMethod() {
        // Given
        // Setup initial conditions
        
        // When
        String result = myService.performAction();
        
        // Then
        assertEquals("ExpectedResult", result);
    }
}


  위의 예시에서 @SpringBootTest 는 MyServiceIntegrationTest 클래스가 Spring Application Context에서 실행될 수 있도록 하고, MyService 빈이 실제로 주입되어 테스트가 실행됩니다.


3️⃣ 요약

  @SpringBootTest는 Spring Boot 애플리케이션에서 통합 테스트를 쉽게 수행할 수 있도록 돕는 강력한 애노테이션입니다.
    
      이 애노테이션을 사용하면 애플리케이션의 전체 컨텍스트를 로드한 상태에서 테스트할 수 있으며, 복잡한 애플리케이션 시나리오를 검증하는 데 유용합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/CS/2024-09-04-API.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/CS/2024-09-04-API.html"><h1 class="title_post">💾 [CS] API(Application Programming Interface)</h1></a>
                        <a href="/Backend/CS/2024-09-04-API.html" class="txt_post">
                            💾 [CS] API(Application Programming Interface)

  API(Application Programming Interface) 는 소프트웨어 간의 상호작용을 가능하게 해주는 인터페이스입니다.
    
      쉽게 말해서 , API는 서로 다른 소프트웨어 시스템이나 애플리케이션이 데이터를 주고 받거나 기능을 사용할 수 있도록 도와주는 규칙과 도구들의 집합입니다.
    
  


1️⃣ API의 주요 개념.

  1. 인터페이스
    
      API는 소프트웨어 시스템이 다른 시스템이나 애플리케이션과 어떻게 소통할 수 있는지를 정의하는 인터페이스입니다.
        
          이 인터페이스는 어떤 데이터나 기능이 노출되고, 그것들을 어떻게 사용할 수 있는지 규정합니다.
        
      
    
  
  2. 추상화
    
      API는 복잡한 시스템 내부의 구현 세부 사항을 숨기고, 사용자나 개발자가 이해하기 쉽게 필요한 기능만을 제공합니다.
        
          예를 들어, 파일을 열거나, 데이터베이스에 쿼리를 보내거나, 웹 페이지의 데이터를 가져오는 등의 작업을 API를 통해 간단하게 수행할 수 있습니다.
        
      
    
  
  3. 모듈화
    
      API는 특정 기능이나 서비스에 대한 접근을 모듈화합니다.
        
          이렇게 모듈화된 API를 사용하면 개발자가 시스템의 다른 부분에 영향을 주지 않고 독립적으로 기능을 사용하거나 확장할 수 있습니다.
        
      
    
  
  4. 표준화
    
      API는 표준화된 방법으로 기능에 접근할 수 있게 해주기 때문에, 여러 개발자나 시스템이 일관된 방식으로 상호작용할 수 있습니다.
        
          예를 들어, REST API는 웹 기반 애플리케이션에서 데이터를 주고받는 표준 방식입니다.
        
      
    
  


2️⃣ API의 유형.

  1. Web API(웹 API)
    
      웹 서비스나 웹 애플리케이션에서 기능을 제공하는 API입니다.
        
          주로 HTTP를 통해 요청과 응답을 주고받으며, REST, SOAP, GraphQL 등이 그 예입니다.
        
      
    
  
  2. Library API
    
      특정 프로그래밍 언어에서 사용할 수 있는 라이브러리나 프레임워크의 함수와 클래스들에 대한 인터페이스입니다.
        
          예를 들어, Python의 표준 라이브러리에서 제공하는 os 나 sys 모듈도 API의 일종입니다.
        
      
    
  
  3. Operating System API
    
      운영 체제가 제공하는 기능에 접근할 수 있게 해주는 API입니다.
        
          예를 들어, Windows API는 윈도우 애플리케이션이 운영 체제의 기능(파일 관리, UI 구성 요소, 네트워크 등)에 접근할 수 있도록 합니다.
        
      
    
  
  4. Database API
    
      데이터베이스와의 상호작용을 위해 제공되는 API입니다.
        
          JDBC(Java Database Connectivity)는 자바 애플리케이션이 데이터베이스와 상호작용할 수 있도록 돕는 대표적인 데이터베이스 API입니다.
        
      
    
  


3️⃣ API의 예.

  Google Maps API
    
      개발자가 자신의 애플리케이션에 지도 기능을 통합할 수 있도록 Google에서 제공하는 API입니다.
    
  
  Twitter API
    
      개발자가 트위터의 기능(예: 트윗 가져오기, 트윗 작성)을 자신의 애플리케이션에 통합할 수 있도록 제공되는 API입니다.
    
  
  Payment Gateway API
    
      PayPal이나 Stripe 같은 결제 서비스에서 제공하는 API로, 애플리게이션에 결제 기능을 통합할 수 있습니다.
    
  


4️⃣ API의 중요성.

  API는 소프트웨어 개발에서 매우 중요한 역할을 합니다.
    
      그것은 소프트웨어 간의 상호 운용성을 촉진하며, 새로운 애플리케이션을 개발하거나 기존 애플리케이션에 새로운 기능을 추가하는 것을 더 쉽게 만들어 줍니다.
        
          또한, API를 통해 외부 시스템이나 서비스와 통합할 수 있어, 다양한 기능을 제공하는 애플리케이션을 보다 효율적으로 개발할 수 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-09-03-java-spring.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-09-03-java-spring.html"><h1 class="title_post">🍃[Spring] 자바 코드로 직접 스프링 빈 등록하기.</h1></a>
                        <a href="/Backend/Spring/2024-09-03-java-spring.html" class="txt_post">
                            🍃[Spring] 자바 코드로 직접 스프링 빈 등록하기.

  스프링에서 자바 코드로 스프링 빈을 직접 등록하는 방법은 주로 @Configuration 애노테이션과 @Bean 애노테이션을 사용하여 이루어 집니다.
    
      이 방식은 XML 설정 파일 대신 자바 클래스를 사용하여 스프링 빈을 정의하고 관리하는 방법입니다.
    
  


1️⃣ @Configuration 과 @Bean 을 사용한 빈 등록

  @Configuration
    
      이 애노테이션은 해당 클래스가 하나 이상의 @Bean 메서드를 포함하고 있으며, 스프링 컨테이너에서 빈 정의를 생성하고 처리할 수 있는 설정 클래스임을 나타냅니다.
    
  
  @Bean
    
      이 애노테이션은 메서드 레벨에서 사용되며, 메서드의 리턴값이 스프링 컨테이너에 의해 관리되는 빈(Bean)이 됨을 나타냅니다.
    
  


2️⃣ 예시.
아래는 MemoryMemberRepository 클래스를 자바 코드로 스프링 빈으로 등록하는 방법을 보여주는 예시입니다.

  1. 빈으로 등록할 클래스 정의
```java
package com.devkobe.hello_spring.repository;


import com.devkobe.hello_spring.domain.Member;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

public class MemoryMemberRepository implements MemberRepository {

private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();
private static long sequence = 0L;

@Override
public Member save(Member member) {
    member.setId(++sequence);
    store.put(member.getId(), member);
    return member;
}

@Override
public Optional&lt;Member&gt; findById(Long id) {
    return Optional.ofNullable(store.get(id));
}

@Override
public Optional&lt;Member&gt; findByName(String name) {
    return store.values().stream()
            .filter(member -&gt; member.getName().equals(name))
            .findAny();
}

@Override
public List&lt;Member&gt; findAll() {
    return new ArrayList&lt;&gt;(store.values());
}

public void clearStore() {
    store.clear();
} } ```



  2. 자바 설정 파일에서 빈 등록
```java
package com.devkobe.hello_spring.config;


import com.devkobe.hello_spring.repository.MemberRepository;
import com.devkobe.hello_spring.repository.MemoryMemberRepository;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

@Bean
public MemberRepository memberRepository() {
    return new MemoryMemberRepository();
} } ```



  3. 스프링 컨테이너에서 빈 사용
```java
package com.devkobe.hello_spring.service;


import com.devkobe.hello_spring.repository.MemberRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class MemberService {

private final MemberRepository memberRepository;

@Autowired
public MemberService(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
}

// 비즈니스 로직 메서드들... } ```


3️⃣ 설명.

  AppConfig 클래스
    
      @Configuration 애노테이션을 사용하여 이 클래스가 스프링 설정 클래스로 사용될 것임을 명시합니다.
      memberRepository() 메서드는 @Bean 애노테이션으로 정의되어 있으며, 이 메서드의 리턴값이 스프링 컨테이너에 의해 관리되는 빈이 됩니다.
        
          이 경우, MemoryMemberRepository 객체가 빈으로 등록됩니다.
        
      
    
  
  빈 사용
    
      MemberService 클래스에서 MemberRepository 타입의 빈이 생성자 주입 방식으로 주입됩니다.
        
          이때, AppConfig 클래스에서 등록된 MemoryMemberRepository 빈이 주입됩니다.
        
      
    
  


4️⃣ 왜 자바 설정을 사용할까?

  1. 타입 안정성
    
      자바 코드는 컴파일 시점에 타입을 체크할 수 있으므로, XML보다 타입 안정성이 높습니다.
    
  
  2. IDE 지원
    
      자바 기반 설정은 IDE의 자동 완성 기능과 리팩토링 도구를 잘 지원받을 수 있습니다.
    
  
  3. 코드 재사용성
    
      자바 설정 클래스는 일반 자바 코드처럼 재사용 사능하며, 상속과 조합 등을 활용할 수 있습니다.
    
  


5️⃣ 결론

  스프링에서 자바 코드로 빈을 등록하는 방법은 @Configuration 과 @Bean 애노테이션을 사용한 방법입니다.
    
      이 방식은 XML 기반 설정보다 더 타입 안전하고, 유지보수하기 쉬우며, 현대적인 스프링 애플리케이션에서 자주 사용됩니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-09-03-address-and-name.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-09-03-address-and-name.html"><h1 class="title_post">🌐[Network] 주소와 이름</h1></a>
                        <a href="/Backend/Network/2024-09-03-address-and-name.html" class="txt_post">
                            🌐[Network] 주소와 이름.

  시스템을 지칭하는 구분자는 내부에서 처리되는 숫자 기반의 주소(Address)와 함께 사용자의 이해와 편리성을 도모하는 문자로 된 이름(Name)을 제공해야 합니다.
  일반 사용자는 내부 주소를 몰라도 이름만으로 시스템에 접근할 수 있어야 하며, 이름과 주소를 연결하는 방법은 시스템 내부적으로 처리되어야 합니다.
  네트워크의 규모가 크지 않아서 관리하는 시스템의 개수가 적은 경우에는 간단한 형식의 주소와 이름을 사용할 수 있으므로 이를 관리하는 시스템도 크게 복잡하지 않습니다.
    
      그러나 관리 대상이 많아지면 주소와 이름의 공간이 커지고, 이를 관리하는 시스템의 기능도 복잡해집니다.
    
  
  네트워크에는 여러 종류의 주소와 이름이 존재합니다.
    
      이는 각 계층의 기능을 담당하는 프로토콜마다 주소를 독립적으로 관리하기 때문입니다.
        
          예를 들어, IP 프로토콜은 호스트를 구분하기 위하여 IP 주소를 사용하며, 데이터 링크 계층에서는 LAN 카드별로 MAC 주소를 따로 부여합니다.
            
              전송 계층을 수행하는 TCP에서는 호스트에서 수행되는 네트워크 프로세스마다 별도의 포트(Port) 주소를 할당하고 관리합니다.
            
          
        
      
    
  


1️⃣ IP 주소

  IP 주소(IP Address)는 네트워크 계층의 기능을 수행하는 IP 프로토콜이 호스트를 구분하기 위하여 사용하는 주소 체계입니다.
  임의의 호스트를 인터넷에 연결하려면 반드시 IP 주소를 할당 받아야 합니다.
  IP 주소는 32비트의 이진 숫자로 구성되는데, 보통 8비트씩 네 부분으로 나누어 십진수로 표현합니다.





  위 그림은 32비트의 이진수 11010011 11011111 11001001 00011110은 인터넷에서 사용하는 실제 IP 주소입니다.
    
      일반 사용자는 이진수에 익숙하지 않고, 그 길이도 길어서 외우기 쉽지 않습니다.
        
          따라서 이를 4개의 십진수로 변환한 후 각각을 점(.)으로 구분한 211.223.201.30으로 표기합니다.
            
              이와 같은 숫자로 된 주소조차 외우기 어려우므로 문자로된 www.korea.co.kr 등의 도메인 이름을 사용합니다.
            
          
        
      
    
  
  IP 주소는 유일성을 보장하기 위해서 국제 표준화 기구가 전체 주소를 관리하고 할당하기 때문에 중복 주소의 사용을 원천적으로 차단합니다.
  IP 프로토콜이 처음 개발될 당시에는 현재처럼 폭넓게 활용되리라 예측하지 못했습니다.
    
      따라서 IP 주소로 표현할 수 있는 최대 주소 공간의 크기를 32비트로 제한함으로써 확장성에 많은 문제점이 야기되고 있습니다.
        
          이를 해결하기 위하여 새로운 프로토콜인 IPv6(Internet Protocol Version 6)에서는 주소 표현 공간을 128비트로 확장했습니다.
            
              그리고 현재의 IP 프로토콜은 IPv6과 구분하기 위해 IPv4로 표현합니다.
            
          
        
      
    
  
  IP 주소는 임의로 할당되는 것이 아니라, 특정 규칙에 따라 인접한 주소들을 그룹으로 묶어 관리합니다.
    
      따라서 IP 주소는 네트워크 계층에서 경로를 선택할 때 중요한 기준이 됩니다.
    
  





  위 그림에서 네트워크 1에는 IP 주소가 211.223.201로 시작하는 호스트들이 있고, 네트워크 2에는 211.223.202로 시작하는 호스트들이 있습니다.
  왼쪽의 인터넷에서 임의의 호스트가 보낸 패킷이 중간의 라우터에 도착한 경우 이 패킷의 목적지 주소가 211.223.201.30 이라면 당연히 네트워크 1로 중개해야 합니다.
    
      이처럼 인터넷에서 IP 주소는 패킷의 경로를 결정하는 데 중요한 역할을 합니다.
    
  
  그림에 설명된 원리에 의하여, 인터넷에서 네트워크 계층 기능을 수행하는 IP 프로토콜이 전송 패킷의 경로를 결정합니다.


2️⃣ 호스트 이름

  인터넷에서 특정 호스트와 연결하려면 반드시 해당 호스트의 IP 주소를 알아야 하고, 인터넷 내부의 네트워크 계층은 호스트를 IP 주소로 구분합니다.
    
      그런데 일반 사용자는 숫자로 된 IP 주소를 기억하기 힘듭니다.
        
          그래서 사용자들은 의미 파악이 쉬운 문자로 된 호스트 이름을 사용하는 것이 일반적입니다.
        
      
    
  





  위 그림은 일반 사용자가 문자로 된 호스트 이름을 사용하였을 때 IP 주소로 변환되는 과정을 보여줍니다.
  맨 밑에 있는 네트워크 계층의 IP 프로토콜은 호스트를 구분하는 용도로 IP 주소만 사용합니다.
  그에 비해 일반 사용자는 IP 주소보다는 문자로 된 호스트 이름을 사용하기 때문에 중간 계층에서 이를 변환하는 기능을 수행해야 합니다.
  일반적으로 FTP, 텔넷과 같은 네트워크 응용 프로그램은 실행 과정에서 사용자로부터 호스트 이름을 명령어 인수로 입력받습니다.
    
      따라서 가장 먼저 수행할 작업은 DNS(Domain Name System)라는 이름과 주소 변환 기능을 이용해서 IP 주소를 얻는 것입니다.
        
          이후 변환된 IP 주소의 호스트에 연결 설정이나 전송 데이터가 포함된 패킷을 전송합니다.
        
      
    
  
  DNS 서비스는 호스트 이름을 , , , 라는 네 계층 구조로 나누고, 이들을 점(.)으로 구분해서 표기합니다.
    
      예를 들어, www.korea.co.kr과 같은 호스트 이름은 대한민국(kr)에 있는 일반 회사(co) 중에서 korea라는 이름의 회사에 소속된 www라는 호스트를 의미합니다.
    
  


&lt;호스트&gt;.&lt;단체 이름&gt;.&lt;단체 종류&gt;.&lt;국가 도메인&gt;



  
    은 가 위치한 국가의 이름을 두 글자의 약자로 표시합니다.

    
      아래의 표처럼 나라마다 고유한 &lt;국가 도메인이 존재합니다.
    
  
  
    는 기관의 성격에 따라 부여하며, 사용 예는 아래의 표와 같습니다.


  




  
    은 보통 단체를 상징하는 이름을 사용합니다.

    
      예를 들어, 회사는 회사명을, 학교는 학교 이름을 사용합니다.
    
  
  마지막으로 는 소속 단체의 네트워크 관리자가 내부 규칙에 따라 개별 호스테에 부여한 이름을 사용합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/CS/2024-09-03-stratege-pattern.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/CS/2024-09-03-stratege-pattern.html"><h1 class="title_post">💾 [CS] 전략 패턴(Strategy pattern)</h1></a>
                        <a href="/Backend/CS/2024-09-03-stratege-pattern.html" class="txt_post">
                            💾 [CS] 전략 패턴(Strategy pattern)

1️⃣ 전략 패턴(Strategy pattern)

  전략 패턴(Strategy pattern) 은 정책 패턴(Policy pattern) 이라고도 하며, 객채의 행위를 바꾸고 싶은 경우 ‘직접’ 수정하지 않고 전략이라고 부르는 ‘캡슐화한 알고리즘’ 을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴입니다.





  아래의 예시 코드는 우리가 어떤 것을 살 때 네이버페이, 카카오페이 등 다양한 방법으로 결제하듯이 어떤 아이템을 살 때 LUNACard로 사는 것과 KAKAOCard로 사는 것을 구현한 예제입니다.
    
      결제 방식의 ‘전략’ 만 바꿔서 두 가지 방식으로 결제하는 것을 구현했습니다.
    
  


// PaymentStrategy - interface

public interface PaymentStrategy {
	void pay(int amount);
}

// KAKAOCardStrategy

public class KAKAOCardStrategy implements PaymentStrategy{
	private String name;
	private String cardNumber;
	private String cvv;
	private String dateOfExpiry;

	public KAKAOCardStrategy(String name, String cardNumber, String cvv, String dateOfExpiry) {
		this.name = name;
		this.cardNumber = cardNumber;
		this.cvv = cvv;
		this.dateOfExpiry = dateOfExpiry;
	}

	@Override
	public void pay(int amount) {
		System.out.println(amount + " paid using KAKAOCard.");
	}
}

// LUNACardStrategy

public class LUNACardStrategy implements PaymentStrategy {
	private String emailId;
	private String password;

	public LUNACardStrategy(String emailId, String password) {
		this.emailId = emailId;
		this.password = password;
	}

	@Override
	public void pay(int amount) {
		System.out.println(amount + " paid using LUNACard");
	}
}

// Item

public class Item {
	private String name;
	private int price;
	public Item(String name, int price) {
		this.name = name;
		this.price = price;
	}

	public String getName() {
		return name;
	}

	public int getPrice() {
		return price;
	}
}

// ShoppingCart

import java.util.ArrayList;
import java.util.List;

public class ShoppingCart {
	List&lt;Item&gt; items;

	public ShoppingCart() {
		this.items = new ArrayList&lt;&gt;();
	}

	public void addItem(Item item) {
		this.items.add(item);
	}

	public void removeItem(Item item) {
		this.items.remove(item);
	}

	public int calculateTotal() {
		int sum = 0;
		for (Item item : items) {
			sum += item.getPrice();
		}
		return sum;
	}

	public void pay(PaymentStrategy pamentMethod) {
		int amount = calculateTotal();
		pamentMethod.pay(amount);
	}
}

// Main

import designPattern.strategy.Item;
import designPattern.strategy.KAKAOCardStrategy;
import designPattern.strategy.LUNACardStrategy;
import designPattern.strategy.ShoppingCart;

public class Main {

	public static void main(String[] args) {
		ShoppingCart cart = new ShoppingCart();

		Item A = new Item("A", 100);
		Item B = new Item("B", 300);

		cart.addItem(A);
		cart.addItem(B);

		// pay by LUNACard
		cart.pay(new LUNACardStrategy("kobe@google.com", "1234"));

		// pay by KAKAOCard
		cart.pay(new KAKAOCardStrategy("Minseong Kang", "123456789", "123", "12/01"));
	}
}


실행 결과

400 paid using LUNACard
400 paid using KAKAOCard.


  위 코드는 쇼핑 카드에 아이템을 담아 LUNACard 또는 KAKAOCard 라는 두 개의 전략으로 결제하는 코드입니다.



  용어 : 컨텍스트
프로그래밍에서의 컨텍스트는 상황, 맥락, 문맥을 의미하며 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보를 말합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-09-02-container.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-09-02-container.html"><h1 class="title_post">🍃[Spring] 스프링 컨테이너(Spring Container)란?</h1></a>
                        <a href="/Backend/Spring/2024-09-02-container.html" class="txt_post">
                            🍃[Spring] 스프링 컨테이너(Spring Container)란?

1️⃣ 스프링 컨테이너(Spring Container)란?

  스프링 컨테이너(Spring Container)는 스프일 프레임워크의 핵심 구성 요소로, 애플리케이션에서 사용되는 객체들은 관리하고 조정하는 역할을 합니다.
    
      이 컨테이너는 객체의 생성, 초기화, 의존성 주입, 설정 및 라이프사이클을 관리하여 애플리케이션의 주요 컴포넌트들이 잘 협력할 수 있도록 돕습니다.
    
  
  스프링 컨테이너는 종종 IoC(Inversion of Control) 컨테이너 또는 DI(Dependency Injection) 컨테이너 라고도 불립니다.


2️⃣ 스프링 컨테이너의 주요 기능.

  1. 빈(Bean) 관리
    
      스프링 컨테이너는 애플리케이션에 필요한 모든 빈(Bean)을 정의하고 생성합니다.
        
          이 빈들은 XML 설정 파일, 자바 설정 클래스, 또는 애노테이션을 통해 정의될 수 있습니다.
        
      
      빈의 라이프사이클(생성, 초기화, 소멸)을 관리하고, 의존성을 자동으로 주입하여 빈 간의 결합도를 낮추어 줍니다.
    
  
  2. 의존성 주입(Dependency Injection)
    
      스프링 컨테이너는 객체 간의 의존성을 자동으로 주입하여, 객체들이 직접 다른 객체를 생성하거나 관리하지 않도록 합니다.
        
          이를 통해 코드의 유연성과 재사용성을 높입니다.
        
      
      의존성 주입은 생성자 주입, 세터 주입, 필드 주입 등 다양한 방법으로 이루어질 수 있습니다.
    
  
  3. 설정 관리
    
      컨테이너는 애플리케이션의 설정 정보를 관리합니다.
        
          이는 빈의 정의뿐만 아니라, 데이터베이스 연결 설정, 메시지 소스, 트랜잭션 관리 등의 다양한 설정을 포함합니다.
        
      
    
  
  4. 라이프사이클 인터페이스 지원
    
      컨테이너는 빈의 라이프사이클 인터페이스(InitializingBean, DisposableBean)을 통해 빈의 초기화 및 소명 작업을 쉽게 구현할 수 있도록 지원합니다.
      또한 @PostConstruct, @PreDestroy 애노테이션을 통해 라이프사이클 콜백을 간단하게 구현할 수 있습니다.
    
  
  5. AOP(Aspect-Oriented Programming) 지원
    
      스프링 컨테이너는 AOP 기능을 지원하여, 애플리케이션 전반에 걸쳐 공통적으로 사용되는 로직(예: 로깅, 트랜잭션 관리)을 비즈니스 로직과 분리하여 모듈화할 수 있게 합니다.
    
  


3️⃣ 스프링 컨테이너의 종류.

  스프링에는 다양한 컨테이너 구현체가 있으며, 대표적으로 다음과 같은 종류가 있습니다.
    
      1. BeanFactory
        
          스프링의 가장 기본적인 컨테이너로, 빈의 기본적인 생성과 의존성 주입을 제공합니다.
            
              하지만 BeanFactory는 지연 로딩(lazy loading) 방식으로 동작하므로, 빈이 실제로 요청될 때 생성됩니다.
            
          
        
      
      2. ApplicationContext
        
          BeanFactory의 확장판으로, 대부분의 스프링 애플리케이션에서 사용되는 컨테이너입니다.
          ApplicationContext 는 BeanFactory의 기능을 포함하면서도, 다양한 기능(예: 이벤트 발행, 국제화 메시지 처리, 환경 정보 관리)을 추가로 제공합니다.
          ApplicationContext 의 구현체에는 ClassPathXmlApplicationContext, FileSystemXmlApplicationContext, AnnotationConfigApplicationContext 등이 있습니다.
        
      
    
  


4️⃣ 스프링 컨테이너의 동작 과정.

  1. 빈 정의 로드
    
      컨테이너가 시작되면, XML 파일, 자바 설정 파일, 애노테이션 등을 통해 빈의 정의를 읽어들입니다.
    
  
  2. 빈 생성 및 초기화
    
      컨테이너는 필요한 빈들을 생성하고 초기화 작업을 수행합니다.
        
          이때 의존성이 있는 경우, 필요한 빈들을 먼저 생성하여 주입합니다.
        
      
    
  
  3. 의존성 주입
    
      빈의 생성 과정에서 필요한 의존성들이 주입됩니다.
        
          이 과정에서 생성자 주입, 세터 주입 등이 사용됩니다.
        
      
    
  
  4. 빈 제공
    
      컨테이너는 요청 시 빈을 제공하며, 애플리케이션은 이 빈을 통해 다양한 작업을 수행할 수 있습니다.
    
  
  5. 빈 소멸
    
      애플리케이션이 종료되거나 컨테이너가 종료될 때, 컨테이너는 빈의 소멸 작업을 처리합니다.
    
  


스프링 컨테이너는 이 모든 과정을 자동으로 처리하며, 이를 통해 개발자는 비즈니스 로직에 집중할 수 있게됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-09-02-Layered-Architecture.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-09-02-Layered-Architecture.html"><h1 class="title_post">🍃[Spring] 계층형 아키텍처(Layered Architecture), 3계층 아키텍처(Three-Tier Architecture)</h1></a>
                        <a href="/Backend/Spring/2024-09-02-Layered-Architecture.html" class="txt_post">
                            🍃[Spring] 계층형 아키텍처(Layered Architecture), 3계층 아키텍처(Three-Tier Architecture)

  Controller를 통해 외부의 요청을 받고, Service에서 비즈니스 로직을 처리하며, Repository에서 데이터를 저장하고 관리하는 패턴은 “계층형 아키텍처(Layered Architecture)” 또는 “3계층 아키텍처(Three-Tier Architecture)” 라고 부릅니다.


1️⃣ 계층형 아키텍처(Layered Architecture)

  이 아키텍처 패턴은 애플리케이션을 여러 계층으로 나누어 각 계층이 특정한 역할을 담당하도록 구조와합니다.
  이 방식은 소프트웨어의 복잡성을 줄이고, 코드의 유지보수성을 높이며, 테스트하기 쉽게 만들어줍니다.
  스프링 프레임워크에서 이 패턴은 자주 사용됩니다.


2️⃣ 각 계층별 역할.

  1. Presentation Layer(프레젠테이션 계층) - Controller
    
      사용자 인터페이스와 상호작용하는 계층입니다.
      외부의 요청을 받아서 처리하고, 응답을 반환합니다.
      스프링에서는 주로 @Controller 또는 @RestController 를 사용하여 이 계층을 구현합니다.
    
  
  2. Business Logic Layer(비즈니스 로직 계층) - Service
    
      비즈니스 로직을 처리하는 계층입니다.
      데이터의 처리, 계산, 검증 등 핵심적인 애플리케이션 로직이 구현됩니다.
      스프링에서는 주로 @Service 애노테이션을 사용하여 이 계층을 구현합니다.
    
  
  3. Data Access Layer(데이터 접근 계층) - Repository
    
      데이터베이스나 외부 데이터 소스와 상호작용하는 계층입니다.
      데이터의 CRUD(Create, Read, Update, Delete) 작업을 처리합니다.
      스프링에서는 주로 @Repository 애노테이션을 사용하여 이 계층을 구현하며 JPA, MyBatis, Hibernate 등의 ORM(Object-Relational Mapping) 도구와 함께 사용됩니다.
    
  


3️⃣ 이 패턴의 주요 장점.

  모듈화
    
      각 계층이 독립적으로 관리되므로, 각 계층의 코드가 명확히 분리됩니다.
    
  
  유지보수성
    
      비즈니스 로직, 데이터 접근, 그리고 프레젠테이션 로직이 분리되어 있어, 각 부분을 독립적으로 수정하거나 확장하기 쉽습니다.
    
  
  테스트 용이성
    
      각 계층을 독립적으로 테스트할 수 있어, 단위 테스트와 통합 테스트가 용이합니다.
    
  
  유연성
    
      특정 계층을 변경하거나 대체할 때, 다른 계층에 미치는 영향을 최소화할 수 있습니다.
    
  


이 계층형 아키텍처는 스프링 프레임워크를 사용하는 대부분의 애플리케이션에서 채택하는 일반적인 구조이며, 소프트웨어 설계의 베스트 프랙티스 중 하나로 널리 인정받고 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-09-02-DI-LC.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-09-02-DI-LC.html"><h1 class="title_post">🍃[Spring] 의존성 주입(Dependency Injection)을 통한 느슨한 결합(Loose Coupling) 유지.</h1></a>
                        <a href="/Backend/Spring/2024-09-02-DI-LC.html" class="txt_post">
                            🍃[Spring] 의존성 주입(Dependency Injection)을 통한 느슨한 결합(Loose Coupling) 유지.

  아래의 코드에서 @Autowired 로 MemberService 클래스의 생성자에 MemberRepository 인터페이스를 주입받는 이유는 의존성 주입(Dependency Injection) 을 통해 느슨한 결합(Loose Coupling) 을 유지하기 위합입니다.
    
      이는 객체지향 설계에서 매우 중요한 원칙 중 하나로, 클래스 간의 결합도를 낮춰 코드의 유연성과 확장성을 높이는 데 기여합니다.
    
  


1️⃣ 전체 코드.

// MemberRepository
import com.devkobe.hello_spring.domain.Member;
import java.util.List;
import java.util.Optional;


public interface MemberRepository {
	Member save(Member member);
	Optional&lt;Member&gt; findById(Long id);
	Optional&lt;Member&gt; findByName(String name);
	List&lt;Member&gt; findAll();
}

// MemoryMemberRepository
import com.devkobe.hello_spring.domain.Member;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.springframework.stereotype.Repository;

@Repository
public class MemoryMemberRepository implements MemberRepository {

	private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();
	private static long sequence = 0L;

	@Override
	public Member save(Member member) {
		member.setId(++sequence);
		store.put(member.getId(), member);
		return member;
	}

	@Override
	public Optional&lt;Member&gt; findById(Long id) {
		return Optional.ofNullable(store.get(id));
	}

	@Override
	public Optional&lt;Member&gt; findByName(String name) {
		return store.values().stream()
				.filter(member -&gt; member.getName().equals(name))
				.findAny();
	}

	@Override
	public List&lt;Member&gt; findAll() {
		return new ArrayList&lt;&gt;(store.values());
	}

	public void clearStore() {
		store.clear();
	}
}

// MemberService
import com.devkobe.hello_spring.domain.Member;
import com.devkobe.hello_spring.repository.MemberRepository;
import com.devkobe.hello_spring.repository.MemoryMemberRepository;
import java.util.List;
import java.util.Optional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class MemberService {
	private final MemberRepository memberRepository;

	@Autowired
	public MemberService(MemberRepository memberRepository) {
		this.memberRepository = memberRepository;
	}

	/*
	 * 회원 가입
	 */
	public Long join(Member member) {

		validateDuplicateMember(member); // 중복 회원 검증
		memberRepository.save(member);
		return member.getId();
	}

	private void validateDuplicateMember(Member member) {
		memberRepository.findByName(member.getName())
				.ifPresent(m -&gt; {
					throw new IllegalStateException("이미 존재하는 회원입니다.");
				});
	}

	/*
	 * 전체 회원 조회
	 */
	public List&lt;Member&gt; findMembers() {
		return memberRepository.findAll();
	}

	public Optional&lt;Member&gt; findOne(Long memberId) {
		return memberRepository.findById(memberId);
	}
}


2️⃣ 구체적인 이유.

  1. 인터페이스를 통한 유연성 확보.
    
      MemberRepository 는 인터페이스로, MemoryMemberRepository 와 같은 구현체들이 이 인터페이스를 구현합니다.
        
          인터페이스를 통해 MemberService 는 특정 구현체에 의존하지 않으며, MemberRepository 인터페이스에 의존하게 됩니다.
            
              이는 MemberService 가 MemoryMemberRepository 나 다른 MemberRepository 구현체(JdbcMemberRepository, JpaMemberRepository 등)에 쉽게 교체될 수 있음을 의미합니다.
                
                  예를 들어, 나중에 메모리가 아닌 데이터베이스에 회원 정보를 저장하는 방식으로 전환하고 싶다면, MemoryMemberRepository 대신 새로운 구현체를 주입하면 됩니다.
                
              
            
          
        
      
    
  
  2. 느슨한 결합.
    
      MemberService 는 MemberRepository 인터페이스에만 의존하기 때문에, 어떤 구현체가 실제로 사용될지는 스프링 컨테이너가 결정합니다.
        
          이렇게 하면 MemberService 는 구현체가 무엇인지 알 필요가 없으므로, 구현체가 변경되더라도 MemberService 를 수정할 필요가 없습니다.
        
      
      이 방식은 유지보수성을 크게 향상시킵니다.
        
          새로운 저장소 방식이 도입되더라도, 기존 비즈니스 로직에 영향을 주지 않고 새로운 기능을 추가할 수 있습니다.
        
      
    
  
  3. 스프링의 의존성 주입 메커니즘 활용.
    
      스프링은 자동으로 @Autowired 를 사용하여 적절한 MemberRepository 구현체를 찾아 주입합니다.
        
          MemoryMemberRepository 클래스에 @Repository 애노테이션이 붙어 있기 때문에, 스프링 컨테이너는 이 클래스를 MemberRepository 타입의 빈으로 인식하고 관리하게 됩니다.
        
      
      스프링은 MemberRepository 인터페이스 타입의 빈을 주입해야 하는 경우, 해당 인터페이스를 구현한 클래스 중 하나를 선택해 주입합니다.
        
          이 예제에서는 MemoryMemberRepository 가 주입됩니다.
        
      
    
  


3️⃣ 결론.

  이러한 설계는 코드의 유연성과 테스트 용이성을 크게 향상시킵니다.
    
      인터페이스를 사용함으로써, MemberService 는 특정 구현체에 구애받지 않고 다양한 환경에서 재사용될 수 있습니다.
        
          또한, 이는 스프링의 DI 원칙에 따라, 컴포넌트 간의 결합도를 낮추고, 애플리케이션이 변화에 잘 대응할 수 있도록 설계하는 방법입니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/CS/2024-09-02-domain.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/CS/2024-09-02-domain.html"><h1 class="title_post">💾 [CS] 도메인(Domain)의 의미.</h1></a>
                        <a href="/Backend/CS/2024-09-02-domain.html" class="txt_post">
                            💾 [CS] 도메인(Domain)의 의미.

  도메인(Domain) 은 소프트웨어 개발에서 특정 문제 영역 또는 비즈니스 영역을 지칭하는 용어입니다.
  도메인은 소프트웨어 시스템이 해결하고자 하는 문제나 제공하는 서비스와 관련된 특정한 지식, 규칙, 절차 등을 포함한 모든 것을 의미합니다.


1️⃣ 도메인(Domain)의 의미.

  1. 문제 영역
    
      도메인은 특정 비즈니스나 문제 영역을 나타내며, 이 영역은 소프트웨어가 해결하려고 하는 실제 세계의 문제와 직접적으로 관련됩니다.
        
          예를 들어, 은행 업무, 전자상거래, 병원 관리, 교육 관리 시스템 등 각각의 도메인은 서로 다른 문제와 규칙을 가지고 있습니다.
        
      
    
  
  2. 도메인 지식
    
      도메인에는 해당 문제 영역에 대한 전문 지식이나 규칙이 포함됩니다.
        
          예를 들어, 금융 도메인에서는 이자 계산, 대출 규정, 계좌 관리와 같은 특정 지식이 중요합니다.
            
              이와 같은 도메인 지식을 바탕으로 소프트웨어의 비즈니스 로직이 정의됩니다.
            
          
        
      
    
  
  3. 도메인 모델
    
      도메인은 일반적으로 “도메인 모델(Domain Model)”로 표현됩니다.
        
          도메인 모델은 도메인의 개념, 객체, 엔티티, 관계, 규칙 등을 추상화하여 표현한 것입니다.
            
              예를 들어, 은행 도메인 모델에는 고객(Customer), 계좌(Account), 거래(Transaction) 같은 객체가 포함될 수 있습니다.
            
          
        
      
      도메인 모델은 시스템이 해당 도메인의 문제를 어떻게 해결할지를 정의하는데 중요한 역할을 합니다.
    
  
  4. 도메인 전문가
    
      도메인 전문가(Domain Expert)는 특정 도메인에 대한 깊은 지식을 가진 사람을 의미합니다.
        
          이들은 비즈니스 핵심 요구 사항과 규칙을 정의하며, 개발자와 협력하여 도메인 모델을 설계하는데 중요한 역할을 합니다.
        
      
    
  


2️⃣ 도메인의 중요성

  도메인은 소프트웨어 개발의 초기 단계에서 매우 중요합니다.
    
      시스템이 해결해야 하는 문제를 명확히 정의하고, 비즈니스 요구 사항을 반영한 도메인 모델을 설계하는 것이 시스템의 성공적인 구현에 필수적입니다.
    
  
  도메인 지식을 제대로 반영하지 못하면, 시스템이 실제 비즈니스 문제를 해결하는 데 실패할 수 있으며, 이는 프로젝트 실패로 이어질 수 있습니다.
    
      따라서 개발자는 도메인 전문가와 긴밀하게 협력하여 도메인을 정확히 이해하고, 이를 코드로 표현하는 것이 중요합니다.
    
  


3️⃣ 도메인 주도 설계(Domain-Driven Design, DDD)

  도메인과 관련된 중요한 소프트웨어 설계 접근법 중 하나는 도메인 주도 설계(Domain-Driven Design, DDD) 입니다.
  DDD는 도메인 모델을 중심으로 소프트웨어를 설계하는 방법론으로, 도메인의 개념과 규칙을 코드에 직접 반영하여 소프트웨어의 복잡성을 관리하고, 도메인의 변화에 쉽게 적응할 수 있도록 돕습니다.


예시

  예를 들어, 전자상거래 도메인 을 생각해보면, 이 도메인에는 다음과 같은 요소들이 포함될 수 있습니다.
    
      고객(Customer) : 상품을 구매하는 사람.
      상품(Product) : 고객이 구매할 수 있는 아이템.
      주문(Order) : 고객이 상품을 구매할 때 생성되는 거래 기록.
      결제(Payment) : 주문에 대한 대금 지불.
    
  


이러한 요소들과 그들 간의 관계가 도메인을 구성하며, 소프트웨어 시스템은 이러한 도메인의 개념을 바탕으로 비즈니스 로직을 구현하게 됩니다.

4️⃣ 결론

  도메인은 소프트웨어가 다루는 문제의 범위와 관련된 개념, 규칙, 객체들을 나타내며, 이를 정확히 이해하고 모델링하는 것이 성공적인 소프트웨어 개발의 핵심입니다.
  도메인 이해를 바탕으로 적절한 비즈니스 로직을 구현하는 것이 소프트웨어의 목표를 달성하는 데 매우 중요합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/CS/2024-09-02-Business-Logic.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/CS/2024-09-02-Business-Logic.html"><h1 class="title_post">💾 [CS] 비즈니스 로직(Business Logic)이란?</h1></a>
                        <a href="/Backend/CS/2024-09-02-Business-Logic.html" class="txt_post">
                            💾 [CS] 비즈니스 로직(Business Logic)이란?

1️⃣ 비즈니스 로직(Business Logic).

  비즈니스 로직(Business Logic) 은 소프트웨어 시스템 내에서 특정 비즈니스 도메인에 대한 규칙, 계산, 절차 등을 구현한 부분을 의미합니다.
    
      이 로직은 애플리케이션이 실제 비즈니스 요구 사항을 충족하도록 하는 핵심 기능을 담당합니다.
    
  
  비즈니스 로직(Business Logic) 은 시스템이 처리해야 하는 업무 규칙과 관련된 의사결정을 포함하며, 데이터의 유효성 검사를 하고, 비즈니스 프로세스를 관리하고, 관련된 계산을 수행하는 역할을 합니다.


2️⃣ 비즈니스 로직의 주요 역할

  1. 도메인 규칙 관리.
    
      특정 비즈니스 도메인에서 따라야 하는 규칙을 정의하고 관리합니다.
        
          예를 들어, 은행 시스템에서 계좌 이체 시 잔액이 충분해야 한다는 규칙을 비즈니스 로직에서 처리합니다.
        
      
    
  
  2. 유효성 검사.
    
      입력된 데이터나 시스템 내부에서 사용되는 데이터가 비즈니스 규칙에 맞는지 검증합니다.
        
          예를 들어, 사용자가 입력한 주문의 총액이 0보다 큰지, 재고가 충분한지 등을 검사하는 로직이 포함됩니다.
        
      
    
  
  3. 비즈니스 프로세스 구현.
    
      비즈니스 워크플로우를 구현하여, 각 단계에서 수행해야 하는 작업을 정의하고, 순서대로 실행되도록 관리합니다.
        
          예를 들어, 주문 처리 시스템에서 주문 접수, 결제 처리, 배송 준비 등의 단계가 비즈니스 로직에 포함될 수 있습니다.
        
      
    
  
  4. 계산과 처리.
    
      특정 비즈니스 규칙에 따라 데이터를 계산하거나 처리하는 역할을 합니다.
        
          예를 들어, 세금 계산, 할인 적용, 이자 계산 등이 여기에 포함됩니다.
        
      
    
  


3️⃣ 비즈니스 로직의 위치

  비즈니스 로직은 보통 애플리케이션의 Service 계층 에 위치합니다.
    
      이 계층은 데이터를 처리하는 로직과 사용자 인터페이스를 담당하는 로직을 분리하여, 코드의 재사용성을 높이고 유지보수를 용이하게 합니다.
    
  
  Service 계층 에서는 비즈니스 로직을 구현하며, 필요한 경우 데이터 접근 계층(Repository) 을 호출하여 데이터를 조회하거나 저장하고, 최종적으로 처리된 결과를 프레젠테이션 계층(Controller) 에 전달합니다.


4️⃣ 비즈니스 로직과 다른 로직의 구분

  비즈니스 로직
    
      실제 비즈니스와 관련된 모든 규칙과 프로세스를 정의합니다.
        
          이는 특정 도메인 지식에 기반하며, 도메인 전문가가 주로 요구 사항을 정의합니다.
        
      
    
  
  프레젠테이션 로직
    
      사용자 인터페이스와 관련된 로직으로, 사용자에게 데이터를 표시하거나 입력을 받는 것과 관련됩니다.
    
  
  데이터 접근 로직
    
      데이터베이스와 상호작용하며, 데이터를 저장하거나 조회하는 작업을 담당합니다.
    
  


5️⃣ 비즈니스 로직의 중요성

  비즈니스 로직은 애플리케이션의 핵심적인 부분이므로, 이 로직의 정확성은 시스템 전체의 신뢰성과 직결됩니다.
  잘 설계된 비즈니스 로직은 애플리케이션이 요구된 비즈니스 목표를 정확히 달성할 수 있도록 돕고, 변경이 필요할 때도 쉽게 확장하거나 수정할 수 있도록합니다.
    
      따라서 비즈니스 로직을 구현할 때는 도메인 전문가와 긴밀하게 협력하여 요구사항을 명확히 이해하고, 이를 코드로 정확히 표현하는 것이 매우 중요합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-09-01-when-use-controller-annotation.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-09-01-when-use-controller-annotation.html"><h1 class="title_post">🍃[Spring] `@Controller` 애너테이션 사용시 일어나는 일.</h1></a>
                        <a href="/Backend/Spring/2024-09-01-when-use-controller-annotation.html" class="txt_post">
                            🍃[Spring] @Controller 애너테이션 사용시 일어나는 일.

1️⃣ 스프링 프레임워크에서 @Controller 애노테이션 사용시 어떤 일이 일어날까요?

  스프링 프레임워크에서 @Controller 애노테이션을 사용하면, 해당 클래스가 스프링 MVC의 웹 컨트롤러로 동작하도록 설정됩니다.
  @Controller 는 기본적으로 웹 요청을 처리하고, 적절한 응답을 생성하는 역할을 담당하는 클래스를 정의할 때 사용됩니다.


@Controller 애노테이션을 사용하면 다음과 같은 일들이 벌어집니다.

  1. 스프링 빈으로 등록.
    
      @Controller 애노테이션이 적용된 클래스는 스프링의 컴포넌트 스캔 메커니즘에 의해 자동으로 스프링 컨텍스트에 빈으로 등록됩니다.
        
          이는 @Component 와 유사하게 동작하며, 스프링이 이 클래스를 관리하도록 만듭니다.
        
      
    
  
  2. 요청 처리 메서드 매핑.
    
      @Controller 가 달린 클래스 내의 메서드들은 @RequestMapping, @GetMapping, @PostMapping 등과 같은 요청 매핑 애노테이션을 통해 특정 HTTP 요청을 처리하는 메서드로 매핑될 수 있습니다.
        
          이러한 매핑을 통해 특정 URL로 들어오는 요청이 어떤 메서드에 의해 처리될지 결정됩니다.
        
      
    
  
  3. 모델과 뷰.
    
      @Controller 는 주로 모델과 뷰를 처리합니다.
        
          요청이 컨트롤러에 도달하면, 컨트롤러는 필요한 데이터를 모델에 담고, 적절한 뷰(예: JSP, Thymeleaf 템플릿)를 반환하여 사용자에게 응답을 보냅니다.
            
              스프링은 이 작업을 쉽게 할 수 있도록 다양한 기능을 제공합니다.
            
          
        
      
    
  
  4. 비즈니스 로직과 서비스 계층.
    
      컨트롤러는 보통 직접 비즈니스 로직을 처리하지 않고, 서비스 계층을 호출하여 필요한 처리를 위임합니다.
        
          컨트롤러는 사용자 입력을 받아 서비스로 전달하고, 서비스의 결과를 받아 사용자에게 반환하는 역할을 합니다.
        
      
    
  
  5. 예외 처리.
    
      @Controller 애노테이션을 사용하는 클래스는 또한 @ExceptionHandler 를 사용하여 특정 예외를 처리할 수 있습니다.
        
          이를 통해 컨트롤러 내에서 발생하는 예외를 잡아 특정 응답을 반환하거나 에러 페이지를 보여줄 수 있습니다.
        
      
    
  


요약하면, @Controller 애노테이션은 해당 클래스를 스프링 MVC에서 요청을 처리하는 컨트롤러로 정의하며, HTTP 요청을 처리하고 적절한 응답을 생성하는데 중요한 역할을 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-09-01-bean.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-09-01-bean.html"><h1 class="title_post">🍃[Spring] 빈(Bean)이란?</h1></a>
                        <a href="/Backend/Spring/2024-09-01-bean.html" class="txt_post">
                            🍃[Spring] 빈(Bean)이란?

1️⃣ 빈(Bean)이란?

  스프링 프레임워크에서 빈(Bean) 이란, 스프링 IoC(Inversion of Control) 컨테이너에 의해 관리되는 객체를 의미합니다.
  스프링 빈은 애플리케이션 전반에서 사용될 수 있도록 스프링 컨텍스트에 등록된 인스턴스입니다.
  빈은 보통 애플리케이션의 핵심 로직이나 비즈니스 로직을 수행하는 객체들로, 스프링은 이러한 빈들을 효율적으로 관리하고 주입합니다.
  빈의 정의와 동작은 스프링의 핵심 개념인 의존성 주입(Dependency Injection, DI) 과 밀접한 관련이 있습니다.


2️⃣ 스프링 빈의 주요 특징.

  1. 싱글톤(Singleton) 스코프
    
      기본적으로 스프링 빈은 싱글톤 스코프로 관리됩니다.
        
          즉, 특정 빈 타입에 대해 스프링 컨테이너는 하나의 인스턴스만을 생성하고 애플리케이션 내에서 재사용합니다.
            
              물론, 필요에 따라 프로토타입, 요청, 세션 등 다른 스코프로 빈을 정의할 수도 있습니다.
            
          
        
      
    
  
  2. 의존성 관리
    
      스프링 컨테이너는 빈의 의존성을 자동으로 주입합니다.
        
          즉, 빈이 생성될 때 필요한 의존성(다른 빈이나 리소스)을 스프링이 자동으로 주입해줍니다.
            
              이 과정에서 생성자 주입, 세터 주입, 필드 주입 등 다양한 방법이 사용될 수 있습니다.
            
          
        
      
    
  
  3. 라이프사이클 관리
    
      스프링은 빈의 생성부터 소멸까지의 라이프사이클을 관리합니다.
        
          빈이 생성될 때 초기화 작업을 하거나, 빈이 소멸될 때 클린업 작업을 수행할 수 있도록 다양한 훅(Hook)을 제공하며, 이 과정에서 @PostConstruct, @PreDestroy 같은 애노테이션을 사용할 수 있습니다.
        
      
    
  
  4. 설정 및 구성
    
      빈은 XML 설정 파일이나 자바 설정 클래스에서 정의될 수 있습니다.
        
          또한, @Component, @Service, @PostConstruct, @PreDestroy 같은 애노테이션을 사용할 수 있습니다.
        
      
    
  
  5. 느슨한 결합(Loose Coupling)
    
      스프링 빈을 사용하면 객체 간의 의존성을 직접 설정하는 것이 아니라, 스프링이 관리하므로 코드가 더욱 유연하고 테스트하기 쉬워집니다.
        
          이는 애플리케이션의 유지보수성과 확장성을 높여줍니다.
        
      
    
  


3️⃣ 스프링 빈의 정의 예시.

  다음은 빈이 어떻게 정의되고, 스프링 컨테이너가 이를 관리하는지에 대한 간단한 예시입니다.
    @Component
public class MyService {
  public void performService() {
      System.out.println("Service is being performed.")
  }
}
    
  
  위 코드에서 @Component 애노테이션이 적용된 MyService 클래스는 스프링 빈으로 등록됩니다.
    
      스프링 컨테이너는 이 빈을 관리하고, 필요할 때 의존성을 주입합니다.
    
  
  빈을 스프링 컨텍스트에서 가져와 사용하는 예시는 다음과 같습니다.
```java
@Autowired
private MyService myService;


public void useService() {
    myService.performService();
}
```

  여기서 @Autowired 애노테이션은 MyService 타입의 빈을 스프링 컨테이너에서 주입받아 useService 메서드에서 사용할 수 있도록 합니다.


결론적으로, 스프링 빈은 스프링 애플리케이션에서 핵심적인 역할을 하는 객체로, 스프링 컨테이너가 관리하는 인스턴스이며, 이를 통해 애플리케이션의 구성 요소들이 유연하고 효율적으로 동작하도록 돕습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-09-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-31-address-presentaion.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-31-address-presentaion.html"><h1 class="title_post">🌐[Network] 주소의 표현</h1></a>
                        <a href="/Backend/Network/2024-08-31-address-presentaion.html" class="txt_post">
                            🌐[Network] 주소의 표현.


  시스템을 설계할 때는 기능이나 목적과 함께 고유의 구분자(Identifier)를 부여하는 방법에 대해서도 우선하여 고려해야 합니다.
  일반적으로 주소의 개념은 단순히 서로를 구분한다는 고유 목적을 넘어서 주소가 가리키는 대상의 특징을 표현할 수 있습니다.
  사람들은 문자로 된 이름에 익숙하지만, 0과 1로 디지털화된 환경에서는 구분자를 숫자로 된 주소로 표현할 수밖에 없습니다.
  디지털 환경에서 숫자로 된 주소 표현 방식은 일반 사용자에게 불편하므로 보통은 외우기 쉬운 문자 형식의 이름을 추가로 사용합니다.
  주소와 이름은 일대일(1:1) 관계가 이루어지며, 이들은 연결하는 기능이 필요합니다.
  인터넷에서 일반 사용자는 문자로 된 이름을 사용하고, 인터넷 내부는 숫자로 된 주소를 사용하므로 둘 사이의 변환 기능이 필요합니다.
  대상을 유일하게 구별하는 구분자는 일반적으로 다음의 네 가지 특징이 있습니다.


1️⃣ 유일성


  구분자의 가장 중요한 역할은 대상을 서로 구분하여 지칭하는 것입니다.
    
      따라서 서로 다른 대상이 같은 구분자를 갖지 않는 유일성을 보장해야 합니다.
        
          그러나 이론적으로 완전한 확장성을 전제로 하는 유일성을 보장하기는 불가능합니다.
            
              예를 들어, 주민 번호에서 앞쪽 여섯 글자인 생년월일은 100년 이내에 출생한 사람들만 구분할 수 있습니다.
                
                  현재는 방편적으로 바로 뒤의 남녀 구분 자리(1900년대 출생자는 1,2를 사용하고, 2000년대 출생자는 3,4를 사용함)를 활용하여 제한적인 확장성을 확보하고 있을 뿐 입니다.
                
              
            
          
        
      
    
  


2️⃣ 확장성


  시스템은 시간이 흐르면서 이용자가 증가하는 보편화 과정이 진행되므로 자연스럽게 규모가 확장됩니다.
    
      따라서 사용하는 구분자의 양도 증가합니다.
    
  
  시스템의 최대 수용 규모를 예측하여 구분자의 최대 한계를 올바르게 설정하지 않으면, 표현할 수 있는 공간의 크기가 제한되어 시스템의 확장성도 제한받게 됩니다.
    
      합리적인 기준을 설정하여 확장의 정도를 예측하고, 또한 그 이후에 대한 고려도 함께 이루어져야 합니다.
    
  
  처음 인터넷을 설계했을 때 지금과 같은 규모로 인터넷을 이용하리라고는 예측하지 못했습니다.
    
      그 결과 인터넷 구분자인 IP 주소의 고갈 문제에 직면해 있습니다.
    
  


3️⃣ 편리성


  시스템 설계 과정에서 부여되는 구분자는 시스템의 내부 처리 구조를 효율적으로 운용할 수 있도록 해주어야 합니다.
    
      컴퓨터 시스템은 내부적으로 숫자에 기반해 처리되기 때문에 구분자의 체계도 숫자 위주입니다.
        
          또한 배치, 검색 등을 원활하게 수행하기 위해 보통 일반인이 의미를 이해할 수 없는 형식을 갖습니다.
            
              이처럼 시스템 내부 동작에 종속된 구분자의 주소 체계는 사용자가 쉽게 이해하기 어려우므로 문자로 된 이름을 추가로 부여합니다.
                
                  따라서 숫자로 된 주소와 문자로 된 이름을 모두 가지므로 이를 매핑(Mapping)하는 기능이 필요합니다.
                
              
            
          
        
      
    
  


4️⃣ 정보의 함축


  구분자는 응용 환경에 필요한 다양한 정보를 포함하는 경우가 많습니다.
    
      예를 들어, 주민 번호는 생년월일, 성별 등을 알 수 있는 숫자로 구성되어 있습니다.
        
          집 주소도 광역시부터 시작해 지역을 소규모로 분할하는 구조로 되어 있어 집의 지리적인 위치를 쉽게 가늠할 수 있습니다.
            
              이처럼 분자는 응용 환경에 적절히 대응할 수 있는 부가 정보를 포함해야 합니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/CS/2024-08-31-Factory-pattern.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/CS/2024-08-31-Factory-pattern.html"><h1 class="title_post">💾 [CS] 팩토리 패턴(factory pattern)</h1></a>
                        <a href="/Backend/CS/2024-08-31-Factory-pattern.html" class="txt_post">
                            💾 [CS] 팩토리 패턴(factory pattern).

1️⃣ 팩토리 패턴(factory pattern).

  
    팩토리 패턴(factory pattern)은 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴입니다.
  
  
    상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 갖게 됩니다.
    
      그리고 객체 생성 로직이 따로 떼어져 있기 때문에 코드를 리팩터링하더라도 한 곳만 고칠 수 있게 되니 유지 보수성이 증가됩니다.
        
          예를 들어 라떼 레시피와 아메리카노 레시피, 우유 레시피라는 구체적인 내용이 들어 있는 하위 클래스가 컨베이어 벨트를 통해 전달되고, 상위 클래스인 바리스타 공장에서 이 레시피들을 토대로 우유 등을 생산하는 생산 공정을 생각하면 됩니다.
        
      
    
  




2️⃣ 자바의 팩토리 패턴

enum CoffeeType {
    LATTE,
    ESPRESSO
}

abstract class Coffee {
    protected String name;
    
    public String getName() {
        return name;
    }
}

class Latte extends Coffee {
    public Latte() {
        name = "latte";
    }
}

class Espresso extends Coffee {
    public Espresso() {
        name = "Espresso";
    }
}

class CoffeeFactory {
    public static Coffee createCoffee(CoffeeType type) {
        switch (type) {
            case LATTE:
                return new Latte();
            case ESPRESSO:
                return new Espresso();
            default:
                throw new IllegalArgumentException("Invalid coffee type: " + type);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Coffee coffee = CoffeeFactory.createCoffee(CoffeeType.LATTE);
        System.out.println(coffee.getName()); // latte
    }
}


3️⃣ 코드 설명.

  팩토리 패턴(Factory Pattern) 은 객체 생성의 로직을 별도의 클래스나 메서드로 분리하여 관리하는 디자인 패턴입니다.
    
      이는 객체 생성에 관련된 코드를 클라이언트 코드에서 분리하여, 객체 생성의 변화에 대한 유연성을 높이고 코드의 유지보수성을 개선하는 데 도움이 됩니다.
    
  
  팩토리 패턴 은 크게 팩토리 메서드 패턴 과 추상 팩토리 패턴 으로 구분되며, 위 코드 예시는 팩토리 메스드 패턴 의 전형적인 예입니다.


1. CoffeeType 열거형(Enum)

enum CoffeeType {
    LATTE,
    ESPRESSO
}



  설명 : CoffeeType 은 커피의 종류를 나타내는 열거형(Enum)입니다.
    
      이 열거형은 LATTE 와 ESPRESSO 두 가지 타입의 커피를 정의하고 있습니다.
    
  
  역할 : 커피의 종류를 코드 내에서 명확하게 구분하고, CoffeeFactory 에서 커피 객체를 생성할 때 사용됩니다.


2. Coffee 추상 클래스.

abstract class Coffee {
    protected String name;
    
    public String getName() {
        return name;
    }
}



  설명 : Coffee 는 커피 객체의 공통된 속성과 메서드를 정의한 추상 클래스입니다.
    
      name 필드는 커피의 이름을 저장하며, getName() 메서드는 커피의 이름을 반환합니다.
    
  
  역할 : 구체적인 커피 클래스들이 상속받아야 하는 공통적인 기능을 정의합니다.


3. Latte 와 Espresso 클래스.
class Latte extends Coffee {
    public Latte() {
        name = "latte";
    }
}

class Espresso extends Coffee {
    public Espresso() {
        name = "Espresso";
    }
}



  설명 : Latte 와 Espresso 는 Coffee 클래스를 상속받아 구체적인 커피 타입을 구현한 클래스들입니다.
    
      각 클래스는 생성자에서 name 필드를 특정 커피 이름으로 초기화합니다.
    
  
  역할 : 특정 커피 타입의 객체를 생성하는 역할을 합니다.


4. CoffeeFactory 클래스.
class CoffeeFactory {
    public static Coffee createCoffee(CoffeeType type) {
        switch (type) {
            case LATTE:
                return new Latte();
            case ESPRESSO:
                return new Espresso();
            default:
                throw new IllegalArgumentException("Invalid coffee tyep: " + type);
        }
    }
}



  설명 : CoffeeFactory 클래스는 팩토리 패턴의 핵심으로, createCoffee() 메서드를 통해 특정 타입의 커피 객체를 생성하여 반환합니다.
    
      CoffeeType 열거형에 따라 적절한 커피 객체를 생성합니다.
    
  
  역할 : 객체 생성의 로직을 중앙 집중화하여 클라이언트 코드에서 객체 생성의 책임을 분리합니다.
    
      클라이언트는 CoffeeFactory 의 createCoffee() 메서드를 호출하여 원하는 커피 객체를 생성할 수 있습니다.
    
  


5. Main 클래스.
public class Main {
    public static void main(String[] args) {
        Coffee coffee = CoffeeFactory.createCoffee(CoffeeType.LATTE);
        System.out.println(coffee.getName()); // latte
    }
}



  설명 : Main 클래스는 클라이언트 코드로, CoffeeFactory 를 사용하여 LATTE 타입의 커피 객체를 생성하고, 그 이름을 출력합니다.
  역할 : 팩토리 패턴을 사용하는 클라이언트 코드로, 직접적으로 객체를 생성하지 않고 팩토리를 통해 객체를 생성합니다.


4️⃣ 팩토리 패턴의 장점.

  1. 코드의 유연성 증가.
    
      객체 생성 로직이 중앙화되어 있으므로, 새로운 커피 타입을 추가할 때 클라이언트 코드를 수정할 필요 없이 팩토리 클래스만 수정하면 됩니다.
    
  
  2. 유지보수성 향상.
    
      객체 생성 코드가 한 곳에 모여 있어 코드의 유지보수가 쉬워집니다.
        
          객체 생성 과정에서의 변경이 필요한 경우에도 팩토리 클래스만 수정하면 됩니다.
        
      
    
  
  3. 코드의 결합도 감소.
    
      클라이언트 코드는 구체적인 클래스에 의존하지 않고, 인터페이스나 추상 클래스를 통해 객체를 다루기 때문에 결합도가 낮아집니다.
    
  


5️⃣ 팩토리 패턴의 단점.

  1. 클래스의 복잡성 증가.
    
      객체 생성을 위한 팩토리 클래스가 추가됨으로써 클래스의 수가 증가하고, 코드 구조가 다소 복잡해질 수 있습니다.
    
  
  2. 확장 시 주의 필요.
    
      새로운 커피 타입을 추가할 때마다 팩토리 클래스의 switch 문이나 if-else 문이 증가할 수 있어, 확장성이 제한될 수 있습니다.
        
          이 문제를 해결하기 위해서는 추상 팩토리 패턴이나 다른 디자인 패턴과 결합하는 방법을 고려할 수 있습니다.
        
      
    
  


6️⃣ 결론.

  팩토리 패턴은 객체 생성의 책임을 분리하여 코드의 유연성과 유지보수성을 높이는 강력한 디자인 패턴입니다.
    
      위 코드 예시에서는 커피 객체를 생성하는 로직을 CoffeeFactory 클래스에 모아두어, 클라이언트 코드가 특정 커피 클래스에 직접적으로 의존하지 않도록 하였습니다.
        
          이를 통해 클라이언트 코드는 커피 객체의 생성 방식에 대해 신경 쓰지 않고도 다양한 타입의 커피를 생성하고 사용할 수 있게 됩니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/CS/2024-08-31-Abstraction.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/CS/2024-08-31-Abstraction.html"><h1 class="title_post">💾 [CS] 추상화(Abstraction)</h1></a>
                        <a href="/Backend/CS/2024-08-31-Abstraction.html" class="txt_post">
                            💾 [CS] 추상화(Abstraction).

1️⃣ 추상화(Abstraction).

  추상화(Abstraction) 는 객체 지향 프로그래밍(Object-Oriented-Programming, OOP)의 중요한 개념 중 하나로, 복잡한 시스템에서 핵심적인 개념이나 기능만을 추려내어 단순화하는 과정입니다.
    
      이를 통해 불필요한 세부 사항을 감추고, 중요한 속성이나 행위만을 노출하여 시스템을 보다 간단하게 이해하고 사용할 수 있게 합니다.
    
  


1️⃣ 추상화의 핵심 개념.

  1. 본질적인 것만 노출.
    
      시스템의 복잡한 내부 구현을 숨기고, 외부에서는 중요한 기능이나 속성만을 사용할 수 있도록 설계합니다.
        
          예를 들어, 자동차를 운전할 때 운전자는 엔진의 작동 원리나 내부 구조를 몰라도, 운전대, 가속 페달, 브레이크 등의 중요한 인터페이스를 통해 자동차를 조작할 수 있습니다.
        
      
    
  
  2. 복잡성 감소.
    
      추상화를 통해 사용자에게 복잡한 시스템을 단순하게 보이도록 하여, 사용자가 시스템을 쉽게 이해하고 사용할 수 있게 합니다.
        
          이는 특히 큰 시스템이나 라이브러리를 설계할 때 중요합니다.
        
      
    
  
  3. 재사용성과 유지보수성 향상.
    
      추상화를 사용하면, 코드의 재사용성을 높이고 유지보수성을 향상시킬 수 있습니다.
        
          동일한 추상 인터페이스를 구현하는 여러 클래스가 있을 때, 구체적인 클래스 구현을 신경 쓰지 않고 인터페이스를 통해 일관된 방식으로 코드를 사용할 수 있습니다.
        
      
    
  


2️⃣ 추상화의 예

  추상화는 주로 추상 클래스와 인터페이스 를 통해 구현됩니다.


추상 클래스.

  추상 클래스는 하나 이상의 추상 메서드를 초함하는 클래스입니다.
  추상 메서드는 선언만 되어 있고, 구체적인 구현은 해당 클래스를 상속받는 하위 클래스에서 제공해야 합니다.


abstract class Animal {
    abstract void sound(); // 추상 메서드
    
    void breathe() { // 구체적인 메서드
        System.out.println("Breathing");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Woof");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Meow");
    }
}



  이 예에서 Animal 클래스는 추상 클래스이고, sound() 메서드는 추상 메서드입니다.
  Dog 와 Cat 클래스는 sound() 메서드를 구체적으로 구현합니다.
  Animal 클래스는 동물의 일반적인 특징인 breath() 메서드를 포함하지만, sound() 는 동물마다 다르므로 하위 클래스에서 구체화됩니다.


인터페이스

  인터페이스는 추상화의 또 다른 형태로, 클래스가 구현해야 하는 메서드의 선언을 포함합니다.
  인터페이스 자체는 구현을 가지지 않으며, 구현은 이를 구현하는 클래스에서 제공됩니다.


interface Flyable {
    void fly(); // 추상 메서드
}

class Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("Bird is flying");
    }
}

class Airplane implements Flyable {
    @Override
    public void fly() {
        System.out.println("Airplane is flying");
    }
}



  여기서 Flyable 인터페이스는 fly() 라는 추상 메서드를 선언하고 있으며, Bird 와 Airplane 클래스는 각각 이 메서드를 구현합니다.
  Flyable 인터페이스를 통해, 비행할 수 있는 객체들은 동일한 방식으로 취급될 수 있습니다.


3️⃣ 추상화의 장점.

  1. 코드의 간결성.
    
      중요한 부분만 남기고 복잡한 구현 세부 사항을 숨겨, 코드를 간결하고 이해하기 쉽게 만듭니다.
    
  
  2. 유연한 설계.
    
      구체적인 구현에 의존하지 않기 때문에, 다양한 구현체를 쉽게 교체하거나 확장할 수 있습니다.
    
  
  3. 재사용성 증가.
    
      추상 클래스나 인터페이스를 통해 여러 클래스에서 공통적으로 사용될 수 있는 구조를 만들 수 있습니다.
    
  


4️⃣ 요약.

  추상화는 복잡한 시스템에서 불필요한 세부 사항을 감추고 중요한 부분만을 노출하여 시스템을 간단하게 만드는 개념입니다.
    
      이를 통해 코드의 복잡성을 줄이고, 유연성과 재사용성을 높이며, 유지보수를 용이하게 할 수 있습니다.
    
  
  추상화는 주로 추상 클래스와 인터페이스를 통해 구현됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/CS/2024-08-29-di.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/CS/2024-08-29-di.html"><h1 class="title_post">💾 [CS] 의존성 주입(DI, Dependency Injection)</h1></a>
                        <a href="/Backend/CS/2024-08-29-di.html" class="txt_post">
                            💾  [CS] 의존성 주입(DI, Dependency Injection).

1️⃣ 의존성 주입(DI, Dependency Injection)

  싱글톤 패턴과 같이 사용하기 쉽고 굉장히 실용적이지만 모듈 간의 결합을 강하게 만들 수 있는 단점이 있는 패턴의 경우 의존성 주입(DI, Dependency Injection)을 통해 모듈 간의 결합을 조금 더 느슨하게 만들어 해결할 수 있습니다.
  의존성이란 종속성이라고도 하며 A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A 또한 변해야 된다는 것을 의미합니다.






  앞의 그림처럼 메인 모듈(main module)이 ‘직접’ 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자(dependency injector)가 이 부분을 가로채 메인 모듈이 "간접적" 으로 의존성을 주입하는 방식입니다.
    
      이를 통해 메인 모듈(상위 모듈)은 하위 모듈에 대한 의존성이 떨어지게 됩니다.
        
          참고로 이를 ‘디커플링이 된다’ 고도 합니다.
        
      
    
  


1️⃣ 의존성 주입의 장점

  모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅하기 쉽고 마이그레이션하기도 수월합니다.
    
      또한, 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어 주기 때문에 애플리케이션 의존성 방향이 일관되고, 애플리케이션을 쉽게 추론할 수 있으며, 모듈 간의 관계들이 조금 더 명확해집니다.
    
  


2️⃣ 의존성 주입의 단점

  모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있으며 약간의 런타임 페널티가 생기기도 합니다.


3️⃣ 의존성 주입 원칙

  의존성 주입은 "상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 합니다. 또한, 둘 다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 말아야 합니다." 라는 의존성 주입 원칙을 지켜주면서 만들어야 합니다.



  위 문장에서 “추상화”의 의미.
문장에서 “추상화”는 구체적인 구현에 의존하지 않고, 일반화된 인터페이스나 추상 클래스 등에 의존해야 한다는 것을 뜻합니다.
이 원칙은 의존성 역전 원칙(DIP, Dependency Inversion Principle) 과 관련이 있습니다.
  
    상위 모듈 : 애플리케이션의 상위 계층에서 동작하는 코드, 즉 더 높은 수준의 정책이나 로직을 구현하는 모듈입니다.
    하위 모듈 : 상위 모듈에서 호출하거나 사용하는 구체적인 기능이나 세부 사항을 구현하는 코드입니다.
  


1️⃣ 추상화.

  “추상화” 는 객채 지향 프로그래밍(OOP)애서 중요한 개념 중 하나로, 구체적인 구현(details)을 감추고, 더 높은 수준의 개념을 정의하는 것을 의미합니다.
  추상화는 구체적인 것보다는 더 일반적이고 보편적인 개념을 다루며, 특정한 구현 사항에 의존하지 않고 인터페이스나 추상 클래스 등을 통해 기능을 정의합니다.


2️⃣ 의존성 주입과 추상화의 관계.

  의존성 주입(DI, Dependency Injection)은 의존성 역전 원칙(DIP, Dependency Inversion Principle)을 구현하기 위한 방법 중 하나입니다.
    
      의존성 주입을 사용하면, 상위 모듈이 하위 모듈의 구체적인 구현에 의존하지 않고, 하위 모듈이 구현한 추상화(인터페이스나 추상 클래스)에 의존하도록 코드를 설계할 수 있습니다.
        
          즉, 상위 모듈과 하위 모듈 모두 추상화된 인터페이스에 의존하게 하여, 구체적인 구현이 변경되더라도 상위 모듈의 코드가 영향을 받지 않도록 합니다.
        
      
    
  


3️⃣ 예시.

  아래는 추상화와 의존성 주입을 적용한 예시입니다.


// 추상화된 인터페이스 (추상화)
public interface PaymentProcessor {
    void processPayment(double amount);
}

// 하위 모듈 - 구체적인 구현
public class PayPalProcessor implements PaymentProcessor {
    @Override
    public void processPayment(double amount) {
        // PayPal을 통해 결제 처리
    }
}

public class CreditCardProcessor implements PaymentProcessor {
    @Override
    public void processPayment(double amount) {
        // 신용카드를 통해 결제 처리
    }
}

// 상위 모듈 - 추상화에 의존함
public class PaymentService {
    private PaymentProcessor paymentProcessor;
    
    // 의존성 주입을 통해 구현체를 주입 받음
    public PaymentService(PaymentProcessor paymentProcessor) {
        this.paymentProcessor = paymentProcessor;
    }
    
    public void makePayment(double amount) {
        paymentProcessor.processPayment(amount);
    }
}



  위 코드에서 "PaymentService" 는 "PaymentProcessor" 라는 추상화에 의존합니다.
    
      "PaymentService" 는 "PayPalProcessor" 나 "CreditCardProcessor" 의 구체적인 구현을 알 필요가 없으며, 단지 "PaymentProcessor" 인터페이스에 정의된 메서드를 호출합니다.
      - 이를 통해 결제 처리 방식이 PayPal에서 신용카드로 변경되더라도 "PaymentService" 는 수정할 필요가 없습나다.
    
  


이처럼 “추상화”는 상위 모듈과 하위 모듈이 특정 구현이 아닌, 일반적인 개념에 의존하도록 만들어줌으로써, 코드의 유연성과 재사용성을 높여주는 중요한 개념입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-29</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-28-Protocol.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-28-Protocol.html"><h1 class="title_post">🌐[Network] 프로토콜</h1></a>
                        <a href="/Backend/Network/2024-08-28-Protocol.html" class="txt_post">
                            🌐[Network] 프로토콜.

1️⃣ 프로토콜.

  프로토콜(Protocol)은 통신 시스템이 데이터를 교환하기 위해 사용하는 통신 규칙입니다.
    
      OSI 7계층 모델에서는 각 계층에서 수행하는 프로토콜이 서로 역할을 분담하여 독립적으로 동작합니다.
        
          따라서 계층 1에는 계층 1끼리 통신할 수 있는 프로토콜이 존재하고, 계층 2에는 계층 2끼리 통신할 수 있는 프로토콜이 존재합니다.
        
      
    
  


1️⃣ 프로토콜의 예.




  위 그림은 일반인이 스마트폰으로 통화하는 규칙을 보여주고 있는데, 이러한 순서와 절차를 프로토콜이라 정의할 수 있습니다.
    
      시간은 위에서 아래로 흐르고, 왼쪽의 발신자가 오른쪽의 수신자에게 통화를 시도하고 있습니다.
      연결을 설정할 때는 항상 발신자의 요청에 의하여 시작되며, 수신자는 미리 연결 대기 상태에 있어야 합니다.
      연결 설정은 상호 간의 합의 아래 이루어지지만, 종료는 한쪽의 일방적인 종결 선언으로도 가능합니다.
    
  
  전화 연결을 위한 규칙(프로토콜 - protocol) 설명.
    
      
        
          수신자는 스마트폰 전원을 켜서 발신자의 통화 요청보다 먼저 대기 상태에 있어야 합니다.
        
      
      
        
          발신자가 수신자의 전화번호를 누르면(또는 번호를 입력한 후  버튼을 누르면)
        
      
      
        
          수신자의 스마트폰의 벨이 울립니다.
        
      
      
        
          수신자가  버튼을 눌러 전화를 받으면 연결이 설정됩니다(수신자가 벨 소리를 무시하고 전화를 받지 않으면 열결되지 않으므로 연결 설정은 반드시 양자의 합의가 있어야 합니다).
        
      
      
        
          일단 연결이 설정되면 연결이 해제되기 전까지 데이터를 주고받을 수 있습니다.
        
      
      
        
          연결 해제는 외형상 한쪽의 일방적인 종료로 이루어지지만
            
              실제로는 대화의 과정에서 쌍방의 합의로 이루어집니다.
            
            
              실제 네트워크 프로토콜에서도 연결 해제를 한쪽의 일방적인 결정과 양자의 합의에 의한 결정으로 구분하여 설계합니다.
            
          
        
      
    
  


2️⃣ 데이터 단위.


  네트워크 프로토콜을 사용해 데이터를 교환할 때는 먼저 데이터를 특정 형태로 규격화하는 작업이 필요합니다.
    
      예를 들어, 우편물을 보낼 때 정해진 규격 봉투를 사용하는 것과 같은 원리입니다.
        
          규격 봉투에 보내는 사람 주소, 받는 사람 주소 등을 규칙에 따라 기입하는 것처럼 네트워크에서도 데이터를 프로토콜에서 정의된 데이터 규격에 맞춰 묶어주어야 합니다.
            
              이와 같은 한 단위의 규격으로 묶인 전송 데이터를 데이터 단위라 합니다.
            
          
        
      
    
  
  OSI 7계층 모델의 각 계층에서 규격화된 데이터에는 아래의 표와 같이 고유 명칭이 있습니다.
    
      계층에 상관없이 사용할 때는 통칭하여 PDU(Protocol Data Unit)라 부릅니다.
    
  





  데이터 단위의 용어 중에서 네트워크 계층에서 정의된 패킷이 인터넷에서 가장 많이 인용되며, 데이터 링크 계층에서 사용하는 프레임도 중요합니다.
  전송 계층에서 정의된 데이터그램은 가상 회선이라는 용어와 대비되면서 중요하게 다루어지기 때문에 이들 세 용어에 익숙해질 필요가 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-08-24-static-content.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-08-24-static-content.html"><h1 class="title_post">🍃[Spring] 정적 컨텐츠.</h1></a>
                        <a href="/Backend/Spring/2024-08-24-static-content.html" class="txt_post">
                            🍃[Spring] 정적 컨텐츠.

  스프링 부트 정적 컨텐츠 기능
  스프링 부트 공식 문서


'resources/static/hello-static.html'
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;static content&lt;/title&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
&lt;/head&gt;
&lt;body&gt;
정적 컨텐츠 입니다.
&lt;/body&gt;
&lt;/html&gt;


실행

  http://localhost:8080/hello-static.html


정적 컨텐츠 이미지


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-08-24-Summary-of-business-requirements.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-08-24-Summary-of-business-requirements.html"><h1 class="title_post">🍃[Spring] 일반적인 웹 애플리케이션 계층 구조와 클래스 의존관계.</h1></a>
                        <a href="/Backend/Spring/2024-08-24-Summary-of-business-requirements.html" class="txt_post">
                            🍃[Spring] 일반적인 웹 애플리케이션 계층 구조와 클래스 의존관계.

1️⃣ 일반적인 웹 애플리케이션 계층 구조.




  Controller : 웹 MVC의 Controller 역할.
    
      사용자의 요청을 받아 이를 처리할 비즈니스 로직(서비스 레이어)에 전달하고, 그 결과를 다시 사용자에게 응답하는 역할을 합니다.
        
          주로 HTTP 요청을 처리하고, 올바른 응답을 생성합니다.
        
      
      컨트롤러는 사용자로부터 입력을 받아 해당 입력을 서비스 레이어로 전달하고, 서비스 레이어에서 처리된 결과를 사용자에게 반환합니다.
        
          이는 주로 웹 애플리케이션의 엔트포인트(예: '/login', '/signup' 와 같은 URL)에 대응됩니다.
        
      
    
  
  Service : 핵심 비즈니스 로직 구현.
    
      비즈니스 로직을 처리하는 계층입니다.
      컨트롤러와 리포지토리 사이에서 중간 역할을 하며, 여러 리포지토리로부터 데이터를 가져오거나 가공하고, 이를 다시 컨트롤러에 전달합니다.
      서비스 계층은 애플리케이션의 핵심 비즈니스 로직이 위치하는 곳입니다.
        
          예를 들어, 사용자 인증, 결제 처리, 이메일 전송 등의 주요 기능이 이 계층에서 처리됩니다.
        
      
    
  
  Repository: 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리.
    
      데이터베이스와 상호작용하는 계층입니다.
      데이터의 저장, 검색, 갱신, 삭제 등의 작업을 처리하며, 데이터베이스와의 직접적인 통신을 담당합니다.
      리포지토리는 데이터를 처리하기 위한 SQL 쿼리나 ORM(Object-Relational Mapping) 작업을 담당합니다.
      이 계층은 서비스 계층에서 필요한 데이터를 가져오거나, 새 데이터를 저장하는 역할을 합니다.
    
  
  Domain: 비즈니스 도메인 객체.
    
      예를 들어 회원, 주문 쿠폰 등등 주로 데이터베이스에 저장하고 관리됨.
      애플리케이션의 핵심 엔티티(Entity)와 비즈니스 규칙을 정의하는 계층입니다.
        
          보통 객체로 표현되며, 비즈니스 로직의 일부를 캡슐화합니다.
        
      
      도메인 계층은 애플리케이션에서 중요한 객체들(예: 'User', 'Product', 'Order' 등)을 정의하고, 이 객체들이 어떤 방식으로 상호작용하는지를 나타냅니다.
        
          이는 애플리케이션이 어떤 비즈니스 문제를 해결하는지에 대한 모델을 나타냅니다.
        
      
    
  


2️⃣ 클래스 의존관계.



  회원 비즈니스 로직에는 회원 서비스가 있다.
    
      회원을 저장하는 것은 인터페이스로 설계 되어있다.
        
          그 이유는 아직 데이터 저장소가 선정되지 않았음을 가정하고 설계했기 때문이다.
          그리고 구현체를 우선은 메모리 구현체로 만들것이다.
            
              그 이유는 일단 개발은 해야하므로 굉장히 단순한 메모리 기반의 데이터 저장소를 사용하여 메모리 구현체로 만든다.
                
                  향후에 메모리 구현체를 구체적인 기술이 선정이 되면(RDB, NoSQL 등) 교체할 것이다.
                    
                      교체하려면 Interface가 필요하므로 Interface를 정의한 것이다.
                    
                  
                
              
            
          
        
      
    
  
  아직 데이터 저장소가 선정되지 않아서, 우선 인터페이스로 구현 클래스를 변경할 수 있도록 설계
  데이터 저장소는 RDB, NoSQL 등등 다양한 저장소를 고민중인 상황으로 가정
  개발을 진행하기 위해서 초기 개발 단계에서는 구현체로 가벼운 메모리 기반의 데이터 저장소 사용


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-08-24-MVC-Template-engine.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-08-24-MVC-Template-engine.html"><h1 class="title_post">🍃[Spring] MVC와 템플릿 엔진.</h1></a>
                        <a href="/Backend/Spring/2024-08-24-MVC-Template-engine.html" class="txt_post">
                            🍃[Spring] MVC와 템플릿 엔진.

  MVC
    
      Model
      View
      Controller
    
  
  Controller


@Controller
public class HelloController {
    
    @GetMapping("hello-mvc")
    public String helloMvc(@RequestParam("name") String name, Model model) {
        model.addAttribute("name", name);
        return "hello-template";
    }
}



  View


&lt;html xmlns:th="htt[://www.thymeleaf.org"&gt;
&lt;body&gt;
&lt;p th:text="'hello ' + ${name}"&gt;hello! empty&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;



  실행
    
      http://localhost:8080/hello-mvc?name=spring
    
  





  MVC 템플릿 엔진 이미지




                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-08-24-API.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-08-24-API.html"><h1 class="title_post">🍃[Spring] API.</h1></a>
                        <a href="/Backend/Spring/2024-08-24-API.html" class="txt_post">
                            🍃[Spring] API.

'@ResponseBody 문자 반환'
@Controller
public class HelloController {

    @GetMapping("hello-string")
    @ResponseBody
    public String helloString(@RequestParam("name") String name) {
        return "hello " + name;
    }
}



  '@ResponseBody' 를 사용하면 뷰 리졸버('viewResolver')를 사용하지 않습니다.
    
      대신에 HTTP와 BODY에 문자 내용을 직접 반환합니다.(HTML BODY TAG를 말하는 것이 아닙니다.)
    
  
  실행
    
      http://localhost:8080/hello-string?name=spring
    
  




'@ResponseBody 객체 반환'
@Controller
public class HelloController {
    
    @GetMapping("hello-api")
    @ResponseBody
    public Hello helloApi(@RequestParam("name") String name) {
        Hello hello = new Hello();
        hello.setName(name);
        return hello;
    }

    static class Hello {
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
}



  실행
    
      http://localhost:8080/hello-api?name=spring
    
  




'@ResponseBody 사용 원리'




  '@ResponseBody' 를 사용
    
      HTTP의 BODY에 문자 내용을 직접 반환
      'viewResolver' 대신에 'HttpMessageConverter' 가 동작
      기본 문자처리: 'StringHttpMessageConverter'
      기본 객체처리: 'MappingJackson2HttpMessageConverter'
      byte 처리 등등 기타 여러 'HttpMessageConverter' 가 기본으로 등록되어 있음.
    
  



  🙋‍♂️ 참고: ** 클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서
**'HttpMessageConverter' 가 선택된다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-24-Internetworking.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-24-Internetworking.html"><h1 class="title_post">🌐[Network] 인터네트워킹</h1></a>
                        <a href="/Backend/Network/2024-08-24-Internetworking.html" class="txt_post">
                            🌐[Network] 인터네트워킹


  네트워크와 네트워크의 연결을 인터네트워킹(Internetworking)이라 하며, 연결되는 네트워크 수가 증가할수록 복잡도가 커집니다.
  인터넷은 IP 프로토콜을 지원하는 전 세계의 모든 네트워크가 반복 구조로 연결된 시스템을 의미하며, 라우터라는 중개 장비를 사용해서 네트워크들을 연결합니다.


1️⃣ 네트워크의 연결




  위 그림처럼 서로 독립적으로 운영되는 2개 이상의 네트워크가 연동되어 정보를 교환하려면, 이를 적절히 연결하여 데이터를 중개할 수 있는 인터네트워킹 시스템이 필요합니다.
    
      여기에서 네트워크가 연동된다는 의미는 물리적인 연결뿐 아니라, 데이터 중개에 필요한 상위의 네트워크 프로토콜들이 지원됨을 뜻합니다.
    
  
  인터넷에서 인터네트워킹 시스템의 주요 기능은 전송 데이터의 경로 선택과 관계가 있습니다.
    
      예를 들어 위 그림의 네트워크 1에서 유입된 데이터를 네트워크 2와 네트워크 3의 누구에게 보낼 것인가를 선택해야 합니다.
        
          이 기능은 7계층 모델에서 네트워크 계층에 포함되므로 인터네트워킹 시스템은 네트워크 계층을 포함한 하위 3개 계층의 기능을 수행합니다.
        
      
    
  
  그림의 예는 일반 도로로 비유하자면 삼거리의 경우와 유사하며, 여기서 자동차 내비게이션 기능이 인터네트워킹 시스템의 주요 기능에 해당합니다.
  인터넷의 내부 구조는 이와 같은 인터네트워킹 시스템들이 복잡하게 연결되어 상호 유기적인 협조 체제로 동작합니다.
  인터네트워킹 시스템에 연결된 네트워크들은 물리적으로 같은 종류일 필요가 없으며, 상위 계층 프로토콜들이 지원하는 논리적 기능도 다를 수 있습니다.
    
      하지만 인터네트워킹 시스템은 연결된 모든 네트워크에 대하여 물리적이고 논리적인 인터페이스를 모두 지원해야 합니다.
        
          즉, 위 그림에서 인터네트워킹 시스템은 네트워크 1, 네트워크 2, 네트워크 3과 개별적으로 연동할 수 있어야 합니다.
          또한 이 과정에서 데이터 표현 방식을 포함해 양쪽 네트워크의 프로토콜이 서로 일치하지 않으면 필요한 변환 작업을 수행해야 합니다.
            
              이러한 방식으로 인터네트워킹 시스템은 둘 이상의 네트워크를 유기적으로 연동할 수 있습니다.
            
          
        
      
    
  


2️⃣ 게이트웨이

  인터네트워킹 시스템은 용어 자체로 의미를 쉽게 설명하고 이해시키기 위한 개념적인 명칭이며, 인터네트워킹 기능을 수행하는 시스템을 일반적으로 게이트웨이(Gateway)라 부릅니다.
  게이트웨이의 종류는 다양하지만, 일반적으로 지원할 수 있는 기능의 한계에 따라 리피터, 브리지, 라우터 등으로 나뉩니다.


1️⃣ 리피터(Repeater)

  리피터(Repeater)는 물리 계층의 기능을 지원합니다.
  물리적 신호는 전송 거리가 멀수록 감쇄되기 때문에 중간에 이를 보완해주어야 합니다.
    
      예를 들어, 사람의 목소리는 멀리 전달될수록 세기가 약해져서 점점 알아들을 수 없게 됩니다.
        
          이와 같이 네트워크에서도 무선 신호 혹은 유선의 전기적 신호도 거리가 멀어질수록 신호의 크기가 약해집니다.
            
              따라서 리피터는 한쪽에서 입력된 신호를 물리적으로 단순히 증폭하여 다른 쪽으로 중개하는 역할을 합니다.
            
          
        
      
    
  


2️⃣ 브리스(Bridge)

  리피터는 단순히 신호를 증폭하는 역할을 하며, 전송과정에서 발생하는 물리적인 오류 문제는 다루지 않습니다.
    
      이를 보완한 브리지(Bridge)는 리피터 기능에 데이터 링크 계틍의 기능이 추가 된 것으로 물리 계층에서 발생한 오류를 해결해줍니다.
        
          예를 들어, 가정에서 사용하는 무선 공유기는 유무선 기능을 모두 지원하는 브리지의 예입니다.
        
      
    
  


3️⃣ 라우터(Router)

  라우터(Router)는 물리 계층, 데이터 링크 계층, 네트워크 계층의 기능을 지원합니다.
    
      네트워크 계층은 경로 선택 기능을 제공해야 하므로 임의의 네트워크에서 들어온 데이터를 어느 네트워크로 전달할지 판단할 수 있어야 합니다.
        
          이를 위하여 라우터는 자신과 연결된 네트워크와 호스트들의 정보를 유지,관리함으로써 특정 경로가 이용 가능한지 여부와 다수의 경로 중에서 어느 경로가 빠른 데이터 전송을 지원하는지 판단할 수 있어야 합니다.
        
      
    
  
  네트워크와 호스트에 대한 정보는 일반적으로 라우팅 테이블(Routing Table)에 보관됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-08-23-Thymeleaf.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-08-23-Thymeleaf.html"><h1 class="title_post">🍃[Spring] Welcome Page 구현 및 동작 방법.</h1></a>
                        <a href="/Backend/Spring/2024-08-23-Thymeleaf.html" class="txt_post">
                            🍃[Spring] Welcome Page 구현 및 동작 방법.

1️⃣ Welcom Page 만들기.

  Welcom Page는 'resource/static' 내부에 'index.html' 이라는 파일로 만들면 됩니다.
```html
&lt;!DOCTYPE html&gt;


	
		Hello
		
	
	
		Hello
		hello
	


- 스프링 부트가 제공하는 Welcom Page 기능.
    - **`'static/index.html'`** 을 올려두면 Welcom page 기능을 제공합니다.
    - [Spring.io 공식 도큐먼트](https://docs.spring.io/spring-boot/3.3-SNAPSHOT/reference/web/reactive.html#web.reactive.webflux.welcome-page)

## 2️⃣ thymeleaf 템플릿 엔진.
- [thymeleaf 공식 사이트](https://www.thymeleaf.org/)
- [스프링 공식 튜토리얼](https://spring.io/guides/gs/serving-web-content)
- [스프링부트 메뉴얼](https://docs.spring.io/spring-boot/3.3-SNAPSHOT/reference/web/servlet.html#web.servlet.spring-mvc.template-engines)

```java
// com/devkobe/hello_spring/controller
@Controller
public class HelloController {
    
    @GetMapping("hello")
    public String hello(Model model) {
        model.addAttribute("data", "hello!!");
        return "hello";
    }
}


&lt;!-- `resource/static/index.html` --&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;Hello&lt;/title&gt;
		&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
	&lt;/head&gt;
	&lt;body&gt;
		Hello
		&lt;a href="/hello"&gt;hello&lt;/a&gt;
	&lt;/body&gt;
&lt;/html&gt;


&lt;!-- `resource/templates/hello.html` --&gt;
&lt;!DOCTYPE html&gt;
&lt;html xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
	&lt;title&gt;Hello&lt;/title&gt;
&lt;/head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;body&gt;
&lt;p th:text="'안녕하세요. ' + ${data}" &gt;안녕하세요. 손님&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;



  thymeleaf 템플릿엔진 동작 확인
    
      실행 : http://localhost:8080/hello
    
  
  
    동작 환경 그림.

  
  컨트롤러에서 리턴 값으로 문자를 반환하면 뷰 리졸버('viewResolver') 가 화면을 찾아서 처리합니다.
    
      스프링 부트 템플릿엔진 기본 'viewName' 매핑.
        
          'resources:template/' + '{ViewName}' + '.html'
        
      
    
  



  🙋‍♂️ 참고: 'spring-boot-devtools' 라이브러리를 추가하면 'html' 파일을 컴파일만 해주면 서버 재시작 없이 View 파일 변경이 가능합니다.
IntelliJ 컴파일 방법 : 메뉴 build ➔ Recompile


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/CS/2024-08-23-Singleton.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/cs.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/CS/2024-08-23-Singleton.html"><h1 class="title_post">💾 [CS] 싱글톤 패턴</h1></a>
                        <a href="/Backend/CS/2024-08-23-Singleton.html" class="txt_post">
                            💾  [CS] 싱글톤 패턴.

1️⃣ 싱글톤 패턴(Singleton pattern)

  싱글톤 패턴(singleton pattern)은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴입니다.
  하나의 클래스를 기반으로 여러 개의 개별적인 인스턴스를 만들 수 있지만, 그렇게 하지 않고 하나의 클래스를 기반으로 단 하나의 인스턴스를 만들어 이를 기반으로 로직을 만드는데 쓰입니다.
    
      보통 데이터베이스 연결 모듈에 많이 사용합니다.
    
  
  하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어드는 장점이 있습니다.
    
      하지만 의존성이 높아진다는 단점이 있습니다.
    
  


2️⃣ Java에서의 싱글톤 패턴.

  Java에서 Singleton 패턴을 구현하는 방법은 여러 가지가 있지만, 가장 일반적으로 사용되는 방법 중 몇 가지를 소개하겠습니다.
    
      Eager Initialization(즉시 초기화)
      Lazy Initialization(지연 초기화)
      Thread-safe Singleton(스레드 안전 싱글톤)
        
          Synchronized Method
          Double-checked Locking
        
      
      Bill Pugh Singleton(Holder 방식)
    
  


1️⃣ Eager Initialization(즉시 초기화)

  가장 간단한 방법으로, 클래스가 로드될 때 즉시 Singleton 인스턴스를 생성합니다.
    public class Singleton {
  // 유일한 인스턴스 생성
  private static final Singleton instance = new Singleton();
    
  // private 생성자: 외부에서 인스턴스 생성을 방지
  private Singleton() {}
    
  // 인스턴스를 반환하는 메서드
  public static Singleton getInstance() {
      return instance;
  }
}
    
  
  이 방법은 간단하고 직관적이지만, 클래스가 로드될 때 바로 인스턴스가 생성되기 때문에, 인스턴스가 사용되지 않더라도 메모리를 차지하게 됩니다.


2️⃣ Lazy Initialization(지연 초기화)

  인스턴스가 처음으로 필요할 때 생성되도록 합니다.
    
      이 방법은 초기화에 드는 비용이 큰 경우 유리합니다.
```java
public class Singleton {
  // 유일한 인스턴스를 저장할 변수 (초기에는 null)
  private static Singleton instance;
    

    // private 생성자: 외부에서 인스턴스 생성을 방지
  private Singleton() {}

    // 인스턴스를 반환하는 메서드 (필요할 때만 생성)
  public static Singleton getInstance() {
      if (instance == null) {
          instance = new Singleton();
      }
      return instance;
  }
}
```
  
  이 방법은 다중 스레드 환경에서 안전하지 않기 때문에, 추가적인 동기화가 필요합니다.


3️⃣ Thread-safe Singleton(스레드 안전 싱글톤)

  다중 스레드 환경에서 안전하게 Lazy Initialization을 구현하려면 동기화를 사용합니다.


1️⃣ Synchronized Method
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {}
    
    // synchronized 키워드로 스레드 안전하게 만듦
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}


  이 방법은 안전하지만, 성능에 약간의 영향을 줄 수 있습니다.
    
      'synchronized' 로 인해 여러 스레드가 동시에 ‘getInstance()‘ 를 호출할 때 병목 현상이 발생할 수 있습니다.
    
  


2️⃣ Double-checked Locking

  이 방법은 성능과 스레드 안전성을 모두 고려한 최적화된 방식입니다.
    public class Singleton {
  private static volatile Singleton instance;
    
  private Singleton() {}
    
  public static Singleton getInstance() {
      if (instance == null) {
          synchronized (Singleton.class) {
              if (instance == null) {
                  instance = new Singleton();
              }
          }
      }
      return instance;
  }
}
    
  
  여기서 'volatile' 키워드는 인스턴스 변수가 스레드 간에 올바르게 초기화되도록 보장합니다.


4️⃣ Bill Pugh Singleton(Holder 방식)

  이 방법은 Lazy Initialization을 사용하면서도, 성능과 스레드 안전성을 모두 보장합니다.
    public class Singleton {
    
  private Singleton() {}
    
  // SingletonHolder가 클래스 로드 시점에 초기화됨
  private static class SingletonHolder {
      private static final Singleton INSTANCE = new Singleton();
  }
    
  public static Singleton getInstance() {
      return SingletonHolder.INSTANCE;
  }
}
    
  
  이 방법은 내부 정적 클래스가 JVM에 의해 클래스 로드 시 초기화되므로, 가장 권장되는 방식 중 하나입니다.
    
      클래스가 로드될 때 초기화가 이루어지므로, 동기화나 추가적인 코드 없이도 스레드 안전성을 보장할 수 있습니다.
    
  


3️⃣ Spring Boot와 MySQL 데이터베이스의 연결 그리고 싱글턴 패턴.

  Spring Boot에서 MySQL 데이터베이스를 연결할 때, 내부적으로 ‘싱글턴 패턴’ 이 사용됩니다.
    
      그러나 이 패턴을 직접 구현할 필요는 없습니다.
        
          ‘Spring Framework’ 자체가 싱글턴 패턴을 활용하여 데이터베이스 연결 및 관리와 관련된 ‘Bean(객체)’ 을 관리합니다.
        
      
    
  


1️⃣ Spring Boot와 싱글턴 패턴.

  Spring Framework는 기본적으로 각 Bean을 싱글턴 스코프로 관리합니다.
    
      이는 특정 클래스의 인스턴스가 애플리케이션 컨텍스트 내에서 한 번만 생성되어 애플리케이션 전반에서 공유됨을 의미합니다.
    
  


2️⃣ 데이터베이스 연결에서의 싱글턴 패턴 사용.

  
    
      DataSource Bean.
        
          Spring Boot에서 MySQL과 같은 데이터베이스에 연결할 때 'DataSource' 라는 'Bean' 을 생성하여 관리합니다.
          이 'DataSource' 객체는 데이터베이스 연결을 관리하는 역할을 하며, Spring은 이 'Bean' 을 싱글턴으로 생성하고 관리합니다.
        
        
          즉, Spring 애플리케이션 내에서는 'DataSource' 객체가 하나만 생성되어 모든 데이터베이스 연결 요청에서 재사용됩니다.
        
      
    
  
  
    
      EntityManagerFactory 및 SessionFactory.
        
          JPA나 Hibernate와 같은 ORM을 사용하는 경우, 'EntityManagerFactory' 나 'SessionFactory' 와 같은 객체도 싱글턴 패턴에 의해 관리됩니다.
        
        
          이들 객체는 데이터베이스 연결을 처리하고 트랜잭션을 관리하며, 역시 Spring에 의해 싱글턴으로 관리됩니다.
        
      
    
  
  
    
      Spring의 싱글턴 관리.
        
          Spring은 개발자가 'Bean' 을 직접 싱글턴으로 관리할 필요가 없도록, 애플리케이션의 컨텍스트 내에서 'Bean' 을 싱글턴으로 관리합니다.
          데이터베이스와의 연결 관련 클래스들이 이 'Bean' 들로 구성되며, 이는 데이터베이스 연결이 효율적이고 일관되게 관리되도록 보장합니다.
        
      
    
  


3️⃣ 예시: Spring Boot에서 MySQL 연결 설정.

  Spring Boot에서 MySQL 데이터베이스를 연결하기 위한 일반적인 설정은 'application.properties' 파일이나 'application.yml' 파일에 데이터베이스 연결 정보를 추가하는 것입니다.


spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver



  이 설정은 Spring Boot가 'DataSource' 'Bean' 을 자동으로 생성하도록 하며, 이 'Bean' 은 애플리케이션 내에서 싱글턴으로 관리됩니다.


4️⃣ ✏️ 요약

  Spring Boot에서 MySQL과 같은 데이터베이스를 연결할 때, Spring은 내부적으로 싱글턴 패턴을 사용하여 데이터베이스 연결을 관리합니다.
    
      'DataSource', 'EntityManagerFactory' 등의 객체가 싱글턴으로 관리되며, 이를 통해 애플리케이션 전반에 걸쳐 일관되고 효율적인 데이터베이스 연결 관리가 이루어집니다.
        
          Spring 자체가 이 패턴을 처리하므로, 개발자는 별도로 싱글턴 패턴을 구현할 필요가 없습니다.
        
      
    
  


4️⃣ Java Servlet 컨테이너와 MySQL 데이터베이스 연결 그리고 싱글턴 패턴.

  Java Servlet 컨테이너에서 MySQL 데이터베이스를 연결할 때, 싱글턴 패턴이 일반적으로 사용됩니다.
    
      다만, 이 패턴은 애플리케이션 코드에서 직접 구현되는 것이 아니라, 서블릿 컨테이너나 데이터베이스 연결 관리 라이브러리에서 사용됩니다.
    
  


1️⃣ JDBC DataSource

  서블릿 컨테이너(예: Tomcat, Jetty)에서 데이터베이스 연결을 설정할 때 보통 'DataSource' 를 사용합니다.
    
      이 'DataSource' 객체는 보통 싱글턴으로 관리되며, 데이터베이스 연결 풀을 제공합니다.
    
  
  Connection Pooling
    
      서블릿 컨테이너는 데이터베이스 연결을 관리하기 위해 연결 풀링(Connection pooling)을 사용합니다.
        
          연결 풀은 여러 데이터베이스 연결을 미리 생성하고 재사용하도록 관리합니다.
        
      
      연결 풀을 관리하는 객채는 'DataSource' 이고, 이는 애플리케이션 내에서 싱글턴으로 관리되어, 여러 서블릿에서 동일한 'DataSource' 객체를 사용하여 효율적으로 데이터베이스에 연결할 수 있습니다.
    
  


2️⃣ 싱글턴 패턴의 활용.

  DataSource 객체
    
      서블릿 컨테이너는 보통 'DataSource' 객체를 싱글턴으로 관리합니다.
        
          'DataSource' 는 데이터베이스 연결 풀을 관리하며, 이 객체가 한 번만 생성되어 애플리케이션 전반에 걸쳐 재사용됩니다.
        
      
    
  
  Connection 객체
    
      각 요청마다 데이터베이스 연결이 필요할 때마다 새로운 'Connection' 객체가 생성되거나 풀에서 가져오게 됩니다.
        
          하지만 'DataSource' 자체는 싱글턴으로 관리되기 때문에, 동일한 'DataSource' 객체를 통해 연결이 이루어집니다.
        
      
    
  


3️⃣ 예시: Tomcat에서 DataSource 설정

  Tomcat과 같은 서블릿 컨테이너에서 MySQL 데이터베이스와의 연결을 설정하는 일반적인 방법은 'context.xml' 파일에서 'DataSource' 를 정의하는 것입니다.


&lt;Context&gt;
    &lt;Resource name="jdbc/MyDB"
              auth="Container"
              type="javax.sql.DataSource"
              maxTotal="100"
              maxIdel="30"
              maxWaitMillis="10000"
              username="root"
              password="password"
              driverClassName="com.myslq.cj.jdbc.Driver"
              url="jdbc:mysql://localhost:3306/mydb"/&gt;
&lt;/Context&gt;


  이 설정은 'jdbc/MyDB' 라는 JNDI 리소스를 정의하고, 'DataSource' 객체를 생성하여 연결 풀링을 관리합니다.
    
      이 'DataSource' 는 Tomcat 내에서 싱글톤으로 관리됩니다.
    
  


4️⃣ 싱글턴 패턴의 이점.

  효율성.
    
      여러 서블릿이 동일한 'DataSource' 객체를 공유함으로써 메모리와 자원을 절약할 수 있습니다.
    
  
  관리의 용이성.
    
      데이터베이스 연결 관리를 중앙화할 수 있으며, 코드에서 직접 관리할 필요 없이 서블릿 컨테이너가 이를 담당합니다.
    
  


5️⃣ ✏️ 요약

  Java Servlet 컨테이너에서 MySQL 데이터베이스를 연결할 때, 싱글턴 패턴은 주로 DataSource 객체에 적용됩니다.
    
      이 DataSource 객체는 서블릿 컨테이너에 의해 싱글턴으로 관리되며, 데이터베이스 연결 풀을 통해 효율적으로 데이터베이스 연결을 처리합니다.
        
          이를 통해 애플리케이션 전반에 걸쳐 일관되고 성능이 최적화된 데이터베이스 연결 관리가 이루어집니다.
        
      
    
  


3️⃣ Java 애플리케이션 서버와 MySQL 데이터베이스의 연결 그리고 싱글턴 패턴.

  Java 애플리케이션 서버에서 MySQL 데이터베이스를 연결할 때, 싱글턴 패턴은 우요한 역할을 합니다.
    
      그러나 이 패넡은 애플리케이션 코드에서 직접 구현되지 않으며, 애플리케이션 서버나 데이터베이스 연결 관리 라이브러리에서 사용됩니다.
    
  


1️⃣ DataSource와 Connection Pooling

  Java 애플리게이션 서버(예: JBoss/WildFly, GlassFish, WebSphere)에서 데이터베이스를 연결할 때 일반적으로 'JDBC DataSource' 와 'Connection Pooling' 을 사용합니다.
    
      이때 DataSource 객체는 싱글턴으로 관리되며, 데이터베이스 연결의 효율성을 높이기 위해 연결 풀을 사용합니다.
    
  
  DataSource 싱글턴 관리
    
      애플리케이션 서버는 데이터베이스와의 연결을 관리하기 위해 DataSource를 생성합니다.
        
          이 DataSource 객체는 서버에서 싱글턴으로 관리됩니다.
            
              즉, 애플리케이션 전반에 걸쳐 동일한 DataSource 객체가 사용됩니다.
            
          
        
      
      DataSource는 내부적으로 데이터베이스 연결 풀을 관리하며, 여러 클라이언트 요청에서 동일한 데이터베이스 연결 객체를 재사용합니다.
    
  
  Connection 객체 관리
    
      데이터베이스와의 실제 연결을 관리하는 Connection 객체는 매번 새로운 요청이 있을 때마다 DataSource에서 가져오지만, DataSource는 싱글턴으로 관리되므로 전체 애플리케이션에서 일관된 연결 풀이 사용됩니다.
    
  


2️⃣ Java EE 환경에서의 DataSource 관리

  Java EE 애플리케이션 서버에서는 'JNDI(Java Naming and Directory Interface)' 를 통해 DataSource를 관리합니다.
    
      이는 서버의 전역 설정에서 관리되며, 여러 애플리케이션이 동일한 데이터베이스 연결을 공유할 수 있도록 합니다.
    
  
  JNDI를 통한 DataSource 설정 예시
```xml



- 이 설정은 애플리케이션 서버가 싱글턴 DataSource 객체를 생성하고 관리하도록 합니다.

### 3️⃣ 싱글턴 패턴의 역할.
- **효율성**
    - 싱글턴으로 관리되는 DataSource는 애플리케이션 서버 전체에서 하나의 객체로 유지되며, 이를 통해 메모리와 자원 사용이 최적화됩니다.
- **일관성**
    - 동일한 데이터베이스 연결 풀을 사용하기 때문에 애플리케이션 전방에 걸쳐 데이터베이스 연결이 일관되게 관리됩니다.
- **관리 용이성**
    - 데이터베이스 연결 관리가 중앙화되어, 각 애플리게이션에서 따로 관리할 필요 없이 서버에서 통합 관리됩니다.

### 4️⃣ EJB와의 통합.
- JavaEE 환경에서 EJB(Enterprise JavaBeans)는 주로 애플리케이션 서버에서 관리되는 비즈니스 로직을 구현하는 데 사용됩니다.
- EJB에서 데이터베이스 연결을 사용할 때도 싱글턴 패턴이 적용된 DataSource를 통해 연결이 이루어집니다.
```java
@Stateless
public class MyService {
    
    @Resource(lookup = "java:/jdbc/MyDB")
    private DataSource dataSource;
    
    public void doSomething() {
        try (Connection connection = dataSource.getConnection()) {
            // 데이터베이스 작업 수행
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


  이 코드에서 'dataSource' 는 서버에 의해 관리되는 싱글턴 DataSource 객체를 참조하며, 이를 통해 데이터베이스 연결을 처리합니다.


5️⃣ ✏️ 요약,

  Java 애플리케이션 서버에서 MySQL 데이터베이스를 연결할 때, 싱글턴 패턴은 DataSource와 같은 중요한 객체 관리에 사용됩니다.
    
      이 패턴을 통해 애플리케이션 서버는 데이터베이스 연결을 효율적이고 일관되게 관리할 수 있으며, 연결 풀링을 통해 자원 사용을 최적화합니다.
        
          애플리케이션 서버가 DataSource를 싱글턴으로 관리함으로써, 서버 전반에 일관된 데이터베이스 연결을 제공하고 효율성을 극대화할 수 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Spring/2024-08-22-logging-framework.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Spring/2024-08-22-logging-framework.html"><h1 class="title_post">🍃[Spring] slf4j와 logback.</h1></a>
                        <a href="/Backend/Spring/2024-08-22-logging-framework.html" class="txt_post">
                            🍃[Spring] slf4j와 logback.

1️⃣ slf4j


  'SLF4J(Simple Logging Facade for Java)' 는 Java 애플리케이션에서 로그 기록을 쉽게 관리하고 다른 로깅 프레임워크와 통합할 수 있도록 도와주는 로깅 인터페이스입니다.
  'SLF4J' 는 다양한 로깅 프레임워크(e.g, Log4j, Logback, java.util.logging 등)에 대해 공통된 인터페이스를 제공하여 개발자가 특정 로깅 프레임워크에 종속되지 않고 유연하게 로그를 관리할 수 있도록 합니다.


1️⃣ slf4j의 주요 기능.

  
    
      로깅 프레임워크와의 추상화
        
          slf4j는 여러 로깅 프레임워크에 종속되지 않게 합니다.
        
        
          예를 들어, 코드에서 slf4j 인터페이스를 사용하면 나중에 로깅 프레임워크를 쉽게 교체할 수 있습니다.
        
      
    
  
  
    
      로깅 성능 최적화
        
          slf4j는 문자열 병합에 따른 성능 문제를 피할 수 있도록 지원합니다.
        
        
          예를 들어, slf4j는 로그 메시지의 문자열 결합을 지연시켜, 로그가 실제로 기록될 때만 결합이 발생하도록 합니다.
        
      
    
  
  
    
      API 일관성
        
          slf4j를 사용하면 로깅을 위한 일관된 API를 제공받을 수 있으며, 이를 통해 로깅을 표준화할 수 있습니다.
        
      
    
  


2️⃣ 사용 방법.

  slf4j를 사용하기 위해서는, 우선 slf4j 인터페이스와 이를 구현한 로깅 프레임워크(예: Logback)를 프로젝트에 포함시켜야 합니다.
    
      코드는 일반적으로 아래와 같이 사용됩니다.
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    
  


public class MyClass {
    // Logger 생성
    private static final Logger logger = LoggerFactory.getLogger(MyClass.class);

public void doSomthing() {
    // 로그 메시지 기록
    logger.info("This is an info message");
    logger.debug("This is a debug message");
} } ``` - 이 코드는 **`'slf4j'`** 를 이용해 로그를 기록하는 예로, 로깅 메시지는 설정된 로깅 프레임워크를 통해 출력됩니다.


✏️ 요약.

  slf4j는 Java 애플리케이션에서 로깅 프레임워크 간의 추상화 레이어를 제공하며, 코드가 특정 로깅 프레임워크에 종속되지 않도록 합니다.
    
      이를 통해 유연한 로깅 관리가 가능해집니다.
    
  


2️⃣ logback

  'logback' 은 Java 애플리케이션에서 사용되는 고성능 로깅 프레임워크로, slf4j의 권장 구현체 중 하나입니다.
  'logback' 은 slf4j를 통해 접근할 수 있으며, 뛰어난 성능과 유연한 설정, 다양한 기능을 제공하는 것이 특징입니다.


1️⃣ logback의 주요 구성 요소.

  
    
      Logback Classic
        
          slf4j와 직접 통합되는 logback의 핵심 모듈입니다.
          'Logback Classic' 은 Java 애플리케이션에서 로깅 기능을 수행하며, 다양한 로그 레벨(INFO, DEBUG, WARN, ERROR 등)을 지원합니다.
        
      
    
  
  
    
      Logback Core
        
          Logback Classic과 Logback Access(웹 애플리케이션용)를 기반으로 하는 일반적인 로깅 기능을 제공합니다.
          'Logback Core' 는 Appender, Layout, Filter 등과 같은 기본 구성 요소를 포함합니다.
        
      
    
  
  
    
      Logback Access
        
          웹 애플리케이션에서 HTTP 요청과 응답을 로깅할 수 있도록 지원하는 모듈입니다.
        
        
          주로 Java Servlet 환경에서 사용됩니다.
        
      
    
  


3️⃣ logback의 특징.

  
    
      높은 성능
        
          'logback' 은 빠른 로깅 성능을 제공하며, 특히 대규모 애플리케이션에서 효과적입니다.
        
      
    
  
  
    
      유연한 구성
        
          'logback' 은 XML 또는 Groovy 스크립트로 로깅 설정을 구성할 수 있습니다.
        
        
          이를 통해 다양한 조건에 따라 로깅 동작을 세밀하게 제어할 수 있습니다.
        
      
    
  
  
    
      조건부 로깅
        
          'logback' 은 특정 조건에서만 로깅을 수행하도록 설정할 수 있어, 불필요한 로그 기록을 줄이고 성능을 최적화할 수 있습니다.
        
      
    
  
  
    
      이전 로그 프레임워크와의 호환성
        
          'logback' 은 기존의 'Log4j' 설정 파일을 사용할 수 있는 기능을 제공하여, 기존 'Log4j' 사용자가 쉽게 'logback' 으로 전환할 수 있도록 돕습니다.
        
      
    
  
  
    
      다양한 출력 형식
        
          'logback' 은 콘솔, 파일, 원격 서버, 데이터베이스 등 다양한 출력 대상으로 로그를 기록할 수 있으며, 출력 형식을 자유롭게 정의할 수 있습니다.
        
      
    
  


4️⃣ logback 사용 예제.
&lt;configuration&gt;
    &lt;!-- 콘솔에 로그를 출력하는 Appender --&gt;
    &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;!-- 파일에 로그를 기록하는 Appender --&gt;
    &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
        &lt;file&gt;mylog.log&lt;/file&gt;
        &lt;append&gt;true&lt;/append&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;!-- 루트 로거 설정 --&gt;
    &lt;root level="debug"&gt;
        &lt;appender-ref ref="STDOUT" /&gt;
        &lt;appender-red red="FILE" /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;



  이 예시는 콘솔과 파일에 로그를 출력하도록 설정하는 간단한 예시입니다.
    
      logback은 이외에도 복잡한 요구 사항을 충족할 수 있는 다양한 기능을 제공하고 있습니다.
    
  


✏️ 요약.

  logback은 Java 애플리케이션에서 사용되는 고성능 로깅 프레임워크로, slf4j와 함께 사용됩니다.
  logback은 유연한 설정과 높은 성능, 다양한 기능이 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-20-Internet-layer-model.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-20-Internet-layer-model.html"><h1 class="title_post">🌐[Network] 인터넷의 계층 모델</h1></a>
                        <a href="/Backend/Network/2024-08-20-Internet-layer-model.html" class="txt_post">
                            🌐[Network] 인터넷의 계층 모델

1️⃣ 인터넷의 계층 모델.



  위 그림은 FTP 프로그램을 이용하는 경우를 예로 들어 인터넷의 계층 구조를 설명하고 있습니다.
  인터넷에서는 IP(Internet Protocol)가 네트워크 계층의 기능을 수행하며, TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 전송 계층의 기능을 수행합니다.
    
      이들 3개의 프로토콜은 인터넷 환경에서 사용자 데이터를 전송하는 핵심 역할을 합니다.
    
  
  전송 계층 이하의 프로토콜들은 호스트의 운영체게 내부에서 구현되며 FTP, 텔넷, 전자 메일 등과 같은 응용 프로그램은 사용자 프로그램 환경에서 계층 5~7이 합쳐져 구현됩니다.
  위 그림과 같이 양쪽 호스트에는 동일한 기능을 수행하는 프로토콜 스택(Protocol Stack)이 존재합니다.
    
      프로토콜 스택은 계층 구조로 이루어진 통신 프로토콜의 집합입니다.

    
  
  각 프로토콜의 동작은 위 그림에서 설명한 것과 같은 원리로 이루어집니다.
    
      그림에 표시되진 않았지만 두 호스트 사이에는 중개 기능을 수행하는 라우터들이 존재할 수 있습니다.
    
  
  인터넷에서는 IP 프로토콜이 중개 기능을 수행하므로 라우터에는 계층 3까지의 프로토콜이 구현되어 있습니다.
  FTP 클라이언트가 FTP 서버에 데이터를 전송하는 과정은 다음과 같습니다.
    
      FTP 클라이언트가 FTP 서버에 직접 데이터를 전송하는 것은 불가능하므로 먼저 자신의 하위 TCP에 데이터를 보내야합니다.
      TCP로 보내진 데이터는 IP 프로토콜과 LAN 카드를 거쳐서 이더넷으로 표현된 전송 매체를 통하여 FTP 서버의 LAN 카드에 전달됩니다.
      FTP 서버에 도착한 데이터는 송신 순서의 반대인 LAN 카드, IP 프로토콜, TCP 프로토콜을 거쳐서 FTP 서버 프로그램에 도착합니다.
        
          FTP 서비스에서 데이터 전송은 양방향 통신을 지원하므로 반대 방향의 전송도 가능합니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-20</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240820_AWS_INSTALL_GRADLE.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240820_AWS_INSTALL_GRADLE.html"><h1 class="title_post">☁️[AWS] Amazon Linux CLI에 Gradle 설치하는 방법.</h1></a>
                        <a href="/Backend/AWS/240820_AWS_INSTALL_GRADLE.html" class="txt_post">
                            ☁️[AWS] Amazon Linux CLI에 Gradle 설치하는 방법.

  이 포스트에서는 수동 설치(바이너리 다운로드) 방법을 소개합니다.


1️⃣ 필요한 도구 설치.

  Gradle을 수동으로 설치하기 전에 'wget' 이나 'unzip' 과 같은 도구가 필요합니다.
    sudo yum install wget unzip -y
    
  


2️⃣ Gradle 바이너리 다운로드.

  Gradle의 최신 릴리스 버전을 다운로드 합니다.
    
      최신 버전은 Gradle 공식 웹사이트에서 확인할 수 있습니다.
        
          🙋‍♂️ 아래 명령어는 버전 8.10을 예로 들어 설명합니다.
필요에 따라 최신 버전을 사용하세요.
        
      
    
  


wget https://services.gradle.org/distributions/gradle-8.10-bin.zip -P /tmp


3️⃣ 다운로드한 파일 압축 해제.

  다운로드한 Gradle 바이너리를 '/opt/gradle' 디렉토리에 압축 해제합니다.
    sudo unzip -d /opt/gradle /tmp/gradle-8.10-bin.zip
    
  


4️⃣ Gradle 경로 설정.

  Gradle을 시스템 경로에 추가하기 위해 심볼릭 링크를 설정하거나 환경 변수를 설정합니다.
    sudo ln -s /opt/gradle/gradle-8.10 /opt/gradle/latest
echo 'export PATH=$PATH:/opt/gradle/latest/bin' &gt;&gt; ~/.bash_profile
source ~/.bash_profile
    
  


5️⃣ 설치 확인.

  Gradle이 제대로 설치되었는지 확인하려면 다음 명령어를 사용합니다.
    gradle -v
    
  




                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-20</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-19-protocol-and-interface.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-19-protocol-and-interface.html"><h1 class="title_post">🌐[Network] 프로토콜과 인터페이스(Protocol and Interface)</h1></a>
                        <a href="/Backend/Network/2024-08-19-protocol-and-interface.html" class="txt_post">
                            🌐[Network] 프로토콜과 인터페이스(Protocol and Interface)

1️⃣ 프로토콜과 인터페이스(Protocol and Interface).

  네트워크 사용자가 통신한다는 것은 데이터를 서로 주고받는다는 것을 의미합니다.
  최종 사용자가 데이터를 보내고 받으려면 양쪽 호스트에서 실행되는 OSI 7계층의 모듈이 유기적으로 연동되어야 합니다.
    
      즉, 호스트끼리 통신하는 과정에서는 각 계층의 모듈이 상대 호스트의 동일 계층과 개별적으로 논리적 통신을 수행해야 합니다.
        
          예를 들어, 통신 양단의 한쪽 호스트의 계층 n 모듈은 상대 호스트의 계층 n 모듈과 통신합니다.
            
              이와 같이 각각의 계층은 정해진 방식과 절차에 따라 상대 계층과 통신하는데, “이 과정에서 필요한 규칙을 프로토콜(Protocol)” 이라고 합니다.
            
          
        
      
    
  
  “상하위의 계층 간에는 인터페이스(Interface)” 라는 규칙이 존재하고, “하위 계층이 상위 계층에 제공하는 인터페이스를 특별히 서비스(Service)” 라 부릅니다.

  위 그림은 계층 n과 계층 n-1의 2개 모듈로 구성된 계층 모델에서 서로 다른 두 호스트의 통신을 지원하기 위한 모듈 간의 관계를 프로토콜, 서비스, 데이터 전송의 관점에서 설명합니다.
  한 호스트를 기준으로 데이터 전송은 위아래 양방향으로 모두 가능하며, 두 호스트 사이에서는 좌우 양방향으로 모두 가능합니다.
    
      다만, 좌우 간의 물리적인 데이터 전송은 반드시 가장 아래의 물리 계층을 통하여 이루어집니다.
    
  
  호스트 1과 호스트 2의 계층 n 프로토콜이 서로 통신하려면 계층 n-1 프로토콜의 서비스가 필요합니다.
    
      즉, 호스트 1의 계층 n이 호스트 2의 계층 n에 데이터를 전송하는 과정은 하위의 계층 n-1을 통해 이루어집니다.
        
          먼저, 호스트 1의 계층 n-1에 전송할 데이터를 주어 호스트 2에 전송하도록 부탁합니다.
          그러면 호스트 1의 계층 n-1은 다시 하위 계층의 도움을 받아 호스트 2의 계층 n-1에 데이터를 보냅니다.
          마지막으로 호스트 2의 계층 n-1이 수신한 데이터를 계층 n에 올려줌으로써 계층 n 사이의 통신이 완료됩니다.
            
              이 원리는 ISO 7계층 모델에서 7개 계층에 모두 적용되며, 상대 호스트에 물리적으로 데이터를 전송하는 것은 맨 아래의 물리 계층입니다.
                
                  물리 계층 위에 있는 계층 프로토콜들은 각자의 정해진 기능을 수행하면서 논리적인 통신을 하는 것입니다.
                
              
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-19-Network-Segment.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-19-Network-Segment.html"><h1 class="title_post">🌐[Network] 네트워크 세그먼트(Network Segment).</h1></a>
                        <a href="/Backend/Network/2024-08-19-Network-Segment.html" class="txt_post">
                            🌐 네트워크 세그먼트(Network Segment).

1️⃣ 세그먼트(Segment).
네트워크 세그먼트(Network Segment)를 알아보기 전에 세그먼트(Segment)가 어떤 뜻을 가지고 있는지 궁금했습니다.
TTA 정보통신용어사전에서는 다음과 같이 세그먼트를 정의하고 있었습니다.

  
    
      서로 구분되는 기억 장치 의 연속된 한 영역.
    
  
  
    
      어떤 프로그램이 너무 커서 한 번에 주기억 장치 에 올라올 수 없이 갈아넣기 기법을 사용하여 쪼개었을 때, 나뉜 각 부분을 가리키는 말.
    
  
  
    
      세그먼테이션 방식의 가상 기억 장치 에서 사용되는 것으로, 페이징에서 페이지와 비슷하나 길이가 가변이고 기억 장치 의 어느 곳에서도 자리할 수 있는 기억 장소 영역을 가리키는 말.
        
          한 세그먼트는 프로그램의 논리적인 한 구성 단위를 저장한다.
        
      
    
  
  
    
      계층 모형의 데이터베이스 에서 여러 항목이 모여 레코드에 해당하는 단위.

    
  


2️⃣ 네트워크 세그먼트(Network Segment).

  네트워크 세그먼트(Network Segment)는 네트워크 내에서 논리적 또는 물리적으로 분리된 하나의 부분 또는 구역을 의미합니다.
  네트워크를 여러 세그먼트로 나누는 것은 네트워크의 성능을 최적화하고, 보안을 강화하며, 트래픽 관리를 효율적으로 ㅎ기 위한 일반적인 방법입니다.


1️⃣ 네트워크 세그먼트의 주요 개념.

  1. 물리적 세그먼트
    
      물리적 네트워크 세그먼트는 실제 네트워크 장비(스위치, 라우터 등)와 물리적 케이블을 통해 분리된 네트워크 구역입니다.
        
          예를 들어, 한 사무실 내에서 여러 층에 있는 네트워크가 각기 다른 물리적 스위치에 연결되어 있다면, 이들 층은 물리적으로 서로 다른 네트워크 세그먼트로 간주될 수 있습니다.
        
      
    
  
  2. 논리적 세그먼트
    
      논리적 네트워크 세그먼트는 물리적 인프라와 무관하게 네트워크를 논리적으로 나누는 것을 의미합니다.
        
          이는 주로 VLAN(가상 로컬 영역 네트워크) 이나 서브넷(Subnet) 을 사용하여 이루어집니다.
            
              예를 들어, 동일한 물리적 네트워크 내에서 서로 다른 부서의 컴퓨터를 논리적으로 분리하여 독립된 네트워크 세그먼트로 만들 수 있습니다.
            
          
        
      
    
  


2️⃣ 네트워크 세그먼트의 주요 목적.

  1. 보안 강화
    
      네트워크 세그먼트는 네트워크를 여러 개의 작은 구역으로 나누어, 각 구역의 트래픽을 독립적으로 관리하고 보호할 수 있습니다.
        
          이를 통해 민감한 데이터를 처리하는 부서나 서버를 외부와 분리하여 보안을 강화할 수 있습니다.
        
      
    
  
  2. 성능 최적화
    
      네트워크를 세그먼트로 나누면 네트워크의 트래픽이 특정 구역 내에서만 흐르게 하여, 트래픽 혼잡을 줄이고 전체 네트워크의 성능을 향상시킬 수 있습니다.
        
          예를 들어, 대용량 파일 전송이 필요한 부서의 네트워크 세그먼트를 다른 부서와 분리함으로써, 다른 부서의 네트워크 성능에 영향을 주지 않도록 할 수 있습니다.
        
      
    
  
  3. 트래픽 관리
    
      네트워크 세그먼트를 통해 트래픽을 효과적으로 관리하고, 특정 세그먼트의 트래픽을 제거할 수 있습니다.
        
          네트워크 관리자는 각 세그먼트에 대해 별도의 라우팅 규칙, 방화벽 규칙 등을 적용할 수 있습니다.
        
      
    
  
  4. 내결함성 향상
    
      네트워크가 세그먼트로 분리되어 있으면, 한 세그먼트에서 발생한 문제가 다른 세그먼트로 확산되지 않도록 방지할 수 있습니다.
        
          예를 들어, 한 세그먼트에서 발생한 네트워크 장애가 전체 네트워크에 영향을 미치지 않게 할 수 있습니다.
        
      
    
  


3️⃣ 예시: 서브넷을 이용한 네트워크 세그먼트.

  서브넷은 네트워크 세그먼트의 한 유형입니다.
    
      예를 들어, ‘10.0.0.0/16’ IP 주소 블록을 가진 VPC에서 ‘10.0.1.0/24’ 와 ‘10.0.2.0/24’ 라는 두 개의 서브넷을 생성할 수 있습니다.
      이 두 서브넷은 동일한 VPC 내에서 서로 독립된 네트워크 세그먼트를 구성합니다.
        
          이로 인해 한 서브넷에서 발생한 네트워크 트래픽은 기본적으로 다른 서브넷에 영향을 미치지 않습니다.
        
      
    
  


✏️ 요약

  요약하자면, 네트워크 세그먼트는 네트워크를 보다 안전하고 효율적으로 운영하기 위해 분리된 네트워크 구역을 의미하며, 물리적 또는 논리적으로 구성될 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240819_AWS_VPC_AND_SUBNET.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240819_AWS_VPC_AND_SUBNET.html"><h1 class="title_post">☁️[AWS] VPC 및 서브넷 생성.</h1></a>
                        <a href="/Backend/AWS/240819_AWS_VPC_AND_SUBNET.html" class="txt_post">
                            ☁️[AWS] VPC 및 서브넷 생성.

  VPC는 EC2 및 기타 AWS 서비스와 마찬가지로 AWS Management Console(GUI) 또는 API를 사용해 생성할 수 있습니다.
    
      관리 콘솔에서 생성하는 경우 화면에서 다음 항목을 설정해야 합니다.
        
          VPC 이름(Name 태그)
          CIDR 블록
          IPv6 설정
          테넌시(전용 하드웨어 사용 여부)
        
      
    
  
  EC2보다 적은 설정 항목으로 즉시 가상 네트워크를 만들 수 있습니다.
    
      IPv6 설정은 기본적으로 비활성화돼 있으며 필요에 따라 설정할 수 있습니다.
      테넌시는 라이선스 및 보안 요구 사항으로 하드웨어를 독점하려는 경우에만 독점 옵션을 지정합니다.

    
  
  VPC만으로는 EC2와 같은 자원을 네트워크에 만들 수 없습니다.
    
      VPC 안에 더 작은 네트워크 단위인 서브넷을 만들어야 합니다.
    
  
  서브넷은 하나의 AZ(Availablity Zone, 가용 영역)에 걸쳐 있을 수 없습니다.
    
      즉, 여러 AZ에 자원을 배치해 가용성을 높이려면 서브넷도 여러 개 만들어야 합니다.
    
  
  서브넷에는 생성할 VPC의 CIDR 블록 범위 내에서 CIDR 블록을 지정해야 합니다.
    
      예를 들어 VPC의 CIDR 블록이 10.0.0.0/16인 경우 10.0.0.0/24와 같이 CIDR 블록을 지정합니다.

    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240819_AWS_VPC_ACCESS_CONTROL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240819_AWS_VPC_ACCESS_CONTROL.html"><h1 class="title_post">☁️[AWS] VPC 접근 제어 및 통신 로그 확인.</h1></a>
                        <a href="/Backend/AWS/240819_AWS_VPC_ACCESS_CONTROL.html" class="txt_post">
                            ☁️[AWS] VPC 접근 제어 및 통신 로그 확인.

1️⃣ VPC 접근 제어 및 통신 로그 확인.

  VPC에는 서브넷 단위로 접근 제어를 설정할 수 있는 네트워크 접근 제어 목록(이후 네트워크 ACL) 이라는 기능이 있습니다.
    
      보안 그룹 과 조합해 접근 제어 설정이 가능합니다.
    
  
  네트워크 ACL과 보안 그룹과의 차이는 다음 표와 같습니다.

  기본 설정 상태에서 네트워크 ACL은 모든 통신을 허용합니다.
    
      서브넷 전체에서 네트워크 접근을 허용하거나 거부하려는 경우 보안 그룹에서 추가 설정을 해 더욱 안전한 네트워크를 구축할 수 있습니다.

    
  
  네트워크 ACL이나 보안 그룹에서 허용되거나 거부된 통신 상황은 VPC 흐름 로그 라고 하는 VPC 내의 IP 트래픽 상황을 로그로 저장할 수 있는 기능을 사용해 확인할 수 있습니다.
    
      로그는 AWS 모니터링 서비스인 CloudWatch Logs 또는 S3에 저장할 수 있습니다.
        
          CloudWatch Logs에 저장하면 로그 내용에 따라 메일 알림을 보낼 수 있게 구성해 감시할 수 있습니다. 요금은 S3가 저렴합니다.
        
      
    
  
  EC2와 같은 VPC의 자원은 IP 주소마다 네트워크 인터페이스(ENI, Elastic Network Interface) 를 가집니다.
    
      로그는 네트워크 인터페이스별로 출력되며 Elastic Load Balancing, RDS, Redshift와 같이 VPC에서 실행되는 모든 서비스 로그도 출력됩니다.
        
          도착지/출발지의 IP 주소와 포트, 전송 허용/거부 등의 정보가 포함됩니다.

        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240819_AWS_VPC.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240819_AWS_VPC.html"><h1 class="title_post">☁️[AWS] 가상 네트워크 Amazon VPC</h1></a>
                        <a href="/Backend/AWS/240819_AWS_VPC.html" class="txt_post">
                            ☁️[AWS] 가상 네트워크 Amazon VPC.

  Amazon Virtual Private Cloud(VPC) 는 AWS에서 생성할 수 있는 프라이빗 가상 네트워크 공간입니다.
    
      이 네트워크에 EC2와 같은 AWS 자원을 배치해 이용합니다.
    
  
  하나의 VPC를 논리적으로 나눠 분리할 수도 있고 여러 VPC를 연결할 수도 있습니다.
    
      인터넷에 공개하는 퍼블릭 VPC 나 VPN(Virtual Private Network - 가상 사설 네트워크) 등을 이용해 접속하는 프라이빗 VPC 도 구축할 수 있습니다.
    
  
  온프레미스로 네트워크 환경을 구축하는 경우 데이터 센터, 네트워크 기기나 서버 기기, 인터넷 회선 등 준비해야 할 것이 많이 준비 기간과 초기 비용이 발생합니다.
    
      반면 AWS에서 VPC를 네트워크 환경으로 준비하는 경우 몇 가지 작업을 수행하면 몇 분 안에 네트워크를 구축할 수 있습니다.

    
  
  VPC를 만들 때 CIDR 블록(IP 주소 범위) 을 지정하고 지정한 CIDR 블록 네트워크를 확보합니다.
    
      예를 들어 ‘10.0.0.0/16’을 지정하면 65,535개의 IP 주소를, ‘10.0.0.0/28’을 지정하면 16개의 IP 주소 를 사용할 수 있습니다.
        
          CIDR 블록에서 사용할 수 있는 IP 주소 수는 다음 그림과 같이 계산합니다.

        
      
    
  
  VPC는 일반적으로 프라이빗 IP 주소를 사용합니다.
    
      이는 AWS의 권고 사항입니다.
        
          임의의 퍼블릭 IP 범위에서 CIDR 블록을 지정할 수 있지만, 외부 퍼블릭 IP와 겹치면 통신할 수 없으므로 기본적으로 프라이빗 IP 주소 공간을 CIDR 블록에 지정하는 것이 좋습니다.
        
      
    
  
  프라이빗 IP 주소의 범위라면 기본적으로 자유롭게 지정해도 되지만, 온프레미스 환경이나 다른 VPC 등 외부 네트워크와의 접속을 검토하고 있다면 접속할 네트워크와 VPC의 CIDR 블록이 중복되지 않게 주의 해야 합니다.
    
      중복되면 직접 연결은 할 수 없습니다.
    
  
  CIDR 블록 설정에 따라 확보할 수 있는 호스트 주소의 수가 달라지는데, 호스트 주소는 여유를 갖도록 가능한 한 많이 확보 해 두는 것이 좋습니다.
    
      일반적으로 처음부터 필요한 총 IP 주소 수를 파악하는 것은 어렵습니다.
        
          나중에 자원을 확장하기 위해 추가 IP 주소가 필요할 수도 있습니다.
            
              또한 AWS가 자동으로 사용하는 IP 주소도 있어 VPC에 설정한 CIDR 블록의 IP 주소를 모두 사용할 수 있는 것도 아니기 때문입니다.

            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240819_AWS_TENANCY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240819_AWS_TENANCY.html"><h1 class="title_post">☁️[AWS] 테넌시(Tenancy)</h1></a>
                        <a href="/Backend/AWS/240819_AWS_TENANCY.html" class="txt_post">
                            ☁️[AWS] 테넌시(Tenancy).
“테넌시(Tenancy)” 라는 용어는 원래 부동산에서 사용되던 개념으로, 특정 공간을 임차하거나 소유하는 상태를 의미합니다.

“이 개념이 IT와 클라우드 컴퓨팅으로 확장되면서, 테넌시는 리소스나 환경을 특정 사용자나 조직이 사용하거나 소유하는 방식으로 사용됩니다.”

1️⃣ 테넌시의 일반적인 개념.

1️⃣ 부동산에서의 테넌시.

  정의
    
      테넌시는 주로 임차인이 집이나 건물을 사용하는 권리를 가지고 있는 상태를 의미합니다.
      테넌시는 임대 계약을 통해 특정 기간 동안 특정 부동산을 사용하는 권리를 확보하게 됩니다.
    
  
  유형
    
      테넌시는 단독 테넌시(한 사람이 독점으로 사용)와 공동 테넌시(여러 사람이 함께 사용) 등으로 구분될 수 있습니다.
    
  


2️⃣ IT와 클라우드 컴퓨팅에서의 테넌시.

  정의
    
      IT 분야에서 테넌시는 특정 사용자나 조직이 IT 자원(서버, 네트워크, 데이터베이스 등)을 사용하는 상태를 의미합니다.
      이 용어는 특히 클라우드 컴퓨팅에서 자주 사용되며, 리소스가 물리적 또는 논리적으로 어떻게 격리되고 공유되는지를 설명하는 데 사용됩니다.
    
  
  유형
    
      클라우드 컴퓨팅에서 테넌시는 주로 다음 두 가지 유형으로 구분됩니다.
        
          단일 테넌시(Single-Tenancy)
            
              한 명의 사용자나 조직이 독점적으로 자원을 사용하는 환경. 물리적 하드웨어 또는 소프트웨어 환경이 다른 사용자와 공유되지 않습니다.
                
                  예를 들어, 전용 서버 또는 전용 호스트 환경이 해당됩니다.
                
              
            
          
          다중 테넌시(Multi-Tenancy)
            
              여러 사용자나 조직이 동일한 물리적 하드웨어 또는 소프트웨어 환경을 공유하는 환경. 하지만 각 사용자의 데이터와 리소스는 논리적으로 격리되어 있습니다.
              대부분의 퍼블릭 클라우드 서비스는 다중 테넌시 구조를 채택하고 있습니다.
            
          
        
      
    
  


3️⃣ 테넌시의 중요성.

  자원 격리
    
      테넌시는 사용자가 특정 IT 자원을 다른 사용자와 공유할지, 아니면 독립적으로 사용할지를 결정하는 중요한 요소입니다.
        
          이를 통해 보안 수준을 강화하거나 비용을 절감할 수 있습니다.
        
      
    
  
  보안 및 규정 준수
    
      일부 조직은 규제 요구 사항을 충족하기 위해 단일 테넌시를 요구할 수 있습니다.
        
          이 경우 물리적 자원을 다른 조직과 공유하지 않음으로써 보안성을 높일 수 있습니다.
        
      
    
  
  비용 효율성
    
      다중 테넌시는 자원을 공유함으로써 비용을 절감할 수 있습니다.
        
          클라우드 서비스 제공자는 다중 테넌시를 통해 자원을 최적화하고, 이를 통해 사용자가 더 저렴한 비용으로 서비스를 이용할 수 있도록 합니다.
        
      
    
  


🎯 요약

  “테넌시(Tenancy)” 는 특정 자원을 사용자 또는 조직이 사용하는 방식과 관련된 개념입니다.
    
      부동산에서는 임차 관계를 의미합니다.
      IT와 클라우드 컴퓨팅에서는 리소스가 어떻게 배치되고 격리되는지를 설명하는 용어로 사용됩니다.
      클라우드 환경에서 테넌시의 선택은 보안, 성능, 비용에 큰 영향을 미칩니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240819_AWS_SUBNET.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240819_AWS_SUBNET.html"><h1 class="title_post">☁️[AWS] 서브넷?</h1></a>
                        <a href="/Backend/AWS/240819_AWS_SUBNET.html" class="txt_post">
                            ☁️[AWS] 서브넷(Subnet).

  AWS애서 서브넷(Subnet)은 VPC(Virtual Private Cloud) 내에서 네트워크를 세분화하고 리소스를 논리적으로 분리하는 방법입니다.
  서브넷은 VPC 내의 특정한 IP 주소 범위를 갖는 네트워크 세그먼트를 나타내며, AWS에서 네트워크 인프라를 구축하고 관리하는 데 중요하는 역할을 합니다.


1️⃣ VPC와 서브넷의 관계.

  VPC(Virtual Private Cloud)
    
      AWS에서 제공하는 가상 네트워크로, 사용자가 자신의 클라우드 리소스를 배치하고 관리할 수 있는 격리된 네트워크 환경입니다.
      VPC는 사용자가 직접 IP 주소 범위, 서브넷, 라우팅 테이블, 네트워크 게이트웨이 등을 설정할 수 있도록 합니다.
    
  
  서브넷(Subnet)
    
      서브넷은 VPC 내에서 특정 IP 주소 범위를 갖는 작은 네트워크 세그먼트입니다.
        
          “각 서브넷은 VPC의 전체 IP 주소 범위 내에서 특정한 부분을 할당받아 사용합니다.”
        
      
    
  


2️⃣ 서브넷의 유형.

  퍼블릭 서브넷(Public Subnet)
    
      인터넷 게이트웨이(Internet Gateway)에 연결된 서브넷으로, 이 서브넷에 배치된 리소스(예: EC2 인스턴스)는 퍼블릭 IP 주소를 가지며 인터넷과 직접 통시할 수 있습니다.
        
          웹 서버와 같은 인터넷과 직접 연결이 필요한 리소스를 퍼블릭 서브넷에 배치합니다.
        
      
    
  
  프라이빗 서브넷(Private Subnet)
    
      인터넷 게이트웨이에 연결되지 않은 서브넷으로, 이 서브넷에 배치된 리소스는 퍼블릭 IP 주소가 없으며, 직접적으로 인터넷과 통신할 수 없습니다.
        
          데이터베이스 서버와 같이 인터넷과 직접 연결될 필요가 없는 리소스를 프라이빗 서브넷에 배치합니다.
            
              인터넷에 접속해야 할 경우, NAT 게이트웨이 또는 NAT 인스턴스 를 통해 간접적으로 인터넷에 접근할 수 있습니다.
            
          
        
      
    
  


3️⃣ 서브넷의 가용 영역(Availability Zone).

  각 서브넷은 특정 가용 영역(AZ)에 속합니다.
    
      이는 가용 영역마다 독립적인 네트워크 세그먼트를 구성할 수 있게 해줍니다.
        
          예를 들어, VPC 내에 여러 가용 영역이 있을 때, 각각의 가용 영역에 서브넷을 만들어 고가용성 아키텍처를 구축할 수 있습니다.
        
      
    
  


4️⃣ 라우팅 테이블과 서브넷.

  각 서브넷은 하나의 라우팅 테이블(Routing Table)과 연결됩니다.
    
      라우팅 테이블은 네트워크 트래픽이 어떻게 라우팅되는지를 결정합니다.
        
          예를 들어, 퍼블릭 서브넷은 라우팅 테이블에 인터넷 게이트웨이로 가는 경로가 설정되어 있지만, 프라이빗 서브넷은 그런 경로가 없습니다.
        
      
    
  


5️⃣ 서브넷의 보안 그룹 및 네트워크 ACL.

  보안 그룹(Security Groups)
    
      서브넷에 배치된 리소스(예: EC2 인스턴스)에 대한 인바운드 및 아웃바운드 트래픽을 제어하는 가상 방화벽입니다.
      보안 그룹은 상태 기반으로 동작하며, 인스턴스 수준에서 적용됩니다.
    
  
  네트워크 ACL(Network Access Control List)
    
      서브넷 수준에서 적용되는 보안 레이어로, 서브넷 내의 모든 리소스에 대한 트래픽을 제어합니다.
      네트웨크 ACL은 상태 비저장(State-less)으로, 각각의 요청과 응답을 별도로 처리합니다.
    
  


6️⃣ 서브넷의 사용 사례.

  웹 서버 및 애플리케이션 서버 배치
    
      퍼블릭 서브넷에 배치하여 외부에서 접근 가능한 웹 서버와 애플리케이션 서버를 운영합니다.
    
  
  데이터베이스 서버 및 내부 애플리케이션 배치
    
      프라이빗 서브넷에 배치하여 외부 접근이 제한된 안전한 네트워크 환경에서 데이터베이스 서버나 비공개 애플리케이션을 운영합니다.
    
  
  멀티 AZ 아키텍처
    
      각 가용 영역에 서브넷을 만들어 장애가 발생해도 시스템이 지속적으로 운영될 수 있는 고가용성 아키텍처를 구축합니다.
    
  


7️⃣ 서브넷과 CIDR 블록.

  각 서브넷은 CIDR(Classless Inter-Domain Routing) 블록으로 정의된 IP 주소 범위를 가집니다.
    
      예를 들어 '10.0.1.0/24' 와 같은 형태의 CIDR 블록이 서브넷의 IP 주소 범위를 정의합니다.
        
          이 CIDR 블록에 따라 서브넷 내에서 사용 가능한 IP 주소의 범위가 결정됩니다.
        
      
    
  



  🎯 서브넷을 잘 설계하고 구성하는 것은 AWS에서 네트워크 인프라를 최적화하고 보안을 강화하는 데 매우 중요합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240819_AWS_ROUTING_INFO.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240819_AWS_ROUTING_INFO.html"><h1 class="title_post">☁️[AWS] 라우팅 정보를 설정해 인터넷과 통신.</h1></a>
                        <a href="/Backend/AWS/240819_AWS_ROUTING_INFO.html" class="txt_post">
                            ☁️[AWS] 라우팅 정보를 설정해 인터넷과 통신.
VPC에는 서브넷, 라우팅과 같은 다양한 설정을 할 수 있습니다.
이 포스트에서는 주요 기능을 통해 VPC의 사용 방법을 설명하겠습니다.

1️⃣ 라우팅 테이블(Routing Table).

  라우팅 테이블 은 네트워크 경로 정보입니다.
  온프레미스 환경에서는 라우터와 같은 네트워크 기기에 라우팅 테이블을 설정하지만 AWS는 VPC에 라우팅 테이블을 생성하고 각 서브넷에 사용할 라우팅 테이블을 지정합니다.
  VPC를 통해 흐르는 패킷은 이 라우팅 테이블의 정보를 기반으로 경로(어디로 통신할지)를 결정합니다.
  VPC를 만들 때 기본적으로 하나의 라우팅 테이블이 만들어 집니다.
    
      기본 상태에서는 VPC 내의 라우팅 정보만 있으므로 VPC 외부로는 통신할 수 없습니다.
    
  
  외부와 통신하려는 경우에는 외부 라우팅 정보를 추가해야 합니다.
    
      예를 들어 대상 0.0.0.0/0(모든 네트워크)에 대해 인터넷 게이트웨이로 라우팅 테이블에 등록하면 인터넷 게이트웨이를 통해 인터넷과 통신할 수 있습니다.

    
  


2️⃣ 인터넷 게이트웨이(Internet Gateway).

  인터넷 게이트웨이 는 서브넷 안에 있는 EC2와 같은 자원이 인터넷과 통신할 수 있게 하기 위한 기능입니다.
  인터넷 게이트웨이를 생성하고 서브넷의 라우팅 테이블에 설정하면 인터넷과 VPC가 서로 통신할 수 있게 됩니다.
  인터넷 게이트웨이로 가는 경로가 설정된 서브넷을 퍼블릭 서브넷 이라고 합니다.
  반대로 인터넷 게이트웨이를 통해 인터넷과 통신할 수 없는 서브넷을 프라이빗 서브넷 이라고 합니다.
  EC2의 경우 퍼블릭 IP 또는 Elastic IP(탄력적 IP) 를 부여해 인터넷과 EC2가 통신할 수 있습니다.
    
      퍼블릭 IP와 Elastic IP는 모두 “EC2에 설정할 수 있는 퍼블릭 IP(글로벌 IP) 주소” 입니다.
        
          퍼블릭 IP는 자동으로 부여되는 IP 주소로 재부팅할 때마다 변경됩니다.
          Elastic IP(탄력적 IP)는 정적 IP라고도 하며 영구적으로 사용할 수 있는 IP 주소입니다.
            
              방화벽 등에서 IP 주소를 고정해 통신을 허가해야 하는 경우 Elastic IP를 사용합니다.
            
          
        
      
    
  
  퍼블릭 IP는 무료로 사용할 수 있지만 Elastic IP는 사용하지 않을 때 약간의 요금이 부과됩니다.
    
      가동 중인 EC2 등에서 사용하는 경우 무료입니다.

    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240819_AWS_Nginx_FireWalld.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240819_AWS_Nginx_FireWalld.html"><h1 class="title_post">☁️[AWS] Amazon Linux 2023에 Nginx 설치하는 방법.</h1></a>
                        <a href="/Backend/AWS/240819_AWS_Nginx_FireWalld.html" class="txt_post">
                            ☁️[AWS] Amazon Linux 2023에 Nginx 설치하는 방법.

1️⃣ 패키지 목록 업데이트

  먼저, 서버의 패키지 목록을 업데이트 합니다.
    sudo dnf update -y
    
  



  🎯 참고 dnf search {검색어}
예를 들어 dnf search java 라고 명령어를 실행하면 java라는 단어가 들어간 목록을 모두 보여줍니다.


2️⃣ Nginx 설치

  다음 명령어로 Nginx를 설치합니다.
    sudo dnf install nginx -y
    
  
  위 명령어는 Amazon Linux 2023의 기본 패키지 저장소에서 Nginx를 다운로드하고 설치합니다.


3️⃣ Nginx 서비스 시작 및 활성화

  Nginx 설치가 완료되면, 다음 명령어를 사용하여 Nginx 서비스를 시작하고, 서버가 부팅될 때 자동으로 시작되도록 설정할 수 있습니다.
    sudo systemctl start nginx
sudo systemctl enable nginx
    
  


4️⃣ 방화벽 설정(선택 사항)

  기본적으로 Amazon Linux 2023에는 firewalld가 설치되어 있지 않습니다.
    
      하지만 방화벽을 사용하는 경우 HTTP와 HTTPS 트래픽을 허용하도록 설정해야 합니다.
    
  


1️⃣ firewalld 설치.

  먼저 'firewalld' 를 설치해야 합니다.
    sudo dnf install firewalld -y
    
  


2️⃣ firewalld 서비스 시작 및 활성화

  설치가 완료되면, 'firewalld' 서비스를 시작하고 부팅 시 자동으로 시작되도록 설정합니다.
    sudo systemctl start firewalld
sudo systemctl enable firewalld
    
  


3️⃣ HTTP 및 HTTPS 서비스 허용

  이제 HTTP와 HTTPS 트래픽을 허용하도록 방화벽 규칙을 추가합니다.
    sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
    
  


4️⃣ 방화벽 재시작

  새로운 규칙이 적용되도록 방화벽을 재시작합니다.
    sudo firewall-cmd --reload
    
  


5️⃣ 방화벽 상태 확인(선택 사항)

  방화벽의 상태를 확인하려면 다음 명령어를 사용할 수 있습니다.
    sudo firewall-cmd --list-all
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240819_AWS_NAT_GATEWAY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240819_AWS_NAT_GATEWAY.html"><h1 class="title_post">☁️[AWS] NAT 게이트웨이.</h1></a>
                        <a href="/Backend/AWS/240819_AWS_NAT_GATEWAY.html" class="txt_post">
                            ☁️[AWS] NAT 게이트웨이.

1️⃣ NAT 게이트웨이.

  “프라이빗 서브넷에 있는 EC2와 같은 자원은 일반적으로 인터넷과 통신할 수 없습니다.”
    
      하지만 인터넷에 있는 소프트웨어 패키지의 다운로드와 같이 VPC 내에서 인터넷과 통신해야 하는 경우가 있습니다.
        
          이때 사용할 수 있는 것이 NAT 게이트웨이 입니다.
        
      
    
  
  인터넷 게이트웨이와 달리 인터넷에서 VPC로 통신할 수 없는 단방향 통신이므로 AWS 외부와 더 안전하게 통신할 수 있습니다.
  NAT는 Network Address Translation 의 약자로 프라이빗 IP 주소를 퍼블릭 IP 주소로 변환 하는 것을 의미합니다.
  “NAT 게이트웨이는 프라이빗 서브넷의 IP 주소를 NAT 게이트웨이의 퍼블릭 IP로 변환해 인터넷과 통신할 수 있게 해줍니다.”
  NAT 게이트웨이를 이용해 통신하기 위해서는 외부 통신을 수행하는 서브넷의 라우팅 테이블에 경로 정보(라우팅 정보)를 등록해야 합니다.



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240816_AWS_NVM.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240816_AWS_NVM.html"><h1 class="title_post">☁️[AWS] Amazon Linux 2023에 nvm 설치와 node.js 버전 바꾸는 방법.</h1></a>
                        <a href="/Backend/AWS/240816_AWS_NVM.html" class="txt_post">
                            ☁️[AWS] Amazon Linux 2023에 nvm 설치와 node.js 버전 바꾸는 방법.

1️⃣ nvm 설치.

  'nvm(Node Version Manager)' 은 Node.js 버전을 관리하는 도구입니다.
    
      다음 명령어를 사용하여 'nvm' 을 설치할 수 있습니다.
        curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash
        
      
    
  
  위 명령어는 'nvm' 설치 스크립트를 다운로드하여 실행합니다.


2️⃣ nvm 환경 설정 적용.
'nvm' 설치가 완료되면, 터미널에서 새로운 셀을 열거나 다음 명령어를 실행하여 환경 변수를 적용합니다.
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm


3️⃣ Node.js 16.x 설치 및 사용.

  이제 'nvm' 을 사용하여 Node.js 16.x 버전을 설치하고 사용할 수 있습니다.
    nvm install 16
nvm use 16
    
  
  이 명령어는 Node.js 16.x 버전을 설치하고, 기본 Node.js 버전으로 설정합니다.


✏️ 요약

  'nvm' 을 사용하여 Node.js 버전을 관리하는 것이 가장 간단하고 강력한 방법입니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-08-18-openvpn-change-passwd.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-08-18-openvpn-change-passwd.html"><h1 class="title_post">📝[Post] OpenVPN Password 변경방법.</h1></a>
                        <a href="/Backend/Post/2024-08-18-openvpn-change-passwd.html" class="txt_post">
                            🙋‍♂️ OpenVPN Password 변경방법.

  OpenVPN Access Server에서 사용자의 비빌번호를 변경하는 방법은 다음과 같습니다.
  ✏️ 사용자 비밀번호 변경.
    
      다음 명령어를 사용하여 'openvpn' 사용자의 비밀번호를 변경할 수 있습니다.
        sudo /usr/local/openvpn_as/scripts/sacli --user openvpn --new_pass "your-new-password" SetLocalPassword
        
        
          🎯 'your-new-password' 를 원하는 새 비밀번호로 바꿔서 입력하세요.
        
      
    
  


✏️ 참고.

  'sacil' 명령어를 사용할 때, 정확한 옵션과 명령어 구문을 확인하기 위해 다음과 같은 명령어로 도움말을 볼 수 있습니다. 🤩
    sudo /usr/local/openvpn_as/scripts/sacli --help
    
    
      🎯 이 명령어를 통해 'sacil' 에서 사용 가능한 모든 옵션과 명령을 확인할 수 있습니다. :)
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-08-16-openvpn-client-ip.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-08-16-openvpn-client-ip.html"><h1 class="title_post">📝[Post] OpenVPN 클라이언트의 IP 주소와 OpenVPN 서버에서 할당된 서브넷 정보 가져오는 방법.</h1></a>
                        <a href="/Backend/Post/2024-08-16-openvpn-client-ip.html" class="txt_post">
                            🙋‍♂️ OpenVPN 클라이언트의 IP 주소와 OpenVPN 서버에서 할당된 서브넷 정보 가져오는 방법.

  
    
      먼저 OpenVPN Access Server에 접속합니다.
        
          🎯 OpenVPN 클라이언트는 꺼진 상태여야 합니다.
만약 OpenVPN 클라이언트가 연결되어 있다면 연결을 끊어주세요.
        
      
    
  
  
    
      로그 파일을 살펴봅니다.
        sudo tail -f /var/log/openvpnas.log
        
      
    
  
  
    
      'SENT CONTROL [client_name]' 또는 'PUSH_REPLY...' 와 같은 메시지를 찾아봅니다.
        
          로그에서 위와 같은 메시지에는 클라이언트가 할당받은 IP 주소 및 서브넷 정보가 포함 되어 있을 수 있습니다.

        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-18-structural-model.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-18-structural-model.html"><h1 class="title_post">🌐[Network] 구조적 모델</h1></a>
                        <a href="/Backend/Network/2024-08-18-structural-model.html" class="txt_post">
                            🌐[Network] 구조적 모델.

  네트워크는 다수의 시스템을 전송 매체로 연결해 구성한 시스템들의 집합체입니다.
    
      소규모의 네트워크들은 전송 매체로 연결되어 더 큰 네트워크로 반복적으로 확장될 수 있습니다.
    
  
  컴퓨터 네트워크는 외형상 호스트 시스템과 전송 매체로 구분합니다.
    
      하지만 이런 물리적인 형태와는 별도로, 그들이 수행하는 내부 기능을 기초로 하여 다양한 구조로 세분할 수 있습니다.
        
          특히, 호스트가 제공하는 복잡한 네트워크 기능을 연관된 그룹으로 묶어 계틍 모델로 설명할 수 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-18-OSI.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-18-OSI.html"><h1 class="title_post">🌐[Network] OSI 7계층 모델.</h1></a>
                        <a href="/Backend/Network/2024-08-18-OSI.html" class="txt_post">
                            🌐[Network] OSI 7계층 모델.

  다수의 시스템을 서로 연결해서 통신하려면 선행적으로 전체 시스템 구조를 표준화해야 합니다.
  국제 표준화 단체인 ISO(International Standard Organization)에서는 OSI(Open Systems Interconnection) 7계층 모델을 제안하여, 네트워크에 연결된 시스템이 갖추어야 할 기본 구조와 기능을 상세히 정의하고 있습니다.


1️⃣ 계층 구조.



  OSI 7계층 모델(OSI 7 Layer Model)에 따르면, 네트워크에 연결된 호스트들은 위 그림과 같이 7개 계층으로 모듈화된 전송 기능을 갖추어야 합니다.
  일반 사용자는 OSI 7계층 맨 위에 있는 응용 계층을 통해 데이터의 송수신을 요청하며, 이 요청은 하위 계층에 순차적으로 전달되어 맨 아래에 있는 물리 계층을 통해 상대 호스트에 전송됩니다.
    
      그리고 요청이 각 계층으로 하달되는 과정에서 송수신 호스트 사이의 라우터들이 중개 기능을 수행합니다.
        
          일반적으로 라우터는 하위 3개 계층의 기능만 수행합니다.
        
      
    
  
  데이터를 수신하는 호스트에서는 송신 호스트와는 반대 방향으로 처리가 이루어집니다.
    
      즉, 물리 계층으로 들어온 데이터는 순차적인 상향 전달 과정을 거쳐 응용 계층으로 올라갑니다.
        
          수신 호스트에서 처리가 완료된 결과를 회신할 때는 반대 과정을 순차적으로 밟아서 송신 호스트로 되돌아갑니다.
        
      
    
  
  데이터를 송수신하는 최종 주체는 송수신 호스트 양쪽에 위치한 응용 계층이며, 하부 계층인 표현 계층은 응용 계층을 지원하기 위한 고유 기능을 수행합니다.
    
      이와 같은 계층 구조의 원리는 모든 상하 계층에 대하여 상대적으로 적용되며, 각각의 계층들은 데이터 전송에 필요한 기능들을 나누어 처리합니다.
    
  


1️⃣ 계층별 기능.

  OSI 7계층 모델의 각 계층은 독립적인 고유 기능을 수행하며, 하위 계층이 바로 위 계층에서 서비스를 제공하는 형식으로 동작합니다.


1️⃣ 물리 계층(Physical Layer).

  네트워크에서 호스트들이 데이터를 전송하려면 반드시 물리적인 전송 매체로 연결되어 있어야 합니다.
  물리 계층(Physical Layer)은 호스트를 전송 매체와 연결하기 위한 인터페이스 규칙과 전송 매체의 특성을 다루며, 크게 유선 매체와 무선 매체로 구분됩니다.


2️⃣ 데이터 링크 계층(Data Link Layer).

  물리 계층으로 데이터를 전송하는 과정에서는 잡음(Noise)등과 같은 여러 외부 요인에 의하여 물리적인 오류가 발생할 수 있습니다.
  데이터 링크 계층(Data Link Layer)은 물리 계층의 오류에 관한 오류 제어(Error Control) 기능을 수행하며, 이를 위해서는 오류의 발생 사실을 인지하는 기능과 오류 복구 기능이 필요합니다.
  물리 계층은 물리적 전송 오류를 감지(Sense)하는 기능을 제공해 상위 계층인 데이터 링크 계층에서 오류를 인지할 수 있도록 해줍니다.
    
      그렇지 않은 경우는 데이터 링크 계층 스스로 별도의 기능을 수행하여 오류를 인지해야 합니다.
        
          대표적인 물리적 오류로는 데이터가 도착하지 못하는 데이터 분실과 내용이 깨져서 도착하는 데이터 변형이 있습니다.
            
              일반적으로 컴퓨터 네트워크에서 오류 복구는 송신자가 원래의 데이터를 재전송(Retransmission)하는 방식으로 처리합니다.
            
          
        
      
    
  


3️⃣ 네트워크 계층(Network Layer)

  송신 호스트가 전송한 데이터가 수신 호스트까지 안전하게 도착하려면 여러 개의 중개 시스템인 라우터(Router)를 거쳐야 합니다.
    
      이 과정에서 데이터가 올바른 경로를 선택할 수 있도록 지원하는 계층이 네트워크 계층(Network Layer)입니다.
    
  
  기본적으로 네트워크 내부 구조는 라우터들로 구성되고, 네트워크 바깥쪽에 연결되는 송수신 호스트 사이의 데이터 중개 기능을 수행합니다.
    
      데이터 중개 과정에서 오류가 발생할 수 있으므로 네트워크 계층에도 오류 제어 기능이 필요합니다.
    
  
  네트워크 부하가 증가하면 특정 지역에 혼잡(Congestion)이 발생할 수 있는데, 혼잡 제어(Congestion Control)도 데이터의 전송 경로와 관계되므로 네트워크 계층이 담당합니다.


4️⃣ 전송 계층(Transport Layer)

  컴퓨터 네트워크에서 데이터를 교환하는 최종 주체는 호스트가 아니고, 호스트 내부에서 실행되는 응용 네트워크 프로세스입니다.
  네트워크 계층은 송수신 호스트 사이의 전송을 지원하지만, 응용 프로세스까지 전달하는 기능은 없습니다.
  전송 계층(Transport Layer)은 송신 프로세스와 수신 프로세스 간의 연결(Connection) 기능을 제공하기 때문에 프로세스 사이의 안전한 데이터 전송을 지원합니다.
  전송 계층은 데이터가 전송되는 최종적인 경로상의 양 끝단 사이의 연결이 완성되는 계층입니다.
    
      일반적으로 계층 4까지의 기능은 운영체제에서 시스템 콜(System Call) 형태로 상위 계층에 제공하며, 계층 5~7의 기능은 응용 프로그램으로 작성됩니다.
    
  


5️⃣ 세션 계층(Session Layer)

  세션 계층(Session Layer)은 전송 계층에서 제공하는 연결의 개념과 유사한 세션 연결을 지원하지만, 이보다는 더 상위의 논리적 연결입니다.
    
      즉, 응용 환경에서 사용자 간 대화(Dialog) 개념의 연결로 사용되기 때문에 전송 계층의 연결과 구분됩니다.
        
          예를 즐어, 인터넷에서 파일 송수신 중에 연결이 끊기면 이는 전송 계층의 연결이 종료된 것입니다.
            
              이후 전송 계층의 연결을 다시 설정하여 이전에 데이터 송수신이 멈춘 지점부터 이어서 전송하는 기능을 세션 계층이 지원합니다.
            
          
        
      
    
  


6️⃣ 표현 계층(Presentation Layer)

  표현 계층(Presentation Layer)은 전송되는 데이터의 의미(Semantic)를 잃지 않도록 올바르게 표현(Syntax)하는 방법을 다룹니다.
    
      즉, 정보를 교환하는 호스트들이 표준화된 방법으로 데이터를 인식할 수 있게 해줍니다.
        
          또한, 데이터의 표현이라는 본래의 기능에 더해, 현재의 표현 계층은 압축과 암호화라는 기능도 중요하게 다루고 있습니다.
            
              동영상과 같은 대용량의 멀티미디어 데이터를 압축(Compression)하면 전송 데이터의 양을 줄일 수 있습니다.
            
          
        
      
    
  
  암호화는 네트워크 보안 기능의 하나이며, 외부의 침입자로부터 데이터를 안전하게 보호하는 기술입니다.
    
      인터넷을 통한 개인 정보의 처리와 금융 상거래가 증가하면서 인터넷 보안의 중요성이 커지고 있습니다.
    
  


7️⃣ 응용 계층(Application Layer)

  응용 계층(Application Layer)은 일반 사용자를 위한 다양한 네트워크 응용 서비스를 지원합니다.
    
      단순히 정보 검색을 지원하던 시대를 지나서 오늘날 인터넷 환경은 인공지능과 결합하는 추세로 발전되고 있습니다.
        
          그에 따라 특정 분야에 한정되지 않고, 사회 전반의 모든 영역으로 네트워크 서비스는 발전하고 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-16-system-basic-term.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-16-system-basic-term.html"><h1 class="title_post">🌐[Network] 시스템 기초 용어.</h1></a>
                        <a href="/Backend/Network/2024-08-16-system-basic-term.html" class="txt_post">
                            🌐[Network] 시스템 기초 용어.


  위 그림과 같이 네트워크는 외형적으로 시스템과 전송 매체의 조합으로 구성됩니다.
  데이터 통신을 위한 전송 매체는 전송 대역, 전송 속도, 전송 오류율과 같은 물리적인 특성이 주 관심사이므로 논리적인 기능은 비교적 단순합니다.
  시스템은 전송 매체를 이용해 다양한 연동 형태로 구성할 수 있으므로 개념의 폭이 넓고 복잡합니다.


1️⃣ 시스템의 구분.

  네트워크를 구성하는 시스템이 반드시 일반 컴퓨터처럼 복잡한 기능을 수행해야 하는 것은 아니지만, 데이터 전송 기능을 포함하여 일정 정도의 컴퓨팅 기능을 보유합니다.
  네트워크 시스템은 수행 기능에 따라 다음과 같이 다양한 명칭으로 부를 수 있습니다.
    
      노드, 라우터, 호스트, 클라이언트, 서버
    
  


1️⃣ 노드(Node)

  노드(Node)는 컴퓨터 이론 분야에서 특정 시스템을 가리키는 가장 일반적인 용어로 사용됩니다.
  인터넷에서도 상호 연결된 시스템을 표현할 수 있는 가장 포괄적 의미로 사용되므로 데이터를 주고받을 수 있는 모든 시스템을 통칭합니다.
  노드는 인터넷 내부를 구성하는 라우터와 인터넷 바깥쪽에 연결되어 데이터를 주고받는 호스트로 구분됩니다.


2️⃣ 라우터(Router)

  라우터(Router)는 인터넷 내부를 구성하며, 기본으로 데이터 전송 기능을 포함합니다.
  라우터의 주요 역할은 데이터 중개 기능이며, 인터넷 바깥쪽에 연결된 호스트들 사이의 데이터 전송이 인터넷 내부에서 최적의 경로를 통하여 이루어지도록 합니다.


3️⃣ 호스트(Host)

  호스트(Host)는 인터넷 바깥쪽에 연결되어 일반 사용자들의 네트워크 접속 창구 역할을 합니다.
  일반적인 컴퓨팅 기능을 갖춘 호스트는 네트워크 응용 프로그램을 실행할 수 있고, 사용자는 이 프로그램을 이용하여 다양한 인터넷 서비스를 제공받습니다.
  호스트는 로스트 사이에 제공되는 서비스를 기준으로 클라이언트와 서버로 나눌 수 있습니다.


4️⃣ 클라이언트(Client)와 서버(Server)

  클라이언트(Client)는 임의의 인터넷 서비스를 이용하는 응용 프로그램이고, 서버(Server)는 서비스를 제공하는 응용 프로그램입니다.
  클라이언트와 서버의 개념은 서비스 단위로 이루어지므로 임의의 호스트가 클라이언트나 서버로 고정되지 않습니다.
    
      이용하는 서비스의 종류에 따라서 클라이언트가 될 수도 있고, 서버가 될 수도 있습니다.
        
          그러므로 특정 서비스를 기준으로 상대적인 관점에서 클라이언트와 서버라는 용어를 사용합니다.
        
      
    
  
  일반적으로 응용 프로그램 혹은 서비스 단위가 아닌 호스트 단위로도 클라이언트와 서버를 사용하기도 합니다.
    
      즉, 다양한 서비스를 제공하는 목적으로 특화된 호스트의 경우 호스트 자체를 서버라 부르기도 합니다.
    
  
  서버는 클라이언트보다 먼저 실행 상태가 되어 클라이언트의 요청에 대기해야 합니다.
    
      그리고 영원히 종료하지 않으면서 클라이언트의 요청이 있을 때마다 서비스를 반복해서 제공합니다.
    
  


2️⃣ 클라이언트(Client)와 서버(Server)


  위 그림은 임의의 응용 서비스를 기준으로 클라이언트와 서버의 상대적인 관계를 설명합니다.
  FTP(File Transfer Protocol)는 원격 호스트끼리 파일 송수신 기능을 제공하는 서비스이고, 텔넷(Telnet)은 원격 호스트에 로그인하는 서비스를 제공합니다.
  호스트 2는 FTP 서비스를 제공하고, 호스트 3은 텔넷 서비스를 제공합니다.
  먼저, FTP 서비스를 살펴보면 호스트 1은 호스트 2에 FTP 서비스를 요청합니다.
    
      따라서 FTP 서비스를 기준으로 하면 호스트 1이 클라이언트가 되고, 호스트 2는 서버가 됩니다.
      반면, 텔넷 서비스는 호스트 2가 호스트 3에 서비스를 요청합니다.
        
          텔넷 서비스를 기준으로 하면 호스트 2가 클라이언트이고, 호스트 3은 서버입니다.
            
              따라서 호스트 2는 사용하는 응용 서비스의 종류에 따라 클라이언트가 되기도 하고 서버가 되기도 합니다.
                
                  결론적으로 클라이언트와 서버라는 용어는 서비스 이용의 상대적 위치에 따라 결정됨을 알 수 있습니다.
                
              
            
          
        
      
    
  
  서버의 명칭을 특정 호스트에 전용으로 부여해서 사용할 수도 있습니다.
  특히 다양한 서비스 기능을 제공하는 대형 시스템을 서버로 설정해 다수의 클라이언트가 접속해서 서비스를 이용하도록 할 수 있습니다.
    
      그러나 기능적인 관점에서는 위 그림에서처럼 호스트에서 실행되는 응용 서비스별로 구분하는 것이 더 정확합니다.
    
  
  인터넷에서 네트워크 서비스의 기능은 대부분 응용 프로그램으로 구현되므로 보통 클라이언트 프로세스, 서버 프로세스라는 호칭이 더 자연스러울 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240816_AWS_Routing_And_Routing_Table.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240816_AWS_Routing_And_Routing_Table.html"><h1 class="title_post">☁️[AWS] 라우팅 및 라우팅 테이블.</h1></a>
                        <a href="/Backend/AWS/240816_AWS_Routing_And_Routing_Table.html" class="txt_post">
                            ☁️[AWS] 라우팅 및 라우팅 테이블.

  실제 세상의 어떤 주소를 찾아가기 위해서는 그 주소까지의 경로를 알아야 합니다.
  네트워크 세계에서도 이처럼 어떤 IP 주소를 찾아가기 위해서는 해당 주소까지의 경로를 알아야 합니다.
    
      하지만 사용자는 이런 경로를 알 필요가 없습니다.
        
          대신 라우터(Router) 가 최적의 경로를 찾아서 경로를 결정하고 연결합니다.
            
              라우터가 IP 주소까지의 경로를 결정하는 것을 라우팅(Routing) 이라고 합니다.
            
          
        
      
    
  
  인터넷을 통해 원하는 사이트까지 가는 경로는 여러 라우터를 거치게 되므로 어떻게 라우팅하는 것이 효율이 좋을지 결정해야 합니다.

  각 라우터는 소유한 경로 정보를 기반으로 목적지 IP 주소를 향해 이동해야 하는 네트워크를 결정합니다.
    
      이 경로 정보를 라우팅 테이블(Routing Table) 이라고 합니다.
        
          라우팅 테이블은 라우터가 소유한 네트워크의 지도와 같은 것입니다.
            
              AWS에서는 Amazon VPC의 라우팅 테이블(Routing Table) 이라는 기능이 이에 해당합니다.
                
                  라우팅 테이블에는 인터넷이나 각 AWS 서비스에 대해 어떤 엔드포인트를 경유할지와 같은 경로 정보를 관리할 수 있습니다.

                
              
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240816_AWS_PUBLIC_IP_AND_PRIVATE_IP.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240816_AWS_PUBLIC_IP_AND_PRIVATE_IP.html"><h1 class="title_post">☁️[AWS] 퍼블릭 IP 주소와 프라이빗 IP 주소</h1></a>
                        <a href="/Backend/AWS/240816_AWS_PUBLIC_IP_AND_PRIVATE_IP.html" class="txt_post">
                            ☁️[AWS] 퍼블릭 IP 주소와 프라이빗 IP 주소.

  IP 주소는 두 가지로 구분할 수 있습니다.

  하나는 한국 또는 전 세계에서 ‘이 주소는 인터넷에서 이 곳’이라고 특정할 수 있는 주소입니다.
    
      이를 퍼블릭 IP 주소 또는 글로벌 IP 주소(공인 IP) 라고 합니다.

    
  
  다른 하나는 프라이빗 IP 주소(사설 IP) 입니다.
    
      퍼블릭 IP 주소는 전 세계에서 식별할 수 있는 주소지만, 프라이빗 주소는 닫힌 네트워크(폐쇄망, 내부 네트워크, 근거리 통신-LAN) 내에서만 식별할 수 있는 IP 주소입니다.
    
  
  프라이빗 IP 주소로 사용할 수 있는 범위는 다음과 같습니다.
    
      10.0.0.0 ~ 10.255.255.255(10.0.0.0/8)
      176.16.0.0 ~ 172.31.255.255(176.16.0.0/12)
      192.168.0.0 ~ 192.168.255.255(192.168.0.0/16)
        
          퍼블릭 IP 주소는 이 주소를 제외한 나머지 주소입니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240816_AWS_LOAD_BALANCER.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240816_AWS_LOAD_BALANCER.html"><h1 class="title_post">☁️[AWS] 부하 분산을 위해 여러 서버에 접속을 분배</h1></a>
                        <a href="/Backend/AWS/240816_AWS_LOAD_BALANCER.html" class="txt_post">
                            ☁️[AWS] 부하 분산을 위해 여러 서버에 접속을 분배.


  많은 사용자가 사용하는 시스템을 구축한다면 부하 분산 을 고려해야 합니다.
  시스템을 사용하는 사용자가 많아질수록 서버의 부담은 커집니다.
  서버 1대당 한 번에 처리할 수 있는 접속자 수는 정해져 있기 때문에 한 번에 많은 사람이 몰리면 CPU나 메모리의 사용량이 증가해 서버가 느려지고 최악의 경우 서버가 멈출 수도 있습니다.
    
      이는 서비스 사용자에게 큰 영향을 줍니다.
        
          이런 상황을 막기 위해 서버를 여러 대 구성해 각 서버가 처리를 나눠서 할 수 있게 구축해야 합니다.
            
              이렇게 부하를 분산시키기 위해서 일반적으로 로드 밸런서(Load Balancer) 라는 장치를 사용합니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240816_AWS_IP_ADDRESS.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240816_AWS_IP_ADDRESS.html"><h1 class="title_post">☁️[AWS] IP 주소(Address)는 네트워크의 번지(주소)</h1></a>
                        <a href="/Backend/AWS/240816_AWS_IP_ADDRESS.html" class="txt_post">
                            ☁️[AWS] IP 주소(Address)는 네트워크의 번지(주소)


  브라우저를 통해 웹 사이트에 접속할 때 우리에게 보이는 웹 페이지는 실제로 어느 주소에 존재하는 ‘웹 사이트를 호스팅하는 서버(웹 서버)’에 접속해서 취득한 웹 페이지 정보입니다.
  웹 서버는 데이터 센터에 있을 수도 있고 AWS와 같은 클라우드 서비스에 있을 수도 있습니다.
    
      그리고 웹 서버에 접근하기 위해서는 웹 서버가 그곳에 있다는 특정 정보가 필요합니다.
        
          이것이 IP 주소 입니다.
        
      
    
  
  웹 사이트에 접속할 때는 이 IP 주소를 바탕으로 위치를 특정해 그곳에 있는 웹 서버에 접속합니다.

  웹 서버뿐만 아니라 PC, 스마트폰 등 네트워크와 연결된 모든 장치에는 IP 주소가 할당됩니다.
    
      일반적으로 IPv4가 표준으로 사용됩니다.
    
  




  IPv4 외에도 IPv6도 있습니다.
    
      IPv4는 주소가 2³²개(=약 43억 개) 존재하는 데 비해 IPv6 주소는 2¹²⁸개(=약 340억 개)가 존재합니다.
    
  
  최근 IPv4만으로는 주소를 할당할 수 없을 정도로 서버나 인터넷에 접속하는 기기가 많아져서 대체할 수 있는 IPv6가 주목받고 있습니다.
    
      하지만 IPv6는 아직 보편적으로 보급되지 않았고 기존에 사용하던 기기가 IPv4만 지원하는 경우가 대부분입니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240816_AWS_FIREWALL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240816_AWS_FIREWALL.html"><h1 class="title_post">☁️[AWS] 방화벽에서 허용된 통신만 통과.</h1></a>
                        <a href="/Backend/AWS/240816_AWS_FIREWALL.html" class="txt_post">
                            ☁️[AWS] 방화벽에서 허용된 통신만 통과.


  인터넷을 통해 전 세계의 다양한 웹 사이트나 서비스에 접속할 수 있지만 전 세계와 연결된다는 것은 각종 악성 코드나 해커의 침입에 노출된다는 뜻과도 같습니다.
    
      이런 보안 위협으로부터 시스템을 지키기 위해 사용하는 것이 방화벽 입니다.
    
  
  방화벽은 이름에서 알 수 있듯이 화재(보안 위협)가 발생했을 때 화재로부터 자산(시스템)을 지키는 역할을 합니다.
  하드웨어 형태의 방화벽도 있고 소프트웨어 형태로 서버에 설치돼 동작하는 방화벽도 있습니다.
    
      일반적으로 사용하는 윈도우 PC에도 ‘보안 센터’ 설정을 보면 방화벽이 설치돼 동작하고 있습니다.
      AWS에서는 보안 그룹이나 네트워크 ACL 같은 방화벽 기능을 가진 서비스가 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240816_AWS_DNS.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240816_AWS_DNS.html"><h1 class="title_post">☁️[AWS] 도메인 이름과 IP 주소를 연결하는 DNS.</h1></a>
                        <a href="/Backend/AWS/240816_AWS_DNS.html" class="txt_post">
                            ☁️[AWS] 도메인 이름과 IP 주소를 연결하는 DNS.

  일반적으로 어떤 웹 사이트에 접속하기 위해서는 'https://OO.com/'과 같은 URL(Uniform Resource Locator)을 사용합니다.
    
      이러한 'https://OO.com/'을 도메인(Domain) 이라고 합니다.
        
          도메인은 점으로 연결된 문자열로 구성돼 있으며 기업 이름과 단체 이름을 표현하는 경우가 많습니다.
          도메인은 해당 문자열에 표시되는 기업, 단체 등이 제공하는 사이트의 주소를 정의합니다.
        
      
    
  
  도메인 이름에는 IP 주소가 연결돼 있어 사용자는 도메인 이름만으로 사이트에 접속할 수 있습니다.
  DNS(Domain Name System) 가 우리 대신 도메인 이름에 연결된 IP 주소를 찾아주기 때문입니다.
    
      이러한 DNS 기능을 이름 해석 이라고 합니다.

    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240816_AWS_CIDR_BLOCK.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240816_AWS_CIDR_BLOCK.html"><h1 class="title_post">☁️[AWS] CIDR(Classless Inter-Domain Routing) 블록으로 IP 주소 범위 결정.</h1></a>
                        <a href="/Backend/AWS/240816_AWS_CIDR_BLOCK.html" class="txt_post">
                            ☁️[AWS] CIDR(Classless Inter-Domain Routing) 블록으로 IP 주소 범위 결정.


  위 그림과 같이 IP 주소를 이용해 네트워크 범위를 정의하는 것을 CIDR(Classless Inter-Domain Routing) 블록 이라고 합니다.
  IP 주소를 나타내는 숫자열은 크게 네트워크 부분과 호스트 부분으로 나눌 수 있습니다.
    
      네트워크 부분은 문자 그대로 네트워크를 정의합니다.
      호스트 부분은 그 네트워크 내의 호스트를 정의합니다.
        
          즉, 네트워크 안에서 접속할 수 있는 서버 등을 나타내는 부분입니다.
        
      
    
  
  위 그림에서 ‘/16’을 서브넷 마스크라고 하며 IP 주소를 사용해 네트워크 범위를 정의하다면 보통 위 표기를 사용합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-15-network-basic-term.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-15-network-basic-term.html"><h1 class="title_post">🌐[Network] 네트워크 기초 용어.</h1></a>
                        <a href="/Backend/Network/2024-08-15-network-basic-term.html" class="txt_post">
                            🌐[Network] 네트워크 기초 용어.

  이미 수많은 사람이 익숙하게 사용하고 있는 인터넷(Internet)은 연구소, 기업, 학교 등의 소규모 조직에서 사용하기 시작한 작은 단위의 네트워크(Network)들을 서로 연결하면서 발전하였습니다.
    
      그 과정에서 자연스럽게 연결 방식의 표준화를 요구하게 되었고, 오늘날 전 세계로 확산되어 거대한 인터넷으로 성장하였습니다.
    
  
  네트워크를 이해하려면 시스템, 인터페이스, 전송 매체, 프로토콜, 네트워크, 인터넷과 같은 용어를 먼저 이해해야 합니다.
  네트워크(Network)는 하드웨어적인 전송 매체(Transmission Media)를 매개로 서로 연결되어 데이터를 교환하는 시스템(System)의 모음이며, 시스템과 전송 매체의 연결 지점에 대한 규격이 인터페이스(Interface)입니다.
  시스템이 데이터를 교환할 때는 소프트웨어적으로 동작하는 통신 규칙인 프로토콜(Protocol)이 필요합니다.
  인터페이스와 프로토콜은 서로 다른 시스템을 상호 연동해 동작시키기 위함이니 반드시 연동 형식의 통일이 필요하고, 이를 표준화(Standardization)라 합니다.




  위 그림은 여러 시스템이 전송 매체로 연결되어 네트워크를 구성한 예입니다.
  시스템은 반드시 일반 컴퓨터일 필요는 없으며, 보통 컴퓨팅 기능을 보유한 네트워크 장비들을 의미합니다.
  그림과 같은 네트워크의 가장 바깥쪽에 스마트폰을 포함한 일반 사용자들의 컴퓨터가 연결되어 데이터 교환 작업을 수행합니다.
  시스템들은 물리적으로 공유하는 전송 매체에 의하여 서로 연결되지만, 시스템이 전송 매체를 통해 데이터를 교환하려면 반드시 표준화된 프로토콜을 사용해야 합니다.
  우리가 알고 있는 인터넷은 IP(Internet Protocol)라는 네트워크 프로토콜이 핵심적인 역할을 하는 네트워크의 집합체입니다.
    
      여기서 IP는 프로토콜의 의미가 포함된 약자이지만 보통 IP 프로토콜이라 부릅니다.
    
  


1️⃣ 시스템(System)

  내부 규칙에 따라 자율적으로 동작하는 대상을 가리킵니다.
    
      자동차, 커피 자판기, 컴퓨터, 마이크로프로세서, 하드디스크 등과 같은 물리적인 대상뿐 아니라, 신호등으로 교통을 제어하는 운영 시스템, Mac OS 등의 운영체제, 프로그램의 실행 상태를 의미하는 프로세스와 같은 소프트웨어적인 대상들도 시스템입니다.
        
          🤩 TIP: 네트워크 환경에서 동작하는 임의의 시스템은 다른 시스템과 데이터를 교환하는 기능이 필수적입니다.
        
      
    
  
  시스템의 동작에 필요한 외부 입력이 있을 수 있으며, 내부 정보와 외부 입력의 조합에 따른 출력(시스템 실행의 결과물)이 있을 수 있습니다.
  한편, 작은 시스템이 여러 개 모여 더 큰 시스템을 구성할 수 있으므로 크기를 기준으로 시스템을 나누지는 않습니다.
  우리가 알고 있는 인터넷은 수많은 소규모 네트워크들이 서로 연동되는 반복적인 과정을 거쳐서 형성된 거대 연합체의 네트워크를 의미합니다.


2️⃣ 인터페이스(Interface)

  시스템과 시스템을 연결하기 위한 표준화된 접촉 지점을 의미하며, 하드웨어적인 관점과 소프트웨어적인 관점이 모두 존재합니다.
    
      하드웨어적인 예로서, 컴퓨터 본체와 키보드를 연결하여 제대로 동작하게 하려면 키보드의 잭을 본체의 정해진 위치에 꽂아야 합니다.
        
          이렇게 하려면 상호 간의 데이터 교환을 위한 RS-232C, USB 등과 같은 논리적인 규격뿐만 아니라, 잭의 크기와 모양 같은 물리적인 규격도 표준화되어야 합니다.
        
      
      소프트웨어적인 예로서, 프로그래밍 언어에서 함수 설계자는 함수 이름과 매개변수를 표준화하여 정의해야 하고, 함수 사용자는 이 정의에 맞게 함수 이름과 인수를 지정하여 사용할 수 있습니다.
    
  
  인터페이스를 논리적인 상하 구조의 개념으로 이해할 필요는 없지만, 양방향으로 데이터를 주고 받는 경우와 한쪽에서 다른 쪽의 단방향으로 데이터를 보내는 경우로 나눌 수 있습니다.


3️⃣ 전송 매체(Transmission Media)

  시스템끼리 정해진 인터페이스를 연동해 데이터를 전달하려면 물리적인 전송 수단인 전송 매체(Transmission Media)가 반드시 있어야 합니다.
  전송 매체는 사람의 눈으로 볼 수 있는 동축 케이블을 포함하여 소리를 전파하는 공기, 무선 신호 등 다양하게 존재합니다.
  인터페이스는 시스템 간의 물리적인 연동을 위한 논리적인 규격이고 인터페이스로 정해진 규격은 전송 매체를 통해 물리적으로 구현되며, 시스템끼리 데이터 전송을 가능하게 합니다.


4️⃣ 프로토콜(Protocol)

  논리적으로 상호 연동되는 시스템이 전송 매체를 통해 데이터를 교환할 때는 표준화된 대화 규칙을 따르는데, 이 규칙을 프로토콜(Protocol)이라 합니다.
  일반적으로 프로토콜은 상하 관계가 아닌 동등한 위치에 있는 시스템 사이의 규칙이라는 측면이 강조되어 인터페이스와 구분이 됩니다.
  인터페이스는 위 그림과 같이 두 시스템이 연동하기 위한 특정한 접촉 지점(Access Point)을 의미하는 경우가 많지만, 프로토콜과 비교하여 인용될 때는 상하 개념이 적용됩니다.
    
      즉, 네트워크의 계층 모델 구조에서 인터페이스는 상하 계층 사이의 관계를 다루고, 프로토콜은 동등 계층 사이의 관계를 다룹니다.
        
          일반적으로 프로토콜은 주고받는 데이터의 형식과 그 과정에서 발생하는 일련의 절차적 순서에 무게를 둡니다.
        
      
    
  


5️⃣ 네트워크(Network)

  통신용 전송 매체로 연결된 여러 시스템이 프로토콜을 사용하여 데이터를 주고받을 때, 이들을 하나의 단위로 통칭하여 네트워크(Network)라 부릅니다.
  일반적인 컴퓨터 네트워크에서는 물리적인 전송 매체로 연결된 컴퓨터들이 동일한 프로토콜을 이용해 서로 데이터를 주고 받습니다.
  소규모 네트워크가 모여 더 큰 네트워크를 구성할 수 있는데, 네트워크끼리는 라우터(Router)라는 중개 장비를 사용해서 연결합니다.


6️⃣ 인터넷(Internet)

  전 세계의 모든 네트워크가 유기적으로 연결되어 동작하는 통합 네트워크입니다.
  인터넷에서 사용되는 시스템, 인터페이스, 전송 매체, 프로토콜들은 그 종류가 매우 복잡하고 다양하지만, 데이터 전달 기능에 한해서는 공통으로 IP(Internet Protocol) 프로토콜을 사용합니다.
    
      즉, ISO의 OSI 7계층 모델에서 계층 3인 네트워크 계층의 기능을 IP 프로토콜이 수행하며 인터넷이라는 용어의 IP의 첫 단어인 Internet에서 유래했습니다.
    
  


7️⃣ 표준화(Standardization)

  서로 다른 시스템이 상호 연동해 동작하려면 표준화(Standardization)라는 연동 형식의 통일이 필요합니다.
    
      예를 들어, 프린트 용지를 생각해봅시다.
        
          일반적으로 프린터와 프린트 용지를 만드는 회사는 다릅니다.
          하지만 사전에 A4 규격이라는 통일된 틀을 만들어두었기 때문에 서로 다른 회사에서 생산한 프린터와 프린트 용지를 자유롭게 사용할 수 있습니다.

        
      
    
  
  현대 산업사회가 눈부시게 성장한 배경에는 증기기관의 개발에 따른 에너지 동력원의 발전이 있었습니다.
  지금은 인간의 노동력이라는 한계를 넘어 인공지능으로 대표되는 새로운 차원의 사회 발전 단계인 4차 산업혁명이 진행되고 있습니다.
    
      그러나 이와 다른 관점에서 더 근원적인 발전 배경을 살펴보면, 표준화 원리를 바탕으로 한 레고의 조합 개념이 산업 전반에 존재해왔기 때문임을 알 수 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240815_AWS_Virtualization.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240815_AWS_Virtualization.html"><h1 class="title_post">☁️[AWS] 가상화</h1></a>
                        <a href="/Backend/AWS/240815_AWS_Virtualization.html" class="txt_post">
                            ☁️[AWS] 가상화.

  클라우드 서비스에서도 사용자는 서버를 임대해 사용합니다.
  사용자가 사용하고 싶은 사양으로 서버를 선택하면 가상화 기술을 이용해 해당 사양의 서버를 가상으로 생성해 사용합니다.
  가상 서버 는 하나 또는 클러스터링 된 물리 서버 내에 만들어집니다.
    
      🙋‍♂️ 클러스터링(Clustering, Computer Cluster)
여러 대의 컴퓨터가 연결돼 하나의 시스템처럼 동작하는 컴퓨터들의 집합을 말합니다.
    
  
  가상 서버는 물리 서버의 CPU나 메모리 같은 컴퓨터 자원을 일부 독점해 물리적으로 독립된 서버와 같이 동작합니다.





  서버만 가상화 기술을 사용할 수 있는 것이 아닙니다.
    
      스토리지나 네트워크 장비 등도 1대의 기기를 가상화 기술로 여러 기기처럼 취급할 수 있습니다.
    
  
  기본적으로 가상화 기술을 통해 생성된 기기들을 ‘가상 OO’ 라고 합니다.




                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240815_AWS_ServerlessAndOpenAndClosedClould.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240815_AWS_ServerlessAndOpenAndClosedClould.html"><h1 class="title_post">☁️[AWS] 서버리스, 개방형 클라우드와 폐쇄형 클라우드</h1></a>
                        <a href="/Backend/AWS/240815_AWS_ServerlessAndOpenAndClosedClould.html" class="txt_post">
                            ☁️[AWS] 서버리스.

  클라우드 서비스에서는 서버리스(Serverless) 라는 단어를 자주 사용합니다.
    
      직역하면 ‘서버가 없다’는 의미로 서비스가 이용될 때만 서버를 가동하는 방식을 가리켜 ‘서버리스 서비스’라고 합니다.
    
  
  클라우드 서비스는 보통 서버를 사용하는 시간만큼 요금이 발생하므로 요금이 부과되는 시간을 줄여 비용을 낮출 수 있다는 장점이 있습니다.




☁️[AWS] 개방형 클라우드와 폐쇄형 클라우드.

  클라우드 서비스는 사용 형태에 따라 ‘개방형 클라우드’ 와 ‘폐쇄형 클라우드’ 로 나눌 수 있습니다.
    
      이 둘을 섞은 혼합형 클라우드(Hybrid Clould)도 존재합니다.
    
  
  폐쇄형 클라우드
    
      기업 내부의 비밀을 유지하기 위해 외부에 공개하지 않도록 기업 내부에 구축하는 형태입니다.
    
  
  개방형 클라우드
    
      모든 사람이 쓸 수 있게끔 공개된 형태입니다.
    
  
  AWS는 모든 사람이 사용할 수 있는 개방형 클라우드 서비스입니다.
    
      좀 더 자세히 말하자면 AWS에는 전용 기기를 사용자에게 할당하는 베어메탈(Bare Metal) 서비스, 가상으로 사용자의 점유 공간을 제공하는 VPN(Virtual Private Clould) 서비스가 있습니다.
        
          이용이 끝나면 대여한 서버를 다른 사용자에게 다시 대여할 수 있으므로 개방형 클라우드입니다.
        
      
    
  
  폐쇄형 클라우드는 온프레미스에 가깝습니다.
    
      사용자는 시설 내부에 클라우드 컨테이너를 두고 전용 클라우드 환경을 구축해서 사용합니다.
    
  
  하지만 VPC와 같은 가상 독점 공간에서도 보안을 충분히 확보할 수 있고 온프레미스에 가까운 형태인 폐쇄형 클라우드는 초기 투자 비용이 크기 때문에 현재는 개방형 클라우드를 선택하는 경우가 많습니다.




                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240815_AWS_RULES.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240815_AWS_RULES.html"><h1 class="title_post">☁️[AWS] 인바운드 규칙(Inbounds Rules)와 아웃바운드 규칙(Outbound Rules)</h1></a>
                        <a href="/Backend/AWS/240815_AWS_RULES.html" class="txt_post">
                            ☁️[AWS] 인바운드 규칙(Inbounds Rules)와 아웃바운드 규칙(Outbound Rules).

  AWS EC2 인스턴스의 보안 그룹은 인스턴스에 대한 네트워크 트래픽을 제어하는 가상 방화벽 역할을 합니다.
  보안 그룹에는 인바운드(들어오는 트래픽) 및 아웃바운드(나가는 트래픽) 규칙이 있으며, 각 규칙은 특정 유형의 트래픽을 허용하거나 차단할 수 있습니다.


1️⃣ 인바운드 규칙(Inbound Rules)
인바운드 규칙은 외부에서 인스턴스로 들어오는 트래픽을 제어합니다.
이 규칙에 따라 특정 IP 주소나 IP 범위에서 오는 트래픽만 허용됩니다.

  예시
    
      SSH 접속을 허용하기 위해 포트 22번에서 들어오는 트래픽을 허용할 수 있습니다.
        
          이 경우, 특정 IP 주소(예: 203.0.113.0/24)에서 SSH 접속이 가능하도록 설정할 수 있습니다.
        
      
      웹 서버를 운영 중이라면 HHTP(포트 80) 또는 HTTPS(포트 443) 트래픽을 허용할 수 있습니다.
    
  
  중요한 점
    
      보안 그룹은 허용 규칙만 존재하며, 명시적으로 허용된 트래픽만 인스턴스로 들어올 수 있습니다.
      기본적으로, 보안 그룹에 명시되지 않은 모든 인바운드 트래픽은 차단됩니다.
    
  


2️⃣ 아웃바운드 규칙(Outbound Rules)
아웃바운드 규칙은 인스턴스에서 외부로 나가는 트래픽을 제어합니다.
기본적으로 모든 아웃바운드 트래픽이 허용되지만, 필요에 따라 이를 제한할 수 있습니다.

  예시
    
      인스턴스가 특정 외부 서비스로의 연결을 허용하도록, 해당 서비스의 IP 주소나 포트로 나가는 트래픽을 허용할 수 있습니다.
      만약 인스턴스가 외부로 데이터를 보내는 것을 제한하고자 한다면, 특정 포트나 IP 주소로의 나가는 트래픽을 차단할 수 있습니다.
    
  
  중요한 점
    
      기본적으로 아웃바운드 트래픽은 모두 허용되지만, 아웃바운드 규칙을 설정하여 특정 트래픽만 허용하도록 제한할 수 있습니다.
    
  


3️⃣ 보안 그룹 작동 방식

  보안 그룹은 상태 정보를 가지고 있습니다. 즉, 인스턴스로 들어오는 요청이 허용되었다면, 그 요청에 대한 응답은 아웃바운드 규칙과 관계없이 허용됩니다.
  보안 그룹은 AWS 계정 수준에서 관리되며, 여러 인스턴스에 동일한 보안 그룹을 적용할 수 있습니다.
  보안 그룹의 변경 사항은 즉시 적용되므로, 보안 그룹을 수정하면 해당 인스턴스에 바로 반영됩니다.


🙋‍♂️ 마무리
보안 그룹을 올바르게 설정하는 것은 EC2 인스턴스를 안전하게 운영하기 위해 매우 중요합니다.
인바운드 규칙을 통해 접근을 제한하고, 필요에 따라 아웃바운드 규칙을 설정하여 인스턴스의 네트워크 트래픽을 제어할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240815_AWS_BASTION_HOST.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240815_AWS_BASTION_HOST.html"><h1 class="title_post">☁️[AWS] Bastion Host란?</h1></a>
                        <a href="/Backend/AWS/240815_AWS_BASTION_HOST.html" class="txt_post">
                            ☁️[AWS] Bastion Host란?

  Bastion Host는 AWS와 같은 클라우드 환경에서 VPC(Virtual Private Clould) 내부의 다른 인스턴스나 리소스에 접근하기 위한 보안 게이트웨이 역할을 하는 EC2 인스턴스를 의미합니다.
  일반적으로 Bastion Host는 보안과 접근 제어를 강화하기 위해 사용됩니다.


1️⃣ Bastion Host의 주요 개념과 기능.

  1. 보안적인 역할
    
      Bastion Host는 VPC 내에서 퍼블릭 서브넷에 위치하며, 외부 인터넷에 직접적으로 노출되는 유일한 인스턴스입니다.
        
          이 인스턴스에 SSH 또는 RDP(Windows의 경우)를 통해 접근한 다음, VPC 내의 다른 프라이빗 서브넷에 있는 인스턴스들을 접근할 수 있습니다.
        
      
      VPC의 다른 인스턴스들은 프라이빗 서브넷에 위치하며, 직접 외부 인터넷에 노출되지 않도록 설정되어 있습니다.
        
          이로 인해 프라이빗 서브넷의 인스턴스들은 직접 외부에서 접근할 수 없고, Bastion Host를 통해서만 접근이 가능합니다.
        
      
    
  
  2. 접근 제어
    
      Bastion Host는 일반적으로 매우 엄격한 보안 정책을 적용하여 접근을 제어합니다.
        
          예를 들어, 특정 IP 주소에서만 SSH 접근을 허용하거나, 다단계 인증(MFA)을 요구할 수 있습니다.
        
      
      또한, Bastion Host에서 다른 인스턴스에 접근할 때는 추가적인 인증 절차나 SSH 키를 사용하여 안전하게 접근할 수 있습니다.
    
  
  3. 로그 및 모니터링
    
      Bastion Host를 통해 이루어진 모든 접근 기록을 로깅하여 누가 언제 어떤 리소스에 접근했는지 추적할 수 있습니다. 이를 통해 보안 사고 발생 시 신속하게 대응할 수 있습니다.
      이러한 접근 로그는 AWS CloudWatch, S3 버킷 등을 통해 저장 및 분석할 수 있습니다.
    
  


2️⃣ 사용 예시.

  개발팀이 운영 중인 여러 서버에 접근해야 할 때, Bastion Host를 통해 접근하면 직접적으로 서버들이 인터넷에 노출되지 않으면서도 필요한 작업을 수행할 수 있습니다.
  데이터베이스 서버와 같은 중요한 리소스가 있는 프라이빗 서브넷에 대한 접근을 Bastion Host를 통해서만 허용함으로써 보안을 강화할 수 있습니다.
  
    
      외부의 사용자는 Bastion Host에 SSH 접속.
    
  
  
    
      Bastion Host에서 VPC 내부의 프라이빗 서브넷에 있는 서버들에 SSH 접속.
        
          이러한 구조를 통해 VPC 내부의 인스턴스들이 외부로부터 보호되면서도 관리자는 필요한 작업을 수행할 수 있게 됩니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/2024_08_15_AWS_CLOULD_CLASSIFICATION.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/2024_08_15_AWS_CLOULD_CLASSIFICATION.html"><h1 class="title_post">☁️[AWS] 서비스 제공 형태에 따른 클라우드 분류.</h1></a>
                        <a href="/Backend/AWS/2024_08_15_AWS_CLOULD_CLASSIFICATION.html" class="txt_post">
                            ☁️[AWS] 서비스 제공 형태에 따른 클라우드 분류.

  클라우드 서비스는 제공하는 서비스에 따라 SasS, PaaS, IaaS 로 나눌 수 있습니다.
  SaaS(Software as a Service)
    
      응용 프로그램을 서비스로 제공하는 형태입니다.
      많은 사람이 사용하는 Gmail, Dropbox, Office365, Zoom이 대표적인 SaaS 입니다.
    
  
  PaaS(Platform as a Service), IaaS(Infrastructure as a Service)
    
      응용 프로그램을 만들기 위한 기능을 서비스로 제공합니다.
      이 서비스는 직접 응용 프로그램을 개발하는 사용자를 위한 서비스로, 사용자는 제공 받은 기능을 조합해 응용 프로그램을 개발합니다.
    
  
  PaaS와 IaaS의 차이는 클라우드 서비스 제공자가 관리하는 범위입니다.
    
      PaaS
        
          클라우드 서비스 제공자는 OS 및 미들웨어까지 관리하고, 필수 기능만 사용자에게 제공합니다.
          AWS에서 관리형 서비스로 제공하는 RDS나 DynamoDB, Lambda 등이 여기에 해당합니다.
          유지보수는 AWS가 담당하며 사용자는 AWS에서 제공하는 범위 안에서 자유롭게 기능을 이용할 수 있습니다.
        
      
      IaaS
        
          서버 및 네트워크 기능만 제공하며 설정과 관리는 사용자의 몫입니다.
          AWS의 EC2와 VPC, EBS와 같이 사용자가 자유롭게 설정할 수 있는 서비스가 IaaS에 해당합니다.

        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-14-network-ip.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-14-network-ip.html"><h1 class="title_post">🌐[Network] IP주소(Address)는 네트워크의 번지(주소)</h1></a>
                        <a href="/Backend/Network/2024-08-14-network-ip.html" class="txt_post">
                            🌐[Network] IP주소(Address)는 네트워크의 번지(주소).

  브라우저를 통해 웹 사이트에 접속할 때 우리에게 보이는 웹 페이지는 실제로 어느 주소에 존재하는 ‘웹 사이트를 호스팅하는 서버(웹 서버)’ 에 접속해서 취득한 웹 페이지 정보입니다.
  웹 서버는 데이터 센터에 있을 수도 있고 AWS와 같은 클라우드 서비스에 있을 수도 있습니다.
    
      그리고 웹 서버에 접근하기 위해서는 웹 서버가 그곳에 있다는 특정 정보가 필요합니다.
        
          이것이 IP 주소 입니다.
        
      
    
  
  웹 사이트에 접속할 때는 이 IP 주소를 바탕으로 위치를 특정해 그곳에 있는 웹 서버에 접속합니다.
  웹 서버뿐만 아니라 PC, 스마트폰 등 네트워크와 연결된 모든 장치에는 IP 주소가 할당됩니다.
    
      일반적으로 IPv4가 표준으로 사용됩니다.
        192.168.1.1
        
      
    
  
  (위 예시에서 ‘192’) 1개의 숫자는 0~255까지 256(2⁸)개의 범위를 갖습니다.
  IPv4는 네 개의 숫자가 마침표로 구분된 형식입니다.
  2⁸개의 숫자가 4개 있는 조합이므로 있는 조합이므로 2⁸ˣ⁴=2³²개의 IPv4 주소가 존재합니다.
  IP(v4) 주소는 4개의 숫자를 점으로 구분해 표시합니다.
  IPv4 외에 IPv6도 있습니다.
    
      IPv4는 주소가 2³²(약 43억 개) 존재하는 데 비해 IPv6 주소는 2¹²⁸개(약 340억 개)가 존재합니다.
    
  
  최근 IPv4 주소만으로는 주소를 할당할 수 없을 정도로 서버나 인터넷에 접속하는 기기가 많아져서 대체할 수 있는 IPv6가 주목받고 있습니다.
    
      하지만 IPv6는 아직 보편적으로 보급되지 않았고 기존에 사용하던 기기가 IPv4만 지원하는 경우가 대부분입니다.
    
  


1️⃣ 퍼블릭 IP 주소와 프라이빗 IP 주소.

  IP 주소는 두 가지로 구분할 수 있습니다.
    
      하나는 한국 또는 전 세계에서 ‘이 주소는 인터넷에서 이곳’이라고 특정할 수 있는 주소입니다.
        
          이를 퍼블릭 IP 주소 또는 글로벌 IP 주소라고 합니다.
        
      
    
  
  다른 하나는 프라이빗 IP 주소 입니다.
    
      퍼블릭 IP 주소는 전 세계에서 식별할 수 있는 주소지만, 프라이빗 주소는 닫힌 네트워크(근거리 통신-LAN) 내에서만 식별할 수 있는 IP 주소입니다.
        
          프라이빗 IP 주소로 사용할 수 있는 범위는 다음과 같습니다.
            
              10.0.0.0 ~ 10.255.255.255(10.0.0.0/8)
              172.16.0.0 ~ 172.31.255.255(172.16.0.0/12)
              192.168.0.0 ~ 192.168.255.255(192.168.0.0/16)
                
                  퍼블릭 IP 주소는 이 주소를 제외한 나머지 주소입니다.
                
              
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-08-11-Nginx.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-08-11-Nginx.html"><h1 class="title_post">📝[Post] Nginx 설치방법.</h1></a>
                        <a href="/Backend/Post/2024-08-11-Nginx.html" class="txt_post">
                            🙋‍♂️ Nginx 를 소스에서 직접 컴파일하여 설치하는 방법.

  이 방법은 Homebrew를 사용하지 않고도 Nginx를 설치하는 방법입니다.
  이 방법은 macOS를 기반으로 설치하는 방법을 설명합니다.


1️⃣ 필요한 도구 설치.

  Nginx를 컴파일하려면 Xcode 와 Xcode Command Line Tools 가 필요합니다.
    
      Xcode Command Line Tools 설치.
    
  


xcode-select --install


  프롬프트가 나타나면 설치를 진행합니다.


2️⃣ 소스 코드 다운로드.


  Nginx의 최신 소스 코드를 Nginx 공식 사이트에서 다운로드하거나 wget 명령어를 사용하여 다운로드할 수 있습니다.


curl -O http://nginx.org/download/nginx-1.26.1.tar.gz



  위 명령어에서 nginx-1.26.1 은 설치할 Nginx 버전에 따라 달라질 수 있습니다.
    
      최신 버전을 사용하려면 공식 사이트에서 최신 버전 번호를 확인하세요.
    
  


3️⃣ 소스 코드 압축 해제.

  다운로드한 소스 코드를 압축 해제합니다.


tar -zxvf nginx-1.26.1.tar.gz
cd nginx-1.26.1


4️⃣ Nginx 컴파일 및 설치.

  Nginx를 컴파일하기 위해 몇 가지 옵션을 지정한 후, make 명령어를 사용하여 컴파일하고 설치합니다.


./configure
make
sudo make install



  이 명령어는 기본 설정으로 Nginx를 컴파일하고 /usr/local/nginx 에 설치합니다.
  ./configure 명령어에 다양한 옵션을 추가하여 컴파일 설정을 조정할 수 있습니다.


5️⃣ Nginx 실행.

  컴파일이 완료되면, Nginx를 다음 명령어로 실행할 수 있습니다.


sudo /usr/local/nginx/sbin/nginx



  이제 Nginx가 실행 중일 것입니다.
    
      http://localhost 에 접속하여 Nginx 기본 환영 페이지를 확인할 수 있습니다.
    
  


6️⃣ Nginx 설정 파일

  소스에서 설치한 Nginx의 설정 파일은 /usr/local/nginx/conf/nginx.conf 에 있습니다.
    
      이 파일을 편집하여 설정을 변경할 수 있습니다.
    
  


sudo vi /usr/local/nginx/conf/nginx.conf



  설정을 변경한 후 Nginx를 재시작하여 변경 사항을 적용해야 합니다.


sudo /usr/local/nginx/sbin/nginx -s reload


7️⃣ Nginx 서비스 관리

  Nginx를 시작하고 중지하는 명령어는 다음과 같습니다.
    
      
        
          Nginx 시작.
              sudo /usr/local/nginx/sbin/nginx
            
          
        
      
      
        
          Nginx 중지.
              sudo /usr/local/nginx/sbin/nginx -s stop
            
          
        
      
      
        
          Nginx 재시작.
              sudo /usr/local/nginx/sbin/nginx -s reload
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Network/2024-08-09-network-cidr.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/network.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Network/2024-08-09-network-cidr.html"><h1 class="title_post">🌐[Network] CIDR이란?</h1></a>
                        <a href="/Backend/Network/2024-08-09-network-cidr.html" class="txt_post">
                            🌐[Network] CIDR이란?

  CIDR(Classless Inter-Domain Routing) 은 IP 주소와 관련된 라우팅 방법을 정의하는 표기법입니다.
  CIDR 표기법은 IPv4 주소를 네트워크와 호스트 부분으로 나누고, 네트워크의 크기(서브넷 크기)를 정의하는 데 사용됩니다.
    
      CIDR 표기법은 다음과 같은 형식으로 표현됩니다.
        192.168.0.0/24
        
      
    
  
  이 표기법은 두 부분으로 나뉩니다.
    
      IP 주소 부분 : 192.168.0.0
      서브넷 마스크 부분: /24
        
          여기서 /24 는 서브넷 마스크의 길이를 나타내며, 이는 네트워크 부분의 비트 수를 의미합니다.
            
              즉, 192.168.0.0/24 는 24비트가 네트워크를 정의하고 나머지 8비트(총 32비트 중)가 호스트를 정의하는 서브넷을 나타냅니다.
            
          
        
      
    
  


1️⃣ IPv4 CIDR의 구조.

  IPv4 주소는 32비트로 구성되어 있으며, 이를 네 개의 8비트 옥텟으로 표현합니다.
    
      예를 들어 다음과 같습니다.
        11000000.10101000.00000000.00000000 (이진)
192.168.0.0 (십진)
        
      
    
  
  CIDR 표기법에서 /24 는 첫 번째 24비트(세 개의 옥텟)가 네트워크 주소를 나타낸다는 것을 의미합니다.
    
      이 경우 192.168.0.0 네트워크에는 192.168.0.1 에서 192.168.0.254 까지의 호스트 주소를 가질 수 있습니다.
    
  


2️⃣ IPv4 CIDR의 용도.

  서브네팅 : 큰 네트워크를 작은 서브넷으로 나누기 위해 CIDR을 사용합니다.
  라우팅 : 인터넷 서비스 제공자(ISP) 및 네트워크 관리자는 CIDR을 사용하여 라우팅 테이블을 관리하고, IP 주소 공간을 효율적으로 사용합니다.
  IP 주소 관리 : CIDR은 IP 주소를 할당하고 네트워크를 관리하는 데 사용됩니다.


3️⃣ CIDR 블록의 생성 기준.

  CIDR 블록을 생성할 때는 네트워크 크기와 필요한 IP 주소 수를 고려해야 합니다. 일반적인 기준은 다음과 같습니다.
    
      1. 네트워크 크기 계산 :
        
          /24 서브넷은 256개의 IP 주소(호스트)를 제공합니다. 이 중 두개의 주소(네트워크 주소와 브로드캐스트 주소)를 제외하고, 254개의 호스트 IP 주소를 사용할 수 있습니다.
          /16 서브넷은 65,536개의 IP 주소를 사용할 수 있습니다.
          /32 는 단일 IP 주소를 나타냅니다.
        
      
      2. 필요한 IP 주소 수에 따라 결정 :
        
          만약 50개의 장치를 연결해야 한다면, /26(64개 IP 주소 제공) 서브넷을 사용할 수 있습니다.
          큰 네트워크에는 /16 이나 /12 처럼 더 작은 서브넷 마스크를 사용할 수 있습니다.
        
      
      3. 보안 및 관리 :
        
          더 작은 서브넷(CIDR 블록)을 사용하면 네트워크 트래픽을 보다 효율적으로 관리하고, 보안을 강화할 수 있습니다.
        
      
    
  


4️⃣ 예시.

  /32 : 단일 IP 주소. 예: 192.168.0.1/32
  /24 : 256개의 IP 주소 제공, 주로 작은 네트워크에서 사용. 예: 192.168.0.0/24
  /16 : 65,536개의 IP 주소 제공, 더 큰 네트워크에 사용. 예: 192.168.0.0/16
  /8 : 16,777,216개의 IP 주소 제공, 매우 큰 네트워크에서 사용. 예: 10.0.0.0/8


5️⃣ 결론.

  CIDR 표기법은 IP 주소와 서브넷 마스크를 결합한 표준입니다.
  네트워크의 크기와 IP 주소와 필요 수를 기준으로 CIDR 블록을 생성합니다.
  CIDR을 사용하면 네트워크를 보다 효율적으로 관리하고 라우팅 테이블을 최적화할 수 있습니다.



  🙋‍♂️ CIDR 블록을 설계할 때, 사용하려는 네트워크 규모와 IP 주소 요구 사항을 염두에 두고, 적절한 서브넷 마스크 길이를 선택하는 것이 중요합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240809_AWS_EC2_UPLOAD.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240809_AWS_EC2_UPLOAD.html"><h1 class="title_post">☁️[AWS] 로컬 파일을 EC2 서버에 올리는 방법.</h1></a>
                        <a href="/Backend/AWS/240809_AWS_EC2_UPLOAD.html" class="txt_post">
                            ☁️[AWS] 로컬 파일을 EC2 서버에 올리는 방법.
“저의 상황을 예로 들어 설명하도록 하겠습니다.”


  로컬 macBook에서 Amazon Linux 2023 EC2 서버로 파일을 업로드하는 방법 중 가장 일반적인 방법은 scp(secure copy) 를 사용하는 것 입니다.
    
      이 명령을 통해 안전하게 파일을 복사할 수 있습니다.
    
  



  🙋‍♂️ 아래 설명하는 단계들은 로컬에서 이루어져야 합니다.


1️⃣ EC2 인스턴스 연결 정보 확인.

  먼저 EC2 인스턴스의 퍼블릭 IP 주소와 연결에 사용하는 키 페어 파일(.pem)을 확인합니다.


2️⃣ 로컬 macBook에서 scp 명령어 사용.

  scp 명령어를 사용하여 로컬 파일을 EC2 인스턴스로 업로드합니다.
    
      예를 들어, 로컬 파일 localfile.txt 를 EC2 인스턴스의 /home/ec2-user/ 디렉토리에 업로드하려면 다음과 같이 합니다.
    
  


scp -i /path/to/your-key-pair.pem /path/to/localfile.txt ec2-uesr@&lt;EC2-Instance-Public-IP&gt;:/home/ec2-user/


👉 예제.

  키 페어 파일 경로 : /Users/bingGu/.ssh/my-key-pair.pem
  로컬 파일 경로 : /Users/bingGu/Documents/localfile.txt
  EC2 퍼블릭 IP : 43.201.230.99


/Users/bingGu/Documents/localfile.txt ec2-user@43.201.230.99:/home/ec2-user/


3️⃣ 디렉토리 업로드.

  만약 디렉토리를 업로드 하고 싶다면 -r 옵션을 사용하여 디렉토리를 재귀적으로 업로드할 수 있습니다.
    
      예를 들어, 로컬 디렉토리 localdir 을 EC2 인스턴스의 /home/ec2-user/ 디렉토리에 업로드하려면 다음과 같이 합니다.
    
  


scp -r -i /path/to/your-key-pair.pem /path/to/localdir ec2-user@&lt;EC2-Instance-Public-IP&gt;:/home/ec2-user/


4️⃣ 업로드 확인.

  EC2 인스턴스에 SSH로 접속하여 파일이나 디렉토리가 정상적으로 업로드되었는지 확인합니다.


ssh -i /path/to/your-key-pair.pem ec2-user@&lt;EC2-Instance-Public-IP&gt;
ls /home/ec2-user/


🎯 Troubleshooting

  Permission Denied : 키 파일의 권한이 적절하지 않을 때 발생할 수 있습니다.
    
      다음 명령어로 권한을 조정합니다.
        chmod 400 /path/to/your-key-pair.pem
        
      
    
  
  Host Key Verification Failed : 로컬 머신의 SSH 설정에서 이전에 연결한 적 없는 서버에 대해 경고가 뜨는 경우, 다음 명령어로 knows_hosts 파일을 업데이트할 수 있습니다.
    ssh-keygen -R &lt;EC2-Instance-Public-IP&gt;
    
  



  🙋‍♂️ 이 단계를 따르면 로컬 macBook에서 Amazon Linux 2023 EC2 인스턴스로 파일을 성골적으로 업로드할 수 있을 것입니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-08-07-webpage.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-08-07-webpage.html"><h1 class="title_post">📝[Post] 정적 웹사이트와 동적 웹사이트.</h1></a>
                        <a href="/Backend/Post/2024-08-07-webpage.html" class="txt_post">
                            🙋‍♂️ 정적 웹사이트와 동적 웹사이트.

  정적 웹사이트와 동적 웹사이트는 웹페이지를 생성하고 제공하는 방식에서 큰 차이를 보입니다.
  각각의 특징을 이해하면 어떤 상황에서 어떤 타입의 웹사이트를 사용해야 하는지 결정하는 데 도움이 됩니다.


1️⃣ 정적 웹사이트.

  정적 웹사이트는 미리 만들어진 HTML 파일들을 그대로 웹 서버에서 사용자의 브라우저로 전송하여 보여주는 웹사이트입니다.
    
      이 파일들은 서버에 미리 저장되어 있으며, 사용자의 요청에 따라 변하지 않고 그대로 제공됩니다.
    
  


👍 정적 웹사이트의 장점.

  단순성과 속도.
    
      복잡한 서버 측 처리 없이 바로 파일을 전송하기 때문에 로딩 시간이 빠릅니다.
    
  
  호스팅 비용.
    
      낮은 서버 자원 사용으로 인해 비용이 저렴합니다.
    
  
  보안.
    
      동적 콘텐츠를 처리하는 서버 측 스크립트가 없어 보안 리스크가 상대적으로 낮습니다.
    
  


👎 정적 웹사이트의 단점.

  유연성 부족.
    
      각 페이지를 수동으로 업데이트해야 하며, 대규모 사이트에서는 유지 관리가 어려울 수 있습니다.
    
  
  사용자 상호작용 부족.
    
      사용자 입력에 따라 내용이 바뀌지 않으므로, 폼 제출이나 검색과 같은 기능을 직접 구현하기 어렵습니다.
    
  


2️⃣ 정적 웹사이트의 예시.

  1. 포트폴리오 웹사이트.
    
      웹 개발자, 디자이너, 사진작가 등의 포트폴리오를 위한 웹사이트들은 주로 정적입니다.
      이 웹사이트들은 작품을 보여주는 갤러리, 연락처 정보, 이력서 등의 고정된 내용을 포함합니다.
    
  
  2. 기업 정보 페이지.
    
      소규모 기업이나 스타트업이 회사 정보, 제품 설명, 연락처 정보 등을 제공하는 단순한 웹사이트를 운영할 때, 이는 종종 정적 웹사이트로 구성됩니다.
    
  
  3. 이벤트 안내 페이지.
    
      특정 이벤트의 일시, 장소, 등록 방법 등을 안내하는 웹페이지로, 주로 내용의 변경이 적고, 정보의 전달이 주 목적일 때 정적 웹사이트로 구현됩니다.
    
  


3️⃣ 동적 웹사이트.

  동적 웹사이트는 서버 측 프로그래밍 언어를 사용하여 사용자의 요청에 따라 실시간으로 웹페이지를 생성하고 제공합니다.
  데이터베이스와의 상호작용을 통해 컨텐츠를 동적으로 생성하고 사용자의 요청에 맞춰 개별적으로 내용을 조정할 수 있습니다.


👍 동적 웹사이트의 장점.

  유연성.
    
      사용자의 입력이나 상호작용에 따라 내용을 쉽게 변경할 수 있습니다.
    
  
  기능성.
    
      데이터베이스에 정보를 저장하고 검색하는 등의 복잡한 기능을 구현할 수 있습니다.
    
  
  개인화.
    
      사용자의 선호나 행동에 따라 개인화된 경험을 제공할 수 있습니다.
    
  


👎 동적 웹사이트의 단점.

  비용과 복잡성.
    
      서버 측 처리를 위한 추가적인 자원이 필요하며, 구현과 유지 관리가 복잡해질 수 있습니다.
    
  
  보안 위험.
    
      데이터베이스와 서버 측 스크립트를 사용함으로써 보안 취약점이 발생할 수 있습니다.
    
  
  속도.
    
      페이지를 실시간으로 생성하므로 처리 시간이 길어질 수 있습니다.
    
  


4️⃣ 동적 웹사이트의 예시.

  1. 전자 상거래 플랫폼.
    
      Amazon, eBay 등의 쇼핑 웹사이트는 사용자의 검색, 구매 이력, 상품의 재고 상태 등에 따라 실시간으로 정보를 업데이트하고 표시해야 합니다.
        
          이런 기능은 동적 웹사이트 기술을 필요로 합니다.
        
      
    
  
  2. 소셜 네트워킹 서비스.
    
      Facebook, Twitter와 같은 소셜 미디어 플랫폼은 사용자의 상호 작용에 기반하여 내용이 계속 업데이트 되며, 이러한 동적 상호 작용을 지원합니다.
    
  
  3. 온라인 교육 플랫폼.
    
      Coursera, Udemy, Inflearn와 같은 교육 플랫폼은 사용자가 선택한 강좌에 따라 개인화된 학습 내용을 제공하고, 퀴즈 점수를 기록하며, 진행 상태를 추적합니다.
    
  


🙋‍♂️ 마무리

  정적 웹사이트와 동적 웹사이트 선택은 프로젝트의 요구 사항, 예산, 기대하는 사용자 경험 등에 따라 달라집니다.
    
      간단한 정보 제공 사이트의 경우 정적 웹사이트가 적합할 수 있고, 사용자 상호작용과 데이터 처리가 중요하 서비스는 동적 웹사이트가 더 적합할 수 있습니다.
    
  
  이러한 예시들을 통해 정적 웹사이트가 주로 고정된 내용을 제공하는 반면, 동적 웹사이트는 사용자의 입력과 상호작용에 따라 콘텐츠가 변경되는 복잡한 기능을 필요로 함을 알 수 있습니다.
    
      각각의 사례에서 요구하는 기능과 특성에 맞춰 웹사이트의 형태를 결정합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240807_AWS_ON-PREMISE.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240807_AWS_ON-PREMISE.html"><h1 class="title_post">☁️[AWS] 온프레미스(on-premise)란?</h1></a>
                        <a href="/Backend/AWS/240807_AWS_ON-PREMISE.html" class="txt_post">
                            ☁️[AWS] 온프레미스(on-premise)란?


  온프레미스(on-premise)란 사용자가 관리하는 시설 내에 서버 등의 기기를 설치해 운용하는 환경입니다.
  AWS와 같은 클라우드 서비스가 등장하기 전까지는 정보 시스템을 구축하기 위해 다음 그림과 같이 자체적으로 관련 기기를 준비하고 설정해야 했습니다.
  이런 기기를 설치하고 운용하는 시설을 일반적으로 데이터 센터(Data Center) 라고 합니다.





  구매, 물리적 설치, 케이블 배선, 네트워크의 설정이 필요하지만 이러한 작업은 전문 업체에 위탁할 수 있습니다.
    
      결과적으로 기기 구매비, 작업에 필요한 인건비 같은 초기 투자 비용이 커지고 설치나 설정에도 시간이 걸리므로 정보 시스템을 구축하기 위한 준비 기간이 길어집니다.
        
          그 대신 기기는 사용자가 자유롭게 이용할 수 있고 이용 형태에 맞게 자유롭게 구성할 수 있습니다.
          초기 투자 비용은 많이 들지만, 이후에 들어가는 비용은 전기 요금과 인터넷 회선 이용 요금 정도이므로 전체 비용에서 운용 비용의 비율이 비교적 낮습니다.
            
              그러나 기기 고장 등 예측하지 못한 상황이 발생해 추가 비용이 발생하는 때도 있습니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240807_AWS_CLOUD.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240807_AWS_CLOUD.html"><h1 class="title_post">☁️[AWS] 클라우드(Cloud)란?</h1></a>
                        <a href="/Backend/AWS/240807_AWS_CLOUD.html" class="txt_post">
                            ☁️[AWS] 클라우드(Cloud)란?


  클라우드(Cloud) 는 클라우드 서비스 제공자가 서버 등의 기기를 준비하고 거기에 구축된 가상 서버나 응용 프로그램 등을 사용자에게 제공하여 이용료를 받는 형태입니다.
  물리적인 기기나 네트워크는 서비스 제공자가 준비해 놨으므로 사용자는 바로 정보 시스템을 구축할 수 있습니다.
  클라우드의 정식 명칭은 클라우드 컴퓨팅(cloud computing) 입니다.
  클라우드의 어원은 단어 뜻 그대로 구름입니다.
    
      보이지 않는 컴퓨팅 자원을 활용한다는 것에서 유래했습니다.
        
          이 말을 풀어 써보면 ‘사용자에게는 보이지 않지만 중앙의 서버 컴퓨팅 자원을 활용해 서비스를 받을 수 있게 하는 플랫폼’ 입니다.
        
      
    
  





  서비스 제공자는 서버나 응용 프로그램을 제공할 뿐만 아니라 내부의 모든 하드웨어를 관리하므로 사용자는 하드웨어 장애에 대해 신경 쓰지 않아도 됩니다.
    
      하지만 사용자는 제공되는 서비스 범위 내에서만 시스템을 이용할 수 있으므로 시스템 구성 자유도는 낮습니다.
      그리고 매원 각종 서비스 사용료를 지불해야 하므로 전체 비용이 커질 수 있습니다.
        
          하지만 기기 노후화나 고장 걱정 없이 안정적으로 컴퓨팅 자원을 사용할 수 있다는 장점이 있습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240804_AWS_JAVA8_INSTALL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240804_AWS_JAVA8_INSTALL.html"><h1 class="title_post">☁️[AWS] Amazon Linux 2에 Java8 설치하는 방법.</h1></a>
                        <a href="/Backend/AWS/240804_AWS_JAVA8_INSTALL.html" class="txt_post">
                            1️⃣ EC2 인스턴스에 로그인.

  SSH를 통해 EC2 인스턴스에 로그인 합니다.
    ssh -i "your-key.pem" ec2-user@your-instance-ip
// 또는
ssh "config에 등록한 서비스명" 
    
  


2️⃣ 업데이트 및 패키지 매니저 설치 확인.

  인스턴스의 패키지 리스트를 업데이트하고 , yum 패키지 매니저가 최신 상태인지 확인합니다.
    sudo yum update -y
    
  


3️⃣ OpenJDK 8 설치.

  OpenJDK 8은 Amazon Linux 2의 기본 레포지토리에서 사용할 수 있습니다.
    
      다음 명령어를 사용하여 설치할 수 있습니다.
        sudo yum install -y java-1.8.0-openjdk
        
      
    
  


4️⃣ 설치된 Java 버전 확인.

  설치가 성공적으로 완료되었는지 확인하기 위해 Java 버전을 확인합니다.
    java -version
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/DB/2024-08-01-Transaction.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/DB/2024-08-01-Transaction.html"><h1 class="title_post">💾[Database] 트랜잭션의 의미와 역할.</h1></a>
                        <a href="/Backend/DB/2024-08-01-Transaction.html" class="txt_post">
                            💾[Database] 트랜잭션의 의미와 역할.

  트랜잭션은 데이터베이스 관리 시스템(DBMS)에서 데이터의 일관성과 정확성을 유지하기 위해 사용되는 기본 단위입니다.
  데이터베이스에서 수행하는 작업들을 안전하게 실행하여, 여러 작업이 모두 성공하거나 모두 실패하도록 보장하는 역할을 합니다.


1️⃣ 트랜잭션의 주요 특징(ACID).


  1. 원자성(Atomicity)
    
      트랜잭션 내의 모든 연산은 원자적으로 처리됩니다. 즉, 연산들은 모두 완벽하게 수행되거나 아예 수행되지 않아야 합니다.
      트랜잭션 중 하나라도 실패하면 전체 트랜잭션은 롤백(취소)되어 원래 상태로 복구됩니다.
    
  
  2. 일관성(Consistency)
    
      트랜잭션이 실행되지 전과 후에 데이터베이스의 상태는 일관된 상태를 유지해야 합니다.
      트랜잭션은 데이터베이스의 일관된 상태를 받아 변경 후에도 그 일관성을 유지하는 변경만을 수행해야 합니다.
        
          이는 데이터의 무결성 제약 조건들을 준수함을 의미합니다.
        
      
    
  
  3. 독립성(Isolation)
    
      동시에 여러 트랜잭션이 실행될 때, 각 트랜잭션이 다른 트랜잭션의 연산에 영향을 받지 않아야 합니다. 이를 통해 데이터베이스의 안정성을 보장합니다.
      DBMS는 이러한 독립성을 보장하기 위해 다양한 격리 수준(Isolation Level)을 제공합니다.
    
  
  4. 지속성(Durability)
    
      트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 데이터베이스에 반영도어야 합니다.
      시스템 장애가 발생해도 이러한 트랜잭션 결과는 손실되지 않습니다.
    
  


2️⃣ 트랜잭션의 역할.


  데이터 무결성 유지
    
      트랜잭션은 데이터의 정확성과 일관성을 유지하며 데이터베이스 시스템의 신뢰성을 보장합니다.
    
  
  시스템 장애 대응
    
      시스템 오류나 장애 발생 시, 트랜잭션은 롤백을 통해 데이터베이스를 안정적인 상태로 복구할 수 있게 돕습니다.
    
  
  동시성 제어
    
      다수의 사용자가 데이터베이스에 동시에 접근할 때, 트랜잭션은 각각의 사용자가 데이터를 안전하게 읽고, 쓸 수 있도록 관리합니다.
    
  




트랜잭션은 데이터베이스 시스템에서 꼭 필요한 기능으로, 데이터의 일관성과 안정성을 보장하는 중요한 메커니즘 입니다. 이를 통해 사용자는 데이터베이스의 신뢰성 있는 동작을 기대할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-07-28-ipAndport.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-07-28-ipAndport.html"><h1 class="title_post">📝[Post] 아이피와 포트</h1></a>
                        <a href="/Backend/Post/2024-07-28-ipAndport.html" class="txt_post">
                            🙋‍♂️ 아이피와 포트

1️⃣ 아이피(IP)

  인터넷에서 컴퓨터 또는 기기들이 서로를 식별하고 통신하기 위한 주소입니다.
    
      그래서 아이피를 알면 서버를 찾을 수 있습니다.
        
          하지만 서버를 이용하려면 아이피만 알아서는 안 됩니다. 포트까지 알아야 합니다.
        
      
    
  


2️⃣ 포트(Port)

  아이피가 서버를 찾기 위한 번호라면 포트는 그 서버에서 운용되고 있는 서비스를 구분하기 위한 번호입니다.
    
      쉽게 말해서 아이피가 백화점이라면 포트는 각자 다른 물건을 살 수 있는 매장이라고 생각하면 됩니다.
    
  


3️⃣ 예시

  예를 들어 우리가 흔히 사용하는 웹 브라우저에 주소에는 사실 아이피와 포트가 들어 있습니다.
    
      www.google.com과 같은 주소는 아이피트를 쉽게 알아보기 위해 이름표를 붙인 것입니다.
      그 앞에 있는 https:// 라는 것은 서버의 443번 포트를 사용하기 위한 입력입니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/DB/2024-07-26-korean-mysql.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/DB/2024-07-26-korean-mysql.html"><h1 class="title_post">💾[Database] MySQL DB에 한글 삽입.</h1></a>
                        <a href="/Backend/DB/2024-07-26-korean-mysql.html" class="txt_post">
                            💾[Database] MySQL DB에 한글 삽입.


  한글을 MySQL 데이터베이스에 삽입하려고 할 때 발생하는 오류는 주로 데이터베이스, 테이블 또는 열의 문자 세트와 관련 있습니다.
    
      이 문제를 해결하기 위해서는 데이터베이스와 테이블의 문자 세트를 UTF-8로 설정해야 합니다.
    
  


🙋‍♂️ 데이터베이스와 테이블의 문자 세트를 UTF-8로 설정하는 방법.

1️⃣ 데이터베이스 생성 시 문자 세트 설정.

CREATE DATABASE {데이터베이스 이름} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


2️⃣ 기존 데이터베이스의 문자 세트 변경.

ALTER DATABASE {데이터베이스 이름} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


3️⃣ 테이블 생성 시 문자 세트 설정.

CREATE TABLE test (
    id INT AUTO_INCREMENT PRIMARY KEY,
    content TEXT
) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


4️⃣ 기존 테이블의 문자 세트 변경.

ALTER TABLE test CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


5️⃣ 각 열의 문자 세트 확인 및 변경.

ALTER TABLE test MODIFY content TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;


6️⃣ MySQL 서버의 기본 문자 세트를 변경.

  my.cnf(또는 my.ini) 파일을 수정하여 기본 문자 세트를 utf8mb4로 설정합니다.
    
      보통 이 파일은 /etc/my.cnf 또는 /etc/mysql/my.cnf 에 위치해 있습니다.
    
  
  my.cnf 파일에 다음 내용을 추가합니다.
```ini
[client]
default-character-set = utf8mb4


[mysql]
default-character-set = utf8mb4

[mysqld]
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci

### 7️⃣ MySQL 서버 재시작.
```shell
sudo systemctl restart mysqld



  이제 한글을 포함한 데이터를 데이터베이스에 삽입할 수 있을 것입니다.
    
      예를 들어, 한글 데이터를 삽입하려면:
        INSERT INTO test (content) VALUES ('테스트 데이터');
        
      
    
  
  이 방법으로 UTF-8 설정을 적용하면 한글 데이터를 MySQL 데이터베이스에 문제 없이 저장할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240726_AWS_JAVA_INSTALL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240726_AWS_JAVA_INSTALL.html"><h1 class="title_post">☁️[AWS] Amazon Linux 2023에 Java8 설치하는 방법.</h1></a>
                        <a href="/Backend/AWS/240726_AWS_JAVA_INSTALL.html" class="txt_post">
                            1️⃣ 시스템 패키지 업데이트

  먼저 시스템 패키지를 업데이트 합니다.


sudo dnf update -y


2️⃣ Amazon Corretto 8 저장소 추가.

  Amazon Corretto는 Amazon에서 제공하는 무료, 멀티플랫폼, 생산성 사용 준비가 된 OpenJDK 배포판입니다.
    
      Correttio 8은 Java 8과 호환됩니다.
    
  


sudo dnf install -y java-1.8.0-amazon-corretto


3️⃣ Java 8 설치 확인

  Java 8이 설치되었는지 확인하려면 다음 명령어를 사용합니다.


java -version



  이 명령어를 실행하면 Java 버전 정보가 출력됩니다. openjdk version "1.8.0_xxx" 와 같이 Java 8이 설치된 것을 확인할 수 있습니다.


4️⃣ 기본 Java 버전 설정


  시스템에 여러 버전의 Java가 설치되어 있을 수 있습니다.
    
      기본으로 사용할 Java 버전을 설정하려면 alternatives 명령어를 사용합니다.
    
  
  먼저 현재 사용 가능한 Java 버전을 확인합니다.


sudo alternatives --config java


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/database.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html"><h1 class="title_post">💾[Database] 데이터베이스의 정의와 특징.</h1></a>
                        <a href="/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html" class="txt_post">
                            💾[Database] 데이터베이스의 정의와 특징.

1️⃣ 데이터베이스 : 여러 사용자나 응용 프로그램이 공유하고 동시에 접근 가능한 ‘데이터의 집합’ 이라고 정의할 수 있습니다.

2️⃣ DBMS(DataBase Management System) : ‘데이터베이스’를 ‘관리,운영하는 소프트웨어’ 입니다.


  🙋‍♂️ 데이터베이스
  
    ‘데이터 저장 공간’ 자체를 의미하기도 합니다.

    DBMS 중 하나인 MySQL에서는 ‘데이터베이스’를 ‘자료가 저장되는 디스크 공간(주로 파일로 구성됨)’으로 취급합니다.
  




위 그림은 데이터베이스, DBMS, 사용자, 응용 프로그램의 관계를 보여줍니다.

위 그림에서 보듯이 DBMS는 데이터베이스를 관리하는 역할을 하는 소프트웨어입니다.

여러 사용자나 응용 프로그램은 DBMS가 관리하는 데이터에 동시에 접속하여 데이터를 공유합니다.

👉 즉, DBMS에서는 데이터베이스에서 사용되는 데이터가 집중 관리됩니다.


  🙋‍♂️ 데이터베이스와 DBMS
  
    데이터베이스를 DBMS와 혼용해서 같은 용어처럼 사용하는 경우도 흔히 있습니다.
바라보는 시각에 따라 그렇게 사용하는 것이 틀린 것은 아니지만
저는 데이터베이스를 ‘데이터의 집합’ 또는 ‘데이터의 저장 공간’으로 보고,
DBMS는 데이터베이스를 운영하는 ‘소프트웨어’라는 의미로 공부하겠습니다.
  


DBMS에는 MySQL 외에도 많은 종류의 프로그램이 있습니다.

  MySQL
  MariaDB
  PostgreSQL
  Oracle
  SQL Server
  DB2
  Access
  SQLite
  …



  🙋‍♂️ 위 명시된 리스트는 2018년 기준 많이 사용되는 DBMS입니다.


3️⃣ DBMS 또는 데이터베이스의 몇 가지 중요한 특징.


  👉 데이터 무결성
    
      데이터베이스 안의 데이터는 어떤 경로를 통해 들어왔든 오류가 있어서는 안 되는데 이를 무결성(Integrity)이라고 합니다.
      무결성을 지키기 위해 데이터베이스는 제약 조건(constraint)을 따릅니다.
        
          예를 들어 학생 데이터에서 모든 학생은 학번이 반드시 있어야 하고 학번이 중복되면 안 된다는 제약 조건을 생각해봅시다.
          이 제약 조건을 충실히 지킨다면 학번으로도 학번으로도 학생 데이터에서 학생을 정확히 찾을 수 있습니다.
            
              즉, 학번은 무결한 데이터를 보장하는 요소이며, 자동 발급기로 성적 증명서나 재학 증명서를 뗄 떼 학번만 조회해도 정확한 자료를 줄력할 수 있습니다.
            
          
        
      
    
  
  👉 데이터의 독립성
    
      데이터베이스의 크기를 변경하거나 데이터 파일의 저장소를 변경하더라도 기존에 작성된 응용 프로그램은 전혀 영향을 받지 않습니다.
        
          즉 데이터베이스와 응용 프로그램은 서로 의존적인 관계가 아니라 독립적인 관계입니다.
            
              예를 들어 데이터베이스가 저장된 디스크가 새것으로 변경되어도 기존에 사용하던 응용 프로그램은 아무런 변경 없이 계속 사용할 수 있습니다.
            
          
        
      
    
  
  👉 보안
    
      데이터베이스 안에 데이터는 아무나 접근할 수 있는 것이 아니라 데이터를 소유한 사람이나 데이터에 접근이 허가된 사람만 접근할 수 있습니다.
      또한, 같은 데이터에 접근할 때도 사용자의 계정에 따라서 각각 다른 권한을 갖습니다.
      최근 들어 고객 정보 유출 사고가 빈번하여 보안(Security)은 데이터베이스에서 더욱 중요한 이슈가 되고 있습니다.
    
  
  👉 데이터 중복 최소화
    
      데이터베이스에서는 동일한 데이터가 여러 군데 중복 저장되는 것을 방지합니다.
        
          학교를 예로 들면, 학생 정보를 이용하는 교직원들(학생처, 교무처, 과사무실 등)이 각 직원마다 별도의 엑셀 파일로 학생 정보를 관리하면 한 명의 학생 정보가 각각의 엑셀 파일에 중복 저장됩니다.
          그러나 데이터베이스에 통합하여 관리하면 하나의 테이블에 데이터를 저장한 후 응용 프로그램마다 이를 공유하여 사용할 수 있어 데이터의 중복을 최소화할 수 있습니다.
        
      
    
  
  👉 응용 프로그램 제작 및 수정 용이
    
      기존 파일 시스템에서는 각각의 파일 포맷에 맞춰 응용 프로그램을 개발했습니다.
      그러나 데이터베이스를 이용하면 통일된 방식으로 응용 프로그램을 작성할 수 있고 유지,보수 또한 쉽습니다.
    
  
  👉 데이터의 안전성 향상
    
      대부분의 DBMS는 데이터의 백업/복원 기능을 제공합니다.
      따라서 데이터가 손상되는 문제가 발생하더라도 원래의 상태로 복원 또는 복구할 수 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-15</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240714_AWS_GRADLEW.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240714_AWS_GRADLEW.html"><h1 class="title_post">☁️[AWS] .gradlew 빌드 실패시 확인해야 할 것들</h1></a>
                        <a href="/Backend/AWS/240714_AWS_GRADLEW.html" class="txt_post">
                            1️⃣ Amazon Corretto JDK 8이 올바르게 설치되었는지 확인하기.

$ls -l /usr/lib/jvm/ava-1.8.0-amazon-corretto.x86_64


위 명령어를 통해 내부를 들여다보니 디렉토리 안에는 jre 디렉토리만 있고, JDK 디렉토리 구조가 포함되어 있지 않아서 JAVA_HOME 으로 설정할 수 없는 오류가 발생했었습니다.

이는 java-1.8.0-amazon-corretto-devel 패키지가 올바르게 설치되지 않았음을 의미할 수 있습니다.

🙋‍♂️ Amazon Corretto JDK 8 설치 및 확인.

먼저, Amazon Corretto JDK 8이 올바르게 설치되었는지 확인하고, 제대로 설치되지 않았다면 다시 설치합니다.


  기존 JDK 제거(필요시)
    sudo dnf remove -y java-1.8.0-amazon-corretto java-1.8.0-amazon-corretto-devel
    
  
  Amazon Corretto JDK 8 설치
    sudo dnf install -y java-1.8.0-amazon-corretto-devel
    
  
  설치된 디렉토리 확인.
    ls -l /usr/lib/jvm/
    
  
  JDK 디렉토리 구조 확인.
    
      JDK 디렉토리 구조가 포함되어 있는지 확인합니다.
        ls -l /usr/lib/jvm/java-1.8.0-amazon-corretto.x86_64/
        
      
    
  


🙋‍♂️ 올바른 JAVA_HOME 설정 및 빌드

  JAVA_HOME 및 PATH 설정
    export JAVA_HOME=/usr/lib/jvm/java-1.8.0-amazon-corretto.x86_64
export PATH=$JAVA_HOME/bin:$PATH
    
  
  설정확인
    echo $JAVA_HOME
java -version
javac -version
    
  
  Gradl 빌드 실행
    ./gradlew clean
./gradlew build
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-07-11-SpringAndSpringBoot.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-07-11-SpringAndSpringBoot.html"><h1 class="title_post">📝[Post] Spring과 SpringBoot의 개념.</h1></a>
                        <a href="/Backend/Post/2024-07-11-SpringAndSpringBoot.html" class="txt_post">
                            



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240710_AWS_MYSQL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240710_AWS_MYSQL.html"><h1 class="title_post">☁️[AWS] Amazon Linux 2023 플랫폼에 MySQL 설치하는 방법.</h1></a>
                        <a href="/Backend/AWS/240710_AWS_MYSQL.html" class="txt_post">
                            Amazon Linux 2023 플랫폼에 MySQL이 기본적으로 설정되어 있지 않습니다.

그러므로 따로 설치해줘야 합니다.

기본적인 방법은 아래와 같습니다.

1️⃣ RPM 파일 다운로드.
sudo wget https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm


위 명령어를 사용하여 RPM 파일을 다운로드 받아줍니다.


  🙋‍♂️ 모든 파일의 설정은 ec2 cli에서 설정해야 합니다.


2️⃣ GPC 퍼블릭 키 설정
sudo dnf install mysql80-community-release-el9-1.noarch.rpm -y


mysql 설치를 위해 퍼블릭 키를 import하는 과정입니다.

sudo dnf update -y


3️⃣ MySQL 설치.

이 부분은 mysql-client와 mysql-server로 나뉩니다.

먼저 mysql-client 설치부터 합니다.

1️⃣ mysql-client 설치.
sudo dnf install mysql-community-client -y


이후에 mysql-server를 설치합니다.

2️⃣ mysql-server 설치.
sudo dnf install mysql-community-server -y


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240709_AWS_HOSTNAME.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240709_AWS_HOSTNAME.html"><h1 class="title_post">☁️[AWS] HOSTNAME 바꾸는 방법</h1></a>
                        <a href="/Backend/AWS/240709_AWS_HOSTNAME.html" class="txt_post">
                            EC2 인스턴스의 호스트 이름을 바꾸는 방법.

🙋‍♂️ 모든 과정은 EC2에 접속 후에 이루어집니다.

1️⃣ 호스트 이름 설정.
hostnamectl 명령어를 사용하여 호스트 이름을 설정합니다.

sudo hostnamectl set-hostname {my-new-hostname}


2️⃣ /etc/sysconfig/network 파일 수정.
/etc/sysconfig/network 파일에 새로운 호스트 이름을 추가합니다.

sudo vi /etc/sysconfig/network


HOSTNAME 항목을 추가하거나 수정합니다.

NETWORKING=yes
HOSTNAME={my-new-hostname}


3️⃣ /etc/hosts 파일 수정.
/etc/hosts 파일을 열어 호스트 이름을 추가합니다.

sudo vi /etc/hosts


파일 내용은 다음과 같이 수정합니다.

127.0.0.1 localhost localhost.localdomain
::1       localhost localhost.localdomain
127.0.0.1 {my-new-hostname}


4️⃣ 즉시 호스트 이름 변경.
호스트 이름을 즉시 적용합니다.

sudo hostname {my-new-hostname}


5️⃣ 셸 프롬프트 구성.
셸 프롬프트에 새로운 호스트 이름이 표시되도록 .bashrc 파일을 수정합니다.

vi ~/.bashrc


다음 줄을 추가하거나 수정합니다.

PS1='[\u@\h \W]\$ '


변경 사항을 적용합니다.

source ~/.bashrc


6️⃣ 인스턴스 재부팅

위의 모든 단계를 수행한 후 인스턴스를 재부팅합니다.

sudo reboot


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-06-27-ServerAndClient-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-06-27-ServerAndClient-1.html"><h1 class="title_post">📝[Post] 서버와 클라이언트의 개념(1)</h1></a>
                        <a href="/Backend/Post/2024-06-27-ServerAndClient-1.html" class="txt_post">
                            🙋‍♂️ Preview

이번 포스트에서는 컴퓨터 과학에서 말하는 서버와 클라이언트의 개념을 크게 세 가지로 나눠 살펴보겠습니다.

  이것은 이해를 돕기 위한 분류로, 서버와 클라이언트라는 개념에 익숙해지고 난 후에 다시 보면 왜 이렇게 나누었는지 이해가 될 것 입니다.


1️⃣ 네트워크에서의 서버와 클라이언트.


  서버(Server) : “서비스를 제공하는 쪽”
  클라이언트(Client) : “서비스를 제공받는 쪽”





  그림에서 서버는 실제 존재하는 물리적인 고성능 컴퓨터이고, 클라이언트는 데스크톱이나 노트북, 스마트폰 등과 같은 사용자들의 단말기를 나타냅니다.
    
      즉, 물리적 장치와 또 다른 물리적 장치 사이의 관계를 의미합니다.
        
          이렇게 물리적인 장치 간에 서로 통신이 이루어지기 위해서는 “통신을 시작하는 쪽”이 “상대방의 네트워크 주소인 IP 주소를 알고 있어야 합니다.”
            
              “클라이언트가 서버의 IP주소를 알고있어야 서버와 클라이언트로서의 관계를 맺을 수 있습니다.”
            
          
        
      
    
  


1️⃣ 트래픽(Traffic) 처리 방법.

우리가 컴퓨터나 스마트폰으로 이용하는 서비스들은 수백만 명 이상의 사용자가 동시에 사용하고 있는 경우가 대부분입니다.
그렇다면 이러한 서비스를 운영하는 서버가 모두 고성능일까요? 🤔

당연히 그렇지 않습니다 ❌

한꺼번에 수백만 명 이상의 사용자로부터 생기는 “트래픽(Traffic)”을 처리하기 위한 방법은 여러가지가 있습니다.

여기서는 가장 범용적이고 직관적인 방법 두 가지, “로드 밸런싱” 과 “캐시”에 대해 간단히 설명하겠습니다.

1️⃣ 로드 밸런싱(Load Balancing).


  “로드 밸런싱(Load Balancing)” : 부하 분산.
    
      즉, 서버에 가해지는 부하(Load)를 분산하는 것입니다.
        
          사용자들의 트래픽을 여러 서버가 나눠 받도록 구성하며, 일반적으로 네트워크 장비인 “스위치(Switch)” 를 할당해 “로드 밸런싱”할 수 있습니다.
            
              스위치에서 어떤 서버로 로드 밸런싱이 되도록 할지는 소프트웨어적으로 제어할 수 있습니다.
            
          
        
      
    
  





  “로드 밸런싱” 은 “스위치” 라는 장비가 “클라이언트의 트래픽을 먼저 받아” 서 여러 대의 서버로 “분산” 해 주는 방식입니다.
    
      이렇게 하면 부하가 분산되는 효과 외에도 스위치 뒤에 연결된 서버들을 필요에 따라 추가하거나 삭제할 수 있어 편리합니다.
    
  


2️⃣ 캐시(Cache).


  “캐시(Cache)” : 비용이 큰 작업의 결과를 어딘가에 저장하여 비용이 작은 작업으로 동일한 효과를 내는 것.
    
      캐시를 이용하면 매번 요청이 들어올 때마다 비용이 큰 작업을 다시 수행할 필요 없이 미리 저장된 결과로 응답하면 됩니다.
        
          물론 이렇게 하면 가장 최신의 데이터는 아닐 수 있지만, 성능을 극대화시키고자 하는 캐시의 목적을 생각해 데이터의 실시간성을 조금 포기해도 되는 경우가 많습니다.
        
      
    
  



  ✏️ Example
  
    음원 서비스

    데이터베이스에 저장된 수많은 음원의 다운로드 수, 스트리밍 수, 추천 수 등으로 인기 점수를 계산하려 100갸의 곡을 오름차순 순위로 제공합니다.

    만약 사용자가 한 번 음원을 조회할 때마다 모든 음원의 인기 점수를 계산해 순위를 매긴다면 아마 사용자가 수백 명만 되어도 서버 부하로 응답 시간이 매우 느려질 것입니다.

    이렇게 수많은 음원의 인기 점수를 매번 계산하여 순위를 매기는 작업이 바로 ‘비용이 큰 작업’ 입니다.

    

    매시 정각마다 TOP 100을 계산한 결과를 저장했다가 사용자의 요청이 들어왔을 때 응답해주면 ‘비용이 작은 작업’으로 대체할 수 있습니다.

    사용자는 16시 30분에 16시에 저장된 TOP 100 결과로도 큰 불편함을 느끼지 않습니다.

    이렇게 사용자가 캐시된 과거의 데이터를 보더라도 서비스 시용에 지장이 없다면 캐시 사용을 충분히 고려할 만합니다.

    
  



  “캐시” 는 다양한 상황에서 비슷한 뜻으로 사용되지만, 공통적으로, ‘비용이 큰 작업을 비용이 작은 작업으로 대신하는 것’이라고 정리할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/ENG/240621-ENG-STUDY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ENG.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/ENG/240621-ENG-STUDY.html"><h1 class="title_post">📚[ENG][240621] 제목만 해석하는 영어 공부 :)</h1></a>
                        <a href="/Backend/ENG/240621-ENG-STUDY.html" class="txt_post">
                            1️⃣ Why You Should Stop Using @Value Annotations In Spring (And Use This Instead)

  🙋‍♂️ 해석: “Spring에서 @Value 어노테이션(주석)을 사용을 중단하고 (대신 이를 사용해야 하는 이유)”
  📝Reference


2️⃣ Be part of a better internet

  🙋‍♂️ 해석: “더 나은 인터넷의 일원이 되세요.”
    
      Be part of : “일원이 되다” 또는 “참여하다” 라는 뜻을 가지고 있습니다. 어떤 단체나 활동, 또는 상황에 참여하거나 속하는 것을 의미합니다.
        
          예를 들어 “Be part of team”은 “팀의 일원이 되다”라는 뜻이 됩니다.
        
      
    
  
  📝Reference


3️⃣ Unpacking the “Day Job”

  🙋‍♂️ 해석: "’본업’을 해부하기”
    
      “Unpacking” : 문자 그대로는 “짐을 풀다”라는 뜻이지만, 비유적으로는 어떤 주제나 개념을 자세히 분석하거나 설명하는 것을 의미합니다.
        
          예를 들어, “Unpacking the ‘Day Job’“은 “본업에 대해 자세히 분석하기” 또는 “본업을 해부하기”라는 의미로 이해할 수 있습니다.
        
      
    
  
  📝Reference


4️⃣ 10 Cheap Desk Upgrades Every Programmer Needs #DeskSeries

  🙋‍♂️ 해석: “모든 프로그래머가 필요한 저렴한 책상 업그레이드 10가지”
  📝Reference


5️⃣ These Dividend Sell-Offs Could Mean Higher Starting Yields For You!

  🙋‍♂️ 해석: “이 배당금 매도는 더 높은 초기 수익률을 의미할 수 있습니다!”
    
      “Dividend” : 주식시장에서 “배당금” 을 의미합니다.
        
          이는 기업이 이익의 일부를 주주들에게 분배하는 금액입니다. 배당금은 주로 보통 현금으로 지급되지만, 주식 형태로 지급되기도 합니다. 배당금은 주로 정기적으로, 예를 들어 분기별이나 연간으로 지급됩니다.
        
      
      “Sell-Offs” : 금융 시장에서 “대규모 매도” 를 의미합니다.
        
          이는 투자자들이 대량으로 자산을 매도하여 시장에 공급이 급증하고, 그로 인해 가격이 하락하는 상황을 말합니다. 주식, 채권, 상품 등 다양한 자산에서 발생할 수 있습니다.
        
      
      “Yields” : 금융 및 투자 분야에서 “수익률” 을 의미합니다.
        
          이는 투자로부터 얻을 수 있는 수익의 비율을 나타내며, 보통 퍼센트로 표시됩니다. 수익률은 다양한 방식으로 계산될 수 있으며, 주식의 경우 배당금 수익률, 채권의 경우 이자 수익률 등이 이에 해당합니다. 일반적으로 수익률은 투자자에게 해당 자산이 얼마나 수익을 창출할 수 있는지를 보여주는 중요한 지표입니다.
        
      
    
  
  📝Reference


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-18-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-18-TIL.html"><h1 class="title_post">📝 [TIL] 240618 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-18-TIL.html" class="txt_post">
                            
  [AWS] 클라우드 컴퓨팅의 유형 정리
  [ENGLISH STUDY] 제목만 해석하는 영어 공부
  [배열 학습]


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/ENG/240618_ENG_STUDY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ENG.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/ENG/240618_ENG_STUDY.html"><h1 class="title_post">📚[ENG] 제목만 해석하는 영어 공부 :) </h1></a>
                        <a href="/Backend/ENG/240618_ENG_STUDY.html" class="txt_post">
                            1️⃣ Which IDE/Code Editor is best for Java Developer 2024

  🙋‍♂️ 해석: “2024년도 Java 개발자들에게 가장 적합한 IDE/코드 편집기는 무엇입니까?”
    
      best for : ~에 가장 적합
    
  
  📝Reference


2️⃣ A Third of My Online College Students are AI-Powered Spambots. Now what?

  🙋‍♂️ 해석: “온라인 대학 수강생의 3분의 1이 AI 스팸봇입니다. 이제 어떻게 해야 할까요?”
  📝Reference


3️⃣ Check your team for get-there-itis

  🙋‍♂️ 해석: “당신의 팀이 ‘목적지 집착증’에 걸렸는지 확인하세요.”
    
      “Get-there-itis” 는 주로 항공 및 해양 분야에서 사용되는 용어로, 목표에 너무 집중한 나머지 안전이나 절차를 무시하고 빨리 도착하려는 경향을 의미합니다.
        
          이 용어는 공식적인 의학 용어는 아니지만, 비공식적으로 목표 지향적인 강박증을 나타냅니다.
          따라서 “Check your team for get-there-itis” 라는 문구는 “당신의 팀이 ‘목적지 집착증’에 걸렸는지 확인하세요” 라는 번역이 개념적으로 맞다고 할 수 있습니다.
        
      
    
  
  💭 나의 생각 : 조금 더 자연스럽게 번역한다면 나라면 “당신의 팀이 너무 ‘목표에 집착’하고 있는지 확인해보세요.” 라고 번역할 것 같다.
  📝Reference


4️⃣ The unsexy problem problem

  🙋‍♂️ 해석: “매력적이지 않은 문제에 대한 문제”
  💭 나의 생각 : “problem” 이라는 단어가 두 번 나와서 어떻게 번역/해석을 해야 하는지 갈피를 못잡았다. 그래서 ChatGPT의 도움을 받았다.
    
      나의 친구(ChatGPT)가 말하길 “The unsexy problem problem” 이라는 문장에서 “problem” 이라는 단어가 두 번 나오기 때문에, 이 표현을 한국어로 번역시, 이를 고려하여 자연스럽게 전달해야 한다고 말해줬다.
      나의 친구는 의미를 좀 더 명확하게 전달하기 위해 “섹시하지 않은 문제라는 문제” 또는 “매력적이지 않은 문제에 대한 문제” 라는 두 번역 예시를 나에게 추천해줬다.
      그 이유를 설명하길 “이렇게 번역하면 원문에서 ‘problem’이 두 번 나오는 이유를 더 잘 반영하면서 의미를 명확하게 전달할 수 있습니다.” 라고 말해줬다. :)
    
  
  📝Reference


5️⃣ Why are my Java virtual threads slower than the platform threads?

  🙋‍♂️ 해석: “왜 나의 자바 가상 스레드는 플랫폼 스레드보다 느릴까?”
  📝Reference


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/AWS/240615_Types_of_Clould_Computing.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/aws.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/AWS/240615_Types_of_Clould_Computing.html"><h1 class="title_post">☁️[AWS] 클라우드 컴퓨팅의 유형</h1></a>
                        <a href="/Backend/AWS/240615_Types_of_Clould_Computing.html" class="txt_post">
                            



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-17-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-17-TIL.html"><h1 class="title_post">📝 [TIL] 240617 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-17-TIL.html" class="txt_post">
                            
  수학, 필요.충분 조건


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-06-17-Math.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-06-17-Math.html"><h1 class="title_post">[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.</h1></a>
                        <a href="/Backend/Math/2024-06-17-Math.html" class="txt_post">
                            












                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-16-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-16-TIL.html"><h1 class="title_post">📝 [TIL] 240616 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-16-TIL.html" class="txt_post">
                            
  Studing English through Newsletters
  Metacognition JAVA의 정석 - 기본형 크기와 특징
  [수학] 명제와 증명 학습


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/ENG/240616-ENG-STUDY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ENG.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/ENG/240616-ENG-STUDY.html"><h1 class="title_post">📚[ENG] 240616 Studing English through Newsletters</h1></a>
                        <a href="/Backend/ENG/240616-ENG-STUDY.html" class="txt_post">
                            1️⃣ AI’s Going to Cost Us

  “AI로 인해 비용이 발생할 것”
  📝Reference


2️⃣ Has the AI Revolution Crashed?

  “AI 혁명은 무너졌는가?”
  📝Reference


3️⃣ Do NOT Make This Navigation Mistake in Jetpack Compose

  “Jetpack Compose에서 이러한 Navigation 실수를 저지르지 마세요”
  📝Reference


4️⃣ Obsidian Plugins Review

  “옵시디언 플러그인 리뷰”
  📝Reference


5️⃣ Software Architecture is Hard

  “소프트웨어 아키텍처는 어렵다.”
  📝Reference


6️⃣ Whenever I Forget Someone’s Name, I Always Use This Brilliant Hack

  “누군가의 이름을 잊어버릴 때마다 나는 항상 이 놀라운 꿀팁을 사용합니다.”
  📝Reference


7️⃣ Mastering WidgetState in Flutter 3.22

  “Flutter 3.22에서 WidgetState 마스터하기.”
  📝Reference


8️⃣ Visualize Like a Pro: Annotate Matplotlib Graphs for Stunning Data Stories

  “전문가처럼 시각화: 놀라운 데이터 스토리를 위해 Matplotilb 그래프에 주석 달기.”
  📝Reference


9️⃣ The Earning Potential of Software Programmers

  “소프트웨어 프로그래머의 수익 잠재력”
  📝Reference


1️⃣0️⃣ End Tech Debt Conversations Forever with 6 Easy Hacks to Team Culture

  “팀 문화에 대한 6가지 쉬운 해킹으로 기술 부채 대화를 영원히 끝내세요.”
  📝Reference


1️⃣1️⃣ With SimPO You Don’t Need a Reference Model to Align Your LLM

  “SimPO를 사용하면 LLM을 정렬하기 위해 참조 모델이 필요하지 않습니다.”
  📝Reference


1️⃣2️⃣ Even if you had perfect data, you should still be building defensive data pipelines

  “완벽한 데이터가 있더라도 여전히 방어적인 데이터 파이프라인을 구축해야 합니다.”
  📝Reference


1️⃣3️⃣ Designing our new REST API

  “새로운 REST API 설계”
  📝Reference


1️⃣4️⃣ Koin-Depondent Composable Previews in Android Jetpack Compose

  “Android Jetpack Compose의 Koin 종속 컴포저블 미리보기”
  📝Reference


1️⃣5️⃣ Let’s Build a RESTful API in Rust

  “Rust에서 RESTful API를 구축해 봅시다”
  📝Reference


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-13-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-13-TIL.html"><h1 class="title_post">📝 [TIL] 240613 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-13-TIL.html" class="txt_post">
                            
  원형 큐를 구현할 때 rear의 초기값을 -1로 설정하지 않는 이유.
  알고리즘
  피자 나눠 먹기(2)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-12-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-12-TIL.html"><h1 class="title_post">📝 [TIL] 240612 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-12-TIL.html" class="txt_post">
                            
  Deque에서의 front와 rear의 변화 정리 및 복습.
  Circular Queue(원형 큐)의 중간 지점 찾기.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-11-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-11-TIL.html"><h1 class="title_post">📝 [TIL] 240611 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-11-TIL.html" class="txt_post">
                            
  피자 나눠 먹기(1)
  과제 수행(Java)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-10-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-10-TIL.html"><h1 class="title_post">📝 [TIL] 240610 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-10-TIL.html" class="txt_post">
                            
  deque에서의 front와 rear의 변화


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-09-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-09-TIL.html"><h1 class="title_post">📝 [TIL] 240609 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-09-TIL.html" class="txt_post">
                            
  짝수는 싫어요
  다형성
  Circular Queue(원형 큐)란?


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-08-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-08-TIL.html"><h1 class="title_post">📝 [TIL] 240608 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-08-TIL.html" class="txt_post">
                            
  Primitive Type과 Wrapper Class
  제네릭
  나머지 구하기
  중앙값 구하기


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-07-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-07-TIL.html"><h1 class="title_post">📝 [TIL] 240607 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-07-TIL.html" class="txt_post">
                            
  LinkedList를 이용한 Deque
  분수의 덧셈 복습


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-06-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-06-TIL.html"><h1 class="title_post">📝 [TIL] 240606 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-06-TIL.html" class="txt_post">
                            
  ArrayDeque
  코딩테스트 입문 - 두 수의 나눗셈
  코딩테스트 입문 - 숫자 비교하기
  코딩테스트 입문 - 분수의 덧셈
  코딩테스트 입문 - 배열 두 배 만들기


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-05-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-05-TIL.html"><h1 class="title_post">📝 [TIL] 240605 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-05-TIL.html" class="txt_post">
                            
  Deque(덱, 데크))
  코딩테스트 입문 - 두 수의 합
  코딩테스트 입문 - 두 수의 차
  코딩테스트 입문 - 두 수의 곱
  코딩테스트 입문 - 몫 구하기


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-03-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-03-TIL.html"><h1 class="title_post">📝 [TIL] 240603 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-03-TIL.html" class="txt_post">
                            
  IntStream


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-02-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-02-TIL.html"><h1 class="title_post">📝 [TIL] 240602 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-02-TIL.html" class="txt_post">
                            
  자바의 배열
  JAVA DOCS 보는 법


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-06-02-HowToReadJavaDocs.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-06-02-HowToReadJavaDocs.html"><h1 class="title_post">📝[blog post] Java Docs 보는 방법.</h1></a>
                        <a href="/Backend/Post/2024-06-02-HowToReadJavaDocs.html" class="txt_post">
                            📝 Java Docs를 읽는 능력이 필요한 이유. :)

저는 Documentation이 그 어떤 유명 테크 블로거의 글 보다 중요하고 심도있게 읽어야 한다는 개인적인 의견이 있습니다.

그 이유는 Java를 개발한 개발자분들이 직접 만든 설명서나 다름 없기 때문입니다.

우리가 레고를 생각해 봅시다.

내가 좋아하는 레고를 사서 집에서 조립할 때 무엇을 보나요? 🤔

맞습니다!

레고 패키지 안에 들어있는 “설명서”를 기반으로 레고를 조립합니다.

레고를 디자인하고 만드신 분이 직접 “이렇게 순서대로 만들면 당신이 원하는 멋진 레고 완성품을 얻을 수 있습니다!” 라는 것을 직.간접적으로 보여주는 아주 자세한 설명이 들어있죠 📝

설명서는 직접 디자인하고 설계한 사람의 철학과 그들이 왜 그렇게 만들었는지 그리고 어떻게 쓰여야하는지 정확, 명료하게 명시되어 있습니다.

또한 다른 구성품과 맞춰볼 수 있는 것도 제안하거나 보여주기도 합니다.

그래서 Documentation을 보고 제대로 활용할 줄 아는 것이 개발자에게는 중요한 능력 중 하나가 아닐까 하는 생각을 합니다 🙋‍♂️

1️⃣ Java Documentation 보기.

1. 온라인 문서.


  Java SE Documentation은 Oracle 공식 사이트에서 제공됩니다.
    
      Java 버전에 따라 다른 문서가 제공되니, 사용하는 Java 버전에 맞는 문서를 선택해야 합니다.
    
  


2. IDE 내장 문서.


  많은 통합 개발 환경(IDE)에는 JavaDoc을 쉽게 볼 수 있는 기능이 내장되어 있습니다. InteillJ IDEA, Eclipes, NetBeans 등에서 코드 작성 시 JavaDocs를 볼 수 있습니다.
    
      예를 들어, IntelliJ IDEA에서 클래스나 메소드 이름 위에 커서를 올리면 해당 클래스나 메소드의 JavaDoc이 팝업으로 표시됩니다.
    
  


3. 로컬 문서.


  Java JDK를 설치할 때, JavaDoc을 로컬에 다운로드할 수 있습니다. 이를 통해 인터넷 연결 없이도 문서를 참조할 수 있습니다.
  JDK 설치 경로 아래의 docs 폴더에 HTML 형식의 문서가 저장되어 있습니다.


2️⃣ Java Documentation 활용 방법

Java Documentation을 효과적으로 활용하는 방법을 알아봅시다.🤩

1. 클래스 및 메소드 탐색.


  API 문서에서 패키지, 클래스, 메소드, 필드 등의 세부 정보를 탐색할 수 있습니다.
    
      예를 들어, java.util 패키지에 어떤 클래스가 포함되어 있는지, ArrayList 클래스에 어떤 메소드가 있는지 등을 확인할 수 있습니다.
    
  


2. 사용 예제 찾기.


  각 클래스와 메소드에는 사용 예제가 포함되어 있을 수 있습니다. 이러한 예제는 해당 API를 올바르게 사용하는 방법을 이해하는 데 도움이 됩니다.


3. 메소드 시그니처 및 설명.


  메소드의 매개변수, 반환값, 예외 등을 설명하는 시그니처와 설명을 통해 메소드의 사용법을 정확히 알 수 있습니다.
    
      예를 들어, String 클래스의 substring 메소드의 시그니처와 설명을 보면, 매개변수로 전달해야 할 값과 반환되는 값에 대한 정보를 얻을 수 있습니다.
    
  


4. 상속 구조 및 인터페이스.


  클래스가 구현하는 인터페이스와 상속받는 클래스에 대한 정보를 확인할 수 있습니다. 이를 통해 클래스의 기능을 확장하거나 인터페이스를 구현하는 방법을 이해할 수 있습니다.


3️⃣ 예제

다음은 Java Documentation을 활용하는 몇 가지 예제입니다.

예제 1: ArrayList 클래스의 메소드 사용법 확인 🙋‍♂️


  온라인 문서에서 ArrayList 클래스를 찾습니다.
    
      Java SE Documentation에서 java.util.ArrayList 를 검색합니다.
      ArrayList 클래스의 API 문서를 열어 메소드 목록을 확인합니다.
    
  
  add(E e) 메소드 사용법 확인하기.
    
      add(E e) 메소드는 리스트의 끝에 요소를 추가하는 메소드입니다.
      메소드 설명을 읽고, 예제를 확인하여 사용법을 이해합니다.
    
  


예제 2. String 클래스의 substring 메소드 사용법 확인 🙋‍♂️


  IDE 내장 문서 활용하기.
    
      IntelliJ IDEA나 Eclipse에서 String 클래스의 substring 메소드를 사용하려고 할 때, 메소드 이름 위에 커서를 올리면 JavaDoc이 표시됩니다.
      JavaDoc을 통해 substring(int beingIndex, int endIndex) 메소드의 매개변수와 반환 값에 대한 설명을 읽습니다.
    
  


public class Main {
    public static void main(String[] args) {
        String text = "Hello, World!";
        String subText = text.substring(7, 12); // "World"
        System.out.println(subText);
    }
}


위 예제에서 substring 메소드의 매개변수가 beginIndex 와 endIndex 임을 알 수 있으며, 이는 시작 인덱스부터 종료 인덱스 전까지의 문자열을 반환합니다.

예제 3. 예외 처리 방법 확인 🙋‍♂️


  예외 클래스 문서 확인하기.
    
      java.lang.NullPointerException 클래스의 문서를 확인하여 언제 이 예외가 발생하는지, 그리고 이를 어떻게 처리할 수 있는지에 대한 정보를 얻습니다.
    
  
  예외 처리 예제


public class Main {
    public static void main(String[] args) {
        try {
            String text = null;
            System.out.println(text.length());
        } catch (NullPointerException e) {
            System.out.println("Caught a NullPointerException");
        }
    }
}


이 예제는 NullPointException 이 발생할 때 이를 처리하는 방법을 보여줍니다.

📝 요약.


  Java Documentation은 Java API를 이해하고 사용하는 데 필수적인 자료입니다.
  Java Documentation를 온라인, IDE, 또는 로컬에서 접근할 수 있습니다.
  API 문서를 통해 클래스와 메소드의 세부 정보를 확인하고, 예제를 참고하여 올바르게 사용하는 방법을 배울 수 있습니다.
  상속 구조와 인터페이스 구현 방법을 이해하여 코드의 재사용성과 확장성을 높일 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-06-01-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-06-01-TIL.html"><h1 class="title_post">📝 [TIL] 240601 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-06-01-TIL.html" class="txt_post">
                            
  배열의 특정 인덱스의 요소를 삭제하는 방법.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-30-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-30-TIL.html"><h1 class="title_post">📝 [TIL] 240530 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-30-TIL.html" class="txt_post">
                            
  다양한 입출력 방법
  큐(Queue)
  큐 구현(LinkedList)
  큐 구현(List)
  큐 구현(Array)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-30</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-29-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-29-TIL.html"><h1 class="title_post">📝 [TIL] 240529 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-29-TIL.html" class="txt_post">
                            
  스택 문제 풀이


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-29</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-28-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-28-TIL.html"><h1 class="title_post">📝 [TIL] 240528 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-28-TIL.html" class="txt_post">
                            
  스택(Stack)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-28</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-27-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-27-TIL.html"><h1 class="title_post">📝 [TIL] 240527 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-27-TIL.html" class="txt_post">
                            
  노드(Node)
  장치 컨트롤러와 장치 드라이버
  트리(Tree)
  이진 트리(Binary Tree)
  완전 이진 트리(Complete Binary Tree)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-27</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-25-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-25-TIL.html"><h1 class="title_post">📝 [TIL] 240525 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-25-TIL.html" class="txt_post">
                            
  해시 테이블(Hash Table)
  해시 맵 정리


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-25</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-24-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-24-TIL.html"><h1 class="title_post">📝 [TIL] 240524 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-24-TIL.html" class="txt_post">
                            
  배열 문제 풀이
  배열 정리
  해시(Hash)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-23-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-23-TIL.html"><h1 class="title_post">📝 [TIL] 240523 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-23-TIL.html" class="txt_post">
                            
  큐(Queue)
  원형 큐(Circular Queue)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-23</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-22-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-22-TIL.html"><h1 class="title_post">📝 [TIL] 240522 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-22-TIL.html" class="txt_post">
                            
  다양한 보조기억장치


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-22</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-21-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-21-TIL.html"><h1 class="title_post">📝 [TIL] 240521 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-21-TIL.html" class="txt_post">
                            
  자료구조 소개
  RAID의 정의와 종류
  선형 자료구조 - 배열


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-18-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-18-TIL.html"><h1 class="title_post">📝 [TIL] 240518 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-18-TIL.html" class="txt_post">
                            
  수학적 귀납법
  명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html"><h1 class="title_post">📝[blog post] 나는 어떤 백엔드 개발자가 되고 싶은걸까?</h1></a>
                        <a href="/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html" class="txt_post">
                            🤔 나는 어떤 백엔드 개발자가 되고 싶은걸까?

🙋‍♂️ 백엔드 개발자의 역할과 책임

어떤 백엔드 개발자가 되고 싶은지 말하기 전에 백엔드 개발자는 어떤 역할과 책임이 있는지 알아보아야 할 것 같아요.

1️⃣ 웹 서버 개발.

  웹 서버 및 API 개발.
  HTTP 요청 및 응답 처리.
  RESTful 서비스 설계 및 구현.


2️⃣ 데이터베이스 관리.

  데이터베이스 설계 및 최적화.
  SQL 및 NoSQL 데이터베이스 작업.
  데이터 모델링 및 스키마 설계.


3️⃣ 서버 사이드 로직.

  비즈니스 로직 구현.
  사용자 인증 및 권한 관리.
  데이터 유효성 검사.


4️⃣ API 개발 및 통합.

  외부 API와의 통합 작업.
  내부 API 설계 및 개발.
  API 문서화 및 유지보수.


5️⃣ 성능 최적화.

  서버 성능 모니터링 및 튜닝.
  캐싱 전략 설계 및 구현.
  로드 밸런싱 및 스케일링.


6️⃣ 보안 관리.

  데이터 보안 및 암호화.
  OWASP 및 기타 보안 지침 준수.
  침입 탐지 및 대응.


7️⃣ 클라우드 컴퓨팅.

  AWS, Azure, GCP 등 클라우드 플랫폼 사용.
  클라우드 기반 서비스 배포 및 관리.
  컨테이나화 및 오케이스트레이션(Docker, Kubernetes)


8️⃣ DevOps와 CI/CD.

  지속적 통합 및 배포(CI/CD) 파이프라인 구축.
  서버 및 서비스의 자동화 및 오케스트레이션.
  인프라스트럭처 코드화(Infrastructure as Code).


9️⃣ 로그 및 모니터링.

  애플리케이션 및 서버 로그 관리.
  모니터링 도구 설정(예: Prometheus, Grafana).
  로그 분석 및 문제 해결.


백엔드 개발자는 일반적으로 이 모든 역할을 하나의 프로젝트 내에서 수행하지 않아요.
회사나 팀의 구조에 따라 특정 역할에 집중하게 된답니다.
예를 들어, 일부 개발자는 데이터베이스 관리에 중점을 두고, 다른 개발자는 클라우드 인프라 관리에 집중할 수 있습니다.

🙋‍♂️ 내가 되고 싶은 백엔드 개발자.

  
    
      맡은 역할과 책임에 최선을 다하는 개발자
        
          저는 맡은 바에 항상 최선을 다해 임무를 완수합니다.
          내가 맡은 바에는 책임이라는 것이 따르기 때문에 항상 최선을 다해야 한다고 생각합니다.
        
      
    
  
  
    
      소통을 잘하는 백엔드 개발자.
        
          커뮤니케이션이 정말 중요하다고 생각합니다.
          하나의 프로그램을 만들기 위해서는 많은 사람들이 함께 만들어가는 것 이기 때문에 함께 협력하고 소통을 잘해야 합니다.
        
      
    
  
  
    
      유연한 사고를 가진 백엔드 개발자.
        
          나 자신의 의견 또는 생각 역시도 틀릴 수 있다는 것을 항상 인지하고 여러 모든 의견을 유연하게 받아들일 수 있는 백엔드 개발자가 되고 싶습니다.
        
      
    
  
  
    
      말이 아닌 코드로 증명하는 개발자.
        
          말로만 대단한 듯이 말하는 개발자가 아닌 진짜 코드로 증명해내는 그런 백엔드 개발자가 되고 싶습니다.
        
      
    
  
  
    
      겸손과 꾸준한 성장을 하는 백엔드 개발자.
        
          겸손의 미덕을 알고 있습니다. 언제나 배움의 자세를 가지고 항상 배우려 노력하며 꾸준히 성장하는 백엔드 개발자가 되고 싶습니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-05-18-Math.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-05-18-Math.html"><h1 class="title_post">[Math] 수학적 귀납법</h1></a>
                        <a href="/Backend/Math/2024-05-18-Math.html" class="txt_post">
                            📝 수학적 귀납법이란?
수학적 귀납법은 자연수에 대한 명제의 참 여부를 증명하는 데 사용되는 강력한 수학적 증명 기법입니다.
이를 통해 무한히 많은 경우에 대해 명제가 참임을 보일 수 있습니다.

수학적 귀납법은 주로 ‘기본 단계’ 와 ‘귀납 단계’ 로 이루어집니다.

1️⃣ 기본 단계(Base Case)
명제가 첫 번째 자연수 n = 1(또는 특정 시작점 n = k)에 대해 참임을 증명합니다.

2️⃣ 귀납 단계(Inductive Step)
명제가 임의의 자연수 n = k에 대해 참이라고 가정했을 때, n = k + 1에도 참임을 증명합니다.

이를 좀 더 형식적으로 설명하면 다음과 같습니다.


  기본 단계:
    P(1)이 참임을 증명합니다.
    
  
  귀납 단계:
    P(k)가 참이라고 가정합니다.(귀납 가정)
P(k+1)이 참임을 증명합니다.
    
  


기본 단계와 귀납 단계가 모두 성립하면, 수학적 귀납법에 의해 모든 자연수 n에 대해 명제 P(n)이 참임을 증명할 수 있습니다.

3️⃣ 예제
자연수 n에 대해 다음 명제를 증명해봅시다:
1+2+3+...+n= n(n+1)/2



  기본 단계:
n = 1일때,
    1 = 1(1+1)/2 = 2/2 = 1
    
  


따라서 P(1)은 참입니다.


  귀납 단계:
P(k)가 참이라고 가정합니다 즉,
    1+2+3+...+k = k(k+1)/2
    
    이 가정하에 P(k+1)이 참임을 증명합니다.
  


1+2+3+...+k+(k+1) = k(k+1)/2+(k+1)


우변을 정리하면,
k(k+1)/2 + (k+1) = (k(k+1)+2(k+1))/2 = ((k+1)(k+2))/2


이는 P(k+1) 입니다.

기본 단계와 귀납단계가 모두 성립했으므로, 수학적 귀납법에 의해 모든 자연수 n에 대해 1+2+3+...+n = n(n+1)/2임을 증명할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-05-18-Math-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-05-18-Math-1.html"><h1 class="title_post">[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.</h1></a>
                        <a href="/Backend/Math/2024-05-18-Math-1.html" class="txt_post">
                            1️⃣ 기하학 - 설득술로서 발전해 온 수학

1️⃣ 명제와 증명.
“필요조건” 과 “충분조건” 에 대한 이해는 모든 논리의 기초가 되는 가장 중요한 사항이라 해도 과언이 아닙니다.

수학은 논리와 떼려야 뗄 수 없는 관계라는 것은 모두가 아는 사실이지만 ‘필요’ 와 ‘충분’ 은 수학의 논리 중에서도 가장 중요한 역할을 하는 기본적인 사고방식입니다.

‘이것 없이는 어떠한 수학적 논리도 전개할 수 없다’라고 단언할 수 있을 정도입니다.

또한, ‘부정’을 이용해서 증명하는 방법인 “대우” 와 “귀류법” 의 이해도 매우 중요합니다.

대우는 얼핏 보기에도 복잡해 보이는 명제를 단순화하고, 귀류법은 정면 돌파로는 증명할 수 없는(하기 어려운) 명제를 증명할 때 큰 힘을 발휘합니다.

명제란 무엇인지 먼저 확인해 봅시다.

명제: 참과 거짓을 객관적으로 판정할 수 있는 문장이나 식


예를 들어 ‘백두산은 한국에서 가장 높은 산이다’는 명제지만 ‘백두산은 멋있다’는 명제가 아닙니다.

백두산의 높이가 한국에서 가장 높은지는 객관적으로 판정할 수 있지만, 백두산이 멋지다고 느끼는 데는 개인차가 있으며(심지어 대부분이 ‘멋지다’고 생각할지라도) 참과 거짓을 객관적으로 판단할 수 없기 때문입니다.

💡 논리적 사고의 기초: 필요조건과 충분 조건.
우선 필요조건과 충분조건의 정의를 살펴보겠습니다.


  필요조건과 충분조건의 정의

  명제 ‘P이면 Q이다’ 가 참일 때,

  P를(Q이기 위한) “충분조건”

  Q를(P이기 위한) “필요조건”

  이라고 합니다.


‘P이면 Q이다’ 에서 P를 ‘재즈’라 하고 Q를 ‘음악’이라 하면 ‘재즈는 음악이다’가 됩니다.
이는 당연히 참이므로(올바르므로) 정의에 따라

  재즈: 충분조건
  음악: 필요조건


이 됩니다.

확실히 재즈가 되기 위해서는 (적어도) 음악일 필요가 있습니다.

또한, 음악이 되기 위해서 재즈면 (넉넉하게) 충분하다고 할 수 있습니다.

재즈는 음악의 한 장르이므로 이 둘의 관계를 그림으로 표현하면 다음과 같은 모습이 됩니다.



이처럼 한쪽이 다른 한쪽을 완전히 포함하는 경우를 다음과 같이 집합으로 이해해 보는 것도 매우 중요합니다.


  영역이 더 작은 쪽(재즈): 충분조건
영역이 더 큰 쪽(음악): 필요조건


특히 두 개의 명제 ‘P이면 Q다’ 와 ‘Q이면 P다’가 모두 참일 경우에는 ‘P와 Q가 서로의 필요충분조건이다’라고 합니다. 또는 ‘P와 Q는 서로 동치다’ 라고도 합니다.


  NOTE : 실수란

  수학에서는 일반적으로 부등식의 범위를 수직선에 나타낼 때,

  등호 없는 부등호(&lt;)는 ○와 대각선

  등호 있는 부등호(≤)는 ●와 (직선에) 수직으로 뻗은 선

  으로 표기합니다.

  예를 들어 1 ≤ x &lt; 4는 다음과 같이 표기합니다.

  


우리는 보통 무언가를 고를 때, 자연스레 “필요저건에 따라 후보를 줄여 나갑니다. 그리고 충분조건을 만족하는 후보를 탐색합니다.”

예를 들어 점심 메뉴를 고를 때, ‘8,000원 안팍의 메뉴’처럼 예산이 필요조건이 사람이 적지 않을 것입니다.

거기에 ‘30분 안에 먹을 수 있는 메뉴’ 혹은 ‘깔끔한 맛’ 등의 필요조건을 더 해, 그 모든 필요조건을 만족하는 메뉴로 후보를 줄여 나갑니다.

그리고 남은 메뉴(후보)가 오늘 점심으로 괜찮은지(충분한지) 고민합니다.

그 결과(예를 들어) ‘그럼 오늘 점심은 경양식 돈까스로 하자’고 결정하는 사고방식은 매우 당연하다고 생각할 것입니다.

이처럼 필요조건과 충분조건을 구분하는 능력은 문제를 해결할 때 대단한 위력을 발휘합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-17-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-17-TIL.html"><h1 class="title_post">📝 [TIL] 240517 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-17-TIL.html" class="txt_post">
                            
  연습 문제 풀이(2)
  예외 처리 - 트러블슈팅
  문자열 처리 - 트러블슈팅


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-17-PracticeSummary-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-17-PracticeSummary-2.html"><h1 class="title_post">📝[blog post] 연습 문제 풀이 정리(2)</h1></a>
                        <a href="/Backend/Post/2024-05-17-PracticeSummary-2.html" class="txt_post">
                            1️⃣ 수열과 재귀.

연습 문제를 풀다보니 수열과 재귀에 대해 많은 수학적 사고력이 필요하겠다는 생각이 들었습니다.


  수열 : 수학에서 수의 나열을 의미합니다.
    
      즉, 어떤 규착에 따라 나열된 수들의 집합을 말합니다.
      수열은 각 수를 나타내는 일련의 할(terms)으로 구성되며, 각 항은 특정 위치(index)를 가집니다.
      수열의 예로는 다음과 같은 것들이 있습니다.
        
          등차수열: 각 항이 일정한 값만큼 증가하거나 감소하는 수열(예: 2, 5, 8, 11…)(각 항이 3씩 증가)
          등비수열: 각 항이 일정한 비율로 증가하거나 감소하는 수열(예: 3, 9, 27, 81…)(각 항이 이전 항의 3배)
          피보나치 수열: 첫 두 항이 0과 1이고, 그 이후의 각 항이 바로 앞 두항의 합인 수열(예: 0, 1, 1, 2, 3, 5, 8….)
            
              수열은 다양한 수학적 문제를 해결하는 데 사용되며, 특히 함수, 극한, 미적분 등의 주제와 밀접한 관련이 있습니다.
            
          
        
      
    
  
  재귀 : 프로그래밍과 수학에서 사용되는 개념으로, 어떤 함수나 알고리즘이 자기 자신을 호출하는 방식울 말합니다.
    
      재귀를 통해 복잡한 문제를 더 작은 하위 문제로 나누어 해결할 수 있습니다.
      재귀 함수는 기본적으로 두 가지 부분으로 구성됩니다.
        
          1. 기저 조건(Base Case) : 재귀 호출이 더 이상 필요하지 않은 경우를 정의합니다. 기저 조건이 충족되면 함수는 더 이상 자기 자신을 호출하지 않고 종료됩니다.
          2. 재귀 호출(Recursive Call) : 함수가 자기 자신을 호출하여 문제를 더 작은 부분으로 나누어 해결하려고 시도합니다.
            
              재귀는 문제를 단순하고 직관적으로 표현할 수 있는 강력한 도구이지만, 재귀 호출이 과도하면 스택 오버플로(stack overflow)가 발생할 수 있으므로 주의가 필요합니다.
                
                  따라서 재귀를 사용할 때는 기저 조건을 잘 정의하고, 필요할 경우 반복(iteration)으로 문제를 해결하는 방법도 고려해야 합니다.
                
              
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-16-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-16-TIL.html"><h1 class="title_post">📝 [TIL] 240516 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-16-TIL.html" class="txt_post">
                            
  연습 문제 정리(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-16-PracticeSummary-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-16-PracticeSummary-1.html"><h1 class="title_post">📝[blog post] 연습 문제 풀이 정리(1)</h1></a>
                        <a href="/Backend/Post/2024-05-16-PracticeSummary-1.html" class="txt_post">
                            1️⃣ 이중 for 문.
이중 for 문은 for 문을 중첩해서 사용하는 것을 말합니다.

한 for 문 안에 또 다른 for 문 안에 또 다른 for 문이 들어있는 구조로, 주로 2차원 배열이나 리스트, 행렬을 처리할 때 사용됩니다.

1.1 기본 구조.
for (초기화1; 조건1; 증감1) {
    for (초기화2; 조건2; 증감2) {
        // 코드 블록
    }
}


1.2 예시
예를 들어, 2차원 리스트의 모든 요소를 출력하는 경우를 생각해 봅시다.
public class Main {
    public static void main(Stringp[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        for (int[] row : matrix) {
            for (int element : row) {
                System.out.println(element);
            }
        }
    }
}



  위 코드에서 ‘matrix’ 는 2차원 리스트입니다.
    
      첫 번째 for 문은 ‘matrix’ 의 각 행(row)을 순회하고, 두 번째 for 문은 각행의 요소(element)를 순회합니다.
    
  


출력 결과는 다음과 같습니다.
1
2
3
4
5
6
7
8
9


2️⃣ 규칙성을 찾는 것이 중요!
어떤 문제를 마주치면 규칙성을 찾는 것이 중요한 것 같습니다.
연습 문제 2-1 중 ‘정수형 숫자를 로마 숫자 표기로 변환하는 프로그램’ 을 작성하는 문제에서 그것을 깨달았습니다.

먼저 어떤 규칙성이 있는지 찾아낸 후 그 규칙성에 따라 문제를 풀고, 문제를 컴퓨터적 사고력을 이용하여 코딩을 하니 문제가 풀리는 것을 알게 되었습니다.

3️⃣ 인덱스를 자유자재로 가지고 놀 줄 알아야 합니다!
연습 문제를 풀면서 느낀 점 중 하나가 “인덱스를 자유자재로 가지고 놀 줄 알아야 한다” 는 부분이었습니다.

“인덱스를 자유자재로 가지고 논다” 라는 말은 문자열이 주어지면 인덱스를 활용하여 문자를 삽입, 삭제, 추출, 변환 등을 자유롭게 할 줄 알아야 한다는 의미입니다.

연습 문제 중 문자열에 대한 문제는 이 부분이 가장 중요시되는 것 같았습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-14-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-14-TIL.html"><h1 class="title_post">📝 [TIL] 240514 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-14-TIL.html" class="txt_post">
                            
  스트림


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-13-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-13-TIL.html"><h1 class="title_post">📝 [TIL] 240513 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-13-TIL.html" class="txt_post">
                            
  컬렉션 프레임워크
  HashMap에 key 값은 항상 int 여야 할까요?
  람다식
  람다식은 하나만!


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-12-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-12-TIL.html"><h1 class="title_post">📝 [TIL] 240512 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-12-TIL.html" class="txt_post">
                            
  입출력(2)
  예외 처리


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-11-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-11-TIL.html"><h1 class="title_post">📝 [TIL] 240511 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-11-TIL.html" class="txt_post">
                            
  인터페이스
  내부 클래스
  입출력(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/blog.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html"><h1 class="title_post">📝[blog post] 프론트엔드와 백엔드는 무엇이 다를까?(+내가 백엔드 개발자가 되고 싶은 이유)</h1></a>
                        <a href="/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html" class="txt_post">
                            1️⃣ 프론트엔드와 백엔드?
처음 이 글의 여정을 함께하기에 앞서 프론트엔트가 무엇인가 백엔드가 무엇인지 알아야 할 것 같아요!

제가 아무것도 모르는 당시 저 두 단어 “프론트엔드”, “백엔드”를 듣고 느낀 것은

“프론트엔드”는 뭔가 프론트 데스크 같이 앞에서 누군가가 나를 반겨주는 느낌이였고, “백엔드”는 뒤쪽에서 나를 받쳐주는 든든한 느낌이랄까? 😆

그저 느낌으로는 알쏭달쏭하니 정확한 의미를 알아보는 여행을 떠나봅시다! 🙋‍♂️

2️⃣ 프론트엔드.
프론트엔드는 웹사이트에서 우리가 볼 수 있는 모든 것들을 만드는 일을 말해요 😆



예를 들어, 컴퓨터나 핸드폰으로 책을 보거나 게임을 할 때, 그 화면에 보이는 모든 것들이 바로 프론트엔드에서 만들어진 거예요.(존경합니다 프론트엔드 개발자님들🙇‍♂️)

이렇게 생각해 볼까요?



웹사이트를 마치 컬러링북처럼 생각한다면, 프론트엔드 개발자는 그림을 그리고 색칠하는 사람이에요 🧑‍🎨

프론트엔드 개발자들은 화면에 나타날 모양이나 색상을 정하고, 어디를 누르면 어떤일이 일어날지도 결정합니다.

예를 들어, ‘스타드’ 버튼을 누르면 게임이 시작되거나, 사진을 클릭하면 커지는 것처럼 말이에요.

즉, 프론트엔드는 우리가 웹사이트에서 보고 만지는 모든 것을 아름답고 재미있게 만들어 주는 중요한 일을 한답니다!

3️⃣ 백엔드.


백엔드는 웹사이트에서 우리가 눈에 보이지 않는 부분을 다루는 일을 해요.(그렇다고 뭐.. 해커 이런건 아닙니다.. 완전히 달라요…)



이것은 마치 마술사가 무대 뒤에서 마술을 준비하는 것과 비슷해요! 🪄

우리가 볼 수는 없지만, 마술이 멋기제 보이도록 도와주죠.

예를 들어, 우리가 컴퓨터로 쇼핑을 할 때, 옷이나 장난감을 고르고 주문 버튼을 눌러요. 이떄 백엔드는 주문한 것이 무엇인지 기억하고, 그 물건을 어디로 보내야 할지 알려줘요.

또한, 우리가 어떤 게임을 하거나 질문을 할 때도, 백엔드는 그 대답을 찾아서 화면에 보여주죠.

백엔드는 컴퓨터와 데이터베이스라는 큰 저장소를 사용해서, 우리가 웹사이트에서 필요한 모든 정보를 처리하고 저장하는 곳이에요.

우리가 보지 못하지만, 웹사이트가 잘 작동하도록 도와주는 매우 중요한 부분이랍니다!

4️⃣ 내가 백엔드 개발자가 되고 싶은 이유.

저는 어렸을 때 레고를 참 좋아했어요 :)



그 중에서도 테크닉 레고를 가장 좋아했었어요 :)

그 이유는 완성된 것을 보는 것도 좋았지만 조립해 나가면서 그 안에 중심이 되는 코어, 즉 움직임의 중앙부를 제가 직접 조립하고 움직임이 어디서부터 시작되는지를 직접 이해하는 것이 너무 재미있었거든요.

자동차 레고를 만들다보면 직접 엔진를 만들게 됩니다.

그러면 진짜 엔진이 어떻게 움직이고 이 엔진이 어떻게 동작하느냐에 따라 자동차의 다른 부품들이 맞물려 하나씩 동작하는지 상상되는게 너무 행복했었어요.

이런것들이 어렸을 때부터 너무 좋았답니다.

그리고나서 조금 커서는 루어 낚시를 좋아하게 되었어요.



이 루어 낚시는 “배스” 라는 어종을 대상으로 하는 낚시인데, 이 어종에 대한 여러가지 공부를 해야 했었어요.

먼저, 이 어종이 온도에 민감해 온도에 따라 공격 패턴이 달라요 그래서 그 패턴에 대한 데이터를 수집해야 했었어요.

두 번째, 이 어종은 수중 구조물에 굉장히 예민해요. 자신이 좋아하는 수중 구조물이 따로 있어서 그 수중 구조물을 따로 탐색하고 이해하는 법을 배워야 했었어요.

세 번째, 날씨에 영향을 많이 받는 어종이에요. 햇빛과 그늘 그리고 비가 오는 날과 안오는 날에 따라 먹이 사냥 패턴이 달라져요. 그에 따른 루어 선택과 패턴을 다르게 골라야 합니다.

네 번째, 피딩 타임이라는 이 어종의 먹이 사냥 시간이 있습니다. 이 시간에 따라 어종의 먹이 사냥 패턴이 매우 다양해요.

마지막, 계절에 따라 이 어종이 물 속이 바닥, 중층 또는 상층에 머무는지 이런 데이터가 달라요.

이렇게 이 어종을 낚기 위해서는 수 많은 변수와 데이터들을 조합하여 적절한 위치에 적합한 루어를 선택하여 공격 패턴에 맞는 액션을 주어야 배스가 물어 줍니다.

그럴때 “아 나의 데이터가 맞았구나!” 하는 희열감과 아드레날린 그리고 도파민이 폭발해버리죠.

이런 특성이 저는 백엔드에서도 비슷하게 적용되는 것 같아요.

레고는 백엔드에서의 중심 동작을 알아가는 과정과 직접 동작하는 로직을 만드는 부분에서의 즐거움을 찾아가는 과정에서 재미를 느끼고,

낚시는 백엔드에서 데이터를 찾고 뽑아내어 가공하고 내어주는 부분에서 희열을 느끼는 것 같습니다.

그래서 저의 적성과 맞는 것 같아요.

저는 이러한 부분에서 백엔드 개발자가 제가 즐길 수 있는 부분이 서로 맞기 때문에 백엔드 개발자가 되고 싶습니다 😆

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-10-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-10-TIL.html"><h1 class="title_post">📝 [TIL] 240510 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-10-TIL.html" class="txt_post">
                            
  다형성
  추상클래스


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-09-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-09-TIL.html"><h1 class="title_post">📝 [TIL] 240509 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-09-TIL.html" class="txt_post">
                            
  상속


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-08-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-08-TIL.html"><h1 class="title_post">📝 [TIL] 240508 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-08-TIL.html" class="txt_post">
                            
  클래스와 객체(2)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-07-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-07-TIL.html"><h1 class="title_post">📝 [TIL] 240507 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-07-TIL.html" class="txt_post">
                            
  다차원 배열
  클래스와 객체(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-06-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-06-TIL.html"><h1 class="title_post">📝 [TIL] 240506 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-06-TIL.html" class="txt_post">
                            
  반복문


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-05-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-05-TIL.html"><h1 class="title_post">📝 [TIL] 240505 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-05-TIL.html" class="txt_post">
                            
  여러가지 연산자(1)
  여러가지 연산자(2)
  조건문


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-04-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-04-TIL.html"><h1 class="title_post">📝 [TIL] 240504 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-04-TIL.html" class="txt_post">
                            
  자바 - 변수와 자료형(4)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-03-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-03-TIL.html"><h1 class="title_post">📝 [TIL] 240503 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-03-TIL.html" class="txt_post">
                            
  자바 - 변수와 자료형(2)
  자바 - 타입 비교
  자바 - 변수와 자료형(3)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/TIL/2024-05-02-TIL.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/TIL.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/TIL/2024-05-02-TIL.html"><h1 class="title_post">📝 [TIL] 240502 Today I Learned.</h1></a>
                        <a href="/Backend/TIL/2024-05-02-TIL.html" class="txt_post">
                            
  기초수학 - 소개(수학과 자바 프로그래밍, 자료구조, 알고리즘의 관계)
  코테 맛보기(1) - 코테를 위한 자바 프로그래밍 언어 사용 숙련도
  코테 맛보기(2) - 코테를 위한 자료구조와 알고리즘 개념 구현 방법 숙지
  자바 - 소개
  자바 - 변수와 자료형(1)


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Math/2024-05-02-Math.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/Math.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Math/2024-05-02-Math.html"><h1 class="title_post">[Math] 기초수학 - 소개</h1></a>
                        <a href="/Backend/Math/2024-05-02-Math.html" class="txt_post">
                            자바 프로그래밍, 수학, 자료구조 / 알고리즘

수학은 자바 프로그래밍과 자료구조 / 알고리즘 사이의 “중간 다리 역할”을 합니다.

자바 프로그래밍, 수학, 자료구조 그리고 알고리즘은 컴퓨터 과학과 소프트웨어 개발의 중요한 구성 요소들이며 서로 긴밀하게 연결되어 있습니다.

각각의 분야가 어떻게 상호작용하는지 살펴봅시다.

1. 수학과 프로그래밍.

🙋‍♂️ 수학과 자바 프로그래밍 사이의 상관관계는 매우 밀접하며, 효과적인 프로그래밍 기술과 문제 해결 능력을 개발하는 데 중요한 역할을 합니다. 수학은 프로그래밍의 논리적 사고, 구조적 접근, 그리고 복잡한 문제의 해결에 기초를 제공합니다.

  다음은 수학이 자바 프로그래밍과 어떻게 연결되는지에 대한 몇 가지 주요 포인트입니다.
    
      1. 논리적 사고와 알고리즘 개발 : 수학은 논리적이고 체계적인 사고를 필요로 합니다. 자바 프로그래밍에서도 마찬가지로, 문제를 분석하고 효과적인 알고리즘을 설계하는 데 이러한 사고방식이 요구됩니다.
        
          예를 들어, 조건문, 반복문, 함수 등의 기본적인 프로그래밍 구조는 수학적 조작과 비슷한 추론을 통해 최적화될 수 있습니다.
        
      
      2. 복잡도 분석 : 프로그램의 성능을 평가하고 최적화하기 위해 수학적인 복잡도 분석이 사용됩니다.
        
          빅 오 표기법 같은 수학적 도구는 알고리즘의 실행 시간과 필요한 메모리 곤간을 예측하는 데 도움을 줍니다.
            
              이는 효율적인 자바 프로그램을 작성하는 데 필수적인 요소입니다.
            
          
        
      
      3. 문제 해결 : 수학적 모델링과 이론은 자바 프로그래밍에서 복잡한 문제를 단순화하고 구조화하는데 사용됩니다.
        
          예를 들어, 경로 찾기, 스케줄링 문제, 최적화 문제 등을 해결할 때 수학적 기법이 프로그래밍 로직의 기반을 형성합니다.
        
      
      4. 데이터 구조 : 수학적 개념, 특히 집합론은 자바에서 사용되는 다양한 데이터 구조의 이해를 돕습니다.
        
          배열, 리스트, 스택, 큐, 트리, 그래프 등의 자료구조는 모두 수학적 원리에 기반을 두고 있으며, 이를 이해하고 활용하는 것은 효율적인 프로그래밍에 직결됩니다.
        
      
      5. 인공 지능과 머신 러닝 : 자바 프로그래밍에서 머신 러닝과 인공 지능 애플리케이션을 개발할 때, 선형대수학, 확률론, 통계학 등의 수학적 분야가 필수적입니다.
        
          이러한 수학적 지식은 데이터를 분석하고, 알고리즘을 구현하는 데 필요합니다.
        
      
      6. 암호화와 보안 : 암호화 알고리즘과 보안 기술의 개발에도 수학이 깊숙이 관련되어 있습니다.
        
          예를 들어, 공개 키 암호화 같은 기술은 수학적 난제에 기반을 두고 있으며, 이는 자바 보안 기능의 핵심 부분입니다.
        
      
    
  


👉 이처럼 수학은 자바 프로그래밍에서 논리적 구조, 효율성, 그리고 문제 해결 능력을 개발하는 데 필수적인 도구입니다.
👉 수학적 사고방식은 효과적인 소프트웨어 개발을 위한 기초적인 스킬로, 프로그래머가 보다 복잡한 문제에 접근하고 해결하는 데 큰 도움을 줍니다.

2. 수학과 자료구조.

🙋‍♂️ 수학과 자료구조 간의 상관관계는 컴퓨터 과학의 깊은 수학적 기반을 통해 잘 드러납니다.

  다음은 수학과 자료구조 간의 몇 가지 중요한 상호작용을 설명합니다.
    
      1. 이론적 기반 제공 : 수학은 자료구조를 이해하고 분석하는 데 필요한 이론적 지반을 제공합니다.
        
          예를 들어, 집합 이론은 자료구조 설계의 기본이 되며, 다양한 자료구조들이 데이터의 집합을 어떻게 조직화하고 관리하는지 이해하는 데 도움을 줍니다.
        
      
      2. 복잡도 분석 : 자료구조의 효율성을 평가하기 위해 수학적 도구가 필요합니다.
        
          빅 오 표기법(O notation)은 알고리즘과 자료구조의 시간 복잡도와 공간 복잡도를 표현하는 데 사용되며, 이는 수학적 함수로 표현됩니다.
            
              이를 통해 개발자들은 자료구조의 성능을 정량적으로 비교하고 분석할 수 있습니다.
            
          
        
      
      3. 그래프 이론 : 그래프 이론은 네트워크, 소셜 미디어, 경로 탐색 등 다양한 문제를 모델링하는 데 사용되는 자료구조인 그래프의 분석과 최적화에 사용됩니다.
        
          이는 컴퓨터 네트워크, 최단 경로 문제, 최소 스패닝 트리 등의 문제 해결에 필수적입니다.
        
      
      4. 논리와 증명 : 수학적 논리와 증명 기법은 자료구조의 올바른 작동을 보장하는 데 중요합니다.
        
          예를 들어, 자료구조릐 구현을 검증하거나, 특정 알고리즘이 주어진 자료구조에서 올바르게 작동함을 증명할 때 사용됩니다.
          또한, 재귀적 자료구조와 알고리의 증명에도 수학적 귀납법이 활용됩니다.
        
      
      5. 최적화 문제 : 다양한 자료구조는 종종 최적화 문제를 해결하는 데 사용됩니다.
        
          예를 들어, 트리 구조를 사용하여 데이터베이스 쿼리의 응답 시간을 최소화하거나, 해시 테이블을 사용하여 데이터 접근 시간을 최적화할 수 있습니다.
            
              이러한 최적화 문제는 수학적 모델링과 알고리즘을 통해 접근됩니다.
            
          
        
      
      6. 확률론과 통계 : 일부 자료구조는 확률론과 통계적 방법에 기반을 둔 설계가 필요합니다.
        
          예를 들어, 블룸 필터와 같은 확률적 자료구조는 데이터의 존재를 빠르게 검사하면서 오차를 허용하는 구조입니다.
            
              이러한 자료구조는 확률론적 모델을 사용하여 성능과 오차 확률을 예측합니다.
            
          
        
      
    
  


👉 이처럼 수학은 자료구조의 설계, 분석, 최적화 및 검증에 깊이 관여하여, 효율적인 소프트웨어 시스템과 알고리즘의 개발을 가능하게 합니다.
👉 수학적 사고는 컴퓨터 과학에서 중요한 문제 해결 도구로 활용되며, 이를 통해 보다 정교하고 효율적인 프로그래밍이 이루어집니다.

3. 수학과 알고리즘.

🙋‍♂️ 수학과 알고리즘 사이의 상관관계는 컴퓨터 과학에서 매우 깊고 중요합니다. 수학은 알고리즘의 기초를 제공하며, 효율적인 알고리즘 설계와 분석을 위해 필수적인 도구와 개념들을 제공합니다.

  다음은 수학이 알고리즘과 어떻게 연결되는지에 대한 몇 가지 주요 사례입니다.
    
      1. 알고리즘 분석 : 알고리즘의 효율성을 평가하기 위해 수학적 도구가 필수적입니다. 시간 복잡도와 공간 복잡도를 정량화하기 위해 빅 오 표기법(O-notation), 빅 세타 표기법(Θ-notation), 빅 오메가 표기법(Ω-notation)등이 사용됩니다.
        
          이러한 복잡도 분석은 알고리즘을 선택하고 최적화하는 데 중요한 기준을 제공합니다.
        
      
      2. 최적화 : 수학적 최적화 기법은 알고리즘에서 특정 목표(예: 최소 비용, 최대 이익, 최소 시간)를 달성하기 위해 사용됩니다.
        
          선형 프로그래밍, 정수 프로그래밍. 동적 프로그래밍 등의 방법이 알고리즘 설계에 자주 사용됩니다.
            
              이러한 방법들은 복잡한 문제를 더 효율적으로 해결할 수 있도록 도와줍니다.
            
          
        
      
      3. 그래프 이론 : 그래프 이론은 네트워크 경로, 소셜 네트워크, 웹 페이지 링크 구조와 같은 다양한 알고리즘 문제를 표현하고 해결하는 데 사용됩니다.
        
          최단 경로 찾기(다익스트라 알고리즘, 벨만-포드 알고리즘), 최소 신장 트리(프림 알고리즘, 크루스칼 알고리즘)와 같은 알고리즘은 모두 그래프 이론을 기반으로 합니다.
        
      
      4. 확률론과 통계 : 확률론은 불확실성 하에서 문제 해결과 의사 결정에 중요한 역할을 합니다.
        
          예를 들어, 랜덤화 알고리즘, 몬테 카를로 방법, 라스베가스 알고리즘과 같은 확률적 알고리즘은 이론적 분석과 함께 실제 응용에서도 중요합니다.
          또한, 기계 학습 알고리즘의 기초로서 확률 모델을 사용합니다.
        
      
      5. 논리학 : 수학적 논리는 알고리즘의 정확성을 증명하는 데 필요합니다.
        
          증명 기법, 예를 들어 귀납법과 수학적 귀납법은 알고리즘의 정확성을 보장하며, 특정 조건에서의 알고리즘의 동작을 증명하는 데 사용됩니다.
        
      
      6. 기하학과 알고리즘 : 기하학은 컴퓨터 그래픽, 로봇 공학, 컴퓨터 비전 들에서 중요한 알고리즘을 제공합니다.
        
          예를 즐어, 충돌 감지, 물체 인식, 경로 계획 등에 사용되는 계산 기하학은 복잡한 기하학적 구조를 효율적으로 계산하는 알고리즘을 개발하는 데 필요합니다.
        
      
    
  


👉 이와 같이, 수학은 알고리즘을 설계하고 분석하는 데 필수적인 도구이며, 효율적이고 신뢰할 수 있는 소프트웨어 시스템을 개발하는 데 중요한 역할을 합니다.
👉 수학적 사고는 알고리즘의 성능을 최적화하고 문제 해결과정을 체계화 하는 데 큰 도움이 됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        </ul>
    
</div>
<div class="pagination">
    <nav class="pagination-container">
        <button class="pagination-button" id="prev-button" aria-label="Previous page" title="Previous page">
            &lt;
        </button>
    
        <div id="pagination-numbers"></div>
      
        <button class="pagination-button" id="next-button" aria-label="Next page" title="Next page">
            &gt;
        </button>
    </nav>
</div>
                
            </div>
        </div>
        <div id="search">
    <div class="wave"></div>
    <div class="wave"></div>
    <div class="wave"></div>

    <div class="search-box">
        <mark>Touch background to close</mark>
        <div class="input-box">
            <input id="search-input" type="search" tabindex="1" spellcheck="false" placeholder="Search...">
            <button id="btn-clear">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"></path></svg>
            </button>
        </div>
        <ul id="search-result"></ul>
    </div>
</div>
    </body>
    <script defer src="/assets/js/background.js"></script>
<script defer src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }

    gtag('js', new Date());
    gtag('config', '');
</script>
    
        <script src="/assets/js/subject.js"></script>
    
    <script src="/assets/js/common.js"></script>
    <script defer>
    var posts = [];

    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > AWS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/AWS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > CPP_DS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/CPP_DS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > CS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/CS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > DataStructure",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/DataStructure/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Database",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Database/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > HackTheSwift",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/HackTheSwift/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Leet-Code",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Leet-Code/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > MySQL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/MySQL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Network",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Network/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > OS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/OS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Read English Book",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Read%20English%20Book/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > SQL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/SQL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > TIL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/TIL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Web",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Web/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Algorithm > 2024",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Algorithm/2024/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Algorithm",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Algorithm/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > AWS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/AWS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > CS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/CS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > DB",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/DB/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > ENG",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/ENG/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Math",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Math/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Network",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Network/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Post",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Post/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Spring",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Spring/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > TIL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/TIL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Java > Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Java/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Java > Java多識",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Java/Java%E5%A4%9A%E8%AD%98/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "SQL > 2024",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/SQL/2024/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "SQL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/SQL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "👾 Day 1 - Variables",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift",
            'url'      : "/2024/HackTheSwift/2024-01-14-Variables.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-15"
        });
    

        posts.push({
            'title'    : "📝 스위프트에 왜 변수가 있을까?",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift, Article",
            'url'      : "/2024/HackTheSwift/2024-01-14-WhyDoseSwiftHaveVariables.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-15"
        });
    

        posts.push({
            'title'    : "📝 배열의 용량 vs 배열의 길이",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-16-ArrayCapacity-VS-Length.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-18"
        });
    

        posts.push({
            'title'    : "👾 Day 2 - String And Integers",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift, Programming",
            'url'      : "/2024/HackTheSwift/2024-01-18-StringAndIntegers.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-18"
        });
    

        posts.push({
            'title'    : "👾 Day 2 - Multi-line String",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift",
            'url'      : "/2024/HackTheSwift/2024-01-18-Multi-line-String.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 기본 배열 작업",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-BasicArrayOperations.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 1(배열의 끝에 삽입하기-Inserting at the End of an Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAtTheEndOfAnArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 2(배열의 시작 부분에 삽입하기 - Inserting at the Start of an Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAtTheStartOfAnArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 3(배열의 아무 곳에나 삽입하기 - Inserting Anywhere in the Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAnywhereInTheArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "🆙 [LeetCode] 1089.Duplicate Zeros.",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-20-DuplicateZeros.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-20"
        });
    

        posts.push({
            'title'    : "🆙 [LeetCode] 88.Merge Sorted Array.",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-22-MergeSortedArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-21"
        });
    

        posts.push({
            'title'    : "👾[Day 3] Doubles and Booleans",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "swift, programming",
            'url'      : "/2024/HackTheSwift/2024-01-22-DoubleAndBool.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-22"
        });
    

        posts.push({
            'title'    : "🌐[Network] 웹소켓(WebSocket)",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Server, Back-end",
            'url'      : "/2024/Network/2024-01-22-webSocket.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "🌐[Network] HTTP 통신.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, HTTP",
            'url'      : "/2024/Network/2024-01-23-HTTP.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "🌐[Network] 패킷(Packet)",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-01-23-Packet.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea.",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-25-TheOldManAndTheSea.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-25"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (2).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-26-TheOldManAndTheSea2.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-26"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (3).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-27-TheOldManAndTheSea3.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-26"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (5).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-29-TheOldManAndTheSea5.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-28"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (4).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-28-TheOldManAndTheSea4.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수 선언.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java",
            'url'      : "/2024/Java/2024-02-01-VariableDeclaration.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-01"
        });
    

        posts.push({
            'title'    : "🌐 [AWS] IAM이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Cloud platform",
            'url'      : "/2024/AWS/post-01.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [AWS] VPC?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "VPC",
            'url'      : "/2024/AWS/post-04.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [Network, AWS] Subnet이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/2024/AWS/post-03.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [Network, AWS] Routing Table이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "Network, AWS",
            'url'      : "/2024/AWS/post-02.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (6).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-02-03-TheOldManAndTheSea6.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-03"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크 기초 용어.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-03-networkBasicTerm1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-04"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 컬럼명 변경, 순서변경, 타입변경, 추가.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-05-COLUMN1.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-05"
        });
    

        posts.push({
            'title'    : "🌐[Network] 시스템(System).",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-05-system.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "🌐[Network] 인터페이스(Interface).",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-05-interface.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (7).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-02-06-TheOldMadAndTheSea7.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "☕️[JAVA] Packaing 옵션.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "JAVA, Programming language",
            'url'      : "/2024/Java/2024-02-06-JavaFormat.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "☕️[JAVA] while문과 for문.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, programming language",
            'url'      : "/2024/Java/2024-02-07-loop.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스코프 존재 이유 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming language",
            'url'      : "/2024/Java/2024-02-07-scope1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-07"
        });
    

        posts.push({
            'title'    : "🌐[Network] 전송매체.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-08-TransmissionMedia.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 형변환 정리.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-09-typecasting.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-09"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 라이브러리 살펴보기",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framwork",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-09-springFramework1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-09"
        });
    

        posts.push({
            'title'    : "🌐[Network] 프로토콜.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-10-protocol.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 향상된 for문",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-11-foreach.html",
            'image'    : "/assets/img/thumbnail/forloop.jpeg",
            'date'     : "2024-02-11"
        });
    

        posts.push({
            'title'    : "🍃[Spring Boot] 스프링?",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring Boot, Framework, Spring",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-13-Spring.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드(2)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-method2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드정의",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-method3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 반환타입.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-methodReturnType.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-methodStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 리펙토링 - 입.출금",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-14-JavaRefAccount1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-14"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-14-aboutNetwork.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-14"
        });
    

        posts.push({
            'title'    : "💾[Database] DBMS의 분류",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/2024/Database/2024-02-15-classificationOfDBMS.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "💾[Database] 데이터베이스의 정의와 특징",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/2024/Database/2024-02-15-databaseDefinition.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 파트 정리.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-15-methodSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스가 필요한 이유.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-15-whyWeNeedClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 인터넷",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Internet",
            'url'      : "/2024/Network/2024-02-15-internet.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 표준화",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Standardization",
            'url'      : "/2024/Network/2024-02-15-standardization.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Route 53에 등록된 서브도메인 github page에 연결하기",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/2024/AWS/post-05.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "💾[Database] SQL의 개요",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database, SQL",
            'url'      : "/2024/Database/2024-02-16-IntroSQL.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-classIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스, 객체, 인스턴스 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-termSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 사용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-useObject.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] MySQL Server Start/Stop",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-16-trobleshootingMysql1.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 배열 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-17-arrayIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🍃[Spring] MVC와 템플릿 엔진",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-17-mvcAndTemplateEngine.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 정적 컨텐츠",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-17-staticContent.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 테이블에 데이터 입력 INSERT INTO",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-InsertInto.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] null 컬럼 변경하기.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-nullColumn.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] SELECT 조회 결과 LIMIT 1000 ROW 해제하기.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-selectAndLimit.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 테이블 삭제하기",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-19-drop.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🍃[Spring] API",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-18-apiSummary.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 배열 도입 - 리팩토링",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-19-arrayIntro-refactoring.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(1)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-20-referenceAndPrimitive.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(2) - 변수 대입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-20-referenceAndPrimitive2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] null",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-null.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(3) - 메서드 호출",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-referenceAndPrimitive3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 참조형과 메서드 호출 - 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-referenceTypesAndMethodCalls.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 초기화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-variableAndInit.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "🌐[Network] 시스템의 구분",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-21-systemClassification.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "🍃[Spring] Gradle과 Maven",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework, Build System",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-21-buildSystem.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] NullPointerException",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-22-NullPointerException.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(1)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-22-procedure-oriented-programming(1).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 지향 프로그래밍 vs 절차 지향 프로그래밍",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-OOPvsPOPsummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 메서드",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-classAndMethod.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 지향 프로그래밍",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-object-oriented-programming.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(2)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-procedure-oriented-programming(2).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(3)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-procedure-oriented-programming(3).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 필요한 이유",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-init(1).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-init(2).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] this",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-this.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본 생성자",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-init(3).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 오버로딩 this()",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-initOverloadingAndThis.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 - import",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-packageImport.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 - 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-packageStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 규칙",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-26-ruleOfpackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-26"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-26-usesOfPackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-26"
        });
    

        posts.push({
            'title'    : "🆙[Cpp DataStructure] 교환(Swap)과 정렬(Sort)",
            'path'     : "2024 > CPP_DS",
            'type'     : "post",
            'tags'     : "Cpp, DataStructure",
            'url'      : "/2024/CPP_DS/2024-02-27-SwapAndSort.html",
            'image'    : "/assets/img/thumbnail/cpp.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자 이해 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-27-accessModifier-1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자 이해 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-27-accessModifier-2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 종류",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 사용 - 필드, 메서드",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-4.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 사용 - 클래스 레벨",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-5.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터의 구성",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-02-29-cs.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-02-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] 캡슐화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-01-Encapsulation.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 메모리 구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-JavaMemoryStructure.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택 영역",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-Stack.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택 영역과 힙 영역",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-StackAndHeap.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택과 큐 자료구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-StackAndQueue.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-04-static1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-04-staticVariable1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticMethod1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticMethod2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticVariable2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticVariable3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-06-staticMethod3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-06"
        });
    

        posts.push({
            'title'    : "🆙[Cpp DataStructure] 안정성(stability) 확인",
            'path'     : "2024 > CPP_DS",
            'type'     : "post",
            'tags'     : "Cpp, DataStructure",
            'url'      : "/2024/CPP_DS/2024-03-07-stableAndUnstable.html",
            'image'    : "/assets/img/thumbnail/cpp.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 상수 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndConstant1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 상수 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndConstant2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 참조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndReference.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 기능 추가",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-InheritanceAndAddingFeatures.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 메모리 구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-InheritanceAndMemoryStructure.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속관계",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-extendRelationship.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속 - 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-extendStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 메서드 오버라이딩",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-09-InheritanceAndMethodOverriding.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 접근 제어",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-10-inheritanceAndAccessControl.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 메서드에 사용되는 final",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-finalUsedInClassesAndMethods.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] super - 부모 참조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-super.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] super - 생성자",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-super2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 구조를 알아야 하는 이유",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-14-WhyYouNeedToKnowComputerArchitecture.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "💾 [CS] 패턴 매칭(Pattern Matching)과 표현 매칭(Expression Matching)",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-14-patternMatchingAndExpressionMatching.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성과 캐스팅",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-14-polymorphismAndCasting.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성(Polymorphism) 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-14-polymorphismStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다운캐스팅과 주의점",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-DowncastingAndPrecaution.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 캐스팅의 종류",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-TypesOfCasting.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] instanceof",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-instanceof.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성과 메서드 오버라이딩",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-17-polymorphismAndMethodOverriding.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-17"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 구조의 큰 그림",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-18-TheBigPictureOfComputerArchitecture.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-19-TakeAdvantageOfPolymorphism3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상 클래스 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-20-AbstractClass1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상 클래스 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-20-AbstractClass2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-20"
        });
    

        posts.push({
            'title'    : "💾 [CS] 0과 1로 숫자를 표현하는 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-21-HowToRepresentNumbersWithZeroAndOne.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 메모리를 16진수로 표시하는 이유",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-21-whyIsComputerMemoryExpressedInhex.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-21-Interface.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스 - 다중구현",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-22-Interface-MultipleImplementation.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 인터페이스 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-22-UsingClassesAndInterfaces.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-23-Polymorphism-RoleImplementatioonExample1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 좋은 객체 지향 프로그래밍이란?",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-23-WhatIsGoodOOP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-24-Polymorphism-RoleImplementatioonExample2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-24"
        });
    

        posts.push({
            'title'    : "💾 [CS] 0과 1로 문자를 표현하는 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-25-HowToRepresentCharactersWithZeroAndOne.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] OCP(Open-Closed Principle) 원칙",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-25-OCP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-25-Polymorphism-RoleImplementatioonExample3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "💉[SQL] 데이터베이스 모델링",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-27-DatabaseModeling.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "💉[SQL] 테이블과 컬럼, SQL",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-27-TableColumnsAndSQL.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "🌐[Web] 웹 브라우저 작동 원리",
            'path'     : "2024 > Web",
            'type'     : "post",
            'tags'     : "Web",
            'url'      : "/2024/Web/2024-03-27-HowWebBrowsersWork.html",
            'image'    : "/assets/img/thumbnail/sparta.jpg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-28-ObjectClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] java.lang 패키지 소개",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-28-java-langPackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 배열",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-ObjectArray.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 다형성",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-ObjectPolymorphism.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] toString()",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-toString.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "💉[SQL] WHERE란?",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-29-WHERE.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "💉[SQL] AND, OR, NOT",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-30-ANDORNOT.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-30"
        });
    

        posts.push({
            'title'    : "💉[SQL] BETWEEN, IN, LIKE",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-30-BETWEENINLIKE.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-30"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object와 OCP",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-31-ObjectAndOCP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] equals() - 1.동일성과 동등성",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-31-equals1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "💉[SQL] SQL 문의 기본 구조, SQL",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-31-sql.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "💾 [CS] 소스코드와 명령어",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-01-SourceCodeAndCommands.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] equals() - 2. 구현",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-01-equals2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "💉[SQL] SUM, AVG, COUNT, MIN, MAX",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-01-SUMAVGCOUNTMINMAX.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "💉[SQL] Query 작성시 플로우",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-01-sqlFlow.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형의 공유",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-02-SharingOfBasicTypesAndReferenceTypes.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "💉[SQL] GROUP BY",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-02-GROUPBY.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "💉[SQL] ORDER BY",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-02-ORDERBY.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-03-ImmutableObjectsIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 공유 참조와 사이드 이펙트",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-03-SharedReferencesAndSideEffects.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-03"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어의 구조",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-04-commandStructure.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 예제",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-04-ImmutableObjectExample.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "💉[SQL] REPLACE, SUBSTRING, CONCAT",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-04-ReplaceSubstringConcat.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 값 변경",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-05-ImmutableObjectChangeValue.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-05-ImmutableObjectSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 기본",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-06-StringClassBasic.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-06"
        });
    

        posts.push({
            'title'    : "💾 [CS] ALU와 제어장치",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-08-ALUandControlUnit.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 비교",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-08-StringClassComparison.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 불변객체",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-09-StringClassImmutableObject.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 주요 메서드 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-09-StringClassMethod-1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] StringBuilder - 가변 String",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-10-StringBuilder.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 주요 메서드 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-10-StringClassMethod2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-10"
        });
    

        posts.push({
            'title'    : "💾 [CS] 레지스터",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-11-register.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 체이닝 - Method Chaining",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-11-MethodChaining.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 최적화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-11-StringOptimization.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-14-StringClassSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-14"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어 사이클과 인터럽트",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-15-InstructionCycleAndIntrrupts.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 기본형의 한계 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-15-WrapperClass-LimitationsOfBaseTypes1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240415 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-15-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 오토 박싱",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-AutoBoxing.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 자바 래퍼 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-JavaWrapperClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 기본형의 한계 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-LimitationOfBaseTypes2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240417 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 주요 메서드와 성능",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-18-WrapperClass-MainMethodsAndPerformance.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240418 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-18"
        });
    

        posts.push({
            'title'    : "💾 [CS] 빠른 CPU를 위한 설계 기법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-19-DesignTechniquesForFastCPUs.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어 병렬 처리 기법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-19-InstructionParallelProcessingTechnique.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] Class 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-19-Class.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] System 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-19-SystemClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240419 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-19-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 변수",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 복합 자료 구조",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 배열",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure3.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 문자열",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-22-DataStructure-2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 삽입 정렬",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-22-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "💻[Operating System] 커널(kernel)이란?",
            'path'     : "2024 > OS",
            'type'     : "post",
            'tags'     : "Operating System",
            'url'      : "/2024/OS/2024-04-22-OS-2.html",
            'image'    : "/assets/img/thumbnail/os.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "💻[Operating System] 리눅스와 우분투의 차이점",
            'path'     : "2024 > OS",
            'type'     : "post",
            'tags'     : "Operating System",
            'url'      : "/2024/OS/2024-04-22-OS.html",
            'image'    : "/assets/img/thumbnail/os.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240422 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-22-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 문제 정의와 선형 스캔",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-23-DataStructure-2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-23"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 변수와 배열이 중요한 이유와 이진 탐색",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-23-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-23"
        });
    

        posts.push({
            'title'    : "💾 [CS] CISC와 RISC",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-25-CISCandRISC.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] Math, Random 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-26-MathAndRandomClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-26"
        });
    

        posts.push({
            'title'    : "[AnD] 두 수의 합.",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "Algorithm, DataStructure",
            'url'      : "/Algorithm/2024/2024-05-01-AnD-1.html",
            'image'    : "/assets/img/thumbnail/AnD.jpeg",
            'date'     : "2024-05-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바란?",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-01-AboutJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-01"
        });
    

        posts.push({
            'title'    : "[Math] 기초수학 - 소개",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-02-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240502 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-02-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 소개",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-02-IntroJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 코테 맛보기(1) - 코테를 위한 자바 프로그래밍 언어 사용 숙련도",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-02-TasteTheCodingTest-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 코테 맛보기(2) - 코테를 위한 자료구조와 알고리즘 개념 구현 방법 숙지",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-02-TasteTheCodingTest-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 변수와 자료형(1)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-02-VariablesAndDataTypes-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240503 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-03-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 타입 비교.",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-03-TypeComparison.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 변수와 자료형(2)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-03-VariablesAndDataTypes-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 자료형(3)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-03-VariablesAndDataTypes-3.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240504 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-04-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 자료형(4)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-04-VariablesAndDataTypes-4.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-04"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240505 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-05-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 여러가지 연산자(2)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-05-VariousOperator-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 여러가지 연산자(1)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-05-VariousOperators-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 조건문",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-05-conditionalStatement.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "💾 [CS] 메모리의 주소 공간",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-06-addressSpaceInMemory.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240506 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-06-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "☕️[Java] 반복문",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-06-loopStatement.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240507 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-07-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 객체(1)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-07-ClassesAndObjects-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다차원 배열",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-07-MultidimensionalArray.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240508 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-08-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 객체(2)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-08-ClassesAndObjects-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-08"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240509 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-09-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-09-Inheritance.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-09"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240510 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-10-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상클래스",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-10-abstractClass.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-10-polymorphism.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "📝[blog post] 프론트엔드와 백엔드는 무엇이 다를까?(+내가 백엔드 개발자가 되고 싶은 이유)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "제로베이스, 백엔드, Java, Spring, 개발자, 백엔드공부, 백엔드스쿨",
            'url'      : "/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240511 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-11-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 내부 클래스",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-11-InnerClass.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 입출력(1)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-11-Input-Output-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-11-Interface.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240512 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-12-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 예외 처리",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-12-ExceptionHandling.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 입출력(2)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-12-Input-Ouput-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240513 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-13-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 컬렉션 프레임워크",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-13-CollectionFramework.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] HashMap에 key 값은 항상 int 여야 할까요?",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 람다식",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-13-lambda.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 람다식은 하나만!",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-13-lambdaIsOnlyOne.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240514 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-14-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스트림",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-14-Stream.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-14"
        });
    

        posts.push({
            'title'    : "📝[blog post] 연습 문제 풀이 정리(1)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging",
            'url'      : "/Backend/Post/2024-05-16-PracticeSummary-1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-16"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240516 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-16-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-16"
        });
    

        posts.push({
            'title'    : "📝[blog post] 연습 문제 풀이 정리(2)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging",
            'url'      : "/Backend/Post/2024-05-17-PracticeSummary-2.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240517 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 예외 처리 - 트러블슈팅",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-17-ExceptionHandling-Troubleshooting.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-18-Math-1.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "[Math] 수학적 귀납법",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-18-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "📝[blog post] 나는 어떤 백엔드 개발자가 되고 싶은걸까?",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "제로베이스, 백엔드, Java, Spring, 개발자, 백엔드공부, 백엔드스쿨",
            'url'      : "/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240518 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 문자열 비교 - 트러블슈팅",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-05-18-Troubleshooting-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "💾 [CS] RAID의 정의와 종류",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-21-RAID.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 자료구조 소개",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-21-IntroDataStructureAndAlgorithm.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 선형 자료구조 - 배열",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-21-linearDS-Array.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240521 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-21-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "💾 [CS] 다양한 보조기억장치",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-22-VariousAuxiliaryMemoryDevices.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-22"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240522 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-22-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-22"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 큐(Queue)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-23-Queue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 원형 큐(Circular Queue)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-23-circularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240523 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-23-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 해시(Hash)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-24-Hash.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-24"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240524 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-24-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-24"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 해시 테이블(Hash Table)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-25-HashTable.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-25"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240525 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-25-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-25"
        });
    

        posts.push({
            'title'    : "💾 [CS] 장치 컨트롤러와 장치 드라이버",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-27-dviceControllerAndDeviceDriver.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 이진 트리(Binary Tree)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-27-BinaryTree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 완전 이진 트리(Complete Binary Tree)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-27-CompleteBinaryTree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 노드(Node)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-27-Node.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 트리(Tree)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-27-Tree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240527 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-27-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 스택(Stack)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-28-Stack.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-28"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240528 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-28-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-28"
        });
    

        posts.push({
            'title'    : "💾 [CS] 다양한 입출력 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-30-VariousInputOutputMethods.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-29"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240529 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-29-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-29"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 큐(Queue)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-05-30-Queue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-30"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240530 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-30-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-30"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 배열에서 특정 인덱스의 요소를 삭제하기.",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-06-01-RemoveSpecificIndexFromArray.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-01"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240601 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-01-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-01"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Java의 배열.",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-06-02-ArrayOfJava.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "📝[blog post] Java Docs 보는 방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging, Documentation",
            'url'      : "/Backend/Post/2024-06-02-HowToReadJavaDocs.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240602 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-02-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240603 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-03-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] IntStream",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-06-03-IntStream.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-03"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Deque(데크, 덱)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-06-05-Deque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-05"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240605 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-05-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-05"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] ArrayDeque",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-06-06-ArrayDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-06"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240606 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-06-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-06"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] LinkedList를 사용한 Deque.",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-06-07-LinkedListDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-07"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240607 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-07-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-07"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240608 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-08-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 제네릭(Generic)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-06-08-Generic.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] Primitive Type과 Wrapper Class.",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-06-08-PrimitiveAndWrapper.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)란?",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-06-09-CircularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240609 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-09-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성(Polymorphism)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-06-09-polymorphism.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Deque에서의 front와 rear의 변화.",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-06-10-ChangeBetweenFrontAndRearInDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-10"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240610 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-10-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-10"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240611 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-11-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-11"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)의 중간 지점 찾기.",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-06-12-CircularQueueFindMiddleIndex.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-12"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240612 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-12-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-12"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 알고리즘(Algorithm)",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-06-13-AboutAlgorithm.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)를 배열로 구현시 rear를 -1으로 설정하지 않는 이유.",
            'path'     : "Algorithm > 2024",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Algorithm/2024/2024-06-13-ReasonOfRearIsntSetToMinusOneInCircularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240613 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-13-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📚[ENG] 240616 Studing English through Newsletters",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study, Newsletters",
            'url'      : "/Backend/ENG/240616-ENG-STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-16"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240616 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-16-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-16"
        });
    

        posts.push({
            'title'    : "[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-06-17-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-06-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240617 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-17"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 클라우드 컴퓨팅의 유형",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240615_Types_of_Clould_Computing.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📚[ENG] 제목만 해석하는 영어 공부 :) ",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study",
            'url'      : "/Backend/ENG/240618_ENG_STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240618 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📚[ENG][240621] 제목만 해석하는 영어 공부 :)",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study",
            'url'      : "/Backend/ENG/240621-ENG-STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 프로그래밍 언어와 자바",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-06-24-ProgrammingLanguageAndJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-24"
        });
    

        posts.push({
            'title'    : "📝[Post] 서버와 클라이언트의 개념(1)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-06-27-ServerAndClient-1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-06-27"
        });
    

        posts.push({
            'title'    : "☁️[AWS] HOSTNAME 바꾸는 방법",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240709_AWS_HOSTNAME.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-09"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023 플랫폼에 MySQL 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240710_AWS_MYSQL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-10"
        });
    

        posts.push({
            'title'    : "📝[Post] Spring과 SpringBoot의 개념.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-07-11-SpringAndSpringBoot.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-11"
        });
    

        posts.push({
            'title'    : "☁️[AWS] .gradlew 빌드 실패시 확인해야 할 것들",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240714_AWS_GRADLEW.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-14"
        });
    

        posts.push({
            'title'    : "💾[Database] 데이터베이스의 정의와 특징.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-07-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 프로그래밍 언어와 자바",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-07-16-Variable.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-16"
        });
    

        posts.push({
            'title'    : "📝[Post] 자바다식(Java多識) - 1",
            'path'     : "Java > Java多識",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Java/Java%E5%A4%9A%E8%AD%98/2024-07-19-no1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-19"
        });
    

        posts.push({
            'title'    : "📝[Post] 자바다식(Java多識) - 2",
            'path'     : "Java > Java多識",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Java/Java%E5%A4%9A%E8%AD%98/2024-07-19-no2.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023에 Java8 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240726_AWS_JAVA_INSTALL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-26"
        });
    

        posts.push({
            'title'    : "💾[Database] MySQL DB에 한글 삽입.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database, MySQL",
            'url'      : "/Backend/DB/2024-07-26-korean-mysql.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-07-26"
        });
    

        posts.push({
            'title'    : "📝[Post] 아이피와 포트",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-07-28-ipAndport.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] @EntityListeners 어노테이션.",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-07-31-EntityListeners.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] Main 클래스 생성 후 오류 대처.",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-07-31-MainBuildFail.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] attribute의 의미와 역할",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-07-31-attribute.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "💾[Database] 트랜잭션의 의미와 역할.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/Backend/DB/2024-08-01-Transaction.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-08-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] ObjectMapper 클래스, 직렬화와 역직렬화",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-01-SerializationAndDeserialization.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] @Transactional의 역할과 의미.",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-02-Transactional.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-02"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2에 Java8 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240804_AWS_JAVA8_INSTALL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] @RequiredArgsConstructor의 역할.",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-05-RequiredArgsConstructor.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-05"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 클라우드(Cloud)란?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240807_AWS_CLOUD.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 온프레미스(on-premise)란?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240807_AWS_ON-PREMISE.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "📝[Post] 정적 웹사이트와 동적 웹사이트.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-07-webpage.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 로컬 파일을 EC2 서버에 올리는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240809_AWS_EC2_UPLOAD.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-09"
        });
    

        posts.push({
            'title'    : "🌐[Network] CIDR이란?",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-09-network-cidr.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-09"
        });
    

        posts.push({
            'title'    : "📝[Post] Nginx 설치방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-11-Nginx.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-11"
        });
    

        posts.push({
            'title'    : "🌐[Network] IP주소(Address)는 네트워크의 번지(주소)",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-14-network-ip.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-14"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 서비스 제공 형태에 따른 클라우드 분류.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/2024_08_15_AWS_CLOULD_CLASSIFICATION.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Bastion Host란?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_BASTION_HOST.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 인바운드 규칙(Inbounds Rules)와 아웃바운드 규칙(Outbound Rules)",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_RULES.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 서버리스, 개방형 클라우드와 폐쇄형 클라우드",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_ServerlessAndOpenAndClosedClould.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 가상화",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_Virtualization.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크 기초 용어.",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-15-network-basic-term.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] CIDR(Classless Inter-Domain Routing) 블록으로 IP 주소 범위 결정.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_CIDR_BLOCK.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 도메인 이름과 IP 주소를 연결하는 DNS.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_DNS.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 방화벽에서 허용된 통신만 통과.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_FIREWALL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] IP 주소(Address)는 네트워크의 번지(주소)",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_IP_ADDRESS.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 부하 분산을 위해 여러 서버에 접속을 분배",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_LOAD_BALANCER.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 퍼블릭 IP 주소와 프라이빗 IP 주소",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_PUBLIC_IP_AND_PRIVATE_IP.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 라우팅 및 라우팅 테이블.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_Routing_And_Routing_Table.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "🌐[Network] 시스템 기초 용어.",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-16-system-basic-term.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "🌐[Network] OSI 7계층 모델.",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-18-OSI.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-18"
        });
    

        posts.push({
            'title'    : "🌐[Network] 구조적 모델",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-18-structural-model.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-18"
        });
    

        posts.push({
            'title'    : "📝[Post] OpenVPN 클라이언트의 IP 주소와 OpenVPN 서버에서 할당된 서브넷 정보 가져오는 방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-16-openvpn-client-ip.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-18"
        });
    

        posts.push({
            'title'    : "📝[Post] OpenVPN Password 변경방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-18-openvpn-change-passwd.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-18"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023에 nvm 설치와 node.js 버전 바꾸는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_NVM.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] NAT 게이트웨이.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_NAT_GATEWAY.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023에 Nginx 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_Nginx_FireWalld.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 라우팅 정보를 설정해 인터넷과 통신.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_ROUTING_INFO.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 서브넷?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_SUBNET.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 테넌시(Tenancy)",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_TENANCY.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 가상 네트워크 Amazon VPC",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_VPC.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] VPC 접근 제어 및 통신 로그 확인.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_VPC_ACCESS_CONTROL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] VPC 및 서브넷 생성.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_VPC_AND_SUBNET.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크 세그먼트(Network Segment).",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-19-Network-Segment.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "🌐[Network] 프로토콜과 인터페이스(Protocol and Interface)",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-19-protocol-and-interface.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux CLI에 Gradle 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240820_AWS_INSTALL_GRADLE.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-20"
        });
    

        posts.push({
            'title'    : "🌐[Network] 인터넷의 계층 모델",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-20-Internet-layer-model.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] java.lang 패키지",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-21-Java-lang.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 클래스",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-21-Object-Class.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 다형성",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-21-Object-Polymorphism.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-21"
        });
    

        posts.push({
            'title'    : "🍃[Spring] slf4j와 logback.",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-08-22-logging-framework.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-08-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 배열",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-22-Object-Array.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-22"
        });
    

        posts.push({
            'title'    : "💾 [CS] 싱글톤 패턴",
            'path'     : "Backend > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/Backend/CS/2024-08-23-Singleton.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-08-23"
        });
    

        posts.push({
            'title'    : "🍃[Spring] Welcome Page 구현 및 동작 방법.",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-08-23-Thymeleaf.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-08-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스 메서드와 인스턴스 메서드",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-23-Class-Instance-Method.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] toString()",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-23-toString.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-23"
        });
    

        posts.push({
            'title'    : "🌐[Network] 인터네트워킹",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-24-Internetworking.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-24"
        });
    

        posts.push({
            'title'    : "🍃[Spring] API.",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-08-24-API.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-08-24"
        });
    

        posts.push({
            'title'    : "🍃[Spring] MVC와 템플릿 엔진.",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-08-24-MVC-Template-engine.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-08-24"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 일반적인 웹 애플리케이션 계층 구조와 클래스 의존관계.",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-08-24-Summary-of-business-requirements.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-08-24"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 정적 컨텐츠.",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-08-24-static-content.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-08-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object와 OCP - 1",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-25-Object-OCP-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object와 OCP - 2",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-25-Object-OCP-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] equals() - 1, 동일성과 동등성",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-25-equals-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] equals() - 2, 구현.",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-26-equals-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-26"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형의 공유",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-27-primitive-reference-type.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-27"
        });
    

        posts.push({
            'title'    : "🌐[Network] 프로토콜",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-28-Protocol.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 도입",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-28-Immutable-Object.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 공유 참조와 사이드 이펙트",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-28-shared-reference-and-side-effects.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-28"
        });
    

        posts.push({
            'title'    : "💾 [CS] 의존성 주입(DI, Dependency Injection)",
            'path'     : "Backend > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/Backend/CS/2024-08-29-di.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-08-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] .equalsIgnoreCase()",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-30-equalsIgnoreCase-method.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-30"
        });
    

        posts.push({
            'title'    : "☕️[Java] 테스트 코드와 Dependancy Injection",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-30-test-and-di.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-30"
        });
    

        posts.push({
            'title'    : "☕️[Java] 테스트 코드와 Reflection.",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-30-test-and-reflection.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-30"
        });
    

        posts.push({
            'title'    : "💾 [CS] 추상화(Abstraction)",
            'path'     : "Backend > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/Backend/CS/2024-08-31-Abstraction.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-08-31"
        });
    

        posts.push({
            'title'    : "💾 [CS] 팩토리 패턴(factory pattern)",
            'path'     : "Backend > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/Backend/CS/2024-08-31-Factory-pattern.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-08-31"
        });
    

        posts.push({
            'title'    : "🌐[Network] 주소의 표현",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-31-address-presentaion.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 예제",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-08-31-Immutable-Object.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-31"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 빈(Bean)이란?",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-09-01-bean.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-09-01"
        });
    

        posts.push({
            'title'    : "🍃[Spring] `@Controller` 애너테이션 사용시 일어나는 일.",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-09-01-when-use-controller-annotation.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-09-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 문제와 풀이",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-01-Immutable-Object-Solve.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 정리",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-01-Immutable-object-summary.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 값 변경",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-01-ImmutableObject-Value-Change.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-01"
        });
    

        posts.push({
            'title'    : "💾 [CS] 비즈니스 로직(Business Logic)이란?",
            'path'     : "Backend > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/Backend/CS/2024-09-02-Business-Logic.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-09-02"
        });
    

        posts.push({
            'title'    : "💾 [CS] 도메인(Domain)의 의미.",
            'path'     : "Backend > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/Backend/CS/2024-09-02-domain.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-09-02"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 의존성 주입(Dependency Injection)을 통한 느슨한 결합(Loose Coupling) 유지.",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-09-02-DI-LC.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-09-02"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 계층형 아키텍처(Layered Architecture), 3계층 아키텍처(Three-Tier Architecture)",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-09-02-Layered-Architecture.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-09-02"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 스프링 컨테이너(Spring Container)란?",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-09-02-container.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-09-02"
        });
    

        posts.push({
            'title'    : "💾 [CS] 전략 패턴(Strategy pattern)",
            'path'     : "Backend > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/Backend/CS/2024-09-03-stratege-pattern.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-09-03"
        });
    

        posts.push({
            'title'    : "🌐[Network] 주소와 이름",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-09-03-address-and-name.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-09-03"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 자바 코드로 직접 스프링 빈 등록하기.",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-09-03-java-spring.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-09-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 기본",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-03-string-basic.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-03"
        });
    

        posts.push({
            'title'    : "💾 [CS] API(Application Programming Interface)",
            'path'     : "Backend > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/Backend/CS/2024-09-04-API.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-09-04"
        });
    

        posts.push({
            'title'    : "🍃[Spring] `@SpringBootTest` 애노테이션",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-09-04-SpringBootTest-Annotation,md.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-09-04"
        });
    

        posts.push({
            'title'    : "🍃[Spring] `@Transactional` 애노테이션",
            'path'     : "Backend > Spring",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/Backend/Spring/2024-09-04-Transactional-Annotation.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-09-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 비교",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-04-String-comparison.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] JDBC(Java Database Connectivity)",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-04-jdbc.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-04"
        });
    

        posts.push({
            'title'    : "💾 [CS] 옵저버 패턴(Observer pattern)",
            'path'     : "Backend > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/Backend/CS/2024-09-05-observer-pattern.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-09-05"
        });
    

        posts.push({
            'title'    : "🌐[Network] 주소 정보의 관리",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-09-05-address-info-management.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-09-05"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크 기초 - Summary",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-09-05-network-basic-summary.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-09-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 불변 객체",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-05-immutable-object-string.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-05"
        });
    

        posts.push({
            'title'    : "💾 [CS] 프록시 패턴과 프록시 서버",
            'path'     : "Backend > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/Backend/CS/2024-09-07-proxy-pattern-and-server.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-09-07"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크 개념 - 프로토콜의 이해",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-09-07-understand-of-protocol.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-09-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 최적화",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-07-String-Optimization.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] StringBuilder - 가변 String",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-07-StringBuilder.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 체이닝 - Method Chaining",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-07-method-chaining.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] Strig 클래스를 StringBuilder 클래스로 변환하는 방법.",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-08-String-and-StringBuilder.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스의 앞뒤 공백 제거 방법.",
            'path'     : "Java > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Java/Java/2024-09-08-String-trim-strip.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-09-08"
        });
    

        posts.push({
            'title'    : "💉[SQL] 데이터베이스와 DBMS",
            'path'     : "SQL > 2024",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/SQL/2024/2024-09-10-database-and-dbms.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-09-10"
        });
    

        posts.push({
            'title'    : "💾 [CS] 프록시 패턴과 프록시 서버 - 2",
            'path'     : "Backend > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/Backend/CS/2024-09-11-proxy-pattern-and-server-2.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-09-11"
        });
    

    searchPost(posts);

    
</script>
</html>

---
title: 🍃[Spring] 연관관계 사용시 고려해야 할 사항들은 무엇이 있을까요?
tags:
    - Spring
    - Framework
date: "2024-11-14"
thumbnail: "/assets/img/thumbnail/spring.jpeg"
---

# 🍃[Spring] 연관관계 사용시 고려해야 할 사항들은 무엇이 있을까요?
- JPA에서 **연관관계를 사용할 때**는 여러 가지 측면을 고려해야 합니다.
- 연관관계를 적절히 설정하지 않으면 성능 저하, 복잡한 트랜잭션 관리, 유지보수성 저하 등의 문제를 초래할 수 있기 때문입니다.

## 1️⃣ 연관관계 사용시 고려해야 할 항목들.

### 1️⃣ 연관관계의 방향(단방향 vs 양방향)

#### 1️⃣ 단방향 연관관계.
- 한쪽 엔티티만 다른 엔티티를 참조하는 관계입니다.
- 단방향 연관관계는 설계와 관리가 간단하고 성능 최적화에도 유리합니다.

#### 2️⃣ 양방향 연관관계.
- 서로 참조하는 관계로, 두 엔티티 간의 관계를 명확히 하고 객체 그래프 탐색이 더 쉬워집니다.
    - 하지만 양방향 연관관계는 서로 참조하면서 복잡성이 증가하고, 데이터 직렬화 과정에서 무한 루프가 발생할 수 있으므로 신중하게 사용해야 합니다.

> 🙋‍♂️ 데이터 직렬화(Serialization)
> 
> **데이터 직렬화(Serialization)는** 객체 또는 데이터 구조를 **저장하거나 전송할 수 있는 형식으로 변환하는 과정을 의미합니다.**
> 이를 통해 메모리에서 객체로 존재하는 데이터를 **파일로 저장**하거나 **네트워크를 통해 다른 시스템으로 전송할 수 있습니다.**
> 반대로, **역직렬화(Deserialization)는** 직렬화된 데이터를 다시 원래의 객체나 데이터 구조로 복원하는 과정입니다.

#### 3️⃣ 선택 기준.
- 가능하면 단방향 연관관계를 우선으로 설계하고, 양방향 연관관계가 반드시 필요한 경우에만 설정하는 것이 좋습니다.

## 2️⃣ 연관관계의 주인(Owning Side)
- 양방향 연관관계에서는 **외래 키(Foreign Key)를 관리할 연관관계의 주인**을 명확히 지정해야 합니다.
- 연관관계의 주인은 데이터베이스에 실제 외래 키(Foreign Key)를 저장하는 엔티티로, 주인이 아닌 엔티티에서 연관관계를 설정해도 데이터베이스에는 반영하지 않습니다.
- 주인을 정확하게 설정하지 않으면 데이터 불일치가 발생할 수 있으며, 데이터베이스에 불필요한 쿼리가 발생할 수 있습니다.

## 3️⃣ 지연 로딩(Lazy Loading)과 즉시 로딩(Eager Loading)

### 1️⃣ 지연 로딩(Lazy Loading).
- 연관된 엔티티를 실제로 사용할 때 데이터를 로드하는 방식입니다.
- 기본적으로 연관 관계는 지연 로딩을 사용하는 것이 성능상 유리하며, 필요한 순간에만 데이터를 가져와 성능을 최적화할 수 있습니다.

### 2️⃣ 즉시 로딩(Eager Loading).
- 엔티티를 조회할 때 연관된 모든 데이터를 즉시 로드하는 방식으로, 필요 이상으로 많은 데이터를 가져와 **N+1 문제**를 유발할 수 있습니다.

### 3️⃣ 선택 기준.
- 일반적으로 지연 로딩(Lazy Loading)을 기본으로 하고, 성능에 큰 영향이 없는 경우에만 즉시 로딩(Eager Loading)을 사용합니다.
- 즉시 로딩(Eager Loading)을 사용하면 연관된 모든 데이터를 한 번에 가져오므로, 특정 조회 시 한 번의 쿼리로 여러 데이터를 가져와야 할 때 유용합니다.

## 4️⃣ 페치 조인(Fetch Join)

### 1️⃣ 지연 로딩(Lazy Loading)에서의 페치 조인(Fetch Join)
- 지연 로딩(Lazy Loading)에서 N+1 문제를 방지하고 필요한 데이터를 한 번에 가져오기 위해 페치 조인(Fetch Join)을 사용합니다.

### 2️⃣ JPQL 쿼리에서 페치 조인(Fetch Join)
- 페치 조인(Fetch Join)은 JPQL 쿼리에서 연관된 데이터를 조인하여 함께 로드하는 방식으로, 성능 최적화에 유용합니다.
- 
### 3️⃣ 선택 기준.
- 페치 조인(Fetch Join)은 필요한 경우에만 사용하며, 쿼리 복잡성을 증가시키므로 무분별하게 사용하지 않도록 주의해야 합니다.

## 5️⃣ Cascade 옵션과 orphanRemoval

### 1️⃣ Cascade 옵션.
- 부모 엔티티에서 자식 엔티티를 함께 관리할 수 있도록 CascadeType.PERSIST, CascadeType.REMOVE 등의 옵션을 설정할 수 있습니다.
    - 예를 들어, 부모 엔티티를 저장할 때 자식 엔티티도 자동으로 저장되거나 삭제할 때 자식 엔티티도 함께 삭제될 수 있습니다.

### 2️⃣ orphanRemoval 옵션.
- 부모와의 관계가 끊긴 자식 엔티티를 자동으로 삭제하도록 설정할 수 있습니다.
    - 예를 들어, 부모 엔티티에서 자식 엔티티 리스트에서 제거되면 데이터베이스에서도 자동으로 삭제됩니다.

### 3️⃣ 선택 기준.
- Cascade와 orphanRemoval은 부모와 자식 간 생명 주기가 완전히 일치할 때만 사용하는 것이 좋습니다.
    - 그렇지 않으면 의도치 않은 데이터 삭제나 영속성 전파 문제가 발생할 수 있습니다.

> 🙋‍♂️ 영속성 전파(Persistence Propagation)
> 
> JPA에서 **하나의 엔티티에 수행한 영속성 작업이 연관된 다른 엔티티에 자동으로 전파되는 기능**을 의미합니다.
> 이를 통해 부모 엔티티가 특정 영속성 상태(예: 저장, 삭제, 병합 등)로 변경될 때, 자식 엔티티도 동일한 상태로 전이될 수 있도록 관리할 수 있습니다.
> 
> JPA에서는 이를 위헤 **Cascade 옵션**을 제공하며, 주로 연관된 여러 엔티티가 하나의 생명주기를 가질 때 사용됩니다.
> 즉, 부모와 자식 관계를 가진 엔티티가 있을 때, 부모 엔티티를 영속 상태로 만들거나 삭제하면, 자식 엔티티도 같은 작업이 자동으로 이루어집니다.

## 6️⃣ 데이터 조회 시 최적화.
- 연관관계를 통해 객체 그래프를 탐색할 때 불필요한 데이터가 과도하게 조회되지 않도록 JPQL, 네이티브 SQL, DTO 등을 활용해 필요한 데이터만 가져오는 방법을 고려해야 합니다.

### 1️⃣ DTO를 사용한 데이터 전송.
- 엔티티의 모든 데이터를 클라이언트로 보내는 대신, 필요한 정보만 담은 DTO(Data Transfer Object)를 통해 성능을 최적화할 수 있습니다.

## 7️⃣ 연관관계 설정이 반드시 필요한지 검토.
- 모든 관계를 연관관계로 설정할 필요는 없습니다.
    - 단순히 ID만 필요하거나 다른 테이블에서 특정 데이터를 조회할 때마다 사용되는 관계라면, 굳이 연관관계를 설정하지 않고 ID를 사용하여 조회하는 것이 성능상 유리할 수 있습니다.
- 데이터베이스의 관계를 모든 엔티티 간 연관관계로 설정하면 오히려 설계가 복잡해지고 성능을 해칠 수 있습니다.

## 8️⃣ 데이터 일관성 및 무결성 관리.
-  연관관계를 통해 데이터 일관성을 유지할 수 있도록, 트랜잭션 관리와 연관 관계 설정을 신중하게 해야 합니다.
-  자식 엔티티가 부모 엔티티에 강하게 종속된 경우(예: 주문과 주문 항목)에는 일관성을 유지할 수 있도록 연관관계를 적절하게 설정하고, Cascade 옵션을 통해 생명 주기를 함께 관리하는 것이 좋습니다.

## 9️⃣ 요약.
- 연관관계를 사용할 때 고려해야 할 사항은 다음과 같습니다.
    - **단방향과 양방향 중 필요한 방식을 선택**하고, 양방향 관계의 경우 반드시 주인을 명확히 설정합니다.
    - **지연 로딩(Lazy Loading)을 기본으로 사용**하며 필요할 때만 즉시 로딩(Eager Loding)이나 페치 조인(Fetch Join)을 사용합니다.
    - **Cascade 옵션과 orphanRemoval**을 신중하게 설정하여 부모-자식 관계를 관리하고, 의도하지 않은 데이터 삭제를 방지합니다.
    - 성능을 고려하여 **데이터 조회 시 최적화**하고, 필요하지 않은 관계는 연관관계는 설정하지 않는 것이 좋습니다.

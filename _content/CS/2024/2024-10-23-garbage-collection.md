---
title: "💾 [CS] 가비지 컬렉션(Garbage Collection)이란 무엇일까요?"
tags:
    - CS
date: "2024-10-23"
thumbnail: "/assets/img/thumbnail/cs.jpeg"
---

# 💾 [CS] 가비지 컬렉션(Garbage Collection)이란 무엇일까요?
- **가비지 컬렉션(Garbage Collection)은 더 이상 사용하지 않는 객체를 메모리에서 자동으로 해제하는 메모리 관리 기법입니다.**
- **자바(Java)와** 같은 프로그래밍 언어에서, 개발자가 수동으로 메모리를 해제하지 않아도 **가비지 컬렉터(Garbage Collector)가** 자동으로 불필요한 객체를 감지하고 메모리를 회수하여 **메모리 누수(Memory Leak)를** 방지합니다.

## 1️⃣ 가비지 컬렉션의 필요성.

### 1️⃣ 자동 메모리 관리.
- 가비지 컬렉션(Garbage Collection)은 프로그래머가 **메모리 할당과 해제를 직접 관리할 필요 없이, 힙 메모리(Heap Memory)에서 더 이상 참조되지 않는 객체를 자동으로 제거하여 메모리 관리를 간편하게 합니다.**
- 자바(Java)와 같은 언어에서는 **new** 키워드로 객체를 생성하고 나면, 메모리 해제를 가비지 컬렉터(Garbage Collector)에 맡기게 됩니다.

### 2️⃣ 메모리 누수 방지.
- 가비지 컬렉션(Garbage Collection)은 더 이상 필요하지 않은 객체가 메모리에서 **해제되지 않고 계속 남아 있어 메모리를 차지하는 상황, 즉 메모리 누수(Memory Leak)를 방지합니다.**
    - 이를 통해 **효율적인 메모리 사용을 보장합니다.**

## 2️⃣ 가비지 컬렉션(Garbage Collection)의 기본 원리.

### 1️⃣ 객체의 수명 주기.
- 자바 프로그램이 실행되면서, 객체는 힙 메모리(Heap Memory)에 할당됩니다.
    - 어떤 객체가 생성된 후, **해당 객체를 참조하는 변수나 다른 객체가 없으면, 그 객체는 더 이상 사용되지 않는 "쓰레기(Garbage)"가 됩니다.**
- 가비지 컬렉터(Garbage Collector)는 주기적으로 힙 메모리(Heap Memory)를 스캔하여 **더 이상 참조되지 않는 객체를 찾아 메모리에서 제거 합니다.**

### 2️⃣ 참조의 개념.
- 객체는 **참조 변수를 통해 접근할 수 있으며,** 가비지 컬렉터(Garbage Collector)는 **객체가 다른 객체나 변수로부터 참조되고 있는지를 판단해 가비지(Garbage) 여부를 결정합니다.**
- **참조되지 않는 객체**는 더 이상 접근할 수 없으므로, 가비지 컬렉터(Garbage Collector)가 메모리에서 제거할 수 있습니다.

## 3️⃣ 가비지 컬렉션(Garbage Collection)의 동작 방식.
- 가비지 컬렉션(Garbage Collection)의 구체적인 동작 방식은 사용되는 알고리즘에 따라 다릅니다.
    - 자바에서는 **다양한 알고리즘**이 가비지 컬렉션(Garbage Collection)을 위해 사용되며, 그중 대표적인 몇 가지 방법을 설명하겠습니다.

### 1️⃣ 마크-앤-스윕(Mark-and-Sweep) 알고리즘.
- **마크 단계(Mark Phase)**
    - 프로그램이 실행되는 동안 **참조 가는한 객체를 "마킹" 합니다.**
        - 참조되지 않는 객체는 마킹되지 않은 채로 남습니다.
- **스윕 단계(Sweep Phase)**
    - 마킹이 되지 않은 객체를 **힙 메모리(Heap Memory)에서 제거하여 메모리를 회수합니다.**
- 이 과정에서 힙 메모리 **조각화(Fragmentation)가** 발생할 수 있습니다.

### 2️⃣ 복사(Copying) 알고리즘
- 힙 메모리(Heap Memory) 두 개의 영역(From-Space와 To-Space)으로 나눕니다.
- **참조 가능한 객체를 To-Space로 복사하고, From-Space에 남은 쓰레기 객체는 삭제합니다.**
- 복사 과정에서 **메모리 조각화(Memory Fragmentation) 문제를 해결할 수 있지만,** 메모리를 두 개의 영역으로 나누어야 한다는 단점이 있습니다.

> 📝 메모리 조각화(Memory Fragmentation)
> 
> **프로그램이 메모리를 할당하고 해제하는 과정에서 메모리 공간이 쪼개져 효율적으로 사용할 수 없는 상태를 말합니다.**
> 이는 메모리의 **사용 가능한 공간이 충분히 존재함에도 불구하고, 연속적인 큰 메모리를 할당하지 못하는 상황을 초래할 수 있습니다.**
> 메모리 조각화(Memory Fragmentation)는 **시스템의 성능 저하와 메모리 낭비의 원인이 되며, 특히 동적 메모리 할당을 많이 사용하는 프로그램에서 자주 발생합니다.**

### 3️⃣ 세대별(Generational) 가비지 컬렉션.
- **자바의 HotSpot JVM**에서 사용되는 가비지 컬렉션 방식으로, **객체의 수명을 기반**으로 메모리를 관리합니다.
- 힙 메모리(Heap Memory)를 **Young Generation, Old Generation, Permanent Generation**으로 나누어, **객체의 수명에 따라 효율적으로 관리합니다.**
    - **Young Generation**
        - 새로 생성된 객체가 저장되는 공간으로, 대부분의 객체는 여기에 생성되며 **빠르게 소멸합니다.**
            - **Minor GC가 주기적으로 발생하여 메모리를 해제합니다.**
    - **Old Generation**
        - Young Generation을 거쳐 **오래 살아남은 객체**가 이동하는 공간으로, **Major GC가 발생하여 메모리를 해제합니다.**
    - **Permanent Generation(Metaspace)**
        - 클래스 정보, 메서드, 상수 풀 등 JVM에 필요한 메타데이터를 저장하는 공간입니다.
            - Java 8 부터는 **Metaspace**라는 새로운 형태로 관리됩니다.

> 📝 메타데이터(Metadata)
> 
> **데이터를 설명하는 데이터**를 의미합니다.
> 즉, **어떤 데이터에 대한 정보나 속성을 제공하는 데이터로, 원본 데이터의 내용, 구조, 형식, 속성 등을 설명하고 정의하는 역할을 합니다.**
> 메타데이터는 **데이터를 더 잘 이해하고, 찾고, 관리할 수 있도록 도와줍니다.**

## 4️⃣ 자바의 가비지 컬렉션 과정.

### 1️⃣ Minor GC
- **Young Generation**에서 발생하는 가비지 컬렉션입니다.
    - 새로운 객체가 생성되다가 Young Generation이 가득 차게 되면 **Minor GC**가 실행되어 참조되지 않는 객체를 제거합니다.
- Minor GC는 **빠르고 자주 실행됩니다.**

### 2️⃣ Major GC(Full GC)
- **Old Generation**에서 발생하는 가비지 컬렉션입니다.
    - Young Generation을 거쳐 오래 살아남은 객체가 Old Generation으로 이동하게 되며, Old Generation이 가득 차면 **Major GC**가 실행됩니다.
- **Major GC**는 **Minor GC**에 비해 **느리고, 프로그램의 일시적인 중단(Stop-the-World)을 유발할 수 있습니다.**

## 5️⃣ 가비지 컬렉션의 장단점.

### 1️⃣ 장점.
- **자동 메모리 관리**
    - 개발자가 메모리 관리를 수동으로 하자 않아도 되어 프로그래밍이 간편해지고, **메모리 누수(Memory Leak)을** 방지할 수 있습니다.
- **효율적인 메모리 사용**
    - 가비지 컬렉터(Garbage Collector)는 불필요한 객체를 자동으로 회수하여 **메모리 사용을 최적화합니다.**

### 2️⃣ 단점.
- **성능 문제**
    - 가비지 컬렉션(Garbage Collection)이 실행될 때 프로그램이 일시적으로 멈출 수 있는 **"Stop-the-World"** 현상이 발생할 수 있습니다.
- **예측 불가능한 실행 시점**
    - 가비지 컬렉션(Garbage Collection)은 특정 시점에 예측 불가능하게 실행되므로, **실시간 애플리케이션**에서는 성능에 영향을 줄 수 있습니다.

## 6️⃣ 가비지 컬렉션의 최적화 방법.

### 1️⃣ JVM 옵션 설정.
- `-Xms`, `-Xmx`, `-Xmn` 등을 사용하여 힙 메모리 크기를 적절히 설정함으로써 가비지 컬렉션의 빈도를 조절할 수 있습니다.
- 예를 들어, `-Xms512m -Xmx1024m` 옵션은 JVM이 시작할 때 512MB의 힙 메모리(Heap Memory)를 사용하고, 최대 1024MB까지 사용할 수 있도록 설정합니다.

### 2️⃣ GC 알고리즘 선택.
- **JVM**은 다양한 가비지 컬렉터 알고리즘을 지원하며, 프로그램의 특성에 맞는 알고리즘을 선택하면 성능을 최적화할 수 있습니다.
- 예: **Serial GC, Paralle GC, G1 GC** 등. G1 GC는 **Stop-the-World** 현상을 최소화하는 데 유리합니다.

### 3️⃣ 메모리 누수 예방.
- 가비지 컬렉터(Garbage Collector)가 메모리를 자동으로 관리하지만, **명시적으로 해제할 수 없는 리소스(파일 핸들, 데이터 베이스 연결 등)는** 코드에서 직접 관리해야 합니다.
- **전역 변수나 static 객체**로 인한 메모리 누수(Memory Leak)를 주의해야 합니다.
    - 이러한 객체가 참조를 유지하고 있으면 가비지 컬렉터(Garbage Collector)는 메모리를 해제하지 않습니다.

## 7️⃣ 요약.
- **가비지 컬렉션(Garbage Collection)은** 자바와 같은 프로그래밍 언어에서 **사용되지 않은 객체를 자동으로 메모리에서 해제하여 메모리 누수(Memory Leak)를 방지하는 메모리 관리 기법입니다.**
- **가비지 컬렉터(Garbage Collector)는** 주기적으로 실행되어, **참조되지 않는 객체를** 감지하고 메모리를 회수합니다.
- 자바에서는 **세대별 가비지 컬렉션(Garbage Collection)을** 통해 객체의 수명에 따라 메모리를 효율적으로 관리합니다.
- 가비지 컬렉션 덕분에 개발자는 메모리 관리에 대한 부담을 덜고, **더 안정적이고 효율적인 프로그램을** 작성할 수 있습니다.

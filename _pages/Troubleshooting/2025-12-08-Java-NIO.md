---
title: "🔍 [Troubleshooting] 🚀 WebFlux 없이 순수 Java NIO로 구현시 구조와 주의점"
tags:
  - Troubleshooting
  - Backend Development
date: "2025-12-08"
thumbnail: "/assets/img/thumbnail/troubleshooting.jpg"
---

## 🎯 시작하며

"Spring WebFlux 쓰면 되는데 왜 굳이 순수 NIO로...?" 

누군가는 이렇게 생각할 수 있습니다. 하지만 때로는 프레임워크 밑바닥이 어떻게 돌아가는지 직접 구현해보는 것이 최고의 학습이죠. 마치 자동차 운전만 하다가 엔진을 직접 뜯어보는 것처럼요.

이 글은 IRC 서버를 순수 Java NIO로 구현하면서 마주한 현실적인 문제들과 해결 방법을 담았습니다.

---

## 📦 1. 의존성: 놀랍게도 아무것도 필요 없습니다

```gradle
// build.gradle에 추가할 것이 없습니다!
```

맞습니다. **단 한 줄의 의존성도 추가하지 않습니다.**

Java NIO(`java.nio.*`)는 JDK에 기본 포함되어 있습니다. JDK 1.4부터 제공된 오래된(?) 친구죠. 외부 라이브러리 없이 순수 Java 코드만으로 고성능 네트워크 서버를 만들 수 있다는 것, 놀랍지 않나요?

---

## 🏗️ 2. 아키텍처: Spring Boot와 NIO의 위험한 동거

여기서부터 진짜 고민이 시작됩니다.

### ⚠️ 핵심 문제: 두 개의 라이프사이클

Spring Boot 애플리케이션은 시작하고, 빈을 초기화하고, 웹 서버를 띄우고... 그리고 나서 메인 스레드는 할 일을 끝냅니다.

하지만 NIO 서버는 `while(true)` 무한 루프로 계속 이벤트를 감시해야 합니다.

**만약 메인 스레드에서 NIO 루프를 돌리면?**
→ Spring Boot가 먹통이 됩니다. 애플리케이션이 시작조차 안 되죠.

**만약 별도 스레드 없이 실행하면?**
→ 서버는 커넥션을 받을 수 없습니다.

### ✅ 해결 방법: 우아한 분리

```java
@Component
public class IRCServer {
    private Selector selector;
    private ServerSocketChannel serverSocket;
    
    // Spring이 관리하는 컴포넌트로 등록
}

@Component
public class ServerInitializer implements ApplicationRunner {
    @Autowired
    private IRCServer ircServer;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        // Spring Boot가 완전히 뜨고 나서 IRC 서버 시작
        ircServer.start();
    }
}
```

**핵심 포인트:**
1. **IRCServer는 Spring Component**로 만들어 의존성 주입 혜택을 받습니다
2. **ApplicationRunner로 시작 시점을 제어**합니다
3. **NIO 루프는 반드시 별도 스레드**에서 실행합니다

---

## ⚙️ 3. Event Loop: Netty가 내부에서 하는 그 일

직접 구현하면 이런 모습이 됩니다:

```java
public class NioIrcServer implements Runnable {
    private Selector selector;
    private ServerSocketChannel serverSocket;

    public void start() throws Exception {
        // 1. Selector 생성 - 이벤트를 감시할 관제탑
        selector = Selector.open();
        
        // 2. 서버 소켓 생성 및 바인딩
        serverSocket = ServerSocketChannel.open();
        serverSocket.bind(new InetSocketAddress(6667)); // IRC 표준 포트
        
        // 3. 🔑 Non-blocking 모드 설정 (이게 NIO의 핵심!)
        serverSocket.configureBlocking(false);
        
        // 4. Accept 이벤트를 Selector에 등록
        serverSocket.register(selector, SelectionKey.OP_ACCEPT);

        // 5. 별도 스레드에서 이벤트 루프 시작
        new Thread(this, "IRC-NIO-Thread").start();
    }

    @Override
    public void run() {
        while (true) { // 무한 루프 - 서버가 살아있는 한 계속
            try {
                // ⏰ 이벤트가 발생할 때까지 대기
                // (blocking이지만, 여러 채널을 동시에 감시하는 효율적인 대기)
                selector.select();

                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                Iterator<SelectionKey> iter = selectedKeys.iterator();

                while (iter.hasNext()) {
                    SelectionKey key = iter.next();

                    if (key.isAcceptable()) {
                        // 🆕 새로운 클라이언트 접속!
                        handleAccept(key);
                    } else if (key.isReadable()) {
                        // 📨 클라이언트가 데이터를 보냈어요
                        handleRead(key);
                    }
                    
                    iter.remove(); // 처리한 키는 반드시 제거!
                }
            } catch (Exception e) {
                // 에러 처리...
            }
        }
    }
}
```

**이게 바로 Netty, Reactor, Vert.x 같은 라이브러리들이 내부에서 하는 일입니다.** 
우리가 직접 구현하면서 그들의 고마움을 뼈저리게 느끼게 됩니다... 😅

---

## 🔥 4. 현실의 벽: 직접 구현하면 마주하는 문제들

"이론상으로는 간단해 보이는데?"라고 생각했다면, 이제부터가 진짜입니다.

### 1️⃣ TCP 패킷 파편화: 악명 높은 Half-Packet 문제

**상황 재현:**

```
클라이언트: "PRIVMSG #channel :Hello World\r\n" 전송

서버 수신 1차: "PRIVMSG #cha"
서버 수신 2차: "nnel :Hello World\r\n"
```

혹은 반대로:

```
클라이언트: "NICK user1\r\n" + "USER user1 0 * :Real Name\r\n" 전송

서버 수신 1차: "NICK user1\r\nUSER user1 0 * :Real Name\r\n"
```

**이게 무슨 일인가요?**

TCP는 **스트림 기반 프로토콜**입니다. 메시지 경계를 보장하지 않습니다. 
- **Fragmentation**: 한 메시지가 여러 패킷으로 쪼개져서 도착
- **Sticky Packets**: 여러 메시지가 한 패킷에 붙어서 도착

**해결 방법: 직접 만드는 Frame Decoder**

```java
public class MessageFrameDecoder {
    private ByteBuffer buffer = ByteBuffer.allocate(1024);
    
    public List<String> decode(ByteBuffer incoming) {
        List<String> messages = new ArrayList<>();
        
        // 기존 버퍼에 새 데이터 추가
        buffer.put(incoming);
        buffer.flip();
        
        // \r\n을 찾아 메시지 추출
        while (buffer.hasRemaining()) {
            byte b = buffer.get();
            if (b == '\n') {
                // 완전한 메시지 발견!
                messages.add(extractMessage());
            }
        }
        
        buffer.compact(); // 남은 데이터는 다음 번을 위해 보관
        return messages;
    }
}
```

**이 부분이 가장 버그가 많이 발생하는 지점입니다.** Netty의 `DelimiterBasedFrameDecoder`가 얼마나 고마운지 알게 됩니다.

### 2️⃣ ByteBuffer: 까다로운 친구

`ByteBuffer`는 단순해 보이지만 실수하기 쉽습니다:

```java
// ❌ 흔한 실수
buffer.put(data);
// flip() 없이 바로 읽으면? → 쓰레기 값!
buffer.get(); 

// ✅ 올바른 사용
buffer.put(data);    // Write 모드
buffer.flip();       // Read 모드로 전환
buffer.get();        // 이제 읽을 수 있음
buffer.compact();    // 남은 데이터 정리
```

**position, limit, capacity**의 삼각관계를 완벽히 이해해야 합니다.

### 3️⃣ 리소스 누수: 조용히 다가오는 재앙

```java
try {
    readData(key);
} catch (IOException e) {
    // ❌ 이렇게만 하면?
    e.printStackTrace();
    // 소켓은 열린 채로, SelectionKey는 등록된 채로...
    // 시간이 지나면 "Too many open files" 에러 발생!
}
```

**올바른 처리:**

```java
try {
    readData(key);
} catch (IOException e) {
    // ✅ 리소스 정리
    key.cancel();                    // Selector에서 제거
    key.channel().close();           // 소켓 닫기
    clientMap.remove(key.channel()); // 애플리케이션 상태 정리
    log.info("Client disconnected: {}", e.getMessage());
}
```

---

## 🎓 마치며: 그래도 한 번쯤은 해볼 만한 여정

순수 NIO 구현은 분명 고된 작업입니다. Netty나 WebFlux를 쓰면 이 모든 걸 프레임워크가 해결해주니까요.

**하지만 이 경험을 통해 얻는 것:**
- ✅ Non-blocking I/O의 진짜 작동 원리 이해
- ✅ 프레임워크가 해결하는 문제들을 피부로 체감
- ✅ 성능 튜닝 시 어디를 봐야 하는지 감각 습득
- ✅ 면접에서 "Reactor 패턴"을 자신 있게 설명 가능!

**프레임워크는 마법이 아니라 누군가의 노력입니다.** 그 노력을 이해하는 개발자가 되는 것, 그것이 이 여정의 진짜 가치입니다.

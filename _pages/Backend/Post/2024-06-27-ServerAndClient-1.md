---
title: "📝[Post] 서버와 클라이언트의 개념(1)"
tags:
    - Post
    - Backend
date: "2024-06-27"
thumbnail: "/assets/img/thumbnail/blog.jpeg"
---

# 🙋‍♂️ Preview

이번 포스트에서는 컴퓨터 과학에서 말하는 서버와 클라이언트의 개념을 크게 세 가지로 나눠 살펴보겠습니다.
- 이것은 이해를 돕기 위한 분류로, 서버와 클라이언트라는 개념에 익숙해지고 난 후에 다시 보면 왜 이렇게 나누었는지 이해가 될 것 입니다.

# 1️⃣ 네트워크에서의 서버와 클라이언트.

- **서버(Server) :** **"서비스를 제공하는 쪽"**
- **클라이언트(Client) :** **"서비스를 제공받는 쪽"**

<img src = "https://github.com/devKobe24/images2/blob/main/this_is_backend_img/serverAndClient-1.png?raw=true">

- 그림에서 서버는 실제 존재하는 물리적인 고성능 컴퓨터이고, 클라이언트는 데스크톱이나 노트북, 스마트폰 등과 같은 사용자들의 단말기를 나타냅니다.
    - **즉, 물리적 장치와 또 다른 물리적 장치 사이의 관계를 의미합니다.**
        - 이렇게 물리적인 장치 간에 서로 통신이 이루어지기 위해서는 "통신을 시작하는 쪽"이 "상대방의 네트워크 주소인 IP 주소를 알고 있어야 합니다."
            - **"클라이언트가 서버의 IP주소를 알고있어야 서버와 클라이언트로서의 관계를 맺을 수 있습니다."**

## 1️⃣ 트래픽(Traffic) 처리 방법.

우리가 컴퓨터나 스마트폰으로 이용하는 서비스들은 수백만 명 이상의 사용자가 동시에 사용하고 있는 경우가 대부분입니다.
그렇다면 이러한 서비스를 운영하는 서버가 모두 고성능일까요? 🤔

당연히 그렇지 않습니다 ❌

한꺼번에 수백만 명 이상의 사용자로부터 생기는 "트래픽(Traffic)"을 처리하기 위한 방법은 여러가지가 있습니다.

여기서는 가장 범용적이고 직관적인 방법 두 가지, "로드 밸런싱" 과 "캐시"에 대해 간단히 설명하겠습니다.

### 1️⃣ 로드 밸런싱(Load Balancing).

- **"로드 밸런싱(Load Balancing)" :** 부하 분산.
    - 즉, 서버에 가해지는 부하(Load)를 분산하는 것입니다.
        - 사용자들의 트래픽을 여러 서버가 나눠 받도록 구성하며, 일반적으로 네트워크 장비인 **"스위치(Switch)"** 를 할당해 "로드 밸런싱"할 수 있습니다.
            - 스위치에서 어떤 서버로 로드 밸런싱이 되도록 할지는 소프트웨어적으로 제어할 수 있습니다.

<img src = "https://github.com/devKobe24/images2/blob/main/this_is_backend_img/loadbalancing.png?raw=true">

- **"로드 밸런싱"** 은 **"스위치"** 라는 장비가 **"클라이언트의 트래픽을 먼저 받아"** 서 여러 대의 서버로 **"분산"** 해 주는 방식입니다.
    - 이렇게 하면 부하가 분산되는 효과 외에도 스위치 뒤에 연결된 서버들을 필요에 따라 추가하거나 삭제할 수 있어 편리합니다.

### 2️⃣ 캐시(Cache).

- **"캐시(Cache)" :** 비용이 큰 작업의 결과를 어딘가에 저장하여 비용이 작은 작업으로 동일한 효과를 내는 것.
    - 캐시를 이용하면 매번 요청이 들어올 때마다 비용이 큰 작업을 다시 수행할 필요 없이 미리 저장된 결과로 응답하면 됩니다.
        - 물론 이렇게 하면 가장 최신의 데이터는 아닐 수 있지만, 성능을 극대화시키고자 하는 캐시의 목적을 생각해 데이터의 실시간성을 조금 포기해도 되는 경우가 많습니다.

> ✏️ **Example**
>>음원 서비스
>>
>> 데이터베이스에 저장된 수많은 음원의 다운로드 수, 스트리밍 수, 추천 수 등으로 인기 점수를 계산하려 100갸의 곡을 오름차순 순위로 제공합니다.
>>
>>  만약 사용자가 한 번 음원을 조회할 때마다 모든 음원의 인기 점수를 계산해 순위를 매긴다면 아마 사용자가 수백 명만 되어도 서버 부하로 응답 시간이 매우 느려질 것입니다.
>>  
>>  이렇게 수많은 음원의 인기 점수를 매번 계산하여 순위를 매기는 작업이 바로 '비용이 큰 작업' 입니다.
>>
>> <img src = "https://github.com/devKobe24/images2/blob/main/this_is_backend_img/musicService.png?raw=true">
>> 
>> 매시 정각마다 TOP 100을 계산한 결과를 저장했다가 사용자의 요청이 들어왔을 때 응답해주면 '비용이 작은 작업'으로 대체할 수 있습니다.
>> 
>> 사용자는 16시 30분에 16시에 저장된 TOP 100 결과로도 큰 불편함을 느끼지 않습니다.
>> 
>> 이렇게 사용자가 캐시된 과거의 데이터를 보더라도 서비스 시용에 지장이 없다면 캐시 사용을 충분히 고려할 만합니다.
>> 
>> <img src = "https://github.com/devKobe24/images2/blob/main/this_is_backend_img/musicService-2.png?raw=true">

- **"캐시"** 는 다양한 상황에서 비슷한 뜻으로 사용되지만, 공통적으로, '비용이 큰 작업을 비용이 작은 작업으로 대신하는 것'이라고 정리할 수 있습니다.

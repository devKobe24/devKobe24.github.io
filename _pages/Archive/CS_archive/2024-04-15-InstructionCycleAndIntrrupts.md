---
title: "💾 [CS] 명령어 사이클과 인터럽트"
tags:
    - CS
date: "2024-04-15"
thumbnail: "/assets/img/thumbnail/cs.jpeg"
---

# 명령어 사이클과 인터럽트.

- **명령어 사이클 :** CPU가 하나의 명령어를 처리하는 과정에는 어떤 정해진 흐름이 있고, CPU는 그 흐름을 반복하며 명령어를 처리해 나갑니다. 이렇게 하나의 명령어를 처리하는 정형화된 흐름을 **"명령어 사이클"** 이라고 합니다.

- **인터럽트 :** CPU는 정해진 흐름에 따라 명령어를 처리해 나가지만, 이 흐름이 끊어지는 상황이 발생합니다. 이를 **"인터럽트"** 라고 합니다.

## 명령어 사이클
프로그램은 수많은 명령어로 이루어져있고, CPU는 이 명령어들을 하나씩 실행합니다.
- 이때 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 **명령어 사이클(instruction cycle)** 이라고 합니다.
    - 즉, 프로그램 속 각각의 명령어들은 명령어 사이클이 반복되며 실행됩니다.

메모리에 저장된 명령어 하나를 실행한다고 가정해 봅시다.
가장 먼저 해야할 것은 명령어를 메모리에서 CPU로 가져와야 합니다.
이게 명령어 사이클의 첫 번째 과정입니다.

- **인출 사이클(fetch cycle) :** 메모리에 있는 명령어를 CPU로 가지고 오는 단계.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-1.png?raw=true">

CPU로 명령어를 인출했다면 이제 명령어를 실행합니다.
이것이 명령어 사이클의 두 번째 과정입니다.

- **실행 사이클(execution cycle) :** CPU로 가져온 명령어를 실행하는 단계, 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-2.png?raw=true">

프로그램을 이루는 수많은 명령어는 일반적으로 인출과 실행 사이클을 반복하며 실행됩니다.
- 즉, CPU는 프로그램 속 명령어를 가져오고 실행하고, 또 가져오고 실행하고를 반복하는 것입니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8E%E1%85%AE%E1%86%AF%E1%84%80%E1%85%AA%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%83%E1%85%A9%E1%84%89%E1%85%B5%E1%86%A8%E1%84%92%E1%85%AA%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-1.png?raw=true">

- 하지만 모든 명령어가 이렇게 간단히 실행되는 건 아닙니다.
    - 명령어를 인출하여 CPU로 가져왔다하더라도 곧바로 실행할 수 없는 경우도 있기 때문입니다.

예를 들어 간접 주소 지정 방식을 생각해 봅시다.
- 간접 주소 지정 방식은 오퍼랜드 필드에 유효 주소의 주소를 명시한다고 했습니다.
    - 이 경우 명령어를 인출하여 CPU로 가져왔다 하더라도 바로 실행 사이클에 돌입할 수 없습니다.
    - 명령어를 실행하기 위해서는 메모리 접근을 한 번 더 해야 하기 때문입니다.
        - 이 단계를 **간접 사이클(indirect cycle)** 이라고 합니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%80%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%E1%84%89%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%83%E1%85%A9%E1%84%89%E1%85%B5%E1%86%A8%E1%84%92%E1%85%AA%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-1.png?raw=true">

## 인터럽트.
프로그램을 개발하다 보면 아래 인터럽트라는 단어를 쉽게 접할 수 있습니다.

인터럽트는 영어로 interrupt이며, '방해하다, 중단시키다'를 의미합니다.
- 즉, CPU가 수행 중인 작업은 방해를 받아 잠시 중단될 수 있는데, 이렇게 CPU의 작업을 방해하는 신호를 **인터럽트(interrupt)** 라고 합니다.

CPU가 작업을 잠시 중단해야 할 정도라면 인터럽트는 'CPU가 꼭 주목해야 할 때' 혹은 'CPU가 얼른 처리해야 할 다른 작업이 생겼을 때' 발생합니다.

인터럽트의 종류에는 크게 동기 인터럽트와 비동기 인터럽트가 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%85%E1%85%A5%E1%86%B8%E1%84%90%E1%85%B3%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-1.png?raw=true">

- **동기 인터럽트(synchronous interrupt) :** CPU에 의해 발생하는 인터럽트입니다.
    - CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때, 가령 CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마추쳤을 때 발생하는 인터럽트입니다.
        - 이런 점에서 동기 인터럽트는 **예외(execption)** 라고 부릅니다.

- **비동기 인터럽트(asynchronous interrupt) :** 주로 입출력장치에 의해 발생하는 인터럽트입니다.
    - 입출력장치에 의한 비동기 인터럽트는 세탁기 완료 알리므 전자레인지 조리 완료 알림과 같은 알림 역할을 합니다.

구체적으로 다음과 같이 사용됩니다.
- CPU가 프린터와 같은 입출력장치에 입출력 작업을 부탁하면 작업을 끝낸 입출력장치가 CPU에 완료 알림(인터럽트)을 보냅니다.
- 키보드, 마우스와 같은 입출력 장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에 입력 알림(인터럽트)을 보냅니다.

### 하드웨어 인터럽트
**하드웨어 인터럽트**는 알림과 같은 인터럽트 입니다.
- CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 이런 알림과 같은 하드웨어 인터럽트를 사용합니다.

하드웨어 인터럽트를 이용하면 CPU는 주기적으로 하드웨어 완료 여부를 확인할 필요가 없습니다.
CPU는 하드웨어로부터 하드웨어 완료 인터럽트를 받을 때까지 다른 작업을 처리할 수 있습니다.
- 이렇듯 하드웨어 인터럽트는 입출력 작업 중에도 CPU로 하여금 효율적으로 명령어를 처리할 수 있게 합니다.

### 하드웨어 인터럽트 처리 순서
1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보냅니다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인합니다.
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인합니다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업합니다.
5. CPU는 **인터럽트 백터**를 참조하여 **인터럽트 서비스 루틴**을 실행합니다.
6. 인터럽트 서비스 루틴이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개합니다.

- **인터럽트 요청 신호 :** 인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기에 다른 누군가가 인터럽트하기 전에 "지금끼어들어도 되나요?" 하고 CPU에 물어봐야 합니다. 이를 **인터럽트 요청 신호**라고 합니다.

이때, CPU가 인터럽트 요청을 수용하기 위해서는 플래그 레지스터의 **인터럽트 플래그(interrupt flag)** 가 활성화되어 있어야 합니다.
- 인터럽트 플래그는 말 그래도 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그입니다.
- CPU가 중요한 작업을 처리해야 하거나 어떤 방해도 받지 않아야 할 때 인터럽트 플래그는 불가능으로 설정됩니다.
    - 만약 인터럽트 플래그가 '불가능'으로 설정되어 있다면 CPU는 인터럽트 요청이 오더라도 해당 요청을 무시합니다.
    - 반대로 인터럽트 플래그가 '가능'으로 설정되어 있다면 CPU는 인터럽트 요청 신호를 받아들이고 인터럽트를 처리합니다.

다만, 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아닙니다.
인터럽트 플래그가 불가능으로 설정되어 있을지라도 무시할 수 없는 인터럽트 요청도 있습니다.
- 무시할 수 없는 하드웨어 인터럽트 가장 우선순위가 높은, 다시 말해 반드시 가장 먼저 처리해야 하는 인터럽트입니다.
    - 정전이나 하드웨어 고장으로 인한 인터럽트가 이에 해당합니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%85%E1%85%A5%E1%86%B8%E1%84%90%E1%85%B3%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7.png?raw=true">

CPU가 인터럽트 요청을 받아들이기로 했다면 CPU는 서비스 루틴이라는 프로그램을 실행합니다.
- **인터럽트 서비스 루틴(ISB: Interrupt Service Routine):** 인터럽트를 처리하기 위한 프로그램. **인터럽트 핸들러(Interrupt handler)** 라고도 불립니다.
    - 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램입니다.
    - 요컨태 'CPU가 인터럽트를 처리한다'는 말은 '인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다' 라는 말과 같습니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%85%E1%85%A5%E1%86%B8%E1%84%90%E1%85%B3%E1%84%89%E1%85%AE%E1%84%92%E1%85%A2%E1%86%BC%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7.png?raw=true">

인터럽트를 처리하는 방법은 입출력장치마다 다르므로 각기 다른 인터럽트 서비스 루틴을 가지고 있습니다.
- 즉, 메모리에는 위 그림처럼 여러 개의 인터럽트 서비스 루틴이 저장되어 있습니다.
    - 이들 하나하나가 '인터럽트가 발생하면 어떻게 행동해야 할지를 알려주는 프로그램'이라고 보면 됩니다.

- **인터럽트 벡터(Interrupt vector) :** CPU는 수많은 인터럽트 서비스 루틴을 구분하기 위해 인터럽트 벡터를 이용합니다. 인터럽트 서비스 루틴을 식별하기 위한 정보입니다.
    - 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있기 때문에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있습니다.

> CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받습니다.

가령, CPU가 작업을 수행하는 도중 키보드 인터럽트가 발생한 경우라면 CPU는 인터럽트 벡터를 참조하여 키보드 인터럽트 서비스 루틴의 시작 주소를 알아내고, 이 시작 주소부터 실행해 나가며 키보드 인터럽트 서비스 루틴을 실행합니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%85%E1%85%A5%E1%86%B8%E1%84%90%E1%85%B3%E1%84%87%E1%85%A6%E1%86%A8%E1%84%90%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7.png?raw=true">

정리하면 'CPU가 인터럽트를 처리한다'는 말은 '인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다'는 말과 같습니다.

- 그리고 CPU가 인터럽트 서비스 루틴을 실행하려면 인터럽트 서비스 루틴의 시작 주소를 알아야 하는데, 이는 **인터럽트 벡터**를 통해 알 수 있습니다.

인터럽트 서비스 루틴은 여느 프로그램과 마찬가지로 명령어와 데이터로 이루어져 있습니다.
- 그렇기에 인터럽트 서비스 루틴도 프로그램 카운터를 비롯한 레지스터들을 사용하며 실행됩니다.

그럼, 인터럽트가 발생하기 전까지 레지스터에 저장되어 있던 값들은 어떻게 할까요?

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%85%E1%85%A5%E1%86%B8%E1%84%90%E1%85%B3%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-1.png?raw=true">

- 인터럽트 요청을 받기 전까지 CPU가 수행하고 있었던 일은 인터럽트 서비스 루틴이 끝나면 되돌아와서 마저 수행을 해야 하기 때문에 지금까지의 작업 내역들은 어딘가에 백업을 해둬야 합니다.
    - 그렇기에 CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업합니다.
    - 그러고 나서 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터 값을 갱신하고 인터럽트 서비스 루틴을 실행합니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%85%E1%85%A5%E1%86%B8%E1%84%90%E1%85%B3%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-2.png?raw=true">

- 인터럽트 서비스 루틴을 모두 실행하면, 다시 말해 인터럽트를 처리하고 나면 스택에 저장해 둔 값을 다시 불러온 뒤 이전까지 수행하던 작업을 재개합니다.

## 키워드 정리
- 인터럽트 요청 신호 : CPU의 작업을 방해하는 인터럽트에 대한 요청
- 인터럽트 플래그 : 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트
- 인터럽트 벡터 : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
- 인터럽트 서비스 루틴 : 인터럽트를 처리하는 프로그램

CPU는 이와 같은 과정을 반복해 나가며 프로그램을 실행한다고 볼 수 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%86%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A5%E1%84%89%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7.png?raw=true">

## 키워드로 정리하는 핵심 포인트
- **명령어 사이클**은 하나의 명령어가 처리되는 주기로, 인출, 실행, 간접, 인터럽트 사이클로 구성되어 있습니다.
- **인터럽트** 는 CPU의 정상적인 작업을 방해하는 신호입니다.
- 인터럽트의 종류에는 **예외**와 **하드웨어 인터럽트**가 있습니다.
- **인터럽트 서비스 루틴**은 인터럽트를 처리하기 위한 동작들로 이루어진 프로그램입니다.

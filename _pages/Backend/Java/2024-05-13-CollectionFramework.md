---
title: "☕️[Java] 컬렉션 프레임워크"
tags:
    - Java
    - Programming Language
    - Backend
date: "2024-05-13"
thumbnail: "/assets/img/thumbnail/JV.jpeg"
---

# 1️⃣ 컬렉션 프레임워크

## 1. 컬렉션 프레임워크(Collection Framework)
자바 컬렉션 프레임워크는 자료 구조를 효율적으로 관리하고 조작할 수 있는 방법을 제공하는 통합 아키텍처입니다.
이 프레임워크는 다양한 인터페이스와 구현을 포함하며, 다양한 종류의 컬렉션들을 제어하고, 데이터 집합을 효율적으로 관리하기 위한 알고리즘을 제공합니다.

## 1.2 컬렉션 프레임워크의 구요 구성 요소.
- **1. 인터페이스(Interface) :** 컬렉션 프레임워크의 핵심 인터페이스로는 **'Collection', 'List', 'Queue'** 등이 있으며 각각 다른 형태의 데이터 집합을 추상화합니다.
    - 예를 들어, **'List'** 는 순서가 있는 데이터 집합을, **'Set'** 은 중복을 허용하지 않는 데이터 집합을 나타냅니다.

- **2. 구현(Implementation) :** 이러한 인터페이스를 실제로 구현한 클래스들로, **'ArrayList', 'LinkedList', 'HashSet', 'TreeSet', 'PriorityQueue'** 등이 포함됩니다.
    - 각 클래스는 컬렉션 인터페이스를 구현하며, 데이터의 특성에 따라 선택하여 사용할 수 있습니다.

- **3. 알고리즘(Algorithm) :** 컬렉션 데이터를 처리하는 데 필요한 다양한 알고리즘이 제공됩니다.
    - 이 알고리즘은 정렬, 검색, 순환 및 변환 등을 포함하며, 이들은 대부분 **'Collections'** 클래스에 정적 메소드로 제공됩니다.

## 1.3 📝 정리.
컬렉션 프레임워크를 사용하면 데이터를 보다 효율적으로 처리할 수 있고, 기능의 재사용성 및 유지 보수성이 향상됩니다.
또한, 자바 개발자로서 다양한 데이터 컬렉션을 쉽게 처리하고, 표준화된 방법으로 데이터를 조작할 수 있는 능력을 갖추게 됩니다.

---

## 2. List 인터페이스.
자바 프로그래밍에서 **'List'** 인터페이스는 **'java.util'** 패키지의 일부로, 순서가 있는 컬렉션을 나타냅니다.
이 인터페이스를 사용하면 사용자가 목록의 특정 위치에 접근, 삽입, 삭제를 할 수 있는 동시에, 목록의 요소들이 입력된 순서대로 저장 및 관리됩니다.
**'List'** 는 중복된 요소의 저장을 허용하기 때문에, 같은 값을 가진 요소를 여러 개 포함할 수 있습니다.

## 2.1 List 인터페이스의 주요 메서드.
- **add(E e) :** 리스트의 끝에 요소를 추가합니다.
- **add(int index, E element) :** 리스트의 특정 위치에 요소를 삽입합니다.
- **remove(Object o) :** 리스트에서 지정된 요소를 삭제합니다.
- **remove(int index) :** 리스트에서 지정된 위치의 요소를 삭제합니다.
- **get(int index) :** 지정된 위치에 있는 요소를 반환합니다.
- **set(int index, E element) :** 리스트의 특정 위치에 요소를 설정(교체)합니다.
- **indexOf(Object o) :** 객체를 찾고, 리스트 내의 첫 번째 등장 위치를 반환합니다.
- **size() :** 리스트에 있는 요소의 수를 반환합니다.
- **clear() :** 리스트에서 모든 요소를 제거합니다.

## 2.3 가장 널리 사용되는 구현체.
**'List'** 인터페이스는 다양한 구현체를 가지고 있으며, 가장 널리 사용되는 구현체는 **'ArrayList'**, **'LinkedList'** 그리고 **'Vector'** 입니다.

각 구현체는 내부적인 데이터 관리 방식이 다르므로, 사용 상황에 따라 적합한 구현체를 선택할 수 있습니다.

- **'ArrayList' :** 내부적으로 배열을 사용하여 요소들을 관리합니다. 인덱스를 통한 빠른 접근이 가능하지만, 크기 조정이 필요할 때 비용이 많이 들 수 있습니다.
- **'LinkedList :'** 내부적으로 양방향 연결 리스트를 사용합니다. 데이터의 삽입과 삭제가 빈번하게 일어나는 경우 유용합니다.
- **Vector :** **'ArrayList'** 와 비슷하지만, 모든 메소드가 동기화되어 있어 멀티스레드 환경에서 사용하기에 안전합니다.

## 2.4 📝 정리.
이러한 특성들로 인해 **'List'** 인터페이스는 자바에서 데이터를 순차적으로 처리할 필요가 있는 다양한 애플리케이션에서 중요하게 사용됩니다.

---

## 3. Set 인터페이스.
자바 프로그래밍에서 **'Set'** 인터페이스는 **'java.util'** 패키지의 일부이며, 중복을 허용하지 않는 요소의 컬렉션을 나타냅니다.

**'Set'** 은 **'Collection'** 인터페이스를 확장하는 인터페이스로서, 집합의 개념을 구현합니다.
이는 각 요소가 컬렉션 내에서 유일하게 존재해야 함을 의미합니다.

인덱스로 요소를 관리하는 **'List'** 인터페이스와 달리, **'Set'** 은 요소의 순서를 유지하지 않습니다.

## 3.1 Set의 주요 특징.
- **중복 불허 :** 같은 요소의 중복을 허용하지 않으며, 이미 **'Set'** 에 존재하는 요소를 추가하려고 시도하면 그 요소는 컬렉션에 추가되지 않습니다.
- **순서 보장 없음 :** 대부분의 **'Set'** 구현체는 요소의 저장 순서를 유지하지 않습니다. 그러나 **'LinkedHashSet'** 과 같은 특정 구현체는 요소의 삽입 순서를 유지할 수 있습니다.
- **값에 의한 접근 :** **'Set'** 은 인덱스를 사용하지 않고 값에 의해 요소에 접근합니다.

## 3.2 주요 메서드.
**'Set'** 인터페이스는 **'Collection'** 인터페이스에서 상속받은 다양한 메소드를 포함합니다.
주요 메서드는 다음과 같습니다.

- **add(E e):** 요소 e를 Set에 추가합니다. 이미 존재하는 요소를 추가하려는 경우, 요소는 추가되지 않고 false를 반환합니다.
- **remove(Object o):** 지정된 객체 o를 Set에서 제거합니다.
- **contains(Object o):** Set이 지정된 객체 o를 포함하고 있는지 여부를 반환합니다.
- **size():** Set의 요소 개수를 반환합니다.
- **isEmpty():** Set이 비어 있는지 여부를 반환합니다.
- **clear():** Set의 모든 요소를 제거합니다

## 3.3 주요 구현체.
**'Set'** 인터페이스는 여러 가지 방법으로 구현될 수 있으며, 각 구현체는 다른 특성을 가집니다.

- **HashSet :** 가장 널리 사용되는 **'Set'** 구현체로, 해시 테이블을 사용하여 요소를 저장합니다. 요소의 삽입, 삭제, 검색 작업은 평균적으로 상수 시간(O(1))이 걸립니다.
- **LinkedHashSet :** **'HashSet'** 의 확장으로, 요소의 삽입 순서를 유지합니다.
- **TreeSet :** 레드-블랙 트리 구조를 사용하여 요소를 저장합니다. 요소는 자연적 순서 또는 비교자에 의해 정렬됩니다.
    - 이로 인해 삽입, 삭제, 검색 작업에 로그 시간(O(log n))이 걸립니다.

## 3.4 📝 정리.
**'Set'** 인터페이스는 주로 중복을 허용하지 않는 데이터 컬렉션을 다루는 데 사용되며, 특히 요소의 유일성을 보장하는데 유용합니다.

---

## 4. Map 인터페이스.
자바에서 **'Map'** 인터페이스는 **'java.util'** 패키지에 속하며, 키(key)와 값(value) 쌍으로 이루어진 데이터를 저장하는 자료구조를 정의합니다.

**'Map'** 은 키의 중복을 허용하지 않으면서 각 키는 하나의 값에 매핑됩니다.

값은 중복될 수 있지만, 각 키는 유일해야 합니다.

이러한 특성 때문에 **'Map'** 은 키를 통해 빠르게 데이터를 검색할 수 있는 효율적인 수단을 제공합니다.

## 4.1 Map의 주요 특징.
- **키 기반 데이터 접근 :** 키를 사용하여 데이터에 접근하므로, 키에 대한 빠른 검색, 삽입, 삭제가 가능합니다.
- **키의 유일성 :** 같은 키를 다시 **'Map'** 에 추가하려고 하면 기존 키에 연결된 값이 새 값으로 대체됩니다.
- **값의 중복 허용 :** 같은 값을 가진 여러 키가 **'Map'** 에 존재할 수 있습니다.

## 4.2 주요 메서드
**'Map'** 인터페이스는 데이터를 관리하기 위해 다음과 같은 주요 메소드를 제공합니다.

- **put(K key, V value):** 키와 값을 Map에 추가합니다. 이미 키가 존재하면, 해당 키의 값이 새로운 값으로 업데이트 됩니다.
- **get(Object key):** 지정된 키에 연결된 값을 반환합니다. 키가 존재하지 않는 경우, null을 반환합니다.
- **remove(Object key):** 지정된 키와 그 키에 매핑된 값을 Map에서 제거합니다.
- **containsKey(Object key):** Map에 특정 키가 있는지 검사합니다.
- **containsValue(Object value):** Map에 특정 값이 하나 이상 있는지 검사합니다.
- **keySet():** Map의 모든 키를 Set 형태로 반환합니다.
- **values():** Map의 모든 값을 컬렉션 형태로 반환합니다.
- **entrySet():** Map의 모든 "키-값" 쌍을 Set 형태의 Map.Entry 객체로 반환합니다.
- **size():** Map에 저장된 "키-값" 쌍의 개수를 반환합니다.
- **clear():** Map의 모든 요소를 제거합니다.

## 4.3 주요 구현체
**'Map'** 인터페이스의 주요 구현체로는 다음과 같은 클래스들이 있습니다.
- **HashMap :** 가장 일반적으로 사용되는 **'Map'** 구현체로, 해시 테이블을 사용합니다.
    - 요소의 순서를 보장하지 않으며, 키와 값에 **'null'** 을 허용합니다.

- **LinkedHashMap :** **'HashMap'** 을 상속받아 구현된 클래스로, 요소의 삽입 순서를 유지합니다.
    - 이는 순회 시 삽인된 순서대로 요소를 얻을 수 있게 해줍니다.

- **TreeMap :** 레드-블랙 트리를 기반으로 하는 **'Map'** 구현체로, 모든 키가 자연적 순서대로 정렬됩니다.
    - 정렬된 순서로의 접근이 필요할 때 유용합니다.

- **Hashtable :** **'HashMap'** 과 유사하지만, 모든 메소드가 동기화되어 있어 멀티스레드 환경에서 사용하기에 안전합니다.
    - 그러나 성능이 **'HashMap'** 보다 느리고, 키와 값에 **'null'** 을 허용하지 않습니다.

## 4.4 📝 정리.
**'Map'** 인터페이스는 다양한 애플리케이션에서 설정, 프로파일, 사용자 세션 등의 데이터를 키와 값의 형태로 관리할 때 유용하게 사용됩니다.


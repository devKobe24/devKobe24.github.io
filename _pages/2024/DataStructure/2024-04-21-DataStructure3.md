---
title: "📦[DataStructure] 배열"
tags:
    - DataStructure
date: "2024-04-21"
thumbnail: "/assets/img/thumbnail/ds.jpeg"
---

# 배열.
일반적으로 **배열(array)** 은 관련된 다수의 값을 저장할 때 사용합니다.

예를 들어, 1년간 매일 마신 커피의 양을 추적하고 싶다고 합시다.
- 이때 개별 변수(AmountDay1, AmountDay2, AmountDay3 등)를 365개 만들어서 저장할 수 있겠지만, 이 방식은 입력하기도 귀찮고 데이터를 어떤 구조로도 사용할 수 없습니다.
    - AmountDay2는 단지 텍스트 꼬리표일 뿐이며, AmountDay2 전날의 정보를 AmountDay1이 저장하고 AmountDay2 다음 날의 정보를 AmountDay3가 저장한다는 사실을 프로그램이 알 수 없습니다.
        - 개발자만 이 정보를 알고 있습니다.

배열은 여러 값을 연속적으로 **인데스(Index)** 가 부여된 상자에 저장하는 간단한 메커니즘을 제공합니다.

아래의 그림처럼 배열은 사실 개별 변수들을 한 줄로 세워둔 것이며, 컴퓨터 메모리에 존재하는 같은 크기의 상자들이 연속적으로 배치된 블록입니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8B%E1%85%B4%E1%84%89%E1%85%A1%E1%86%BC%E1%84%8C%E1%85%A1%E1%84%83%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%91%E1%85%AD%E1%84%92%E1%85%A7%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7.png?raw=true">

- 개별 변수처럼 배열도 어떤 메모리 덩어리를 차지하며 임의의 다른 정보와 인접할 수 있습니다.
- 배열의 각 상자에는 숫자, 문자, 포인터 또는 다른(크기가 정해져 있는) 자료 구조와 같은 타입의 값을 저장할 수 있습니다.

일상생활에서도 배열을 매우 많이 사용합니다.
- 예를 들어, 고등학교 복도에 늘어선 사물함은 학생들의 책과 외투를 저장하는 물리적인 배열입니다.
    - 우리는 개별 사물함을 열어 내부 공간에 쉽게 접근할 수 있습니다.

배열의 구조는 위치(또는 인덱스)를 지정하여 배열 내 개별 값, 즉 **원소(element)** 에 접근할 수 있게 해줍니다.
- 배열 내 상자들은 컴퓨터 메모리에서 서로 인접해 있으므로, 첫 번째 원소로부터 오프셋(offset)을 계산해서 해당하는 위치의 메모리를 읽는 방식으로 각 상자에 쉽게 접근할 수 있습니다.
    - 이는 접근하려는 상자의 위치와 관계없이 덧셈 한 번과 메모리 접근만 필요하다는 뜻입니다.
        - 이러한 구조는 우리의 일일 커피 섭취량을 추적하는 것과 같이 순서가 있는 항목을 저장할 때 특히 편리합니다.

형식적으로 배열 A에서 인덱스 i에 있는 값을 A[i]로 참조합니다.
- 사물함 예제에서 인덱스는 사물함 앞에 표시된 숫자에 해당합니다.

대부분의 프로그래밍 언어는 0부터 시작하는(zero based) 인덱스를 사용합니다.
- 이 말은 아래의 그림처럼 배열의 첫 번째 값은 인덱스 0, 두 번째 값은 인덱스 1, ...에 위치한다는 뜻입니다.

<img src = "https://github.com/devKobe24/images/blob/main/0%E1%84%8B%E1%85%B3%E1%86%AF%E1%84%80%E1%85%B5%E1%84%8C%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B5%E1%86%BC%E1%84%83%E1%85%AC%E1%86%AB%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF.png?raw=true">

아래 그림은 컴퓨터 메모리 안 배열 모습을 보여줍니다.
- 여기서 흰 칸이 배열 원소에 해당합니다.
<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%82%E1%85%A2%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%8B%E1%85%B50%E1%84%8B%E1%85%B3%E1%86%AF%E1%84%80%E1%85%B5%E1%84%8C%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B5%E1%86%BC%E1%84%83%E1%85%AC%E1%86%AB%E1%84%86%E1%85%A9%E1%84%89%E1%85%B3%E1%86%B8.png?raw=true">

0을 기준으로 인덱싱하면 메모리 내에서 배열의 시작점부터 오프셋을 사용해 위치를 계산할 때 편리합니다.

i번째 원소의 위치는 다음과 같이 계산할 수 있습니다.
```
위치(인덱스 i의 원소) = 위치(배열 시작) + 각 원소의 크기 x i
````

인덱스 0의 위치는 배열 시작점과 같습니다.
- 예를 들어, 위 그림에서 배열 A의 다섯 번째 원소는 A[4]이며 그림 1-4를 찾아보면 그 위치에는 9라는 값이 들어 있습니다.

> **노트**
> 인덱스를 1부터 시작하는 것도 가능하며, 일부 프로그래밍 언어는 이 규칙을 따릅니다.
> 1을 기준으로 인덱싱하는 경우 상자의 주소를 계산하는 식은 다음과 같습니다.
> ```
> 위치(인덱스 i의 원소) = 위치(배열 시작) + 각 원소의 크기 x (i-1)
> ```

대부분의 프로그래밍 언어에서는 배열 이름과 인덱스를 조합해 값을 가져오거나 설정합니다. 
- 예를 들어, 다음과 같이 인덱스가 5인 상자의 값을 16으로 설정할 수 있습니다.

```
A[5] = 16
````

커피 추적 예제에서 하루 동안 섭취한 커피 컵 수를 저장하기 위해 Amount라는 배열을 정의하고, 해당 수량을 Amount[0] 부터 Amount[364]까지 저장할 수 있습니다.
- 배열을 사용하면 단 하나의 이름으로 365개 다른 값에 순서대로 접근 할 수 있는데, 이름은 비슷하지만 서로 독립적인 변수들을 연속적으로 위치시켰던 것을 수학적인 오프셋으로 전환한 것입니다.

이 개념의 장점을 이해하려면 학교 사물함을 생각하면 됩니다.
- 개별 사물함을 '제레미의 사물함'이나 'K로 시작하는 세 번째 학생의 사물함'처럼 이름 붙이면 빠르게 찾기가 거의 불가능합니다.
    - 이런 방식을 사용하면 그냥 인덱스를 사용하는 경우와 달리 모든 사물함에 붙은 꼬리표를 일일이 찾아봐야 합니다.

하지만 배열 인덱스를 사용하면 학생들은 오프셋을 사용해 사물함이 어디 있는지 결정하고 직접 해당 사물함에 접근할 수 있습니다.

종종 배열을 전체 자료 구조로 시각화하고 논의하지만, 각 상자가 개별 변수처럼 작동한다는 사실을 기억하는 것이 중요합니다.
- 배열을 전체적으로 바꾸려면 모든 상자를 하나하나 바꿔야 합니다.
    - 예를 들어, 원소를 한 칸 앞으로 이동시키고 싶으면 아래 그림처럼 해야 합니다.
<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%8B%E1%85%B4%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%A9%E1%84%85%E1%85%B3%E1%86%AF%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8F%E1%85%A1%E1%86%AB%E1%84%8A%E1%85%B5%E1%86%A8%E1%84%8B%E1%85%A1%E1%87%81%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%84%8F%E1%85%B5%E1%84%80%E1%85%B5.png?raw=true">

배열은 책장에 꽂혀 있는 책들과 다릅니다.
- '커피 애호가를 위한 최고의 공정 무역 커피 가이드'를 끼워넣기 위해 책 컬렉션 전체를 밀어낼 수 있지만, 배열을 그렇지 않습니다.

배열은 오히려 일렬로 늘어선 가게와 같습니다.
- 서점과 미용실 사이에 커피숍을 끼어넣을 수 없습니다.
    - 커피숍 공간을 확보하려면 인접한 건물로 서점(또는 미용실)을 이전해서 기존 공간을 비우는 방식으로 가게를 하나씩 옮겨야만 합니다.

실제로 배열에서 단순히 두 값을 교환하고 싶은 경우에도 값들을 미묘하게 조정해야 합니다.
- 예를 들어, 어떤 인덱스 i와 j에 있는 두 값을 교환하려면 먼저 둘 중 하나를 임시 변수에 할당해야 합니다.
```
Temp = A[i]
A[i] = A[j]
A[j] = Temp
````

- 그렇지 않으면 어떤 한 상자 안 값을 덮어쓰게 되어 두 상자가 동일한 값을 가지게 됩니다.

마찬가지로 커피숍과 서점의 위치를 바꾸려고 한다면, 먼저 서점의 가구와 물품 등을 비어 있는 세 번째 임시 위치로 커피숍의 것들을 넣을 수 있는 공간을 확보해야 합니다.
- 그 후 커피숍을 옮길 수 있고, 서점의 가구와 물품 등을 세 번째 임시 위치에서 커피숍의 이전 위치로 옮길 수 있습니다.

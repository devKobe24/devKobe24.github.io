<!DOCTYPE html>
<html lang="en">
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
    
        Java
    
</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Index | devkobe24.com</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="Index">
<meta property="og:locale" content="en_US">
<meta name="description" content="Kobe - Developer blog">
<meta property="og:description" content="Kobe - Developer blog">
<meta property="og:site_name" content="devkobe24.com">
<meta property="og:type" content="article">
<meta property="article:published_time" content="1900-01-01T00:00:00+09:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Index">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"1900-01-01T00:00:00+09:00","datePublished":"1900-01-01T00:00:00+09:00","description":"Kobe - Developer blog","headline":"Index","mainEntityOfPage":{"@type":"WebPage","@id":"/Backend/Java/"},"url":"/Backend/Java/"}</script>
<!-- End Jekyll SEO tag -->


<link rel="shortcut icon" type="image/png" href="/assets/img/favicon.webp">
<style>
@font-face {
    font-family: 'Nunito Sans';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Nunito Sans'),
         url("/assets/fonts/NunitoSans-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Righteous';
    font-style: normal;
    font-weight: 600;
    font-display: optional;
    src: local('Righteous'),
         url("/assets/fonts/Righteous-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Lato';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Lato'),
         url("/assets/fonts/Lato-Regular.woff2") format("woff2");
}
</style>

<script src="/assets/js/fontfaceobserver.js" type="text/javascript"></script>
<script type="text/javascript">
    const nunitoObserver = new FontFaceObserver('Nunito Sans');
    const righteousObserver = new FontFaceObserver('Righteous');
    const latoObserver = new FontFaceObserver('Lato');
  
    Promise.all([
        nunitoObserver.load(),
        righteousObserver.load(),
        latoObserver.load(),
    ]).then(function(){
        document.documentElement.className += " fonts-loaded";
    });
</script>

<meta name="baseurl" content="">
<meta name="description" content="Kobe - Developer blog">
        <link rel="preload" href="/assets/img/profile.jpg" as="image">
        <link rel="stylesheet" href="/assets/css/style.css">
        
    </head>
    <body>
        <script type="text/javascript">
            let currentTheme = localStorage.getItem('theme');
        
            document.body.classList[currentTheme === 'dark' ? 'add' : 'remove']('dark-theme');
        </script>
        <canvas id="stars" width="100%" height="100%"></canvas>
        <div class="sidebar sidebar-left">
    <div class="side-banner">
        <h1 class="site-tab">
            <a href="/" class="site-name">
                <img src="/assets/img/icon/house.webp" alt="" loading="lazy">
                <mark>devkobe24.com</mark>
            </a>
            <button id="btn-brightness" aria-label="brightness-button">
                <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
                <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
            </button>
            <button id="btn-search" aria-label="search-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
            </button>
            <button id="btn-nav" aria-pressed="false" aria-label="menu-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"></path></svg>
            </button>
        </h1>
        <a href="/" class="site-avatar" aria-label="site-avatar">
            <img src="/assets/img/profile.jpg" loading="lazy" alt="homepage" aria-label="homepage-button">
        </a>
    </div>
    <div class="side-info">
        <nav id="navigation">
    
    
    

    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

    
    
    

    <ul class="nav-list">
<li id="nav-first" aria-label="2024">
            <div class="nav-item">
                <a href="/2024/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>2024</span>
                </a><button class="nav-list-expander" aria-label="toggle items in 2024 category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="AWS">
                    <div class="nav-item">
                        <a href="/2024/AWS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>AWS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CPP_DS">
                    <div class="nav-item">
                        <a href="/2024/CPP_DS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CPP_DS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CS">
                    <div class="nav-item">
                        <a href="/2024/CS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="DataStructure">
                    <div class="nav-item">
                        <a href="/2024/DataStructure/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>DataStructure</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Database">
                    <div class="nav-item">
                        <a href="/2024/Database/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Database</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="HackTheSwift">
                    <div class="nav-item">
                        <a href="/2024/HackTheSwift/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>HackTheSwift</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/2024/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Leet-Code">
                    <div class="nav-item">
                        <a href="/2024/Leet-Code/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Leet-Code</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="MySQL">
                    <div class="nav-item">
                        <a href="/2024/MySQL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>MySQL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Network">
                    <div class="nav-item">
                        <a href="/2024/Network/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Network</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="OS">
                    <div class="nav-item">
                        <a href="/2024/OS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>OS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Read English Book">
                    <div class="nav-item">
                        <a href="/2024/Read%20English%20Book/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Read English Book</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="SQL">
                    <div class="nav-item">
                        <a href="/2024/SQL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>SQL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Spring &amp; Spring Boots">
                    <div class="nav-item">
                        <a href="/2024/Spring%20&amp;%20Spring%20Boots/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Spring &amp; Spring Boots</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="TIL">
                    <div class="nav-item">
                        <a href="/2024/TIL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>TIL</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Web">
                    <div class="nav-item">
                        <a href="/2024/Web/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Web</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Backend">
            <div class="nav-item">
                <a href="/Backend/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Backend</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Backend category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="AWS">
                    <div class="nav-item">
                        <a href="/Backend/AWS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>AWS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="AnD">
                    <div class="nav-item">
                        <a href="/Backend/AnD/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>AnD</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="CS">
                    <div class="nav-item">
                        <a href="/Backend/CS/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>CS</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="DB">
                    <div class="nav-item">
                        <a href="/Backend/DB/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>DB</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="ENG">
                    <div class="nav-item">
                        <a href="/Backend/ENG/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>ENG</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java多識">
                    <div class="nav-item">
                        <a href="/Backend/Java%E5%A4%9A%E8%AD%98/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java多識</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/Backend/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Math">
                    <div class="nav-item">
                        <a href="/Backend/Math/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Math</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Network">
                    <div class="nav-item">
                        <a href="/Backend/Network/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Network</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Post">
                    <div class="nav-item">
                        <a href="/Backend/Post/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Post</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="TIL">
                    <div class="nav-item">
                        <a href="/Backend/TIL/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>TIL</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Metacognition">
            <div class="nav-item">
                <a href="/Metacognition/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Metacognition</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Metacognition category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list"><li id="nav-second" aria-label="Java">
                    <div class="nav-item">
                        <a href="/Metacognition/Java/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Java</span>
                        </a>
</div>
</li></ul>
</li>
<li id="nav-first" aria-label="Home">
            <div class="nav-item">
                <a href="/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Home</span>
                </a>
</div>
</li>
</ul>
</nav>
        <div id="contact">
            <hr>
            <h3>Contact</h3>
            <ul class="contact-list">
                
                    <li><a aria-label="My Github" href="https://github.com/devKobe24">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Email" href="mailto:dev.skyachieve91@gmail.com">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48H48zM0 176V384c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V176L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"></path></svg>
                    </a></li>
                
                <!-- 
                    <li><a aria-label="My Twitter" href="https://twitter.com/twitter">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.4 151.7c.3 4.5 .3 9.1 .3 13.6 0 138.7-105.6 298.6-298.6 298.6-59.5 0-114.7-17.2-161.1-47.1 8.4 1 16.6 1.3 25.3 1.3 49.1 0 94.2-16.6 130.3-44.8-46.1-1-84.8-31.2-98.1-72.8 6.5 1 13 1.6 19.8 1.6 9.4 0 18.8-1.3 27.6-3.6-48.1-9.7-84.1-52-84.1-103v-1.3c14 7.8 30.2 12.7 47.4 13.3-28.3-18.8-46.8-51-46.8-87.4 0-19.5 5.2-37.4 14.3-53 51.7 63.7 129.3 105.3 216.4 109.8-1.6-7.8-2.6-15.9-2.6-24 0-57.8 46.8-104.9 104.9-104.9 30.2 0 57.5 12.7 76.7 33.1 23.7-4.5 46.5-13.3 66.6-25.3-7.8 24.4-24.4 44.8-46.1 57.8 21.1-2.3 41.6-8.1 60.4-16.2-14.3 20.8-32.2 39.3-52.6 54.3z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Instagram" href="https://www.instagram.com/instagram">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Facebook" href="https://www.facebook.com/facebook">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M512 256C512 114.6 397.4 0 256 0S0 114.6 0 256C0 376 82.7 476.8 194.2 504.5V334.2H141.4V256h52.8V222.3c0-87.1 39.4-127.5 125-127.5c16.2 0 44.2 3.2 55.7 6.4V172c-6-.6-16.5-1-29.6-1c-42 0-58.2 15.9-58.2 57.2V256h83.6l-14.4 78.2H287V510.1C413.8 494.8 512 386.9 512 256h0z"/></svg>
                    </a></li>
                
                
                    <li><a aria-label="My LinkedIn" href="https://www.linkedin.com/in/linkedin">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
                    </a></li>
                 -->
            </ul>
            <hr>
            <span>
                Copyright © 2024 | <a href="https://github.com/byanko55/jekyll-theme-satellite">Yankos</a>
            </span>
        </div>
    </div>
</div>
<div class="sidebar sidebar-right">
    <div class="tools">
        <button id="btn-brightness" aria-label="brightness-button">
            <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
            <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
        </button>
        <button id="btn-search" aria-label="search-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
        </button>
    </div>
</div>

        <div id="post">
            <div class="inner-header">
                <span class="dot" style="background-color: #F86158;"></span>
                <span class="dot" style="background-color: #FBBF2D;"></span>
                <span class="dot" style="background-color: #2ACB45;"></span>
            </div>
            <div class="inner-content">
                <div class="category-tree">
<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 576 512"><path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"></path></svg>
    <p>
                <a href="/">Home</a>
                &gt;
            <a href="/Backend/">Backend</a>
                &gt;
            
                
                    Java
                
            </p>
</div>
                
                    <div id="loading">
    <div class="loading_box">
        <img src="/assets/img/loading.webp" loading="lazy">
        <p>Now Loading ...</p>
    </div>
</div>
                    <h1 class="category-header">
    
        Java
    
</h1>
<div id="category-list">
    <ul class="paginated-list" data-current-page="1" aria-live="polite">
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-08-21-Object-Class.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-08-21-Object-Class.html"><h1 class="title_post">☕️[Java] Object 클래스</h1></a>
                        <a href="/Backend/Java/2024-08-21-Object-Class.html" class="txt_post">
                            ☕️[Java] Object 클래스.
자바에서 모든 클래스의 “최상위 부모 클래스는 항상 'Object' 클래스”  입니다.



1️⃣ Object 클래스.

package lang.object;

// 부모가 없으면 묵시적으로 Object 클래스를 상속 받습니다.
public class Parent {
    public void parentMethod() {
        System.out.println("Parent.parentMethod");
    }
}



  위 코드는 묵시적으로 'Object' 클래스를 상속 받기 때문에 'extends Object' 코드가 없습니다.
    
      위 코드를 명시적으로 구현하면 아래와 같습니다.
        
          즉, 위 코드와 아래 코드는 같은 코드입니다.
        
      
    
  



  ✏️ 묵시적(Implicit) vs 명시적(Explicit)
묵시적(Implicit) : 개발자가 코드에 직접 기술하지 않아도 시스템 또는 컴파일러에 의해 자동으로 수행되는 것을 의미.
명시적(Explicit) : 개발자가 코드에 직접 기술해서 작동하는 것을 의미.


package lang.object;


public class Parent extends Object {
    public void parentMethod() {
        System.out.println("Parent.parentMethod");
    }
}


  클래스에 상속 받을 부모 클래스가 없으면 “묵시적으로 'Object' 클래스” 를 상속 받습니다.
    
      즉, 자바가 'extends Object' 코드를 넣어줍니다.
        
          따라서 'extends Object'는 생략하는 것을 권장합니다.
        
      
    
  


package lang.object;

public class Child extends Parent {
    public void childMethod() {
        System.out.println("Child.childMethod");
    }
}


  클래스에 상속 받을 부모 클래스를 명시적으로 지정할 경우에는 'Object' 상속 받지 않습니다.
    
      즉, 이미 명시적으로 상속했기 때문에 Java가 'extends Object' 코드를 넣지 않는 것입니다.
    
  


package langReview.object;

public class ObjectMain {
    public static void main(String[] args) {
        Child child = new Child();
        child.childMethod();
        child.parentMethod();

        // toString()은 Object 클래스의 메서드
        String string = child.toString();
        System.out.println(string);
    }
}


실행 결과
Child.childMethod
Parent.parentMethod
langReview.object.Child@452b3a41


실행 결과 그림

  'Parent' 는 'Object' 를 묵시적으로 상속 받았기 때문에 메모리에도 함께 생성됩니다.





  
    
      'child.toString()' 을 호출합니다.
    
  
  
    
      먼저 본인의 타입인 'Child' 에서 'toString()' 을 찾습니다.
        
          'toString()' 이 없으므로 부모 타입으로 올라가서 찾습니다.
        
      
    
  
  
    
      부모 타입인 'Parent' 에서 'toString()' 을 찾습니다.
        
          이곳에도 없으므로 부모 타입으로 올라가서 찾습니다.
        
      
    
  
  
    
      부모 타입인 'Object' 에서 'toString()' 을 찾습니다.
        
          부모 타입인 'Object' 에는 'toString()' 이 있으므로 이 메서드를 호출합니다.
        
      
    
  


정리

  자바에서 모든 객체의 최종 부모는 'Object' 다.


2️⃣ 자바에서 Object 클래스가 최상위 부모 클래스인 이유.
모든 클래스가 'Object' 클래스를 상속 받는 이유는 다음과 같습니다.

  공통 기능 제공.
  다형성의 기본 구현.


1️⃣ 공통 기능 제공.

  객체의 정보를 제공하고, 이 객체가 다른 객체와 같은지 비교하고, 객체가 어떤 클래스로 만들어졌는지 확인하는 기능은 모든 객체에게 필요한 기본 기능입니다.
    
      이런 기능을 객체를 만들 때 마다 항상 새로운 메서드를 정의해서 만들어야 한다면 상당히 번거로울 것입니다.
      그리고 막상 만든다고 해도 개발자마다 서로 다른 이름의 메서드를 만들어서 일관성이 없을 것입니다.
        
          예를 들어서 객체의 정보를 제공하는 기능을 만든다고 하면 어떤 개발자는 'toString()' 으로 또 어떤 개발자는 'objectInfo()' 와 같이 서로 다른 이름으로 만들 수 있습니다.
          객체를 비교하는 기능을 만들 때고 어떤 개발자는 'equals()' 로 어떤 개발자는 'same()' 으로 만들 수 있습니다.
        
      
    
  
  'Object' 는 모든 객체에 필요한 '공통 기능' 을 제공합니다.
  'Object' 는 최상위 부모 클래스이기 때문에 모든 객체는 '공통 기능' 을 편리하게 제공(상속) 받을 수 있습니다.
  'Object' 가 제공하는 기능은 다음과 같습니다.
    
      객체의 정보를 제공하는 'toString()'
      객체의 같음을 비교하는 'equals()'
      객체의 클래스 정보를 제공하는 'getClass()'
      기타 여러가지 기능
    
  
  개발자는 모든 객체가 앞서 설명한 메서드를 지원한다는 것을 알고 있습니다.
    
      따라서 프로그래밍이 단순화되고, 일관성을 가집니다.
    
  


2️⃣ 다형성의 기본 구현.

  부모는 자식을 담을 수 있습니다.
  'Object' 는 모든 클래스의 부모 클래스 입니다.
    
      따라서 모든 객체를 참조할 수 있습니다.
    
  
  'Object' 클래스는 다형성을 지원하는 기본적인 메커니즘을 제공합니다.
    
      모든 자바 객체는 'Object' 타입으로 처리될 수 있으며, 이는 다양한 타입의 객체를 통합적으로 처리할 수 있게 해줍니다.
        
          즉, 'Object' 는 모든 객체를 다 담을 수 있습니다.
          타입이 다른 객체들을 어딘가에 보관해야 한다면 바로 'Object' 에 보관하면 됩니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-08-21-Java-lang.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-08-21-Java-lang.html"><h1 class="title_post">☕️[Java] java.lang 패키지</h1></a>
                        <a href="/Backend/Java/2024-08-21-Java-lang.html" class="txt_post">
                            ☕️[Java] java.lang 패키지.
자바가 기본으로 제공하는 라이브러리(클래스 모음) 중에 가장 기본이 되는 것이 바로 'java.lang' 패키지 입니다.
여기서 'lang' 은 'Language(언어)' 의 줄임말 입니다.
즉, 자바 언어를 이루는 가장 기본이 되는 클래스들을 보관하는 패키지를 뜻합니다.

1️⃣ java.lang 패키지의 대표적인 클래스들.

  'Object'
    
      모든 자바 객체의 부모 클래스.
    
  
  'String'
    
      문자열.
    
  
  'Integer, Long, Double'
    
      래퍼 타입, 기본형 데이터 타입을 객체로 만든 것.
    
  
  'Class'
    
      클래스 메타 정보.
    
  
  'System'
    
      시스템과 관련된 기본 기능들을 제공
        
          🙋‍♂️ 여기서 나열한 클래스들은 자바 언어의 기본을 이루기 때문에 반드시 잘 알아두어야 합니다.
        
      
    
  


2️⃣ import 생략 가능.

  'java.lang' 패키지는 모든 자바 애플리케이션에 자동으로 'import' 됩니다.
    
      따라서 'import' 구문을 사용하지 않아도 됩니다.
    
  


package langReview;

public class LangMain {
    public static void main(String[] args) {
        System.out.println("hello java");
    }
}


  'import java.lang.System' 코드가 없어도 정상 동작합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-21</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-08-05-RequiredArgsConstructor.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-08-05-RequiredArgsConstructor.html"><h1 class="title_post">☕️[Java] @RequiredArgsConstructor의 역할.</h1></a>
                        <a href="/Backend/Java/2024-08-05-RequiredArgsConstructor.html" class="txt_post">
                            ☕️[Java] @RequiredArgsConstructor 역할.


  RequiredArgsConstructor 어노테이션은 Lombok 라이브러리에서 제공하는 기능 중 하나로, 클래스에 필수적인 생성자를 자동으로 생성하는 역할을 합니다.
  이 어노테이션을 클래스에 적용하면, Lombok 이 그 클래스의 final 필드 또는 @NonNull 어노테이션이 붙은 필드를 인자로 받는 생성자를 자동으로 생성합니다.


1️⃣ @RequiredArgsConstructor의 주요 기능.

  1. 자동 생성자 생성
    
      클래스 내의 모든 final 필드와 @NonNull 어노테이션이 붙은 필드에 대한 생성자를 자동으로 생성합니다.
      이 생성자는 이 필드들을 초기화하는 데 필요한 파라미터를 요구합니다.
    
  
  2. 코드 간결화
    
      수동으로 생성자를 작성하는 번거로움을 줄여줍니다.
      특히 많은 필드를 가진 클래스에서 유용하게 사용될 수 있습니다.
    
  
  3. 불변성 강화
    
      final 필드를 사용함으로써 클래스의 불변성을 강화할 수 있습니다.
      생성자를 통해 한 번 설정되면, 이 필드들의 값은 변경될 수 없습니다.
    
  
  4. 의존성 주입 용이
    
      Spring과 같은 프레임워크에서 생성자를 통한 의존성 주입을 사용할 때 유용합니다.
      필요한 의존성을 생성자를 통해 주입받기 때문에, 컴포넌트 간의 결합도를 낮출 수 있습니다.
    
  


2️⃣ 사용 예시.


  다음은 @RequiredArgsConstructor 어노테이션을 사용한 간단한 클래스 예제입니다.


import lombok.RequiredArgsConstructor;
import lombok.NonNull;

@RequiredArgsConstructor
public class UserData {
    private final String username; // final 필드에 대한 생성자 파라미터 자동 포함.
    @NonNull private String email; // @NonNull 필드에 대한 생성자 파라미터 자동 포함.
    
    // 추가 메소드 등
}



  위 코드에서 UserData 클래스에는 username 과 email 두 필드가 있으며, username 은 final 로 선언되어 수정할 수 없고, email 은 @NonNull 어노테이션이 붙어 null 값을 허용하지 않습니다.
  Lombok은 이 두 필드를 초기화하는 생성자를 자동으로 생성합니다.


3️⃣ 주의 사항.

  @RequiredArgsConstructor 는 필드가 많고, 특히 final 또는 @NonNull 필드가 있는 경우 유용합니다.
    
      그러나 생성자를 통한 초기화가 필요하지 않은 필드에는 적용되지 않습니다.
    
  
  Lombok을 사용하면 코드가 간결해지고 가독성이 향상되지만, 코드의 명시성이 다소 떨어질 수 있습니다.
    
      따라서 Lombok 사용 시, 팀 내에서 Lombok에 대한 이해도가 충분한지 확인하는 것이 좋습니다.
    
  





  Lombok 의 @RequiredArgsConstructor 는 반복적인 코드 작성을 줄여주고, 오류 가능성을 감소시키며, 더 깔끔하고 관리하기 쉬운 코드베이스를 유지하는 데 도움을 줄 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-08-02-Transactional.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-08-02-Transactional.html"><h1 class="title_post">☕️[Java] @Transactional의 역할과 의미.</h1></a>
                        <a href="/Backend/Java/2024-08-02-Transactional.html" class="txt_post">
                            ☕️[Java] @Transactional의 역할과 의미.


  @Transaction 어노테이션은 스프링 프레임워크에서 제공하는 선언적 트랜젝션 관리 기능을 활용하기 위해 사용됩니다.
  이 어노테이션을 사용함으로써, 특정 메서드 또는 클래스 전체에 걸쳐 데이터베이스 트랜잭션의 경계를 설정할 수 있습니다.
  트랜잭션은 일련의 연산들이 전부 성공적으로 완료되거나, 하나라도 실패할 경우 전체를 취소(롤백)하여 데이터의 일관성과 정합성을 보장하는 것을 목적으로 합니다.


1️⃣ @Transactional의 주요 기능과 특징.


  1. 자동 롤백
    
      @Transactional 이 적용된 메서드에서 런타임 예외(RuntimeException)가 발생하면, 그 트랜잭션에서 수행된 모든 변경이 자동으로 롤백됩니다.
      이는 데이터의 일관성을 유지하는 데 필수적입니다.
    
  
  2. 프로파게이션(Propagation)
    
      트랜잭션의 전파 행위를 제어합니다.
        
          예를 들어, 이미 진행 중인 트랜잭션이 있을 때 새로운 트랜잭션을 시작할 것인지, 아니면 기존 트랜잭션을 참여할 것인지 결정할 수 있습니다.
            
              REQUIRED(기본값) : 이미 진행 중인 트랜잭션이 있다면 그 트랜잭션이 참여하고, 없다면 새로운 트랜잭션을 시작합니다.
              REQUIRED_NEW : 항상 새로운 트랜잭션을 시작합니다. 이미 진행 중인 트랜잭션이 있다면 잠시 보류합니다.
            
          
        
      
    
  
  3. 격리 수준(Isolation Level)
    
      다른 트랜잭션이 데이터에 동시에 접근했을 때 발생할 수 있는 문제를 제어합니다.
        
          예를 들어, READ_COMMITTEED, REPEATED_READ, SERIALIZABLE 등 다양한 격리 수준을 지정할 수 있습니다.
        
      
    
  
  4. 읽기 전용(Read-Only)
    
      트랜잭션을 읽기 전용으로 설정할 수 있어, 데이터 수정이 이루어지지 않는다는 것을 데이터베이스 최적화 엔진에 알려 성능을 향상시킬 수 있습니다.
    
  
  5. 롤백 규칙(Rollback Rules)
    
      특정 예외가 발생했을 때 롤백을 수행할지 아니면 커밋을 수행할지를 세밀하게 제어할 수 있습니다.
      기본적으로 런타임 예외에서는 롤백을 수행하고, 체크 예외에서는 커밋을 수행합니다.
    
  


2️⃣ 사용 예제.
import org.springframework.transaction.annotation.Transactional;
import org.springframework.stereotype.Service;

@Service
public class TransactionalService {
    
    @Transactional(readOnly = true)
    public User getUser(Long id) {
        return userRepository.findById(id);
    }
    
    @Transactional(rollbackFor = Exception.class)
    public User updateUser(User user) {
        return userRepository.save(user);
    }
}


  위 예시처럼, getUser 메서드는 데이터를 변경하지 않고 조회만 수행하기 때문에 readOnly = true 로 설정했습니다.
  반면, updateUser 메서드는 데이터를 변경할 가능성이 있으므로, 모든 예외(Exception)가 발생할 경우 롤백하도록 설정했습니다.




@Transactional 을 사용함으로써 개발자는 복잡한 트랜잭션 관리 코드를 직접 작성하지 않고도, 스프링 프레임워크가 제공하는 선언적 방식을 통해 간단하게 트랜잭션을 관리할 수 있게 됩니다.
이는 애플리케이션의 데이터 처리 로직을 더욱 안정적이고 효율적으로 만듭니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-08-01-SerializationAndDeserialization.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-08-01-SerializationAndDeserialization.html"><h1 class="title_post">☕️[Java] ObjectMapper 클래스, 직렬화와 역직렬화</h1></a>
                        <a href="/Backend/Java/2024-08-01-SerializationAndDeserialization.html" class="txt_post">
                            ☕️[Java] ObjectMapper 클래스, 직렬화와 역직렬화.


  ObjectMapper 는 주로 JSON 데이터를 처리하기 위해 사용되는 Jackson 라이브러리의 핵심 클래스입니다.
  이 클래스는 자바 객체와 JSON 형식 간의 직렬화(Serialization)와 역직렬화(Deserialization)를 수행합니다.
  ObjectMapper 는 JSON 데이터를 자바 객체로 변환하거나 자바 객체를 JSON 데이터로 변환하는 등의 작업을 매우 효율적으로 처리할 수 있게 해줍니다.


1️⃣ 직렬화(Serialization)


  ObjectMapper 를 사용하여 자바 객체를 JSON 문자열로 직렬화하는 과정은 다음과 같습니다.


import com.fasterxml.jackson.databind.ObjectMapper;

// 예시 자바 객체
pulbic class User {
    public String name;
    public int age;
}

// 직렬화 예제
ObjectMapper mapper = new ObjectMapper();
User user = new User();
user.name = "Kobe";
user.age = "30";

String json = mapper.writeValueAsString(user); // 자바 객체를 JSON 문자열로 변환

System.out.println(json);


2️⃣ 역직렬화(Deserialization)


  ObjectMapper 를 사용하여 JSON 문자열을 자바 객체로 역직렬화하는 과정은 다음과 같습니다.


import com.fasterxml.jackson.databind.ObjectMapper;

// 예시 자바 객체
public class User {
    public String name;
    public int age;
}

// 역직렬화 예제
ObjectMapper mapper = new ObjectMapper();
String json = "{\"name\":\"Kobe\", \"age\":30}";

User user = mapper.readValue(json, User.class); // JSON 문자열을 자바 객체로 변환

Systeom.out.println(user.name + " is" + user.age + " year old.");


3️⃣ 주요 기능


  
    다양한 데이터 포맷 지원 :  ObjectMapper 는 JSON 외에도 XML, CSV 등 여러 데이터 포맷을 지원합니다.(Jackson 데이터 포맷 모듈 설치 필요).
  
  유연성과 설정 : ObjectMapper 는 맞춤 설정이 가능하여, 다양한 JSON 직렬화/역직렬화 방법을 지원합니다.
    
      예를 들어, 필드 이름의 자동 감지, 날짜 형식 지정, 무시할 필드 설정 등을 조정할 수 있습니다.
    
  
  성능 : Jackson은 JSON 처리를 위해 최적화된 라이브러리 중 하나로, 대용량 데이터 처리에도 뛰어난 성능을 보입니다.




🤔 직렬화와 역직렬화란?


  직렬화(Serialization)와 역직렬화(Deserialization)는 데이터 구조 또는 객체 상태를 저장하고 전송하기 위해 다루기 쉬운 데이터 포맷으로 변환하는 과정을 의미합니다.
    
      컴퓨터 과학의 맥락에서 이 개념은 특히 중요하며, 객체 지향 프로그래밍에서 널리 사용됩니다.
    
  


1️⃣ 직렬화(Serialization)

  직렬화는 객체의 상태(즉, 객체가 가진 데이터와 그 구조)를 일련의 바이트로 변환하는 과정입니다.
    
      이 바이트 스트림은 나중에 파일, 데이터베이스 또는 네트워크를 통해 쉽게 저장하거나 전송할 수 있습니다.
        
          예를 들어, 자바에서는 Serialization 인터페이스를 구현한 객체를 바이트 스트림으로 변환하여 파일 시스템에 저장하거나 네트워크를 통해 다른 시스템으로 보낼 수 있습니다.
        
      
    
  


2️⃣ 직렬화의 주요 목적.

  
    
      영속성 : 객체의 상태를 영구적으로 저장하여 나중에 다시 로드할 수 있습니다.
    
  
  
    
      네트워크 전송 : 객체를 네트워크를 통해 다른 시스템으로 전송하기 위해 사용됩니다.
    
  
  
    
      데이터 교환 : 다양한 언어나 플랫폼 간의 데이터 교환이 가능하도록 합니다.
    
  


3️⃣ 역직렬화(Deserialization)

  역직렬화는 직렬화된 바이트 스트림을 다시 원래의 객체 상태로 복원하는 과정입니다.
    
      즉, 파일, 데이터베이스 또는 네트워크로부터 바이트 스트림을 읽어 들여서 실행 중인 프로그램에서 사용할 수 있는 실제 객체로 변환합니다.
      이 과정은 직렬화의 반대 과정으로, 복원된 객체는 원복 객체와 동일한 상태를 가집니다.
    
  


4️⃣ 역직렬화의 주요 사용 사례.

  
    
      객체 복원 : 저장되거나 전송된 데이터로부터 객체를 재구성합니다.
    
  
  
    
      상태 복구 : 애플리케이션의 이전 상태를 복구하는 데 사용됩니다.
    
  
  
    
      데이터 접근 : 다른 시스템에서 전송된 데이터를 로컬 시스템에서 접근하고 사용할 수 있게 합니다.
    
  


5️⃣ 데이터 포맷과 직렬화 도구

  다양한 데이터 포맷(JSON, XML, YAML 등)과 여러 프로그래밍 언어 또는 라이브러리에서 직렬화와 역직렬화를 지원합니다.
  자바에서는 ObjectMapper 를 사용해 JSON 데이터 포맷으로의 직렬화와 역직렬화를 처리하며, 이는 데이터를 쉽게 읽고 쓸 수 있는 구조로 만드는 데 유용합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-08-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-31-attribute.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-31-attribute.html"><h1 class="title_post">☕️[Java] attribute의 의미와 역할</h1></a>
                        <a href="/Backend/Java/2024-07-31-attribute.html" class="txt_post">
                            ☕️[Java] attribute의 의미와 역할.


  Java 백엔드 개발에서 “attribute”라는 용어는 몇 가지 다른 맥락에서 사용될 수 있습니다.
  주로 두 가지 의미로 사용되는 경우가 많은데, 클래스의 속성 을 의미하는 경우와 웹 개발에서 HTTP 요청이나 세션과 관련된 데이터를 지칭하는 경우입니다.


1️⃣ 클래스의 속성(Field or Property)

  Java에서 클래스의 “attribute” 는 해당 클래스의 상태를 정의하는 변수를 말합니다.
    
      이러한 변수들은 객체의 데이터이터를 저장하고, 클래스의 인스턴스들이 갖는 특징과 상태 정보를 나타냅니다.
        
          예를 들어, ‘Person’ 클래스가 있다면, ‘name’, ‘age’ 같은 필드들이 이 클래스의 “attribute” 가 됩니다.
        
      
    
  


public class Person {
    private String name; // Attribute
    private int age; // Attribute
    
    // Constructors, getters, setters 등
}


2️⃣ 웹 개발에서의 Attribute

  웹 개발에서 “attribute” 는 주로 세션(Session)이나 요청(Request) 객체에 저장된 데이터를 지칭 합니다.
    
      이 데이터는 사용자가 웹 사이트를 이용하는 동안 지속되거나 요청 동안에만 존재할 수 있습니다.
        
          예를 들어, 사용자가 로그인을 하면 그 사용자의 정보를 세션 attribute로 저장하여 다른 페이지에서도 사용자 정보를 유지할 수 있게 합니다.
        
      
    
  


// 세션에 사용자 정보 저장
request.getSession().setAttribute("user", userObject);

// 세션에서 사용자 정보 가져오기
User user = (User) request.getSession().getAttribute("user");



  이 두 가지 사용 사례는 Java 백엔드 개발에서 매우 흔하게 접할 수 있으며, 각각의 맥락에서 attribute가 가지는 의미와 역할을 이해하는 것은 중요합니다.
    
      첫 번째 경우는 객체 지향 프로그래밍의 핵심 요소로 클래스의 속성을 정의합니다.
      두 번째 경우에는 웹 애플리케이션의 상태 관리를 돕는 수단으로서 활용됩니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-31-MainBuildFail.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-31-MainBuildFail.html"><h1 class="title_post">☕️[Java] Main 클래스 생성 후 오류 대처.</h1></a>
                        <a href="/Backend/Java/2024-07-31-MainBuildFail.html" class="txt_post">
                            ☕️[Java] Main 클래스 생성 후 오류 대처.

1️⃣ 메인 클래스 생성.

  모든 프로젝트에는 메인 클래스가 있어야 합니다.
    
      직접 만든 클래스를 메인 클래스로 사용하기 위해 다음과 같이 코드를 입력했다고 가정해봅시다.
    
  


// PortfolioBolgApplication.java

package com.devkobe.portfolioBlog;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PortfolioBolgApplication {
    public static void main(String[] args) {
        SpringApplication.run(PortfolioBolgApplication.class, args);
    }
}



  코드 작성이 끝났다면 클래스 왼쪽에 실행 아이콘 ▶︎을 누르고, [RUN] 버튼을 눌러 클래스를 실행했을 경우 콘솔창에서 애플리케이션이 실행되면 성공입니다.


2️⃣ 실패했을 경우.

Process 'command...bin/java 'finshed with non-zero exit value 1'


  콘솔창에 위와 같은 오류 발생시에는 다음과 같이 순차적으로 해결하면 됩니다.
    
      
        
          Settings 로 들어갑니다.
        
      
      
        
          Build, Excecution, Deplyment 카테고리를 찾아 펼칩니다.
        
      
      
        
          하위에 Gradle을 클릭합니다.
        
      
      
        
          ‘Build and run using’ 이라는 색션을 찾습니다.
            
              이것의 선택값이 ‘Gradle(default)’ 일 것입니다.
            
            
              이 값을 ‘IntelliJ IDEA’ 로 바꿔 프로젝트를 다시 시작합니다.
            
          
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-31-EntityListeners.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-31-EntityListeners.html"><h1 class="title_post">☕️[Java] @EntityListeners 어노테이션.</h1></a>
                        <a href="/Backend/Java/2024-07-31-EntityListeners.html" class="txt_post">
                            ☕️[Java] @EntityListeners 어노테이션.

1️⃣ 사용 방법.


  @EntityListeners 어노테이션은 엔티티 클래스 또는 매핑된 슈퍼클래스에서 사용할 수 있으며, 하나 이상의 리스너 클래스를 지정할 수 있습니다.
    
      이 리스너 클래스들은 앞서 언급한 이벤트를 처리할 메소드들을 포함하고 있어야 합니다.
    
  


import javax.persistence.EntityListeners;
import javax.persistence.PostPersist;

@EntityListeners(MyEntityListner.class)
public class MyEntity {
    // 엔티티 필드와 메서드
}

public class MyEntityListner {
    @PostPersist
    public void afterPersist(Object entity) {
        System.out.println("Entity has been persisted: " + entity);
    }
}


2️⃣ 사용 사례.

  엔티티 리스너는 로깅, 유효성 검사, 보안 검사, 비즈니스 로직 실행 등 다양한 목적으로 사용할 수 있습니다.
    
      
        예를 들어, 사용자 계정의 엔티티가 데이터베이스에 저장될 때 비밀번호 강도를 자동으로 검증하거나, 엔티티가 업데이트 될 때 특정 필드의 변경을 추적할 수 있습니다.
      
    
  


이처럼 @EntityListeners는 JPA 엔티티의 생명주기에 자동으로 반응하는 메소드를 구현함으로써, 엔티티와 관련된 비즈니스 로직을 분리하고 관리하는 데 큰 도움을 줍니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-31</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-07-16-Variable.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-07-16-Variable.html"><h1 class="title_post">☕️[Java] 프로그래밍 언어와 자바</h1></a>
                        <a href="/Backend/Java/2024-07-16-Variable.html" class="txt_post">
                            변수 선언.


  컴퓨터 메모리(RAM)은 수많은 번지들로 구성된 데이터 저장 공간입니다.
  프로그램은 데이터를 메모리에 저장하고 읽는 작업을 비번히 수행합니다.
    
      이때 데이터를 어디에, 어떤 방식으로 저장할지 정해져 있지 않다면 메모리 관리가 무척 어려워집니다.
        
          이 문제를 해결하기 위해 변수(Variable)을 사용합니다.
        
      
    
  
  변수(Variable)는 하나의 값을 저장할 수 있는 메모리 번지에 붙여진 이름입니다.
  변수를 통해 프로그램은 메모리 번지에 값을 저장하고 읽을 수 있습니다.
  자바의 변수는 다양한 타입의 값을 저장할 수 없습니다.
    
      즉, 정수형 변수에는 정수값만 저장할 수 있고, 실수형 변수에는 실수값만 저장할 수 있습니다.
    
  
  변수를 사용하려면 변수 선언이 필요합니다.
    
      변수 선언은 어떤 타입의 데이터를 저장할 것인지 그리고 변수 이름이 무었인지 결정하는 것입니다.
        int age; // 정수(int) 값을 저장할 수 있는 age 변수 선언
double value; // 실수(double) 값을 저장할 수 있는 value 변수 선언
        
      
    
  
  변수 이름의 첫 번째 글자가 문자여야 하고, 중간부터는 문자, 숫자, $, _를 포함할 수 있습니다.
    
      또한, 첫 문자를 소문자로 시작하되 캐멀 케이스로 작성하는 것이 관례입니다.
    
  
  변수가 선언 되었다면 값을 저장할 수 있습니다.
    
      이때 대입 연산자인 =를 사용합니다.
      수학에서 등호(=)는 ‘같다’라는 의미이지만, 자바에서는 우측 값을 좌측 변수에 대입하는 연산자로 사용됩니다.
        int score; // 변수 선언
score = 60; // 값 대입
        
      
    
  
  변수 선언은 저장되는 값의 타입과 이름만 결정한 것이지, 아직 메모리에 할당된 것은 아닙니다.
    
      변수에 최초로 값이 대입될 때 메모리에 할당되고, 해당 메모리에 값이 저장됩니다.
    
  
  변수에 최초로 값을 대입하는 행위를 변수 초기화라고 하고, 이때의 값을 초기값이라고 합니다.
    
      초기 값은 다음과 같이 변수를 선언함과 동시에 대입할 수도 있습니다.
        int score = 90;
        
      
    
  
  초기화되지 않은 변수는 아직 메모리에 할당되지 않았기 때문에 변수를 통해 메모리 값을 읽을 수 없습니다.
    
      따라서 다음은 잘못된 코딩입니다.
        int value; // &lt;- 1.변수 value 선언
int result = value + 10; // &lt;- 2.변수 value 값을 읽고 10을 더해서 변수 result에 저장
        
      
    
  
  1 에서 변수 value가 선언되었지만, 초기화되지 않았기 때문엔 2 value + 10에서 value 변수값은 읽어올 수 없습니다.
    
      따라서 위 코드는 다음과 같이 변경해야 합니다.
        int value = 30; // 변수 value가 30으로 초기화됨
int result = value + 10; // 변수 value 값(30)을 읽고 10을 더해서 변수 result에 저장
        
      
    
  
  다음 예제는 초기화되지 않은 변수를 연산식에 사용할 경우 컴파일 에러(The local variable value may not have been initializer)가 발생하는 것을 보여줍니다.
    public class VariableInitializationExample {
  public static void main(String[] args) {
      // 변수 value 선언
      int value;
        
      // 연산 결과를 변수 result의 초기값으로 대입
      int result = value + 10; // &lt;------- 컴파일 오류
        
      // 변수 result 값을 읽고 콘솔에 출력
      System.out.println(result);
  }
}
    
  
  변수는 출력문이나 연산식에 사용되어 변수값을 활용합니다.
  
    다음 예제는 변수를 문자열과 결합 후 출력하거나 연산식에서 활용하는 모습을 보여줍니다.
```java
public class VariableUseExample {
  public static void main(String[] args) {
      int hour = 3;
      int minute = 5;
      System.out.println(hour + “시간” + minute + “분”);

      int totalMinute = (hour*60) + minute;
  System.out.println("총" + totalMinute + "분");   } }
    
  


// 실행 결과
// 3시간 5분
// 총 185분
- 변수는 또 다른 변수에 대입되어 메모리 간에 값을 복사할 수 있습니다.
    - 다음 코드는 변수 x 값을 변수 y 값으로 복사합니다.
```java
int x = 10; // 변수 x에 10을 대입
int y = x; // 변수 y에 변수 x값을 대입


  다음 예제는 두 변수의 값을 교환하는 방법을 보여줍니다.
    
      
        두 변수의 값을 교환하기 위해서 새로운 변수 temp를 선언한 것에 주목합시다.
```java
public class VariableExchangeExample {
  public static void main(String[] args) {
  int x = 3;
  int y = 5;
  System.out.println(“x:” + x + “, y:” + y);

        int temp = x;
  x = y;
  y = temp;
  System.out.println(“x:” + x + “, y:” + y);
  }
}
      
    
  


// 실행 결과
// x:3, y:5
// x:5, y:3
```

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-07-16</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html"><h1 class="title_post">☕️[Java] 프로그래밍 언어와 자바</h1></a>
                        <a href="/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html" class="txt_post">
                            1️⃣ 프로그래밍 언어와 자바.


  기계어(Machine language)
    
      0과 1로 이루어진 이진 코드를 사용합니다.
      사람이 이해하기에는 어렵습니다.
    
  
  프로그래밍 언어(Programming language)
    
      고급 언어(High-level language)와 저급 언어(Low-level language)로 구분됩니다.
    
  
  고급 언어(High-level language)
    
      컴퓨터와 대화할 수 있도록 만든 언어 중에서 사람이 쉽게 이해할 수 있는 언어를 말합니다.
      고급 언어로 작성된 소스 파일(Source file)은 컴퓨터가 바로 이해할 수 없기 때문에 컴파일(Compile)이라는 과정을 통해서 컴퓨터가 이해할 수 있는 0과 1로 이루어진 기계어(Machine language)로 변환한 후 컴퓨터가 사용하게 됩니다.
    
  



  🤔 MORE : 소스 파일(Source file).
프로그래밍 언어에서 “소스 파일(Source file)” 이란 특정 프로그래밍 언어로 작성된 텍스트 파일을 의미합니다.
이 파일에는 개발자가 작성한 코드가 포함되어 있으며, 컴퓨터가 이를 이해하고 실행할 수 있도록 하기 위해서는 보통 컴파일러나 인터프리터가 필요합니다.



  저급 언어(Low-level language)
    
      기계어에 가까운 언어를 말하는데, 대표적으로 어셈블리어가 저급언어에 속합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-09-polymorphism.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-09-polymorphism.html"><h1 class="title_post">☕️[Java] 다형성(Polymorphism)</h1></a>
                        <a href="/Backend/Java/2024-06-09-polymorphism.html" class="txt_post">
                            1️⃣ 다형성(Polymorphism).

‘다형성(Polymorphism)’ 은 ‘객체 지향 프로그래밍(OOP)’ 의 중요한 개념 중 하나로, 같은 인터페이스를 통해 서로 다른 데이터 타입의 객체를 조작할 수 있도록 합니다.

다형성은 코드의 재사용성과 유연성을 높여주며, 유지보수를 쉽게 해줍니다.

Java에서 ‘다형성’ 은 주로 ‘상속’ 과 ‘인터페이스’ 를 통해 구현됩니다.

2️⃣ 다형성의 개념.

다형성은 “하나의 인터페이스로 여러 가지 형태를 구현할 수 있는 능력” 을 의미합니다.

이는 같은 메서드가 다양한 객체에서 다르게 동작할 수 있게 합니다.

3️⃣ 다형성의 두 가지 형태.

1️⃣ 컴파일 시간 다형성(Compile-time Polymorphism)


  
    메서드 오버로딩(Method Overloading)을 통해 구현됩니다.
  
  
    컴파일 시점에 어떤 메서드가 호출될지 결정됩니다.
  
  
    같은 이름의 메서드를 여러 개 정의하지만, 매개변수의 타입이나 개수가 달라야 합니다.
  


2️⃣ 런타임 다형성 (Runtime Polymorphism)


  
    메서드 오버라이딩(Method Overriding)을 통해 구현됩니다.
  
  
    실행 시점에 어떤 메서드가 호출될지 결정됩니다.
  
  
    부모 클래스의 메서드를 자식 클래스에서 재정의하여 사용합니다.
  


4️⃣ 컴파일 시간 다형성(Method Overloading).

메서드 오버로딩은 같은 클래스 내에서 같은 이름을 가진 메서드를 여러 개 정의하는 것입니다.

단, 매개변수의 수나 타입이 달라야 합니다.

💻 예제.

public class MathOperations {
	// 정수 두 개의 합
	public int add(int a, int b) {
		return a + b;
	}

	// 실수 두 개의 합
	public double add(double a, double b) {
		return a + b;
	}

	// 새 개의 정수의 합
	public int add(int a, int b, int c) {
		return a + b + c;
	}

	public static void main(String[] args) {
		MathOperations mathOperations = new MathOperations();
		System.out.println(mathOperations.add(1, 2)); // 3
		System.out.println(mathOperations.add(1.5, 2.5)); // 4.0
		System.out.println(mathOperations.add(1, 2, 3)); // 6
	}
}


5️⃣ 런타임 다형성(Method Overriding).

메서드 오버라이딩은 자식 클래스가 부모 클래스의 메서드를 재정의하는 것을 말합니다.

이를 통해 자식 클래스의 객체가 부모 클래스의 메서드를 호출할 때, 자식 클래스의 메서드가 실행되도록 합니다.

💻 예제.

class Animal {
	void makeSound() {
		System.out.println("Animal makes a sound");
	}
}

class Dog extends Animal {
	@Override
	void makeSound() {
		System.out.println("Dog barks");
	}
}

class Cat extends Animal {
	@Override
	void makeSound() {
		System.out.println("Cat meows");
	}
}

public class Main {

	public static void main(String[] args) {
		Animal myDog = new Dog(); // Animal 타입으로 Dog 객체 생성
		Animal myCat = new Cat(); // Animal 타입으로 Cat 객체 생성

		myDog.makeSound(); // Dog barks
		myCat.makeSound(); // Cat meows
	}
}


6️⃣ 인터페이스를 통한 다형성.

인터페이스를 통해서도 다형성을 구현할 수 있습니다.

인터페이스는 메서드의 서명만을 정의하며, 이를 구현하는 클래스가 메서드의 구체적인 동작을 정의합니다.

💻 예제.

interface Shape {
	void draw();
}

class Circle implements Shape {
	@Override
	public void draw() {
		System.out.println("Drawing a Circle");
	}
}

class Square implements Shape {
	@Override
	public void draw() {
		System.out.println("Drawing a Square");
	}
}

public class Main {

	public static void main(String[] args) {
		Shape myShape1 = new Circle();
		Shape myShape2 = new Square();

		myShape1.draw(); // Drawing a Circle
		myShape2.draw(); // Drawing a Square
	}
}


7️⃣ 다형성의 장점.


  
    코드 재사용성 : 상위 클래스나 인터페이스를 사용하여 다양한 하위 클래스나 구현체를 다룰 수 있어 코드의 재사용성이 높아집니다.
  
  
    유연성 : 새로운 클래스나 기능을 추가할 때 기존 코드를 수정할 필요 없이 확장할 수 있습니다.
  
  
    유지보수성 : 코드를 이해하고 유지보수하는 것이 더 쉬워집니다. 메서드의 호출이 어디서 어떻게 이루어지는지 명확하기 때문입니다.
  


8️⃣ 예제: 다형성의 실질적 사용.

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class PolymorphismExample {

	public static void main(String[] args) {
		List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
		List&lt;String&gt; linkedList = new LinkedList&lt;&gt;();

		arrayList.add("ArrayList Item");
		linkedList.add("LinkedList Item");

		printList(arrayList); // ArrayList Item
		printList(linkedList); // LinkedList Item
	}

	public static void printList(List&lt;String&gt; list) {
		for (String item : list) {
			System.out.println(item);
		}
	}
}



  이 예제에서는 ‘List‘ 인터페이스를 사용하여 ‘ArrayList‘ 와 ‘LinkedList‘ 를 동일한 방식으로 처리합니다.
이를 통해 다양한 구현체를 다룰 수 있는 유연한 코드를 작성할 수 있습니다.


📝 결론.

다형성은 객체 지향 프로그래밍의 핵심 개념 중 하나로, 코드의 유연성과 재사용성을 크게 향상시킵니다.

이를 통해 다양한 형태의 객체를 동일한 방식으로 다룰 수 있으며, 새로운 기능을 쉽게 확장하고 유지보수할 수 있습니다.

다형성은 상속과 인터페이스를 통해 구현되며, 메서드 오버로딩과 오버라이딩을 통해 다양한 형태를 취할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-08-PrimitiveAndWrapper.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-08-PrimitiveAndWrapper.html"><h1 class="title_post">☕️[Java] Primitive Type과 Wrapper Class.</h1></a>
                        <a href="/Backend/Java/2024-06-08-PrimitiveAndWrapper.html" class="txt_post">
                            1️⃣ 도화선 🧨

‘int와 Integer의 차이가 무엇이 있을까?’ 하는 호기심이 도화선이 되어 이 글을 쓰게 되었습니다 :)

먼저 ‘int와 Integer의 차이’를 알아보니 ‘int’ 는 ‘Primitive Type’ 이고, ‘Integer’ 는 ‘Wrapper Class’ 라는 것을 알게 되었습니다.

2️⃣ Primitive Type과 Wrapper Class.

Java에서 Primitive Type 과 Wrapper Class는 각각 기본 데이터 타입과 그 기본 타입을 객체로 감싸는 클래스입니다.

이 둘의 개념과 차이점을 이해하는 것은 Java 프로그래밍에서 매우 중요합니다.

1️⃣ Primitive Type (기본 데이터 타입).

Primitive Type은 Java에서 가장 기본적인 데이터 타입을 말합니다.

Java는 다음과 같은 8가지 기본 데이터 타입을 제공합니다.


  
    
      boolean : 논리값(true 또는 false).
    
  
  
    
      byte : 8비트 정수.
    
  
  
    
      short : 16비트 정수.
    
  
  
    
      int : 32비트 정수.
    
  
  
    
      long : 64비트 정수.
    
  
  
    
      float : 32비트 부동 소수점.
    
  
  
    
      double : 64비트 부동 소수점.
    
  
  
    
      char : 16비트 유니코드 문자.
    
  


이러한 타입들은 성능이 뛰어나고 메모리를 적게 사용하며, 객체를 생성할 필요 없이 값 그 자체를 저장하고 조작할 수 있습니다.

예시

int a = 10;
boolean isJavaFun = true;
char letter = 'A';


2️⃣ Wrapper Class (래퍼 클래스)

Wrapper Class 는 각 Primitive Type 에 대응되는 클래스입니다.

이 클래스들은 Primitive Type을 객체로 감싸기 때문에 “래퍼 클래스” 라고 불립니다.

Java는 각 기본 타입에 대한 래퍼 클래스를 제공합니다.


  
    
      boolean -&gt; ‘Boolean’
    
  
  
    
      byte -&gt; ‘Byte’
    
  
  
    
      short -&gt; ‘Short’
    
  
  
    
      int -&gt; ‘Integer’
    
  
  
    
      long -&gt; ‘Long’
    
  
  
    
      float -&gt; ‘Float’
    
  
  
    
      double -&gt; ‘Double’
    
  
  
    
      char -&gt; ‘Character’
    
  


Wrapper Class 는 다음과 같은 이유로 사용됩니다.


  Primitive Type 을 객체로 다루어야 할 때(예: 컬렉션 프레임워크에서는 객체만 저장할 수 있음)
  null 값을 처리해야 할 때
  추가 메서드 및 기능을 사용해야 할 때(예: 문자열을 정수로 변환하는 메서드 등)


예시

Integer a = 10;
Boolean isJavaFun = true;
Character letter = 'A';


3️⃣ Autoboxing 과 Unboxing

Java는 기본 타입과 래퍼 클래스 간의 자동 변환을 지원합니다.

이를 Autoboxing 과 Unboxing 이라고 합니다.


  
    Autonboxing : 기본 타입이 자동으로 해당 래퍼 클래스 객체로 변환되는 것.
  
  
    Unboxing : 래퍼 클래스 객체가 자동으로 해당 기본 타입으로 변환되는 것,
  


예시

int primitiveInt = 5;
Integer wrapperInt = primitiveInt; // Autoboxing

Integer anotherWrapperInt = 10;
int anotherPrimitiveInt = anotherWrapperInt; // Unboxing


4️⃣ Primitive Type 과 Wrapper Class의 차이점.


  
    
      메모리 사용 :
        
          Primitive Type : 메모리 효율적, 객체 오버헤드 없음.
          Wrapper Class : 객체 오버헤드가 있어 더 많은 메모리 사용.
        
      
    
  
  
    
      기본값 :
        
          Primitive Type : 기본값이 정의되어 있음 (예: int는 0, boolean은 false).
          Wrapper Class : 기본값이 ‘null’ 일 수 있음.
        
      
    
  
  
    
      성능 :
        
          Primitive Type : 빠른 연산 속도.
          Wrapper Class : 객체 생성과 가비지 컬렉션의 오버헤드로 인해 상대적으로 느립.
        
      
    
  
  
    
      기능성 :
        
          Primitive Type : 단순한 데이터 저장과 연산에 적합.
          Wrapper Class : 다양한 유틸리티 메서드 제공 (예: 문자열 반환, 비교 메서드 등).
        
      
    
  


예제 코드

다음은 Primitive Type과 Wrapper Class의 사용 예를 보여주는 코드입니다.

import java.util.ArrayList;
import java.util.List;

public class Main {

	public static void main(String[] args) {
		// Primitive Type 사용
		int primitiveInt = 100;
		boolean primitiveBoolean = true;

		// Wrapper Class 사용
		Integer wrapperInt = Integer.valueOf(100); // 명시적 변환
		Boolean wrapperBoolean = Boolean.valueOf(true);

		// Autoboxing and Unboxing
		Integer autoboxedInt = 200; // Autoboxing
		int unboxedInt = autoboxedInt; // Unboxing

		// Primitive Type은 컬렉션에 저장할 수 없음
		List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();
		intList.add(primitiveInt); // Autoboxing
		intList.add(wrapperInt);

		// 컬렉션에서 값을 가져올 때 Unboxing
		int sum = 0;
		for (int num : intList) {
			sum += num; // Unboxing
		}

		System.out.println("Sum: " + sum); // Output: Sum: 200
	}
}



  이 예제에서는 기본 타입과 래퍼 클래스를 사용하여 변수레 값을 저장하고, 컬렉션에 저장된 래퍼 클래스 객체를 사용하려 연산을 수행하는 과정을 보여줍니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-08-Generic.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-08-Generic.html"><h1 class="title_post">☕️[Java] 제네릭(Generic)</h1></a>
                        <a href="/Backend/Java/2024-06-08-Generic.html" class="txt_post">
                            1️⃣ 제네릭(Generic)

Java에서의 제네릭(Generic) 은 클래스나 메서드에서 사용할 데이터 타입을 나중에 지정할 수 있도록 하는 기능입니다.

제네릭을 사용하면 코드의 재사용성을 높이고, 컴파일 시 타입 안전성을 제공하며, 명시적 타입 캐스팅을 줄일 수 있습니다.

2️⃣ 제네릭(Generic)의 주요 개념.


  타입 매개변수 :
    
      제네릭 클래스나 메서드는 타입 매개변수를 사용하여 타입을 정의합니다. 이 타입 매개변수는 클래스나 메서드가 호출될 때 구체적인 타입으로 대체됩니다.
    
  
  타입 안정성 :
    
      제네릭을 사용하면 컴파일 시 타입을 검사하므로, 런타입에 발생할 수 있는 타입 오류를 줄일 수 있습니다.
    
  
  재사용성 :
    
      제네릭 클래스나 메서드는 다양한 타입에 대해 동작하도록 설계할 수 있어, 코드의 재사용성을 높입니다.
    
  


3️⃣ 제네릭 클래스.

제네릭 클래스는 클래스 선언에 타입 매개변수를 포함하여 정의합니다.

일반적으로 타입 매개변수는 한 글자로 표현 되며, ‘T(Tyep)‘, ‘E(Element)‘, ‘K(Key)‘, ‘V(Value)‘ 등이 자주 사용됩니다.

예제.

// Box 클래스
public class Box&lt;T&gt; {
	private T item;

	public void setItem(T item) {
		this.item = item;
	}

	public T getItem() {
		return item;
	}
}

// Main 클래스
public class Main {

	public static void main(String[] args) {
		Box&lt;String&gt; stringBox = new Box&lt;&gt;();
		stringBox.setItem("Hello");
		System.out.println("String item: " + stringBox.getItem()); // String item: Hello

		Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();
		integerBox.setItem(123);
		System.out.println("Integer item: " + integerBox.getItem()); // Integer item: 123
	}
}


4️⃣ 제네릭 메서드.

제네릭 메서드는 메서드 선언 타입 매개변수를 포함하여 정의합니다.

예제.

public class GenericMethodExample {
	public static &lt;T&gt; void printArray(T[] array) {
		for (T element : array) {
			System.out.print(element + " ");
		}
		System.out.println();
	}

	public static void main(String[] args) {
		Integer[] intArray = {1, 2, 3, 4, 5};
		String[] strArray = {"A", "B", "C", "D"};

		printArray(intArray); // 1 2 3 4 5 
		printArray(strArray); // A B C D 
	}
}


5️⃣ 제네릭 타입 제한 (Bounded Type Parameters)

제네릭 타입 매개변수에 제한을 걸어 특정 타입의 하위 클래스나 인터페이스만 허용할 수 있습니다.

상한 제한 (Upper Bound)

public class BoundedTypeExample&lt;T extends Number&gt; {
	private T number;

	public BoundedTypeExample(T number) {
		this.number = number;
	}

	public void printNumber() {
		System.out.println("Number: " + number);
	}

	public static void main(String[] args) {
		BoundedTypeExample&lt;Integer&gt; intExample = new BoundedTypeExample&lt;&gt;(123);
		intExample.printNumber(); // Number: 123

		BoundedTypeExample&lt;Double&gt; doubleExample = new BoundedTypeExample&lt;&gt;(45.67);
		doubleExample.printNumber(); // Number: 45.67
	}
}



  여기서 ‘T’ 는 ‘Number’ 클래스나 그 하위 클래스만 될 수 있습니다.


하한 제한 (Lower Bound)

하한 제한은 와일드카드(’? super T‘)를 사용하여 정의됩니다.

예를 들어 ‘List&lt;? super Integer&gt;‘ 는 ‘Integer‘ 의 상위 타입인 ‘Number‘, ‘Object‘ 등이 될 수 있습니다.

import java.util.ArrayList;
import java.util.List;

public class LowerBoundWildcardExample {
	public static void addNumbers(List&lt;? super Integer&gt; list) {
		for (int i = 0; i &lt; 5; i++) {
			list.add(i);
		}
	}

	public static void main(String[] args) {
		List&lt;Number&gt; numberList = new ArrayList&lt;&gt;();
		addNumbers(numberList);
		System.out.println(numberList); // [0, 1, 2, 3, 4]
	}
}


6️⃣ 제네릭의 제한 사항.


  Primitive Type 사용 불가 : 제네릭은 참조 타입만 허용하며, 기본 타입은 사용할 수 없습니다.


// 올바르지 않음
Box&lt;int&gt; intBox = new Box&lt;&gt;(); // 컴파일 오류



  정적 컨텍스트에서의 타입 매개변수 사용 : 정적 메서드나 정적 변수에서는 타입 매개변수를 사용할 수 없습니다.


public class GenericClass&lt;T&gt; {
    private static T item; // 컴파일 오류
}



  제네릭 배열 생성 불가 : 제네릭 배열을 직접 생성할 수 없습니다.


// 올바르지 않음
T[] array = new T[10]; // 컴파일 오류



  제네릭은 Java의 강력한 기능으로, 타입 안전성을 높이고 코드의 재사용성을 극대화할 수 있게 해줍니다.
이를 적절히 활용하면 더 안정적이고 유지보수하기 쉬운 코드를 작성할 수 있습니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-06-03-IntStream.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-06-03-IntStream.html"><h1 class="title_post">☕️[Java] IntStream</h1></a>
                        <a href="/Backend/Java/2024-06-03-IntStream.html" class="txt_post">
                            1️⃣ Java Docs - IntStream.


  Module : java.base
  Package : java.util.stream


Interface IntStream

All SuperInterfaces : AutoCloseble, BaseStream&lt;Integer, IntStream&gt;


  AutoCloseble
  BaseStream
  Integer
  IntStream




public interface IntStream extends BaseStream&lt;Integer, IntStream&gt;



  순차 및 병렬 집계 연산을 지원하는 기본 int 값 요소의 시퀀스입니다. 이것은 Stream의 int 기본형 특수화입니다.
    
      IntStream 이 Stream 의 한 형태로, int 값의 시퀀스를 처리하며 순차 및 병렬 연산을 지원한다는 의미입니다.
    
  
  다음 예제는 Stream과 IntStream을 사용하여 빨간색 위젯의 무게 합계를 계산하는 집계 연산을 보여줍니다.


int sum = widgets.stream()
                 .filter(w -&gt; w.getColor() == RED)
                 .mapToInt(w -&gt; w.getWeight())
                 .sum();



  streams(스트림), stream operations(스트림 연산), stream pipelines(스트림 파이프라인), and parallelism(및 병렬 처리)에 대한 추가적인 명세는 Stream 클래스 문서와 java.util.stream 패키지 문서를 참조하십시오.


Since : 1.8

Nested Class Summary

Nested Classes

  Modifier and Type: static interface
  Interface: IntStream.Builder
  Description: IntStream용 변경 가능한 빌더입니다.


2️⃣ IntStream.

IntStream 은 Java의 스트림 API(Stream API)의 일부로, 기본형 int 에 특화된 스트림을 나타냅니다.

IntStream 은 Java 8에서 도입된 스트림 API의 일부로, 컬렉션(리스트, 배열 등)과 같은 데이터 소스를 함수형 프로그래밍 스타일로 처리할 수 있게 해줍니다.

IntStream 은 Stream&lt;Integer&gt; 와는 달리 오토박싱과 언박싱의 오버헤드가 없는 것이 특징입니다.

🙋‍♂️ IntStream의 주요 기능

1. 생성:


  IntStream 을 생성하는 방법은 여러가지가 있습니다.
    
      예를 들어, 배열, 범위, 임의의 수 등을 사용하여 생성할 수 있습니다.
    
  


2. 연산:


  스트림 연산은 두 가지로 나뉩니다.
    
      중간 연산과 최종 연산.
        
          중간 연산은 또 다른 스트림을 반환하고, 지연(lazy) 평가됩니다.
          최종 연산은 스트림을 소비하여 결과를 반환합니다.
        
      
    
  


🙋‍♂️ IntStream 생성 방법.

1. of() 메서드:


  고정된 개수의 int 값을 스트림으로 생성합니다.


IntStream stream = IntStream.of(1, 2, 3, 4, 5);


2. range() 및 rangeClosed() 메서드:


  범위를 지정하여 스트림을 생성합니다. range 는 시작 값 포함, 끝 값 미포함, rangeClosed 는 시작 값과 끝 값을 모두 포함합니다.


IntStream stream = IntStream.range(0, 5); // 0, 1, 2, 3, 4, 5
IntStream closedStream = IntStream.rangeClosed(0, 5); // 0, 1, 2, 3, 4, 5


3. generate() 메서드:


  람다 표현식을 사용하여 무한 스트림을 생성합니다.
    
      🚨 주의: 무한 스트림은 반드시 제한을 걸아야 합니다.
    
  


IntStream stream = IntStream.generate(() -&gt; 1).limit(5); // 1, 1, 1, 1, 1


4. iterate() 메서드:


  초기값과 반복 함수로 스트림을 생성합니다.


IntStream stream = IntStream.iterate(0, n -&gt; n + 2).limit(5); // 0, 2, 4, 6, 8


5. builder() 메서드:


  IntStream.Builder 를 사용하여 스트림을 생성합니다.


IntStream.Builder builder = IntStream.builder()l
builder.add(1).add(2).add(3).add(4).add(5);
IntStream stream = builder.builder();


6. 배열에서 생성:


  배열을 스트림으로 변환합니다.


int[] array = {1, 2, 3, 4, 5};
IntStream stream = Arrays.stream(array);


🙋‍♂️ IntStream의 주요 메서드.

1. 중간 연산:


  map() : 각 요소에 함수 적용.
  filter() : 조건에 맞는 요소만 통과
  distinct() : 중복 요소 제거
  sorted() : 정렬
  limit() : 스트림 크기 제한
  skip() : 처음 n개 요소 건너뛰기


2. 최종 연산:


  forEach() : 각 요소에 대해 액션 수행
  toArray() : 배열로 변환
  reduce() : 모든 요소를 누적하여 하나의 값으로
  collect() : 컬렉션으로 변환
  sum() : 합계 연산
  average() : 평균 계산
  min(), max() : 최소, 최대값 찾기
  count() : 요소 개수 반환


💻 예제 코드

예제 1: 0에서 5까지 거꾸로 출력.

import java.util.stream.IntStream;

public class Reverse {

	public static void main(String[] args) {
		IntStream.rangeClosed(0, 5)
		         .map(i -&gt; 5 - i)
		         .forEach(System.out::println);
	}
}
/*
=== 출력 ===
5
4
3
2
1
0
*/


예제 2: 배열의 합계 계산

import java.util.stream.IntStream;

public class ArraySum {

	public static void main(String[] args) {
		int[] array = {1, 2, 3, 4, 5};
		int sum = IntStream.of(array).sum();
		System.out.println("sum = " + sum); // sum = 15
	}
}


예제 3: 짝수 필터링

import java.util.stream.IntStream;

public class FilterEvenNumber {

	public static void main(String[] args) {
		IntStream.rangeClosed(1, 10)
		         .filter(n -&gt; n % 2 == 0)
		         .forEach(System.out::println);
	}
}
/*
=== 출력 ===
2
4
6
8
10
*/


📝 요약

IntStream 은 Java의 스트림 API의 일부분으로, 기본형 int에 특화된 스트림입니다.

이를 통해 컬렉션이나 배열을 함수형 프로그래밍 스타일로 처리할 수 있습니다.

IntStream 은 다양한 생성 방법과 중간 및 최종 연산을 제공하여 효율적이고 직관적인 데이터 처리를 가능하게 합니다.

📚 참고 문헌.

  Java Docs - IntStream


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-06-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-18-Troubleshooting-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-18-Troubleshooting-1.html"><h1 class="title_post">☕️[Java] 문자열 비교 - 트러블슈팅</h1></a>
                        <a href="/Backend/Java/2024-05-18-Troubleshooting-1.html" class="txt_post">
                            1️⃣ 문자열 비교.
  private static String exceptionHandleForPersonOfNationalMerit(Scanner scanner) throws InvalidCheckException {
    System.out.print("국가유공자 여부를 입력해 주세요.(y/n) :");
    String personOfNationalMerit = scanner.next();

    // 들어온 값이 y 또는 n이 아닌 경우 예외를 던집니다.
    if (personOfNationalMerit != "y" &amp;&amp; personOfNationalMerit != "n") {
      throw new InvalidCheckException("유효하지 않은 입력입니다. y 또는 n을 입력해주세요.");
    }
    return personOfNationalMerit;
  }


🤔 문제 상황.
1. 문자열 비교가 안되는 상황.

  ’==’ 연산자를 사용해서 “y” 또는 “n” 외의 다른 문자열이 들어올 경우 커스텀한 에러 를 발생시키려 했지만 정상적인 값인 “y” 와 n 을 넣어도 에러가 발생 하는 문제가 생겼습니다.


💻 트러블슈팅.
1. equals() 메소드의 사용.

자바에서는 문자열 비교를 할 때 ’==’ 연산자를 사용하는 것이 아니라 ‘equals()’ 메소드를 사용해야 합니다.

  ’==’ 연산자는 객체의 레퍼런스를 비교하기 때문에, 두 문자열이 같은 객체를 참조하는지 여부를 확인합니다.
  ‘equals()’ 메소드는 문자열의 내용을 비교합니다.


따라서, “y” 와 “n” 을 비교할 때 ’==’ 대신 ‘equals()’ 를 사용해야 합니다.

  private static String exceptionHandleForPersonOfNationalMerit(Scanner scanner) throws InvalidCheckException {
    System.out.print("국가유공자 여부를 입력해 주세요.(y/n) :");
    String personOfNationalMerit = scanner.next();

    // 들어온 값이 y 또는 n이 아닌 경우 예외를 던집니다.
    if (!personOfNationalMerit.equals("y") &amp;&amp; !personOfNationalMerit.equals("n")) {
      throw new InvalidCheckException("유효하지 않은 입력입니다. y 또는 n을 입력해주세요.");
    }
    return personOfNationalMerit;
  }


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-18</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html"><h1 class="title_post">☕️[Java] 예외 처리 - 트러블슈팅</h1></a>
                        <a href="/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html" class="txt_post">
                            1️⃣ 예외 처리.

실제 코드를 작성하면서 예외 처리에 대한 문제를 맞닥뜨려 어떻게 해야 할지 고민하다 다음과 같이 풀어보았습니다.

  private static int enterTheAge(Scanner scanner) {
    while (true) {
      try {
        System.out.print("나이를 입력해 주세요.(숫자): ");
        int age = scanner.nextInt();
        return age;
      } catch (InputMismatchException e) {
        System.out.println("숫자를 입력해 주세요.");
        scanner.next();
      }
    }
  }


🤔 문제 상황.
1. 나이는 숫자만 입력되어야 한다.

  숫자가 아닌 것들이 들어왔을 경우 예외 처리를 해줘서 다시 유저가 나이를 입력할 수 있게끔 하도록 만드는 과정에서 문제 상황이 발견되었습니다.


💻 트러블슈팅.
1. while 반복문의 사용.

  while (true) 를 사용하여 무한 루프를 돌려 내부에서 숫자가 아니면 다시금 유저가 “유효하지 않은 입력입니다” 라는 예외 처리 출력문을 받고 “나이를 입력해 주세요” 라는 원래의 출력문을 받을 수 있도록 했습니다.


2. try-catch 문의 사용.

  try-catch 문을 사용하여 Scanner 클래스 메소드를 사용할 때 발생하는 예외중, 사용자가 기대하는 타입의 입력을 제공하지 않았을 때 던져지는 InputMismatchException 를 catch 문에 넣어주어 이 예외가 발생시 잡아서 실행하는 블럭 내부에 예외 처리 코드를 아래와 같이 삽입 하였습니다.
    try {
  System.out.print("나이를 입력해 주세요.(숫자): ");
  int age = scanner.nextInt();
  return age;
} catch (InputMismatchException e) {
  System.out.println("숫자를 입력해 주세요.");
  scanner.next();
}
    
  
  ‘scanner.next()’ 를 호출하여 잘못된 입력을 버리고, 다음 입력을 기다리도록 합니다.
  사용자가 유효한 숫자를 입력하면 ‘age’ 를 반환하고 메소드를 종료합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-17</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-14-Stream.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-14-Stream.html"><h1 class="title_post">☕️[Java] 스트림</h1></a>
                        <a href="/Backend/Java/2024-05-14-Stream.html" class="txt_post">
                            1️⃣ 스트림.

1. 스트림(Stream)
자바에서 스트림(Stream) API는 자바 8에서 도입되어 컬렉션의 요소를 선언적으로 처리할 수 있는 방법을 제공합니다.
스트림 API를 이용하면 데이터 요소의 시퀀스를 효율적으로 처리할 수 있으며, 데이터를 병렬로 처리하는 것도 간단할게 할 수 있습니다.
스트림을 이용하면 복잡한 데이터 처리 작업을 간결하고 명확한 코드로 작성할 수 있습니다.

1.2 스트림의 주요 특정.

  
    1. 선언적 처리 : 스트림을 사용하면 무엇을 할 것인지(what)에 집중하여 작업을 설명할 수 있고, 어떻게 처리할 것인지(how)는 스트림 API가 알아서 최적화하여 처리합니다.
  
  
    2. 파이프라이닝 : 스트림 연산은 파이프라인을 형성할 수 있으며, 여러 단계의 처리 과정을 연결하여 복잡한 데이터 처리를 효과적으로 할 수 있습니다.
  
  
    3. 내부 반복 : 스트림은 “내부 반복”을 사용합니다. 즉, 데이터를 어떻게 반복할지 스트림이 처리하므로, 개발자는 각 요소에 어떤 처리를 할지만 정의하면 됩니다.
  
  
    4. 불변성 : 스트림은 데이터를 수정하지 않습니다. 대신, 각 단계에서 결과를 내는 새로운 스트림을 생성합니다. 이는 함수형 프로그래밍의 특성을 반영합니다.
  


1.3 스트림의 작업 흐름.
스트림 API의 작업 흐름은 크게 세 부분으로 나눌 수 있습니다.


  1. 스트림 생성 : 컬렉션, 배열, I/O 자원 등의 데이터 소스로부터 스트림을 생성합니다.
    List&lt;String&gt; myList = Arrays.asList("a1", "a2", "b1", "b2", "c2", "c1");
Stream&lt;String&gt; myStrean = myList.stream();
    
  
  2. 중간 연산(Intermediate operations) : 스트림을 변환하는 연산으로, 필터링, 매핑, 정렬 등이 있으며, 이 연산들은 연결 가능하고, 또한 게으르게(lazily) 실행됩니다.
    myStream.filter(s -&gt; s.startsWith("c"))
      .map(String::toUpperCase)
      .sorted();
    
  
  3. 종단 연산(Terminal operations) : 스트림의 요소들을 소모하여 결과를 생성하는 연산입니다. 예를 들어, forEach, reduce, collect 등이 있으며, 이 연산을 수행한 후 스트림은 더 이상 사용할 수 없습니다.
    myStream.forEach(System.out::println);
    
  


1.4 스트림과 병렬 처리.
스트림 API는 병렬 처리를 간단하게 지원합니다.
‘paralleStream()’ 을 호출하면 자동으로 여러 쓰레드에서 스트림 연산이 병렬로 수행됩니다.
이는 데이터가 큰 경우에 유용하며, 멀티코어 프로세서의 이점을 쉽게 활용할 수 있게 해줍니다.

1.5 📝 정리.
스트림은 자바에서 데이터 컬렉션을 함수형 스타일로 쉽게 처리할 수 있게 하는 강력한 도구입니다.
이는 코드의 간결성과 가독성을 높이는 데 큰 도움을 줍니다.



2. 중개 연산(Intermediate operations)
자바 스트림 API에서 중개 연산(Intermediate operations)은 스트림의 요소들을 처리하고 변형하는 연산들로서, 다른 스트림을 반환합니다.

중개 연산은 게으른(lazy) 특성을 가지며, 종단 연산(Terminal operation)이 호출되기 전까지는 실제로 실행되지 않습니다.

이런 특성은 연산의 체인을 구성할 때 성능 최적화에 도움을 줍니다.

2.1 중개 연산의 주요 특성.

  
    게으른 실행(Lazy Execution) : 중개 연산은 호출되었을 때 즉시 실행되지 않습니다. 대신, 종단 연산이 호출될 때 까지 실행이 지연됩니다.
  
  
    스트림 변환 : 각 중개 연산은 변형된 형태의 새로운 스트림을 변환합니다. 이는 연산을 연쇄적으로 연결할 수 있도록 합니다.
  


2.2 주요 중개 연산의 종류.

  1. 필터링(Filtering)
    
      ‘filter(Predicate&lt;T&gt; predicate)’ : 주어진 조건(프리디케이트)에 맞는 요소만을 포함하는 스트림을 반환합니다.
        List&lt;String&gt; names = Arrays.asList("Jo", "Lee", "Park", "Kang");
  names.stream()
   .filter(name -&gt; name.startsWith("K"))
   .forEach(System.out::println); // 출력: "Kang"
        
      
    
  
  2. 매핑(Mapping)
    
      ‘map(Function&lt;T, R&gt; mapper)’ : 스트림의 각 요소에 주어진 함수를 적용하고, 함수 결과로 주성된 새 스트림을 반환합니다.
      ‘flatMap(Function&lt;T, Stream&lt;R&gt;&gt; mapper)’ : 각 요소에 함수를 적용한 결과로 생성된 여러 스트림을 하나의 스트림으로 평탄화합니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);
numbers.stream()
 .map(number -&gt; number * number)
 .forEach(System.out::println); //출력: 1, 4, 9, 16
        
      
    
  
  3. 정렬(Sorting)
    
      ‘sorted() :’ 자연 순서대로 스트림을 정렬합니다.
      ‘sorted(Comparator&lt;T&gt; comparator) :’ 주어진 비교자를 사용하여 스트림을 정렬합니다.
        List&lt;String&gt; fruits = Arrays.asList("banana", "apple", "orange", "kiwi");
fruits.stream()
.sorted()
.forEach(System.out::println); // 출력: apple, banana, kiwi, orange
        
      
    
  
  4. 제한(Limiting) 및 건너뛰기(Skipping)
    
      ‘limit(long maxSize)’ : 스트림의 요소를 주어진 크기로 제한합니다.
      ‘skip(long n)’ : 스트림의 처음 n개 요소를 건너뜁니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
numbers.stream()
 .skip(2)
 .limit(3)
 .forEach(System.out::println); // 출력 3, 4, 5
        
      
    
  
  5. 중복 제거(Distinct)
    
      ‘distinct()’ : 스트림에서 중복된 요소를 제거합니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 2, 3, 4, 4, 5);
numbers.stream()
 .distinct()
 .forEach(System.out::println); // 출력: 1, 2, 3, 4, 5
        
      
    
  


2.3 📝 정리.
중개 연산을 통해 데이터 스트림을 세밀하게 제어하고 원하는 형태로 데이터를 변형 할 수 있습니다.
이러한 연산들은 다양한 데이터 처리 작업에서 매우 유용하게 사용됩니다.



3. 최종 연산(Terminal operations)
자바 스트림 API에서 최종 연산(Terminal operations)은 스트림 파이프라인의 실행을 트리거하고 스트림의 요소를 소비하여 결과를 생성하거나 부작용(side effect)을 일으키는 연산입니다.

최종 연산이 호출되기 전까지 중간 연산들은 게으른(lazy) 방식으로 처리되며 실행되지 않습니다.
최종 연산 후에는 스트림이 소비되어 더 이상 사용할 수 없게 됩니다.

3.1 최종 연산의 주요 유형.

  1. 수집(Collection)
    
      ‘collect(Collector&lt;T, A, R&gt; collector)’ : 스트림의 요소를 변환, 결합하고 컬렉션으로 또는 다른 형태로 결과를 수집합니다.
        
          예를 들어, ‘toList()’, ‘toSet()’, ‘toMap()’ 등이 있습니다.
            List&lt;String&gt; names = Array.asList("Alice", "Bob", "Charlie", "David");
List&lt;String&gt; list = names.stream()
               .filter(name -&gt; name.startsWith("A"))
               .collect(Collectors.toList());
System.out.println(list); // 출력 ["Alice"]
            
          
        
      
    
  
  2. 집계(Aggregation)
    
      ‘count()’ : 스트림의 요소 개수를 반환합니다.
      ‘max(Comparator&lt;T&gt; comparator)’ : 스트림에서 최대값을 찾습니다.
      ‘min(Comparator&lt;T&gt; comparator)’ : 스트림에서 최소값을 찾습니다.
      ‘reduce(BinaryOperator&lt;T&gt; accumulator)’ : 스트림의 요소를 결합하여 하나의 결과를 생성합니다.
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);
int sum = numbers.stream()
           .reduce(0, (a, b) -&gt; a + b);
System.out.println(sum); // 출력: 10
        
      
    
  
  3. 반복(Iteration)
    
      ‘forEach(Consumer&lt;T&gt; action)’ : 각 요소에 대해 주어진 작업을 수행합니다. 스트림의 순서대로 실행됩니다.
        List&lt;String&gt; names = Arrays.asList("Alist", "Bob", "Charlie", "David");
names.stream()
   .forEach(System.out::println); // Alice, Bob, Charlie, David
        
      
    
  
  4. 조건 검사(Checking)
    
      ‘allMatch(Predicate&lt;T&gt; predicate) :’ 모든 요소가 주어진 조건을 만족하는지 검사합니다.
      ‘anyMatch(Predicate&lt;T&gt;predicate) :’ 어떤 요소라도 주어진 조건을 만족하는지 검사합니다.
      ‘noneMatch(Predicate&lt;T&gt;predicate) :’ 모든 요소가 주어진 조건을 만족하지 않는지 검사합니다.
        boolean allEven = numbers.stream()
                   .allMatch(n -&gt; n % 2 == 0);
System.out.println(allEven); // 출력: false
        
      
    
  
  5. 요소 검색(Finding)
    
      ‘findFirst()’ : 스트림의 첫 번째 요소를 Optional로 반환합니다.
      ‘findAny()’ : 스트림에서 임의의 요소를 Optional로 반환합니다. 병렬 스트림에서 유용합니다.
        Optional&lt;String&gt; first = names.stream()
                        .findFirst();
first.ifPresent(System.out::println); // 출력 Alice
        
      
    
  


3.2 📝 정리.
이러한 최종 연산들은 스트림 처리를 완료하고 필요한 결과를 도출하기 위해 사용됩니다.
스트림 API를 통해 데이터 처리를 선언적이고 간결하게 할 수 있으며, 복잡한 로직을 효과적으로 관리할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-14</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html"><h1 class="title_post">☕️[Java] HashMap에 key 값은 항상 int 여야 할까요?</h1></a>
                        <a href="/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html" class="txt_post">
                            🤔 HashMap에 key 값은 항상 int 여야 할까요?

강의와 예제 코드를 열심히 보고 따라서 타이핑하고 있던 중 “문뜩!” 떠올랐습니다. 🤩

‘HashMap에 key 값은 항상 int 여야 할까요?🤔’

그래서 구글링과 챗 지피티 그리고 Java의 정석 도서를 살펴본 후 이 글을 쓰게 되었습니다 :)



🙅‍♂️ 대답은 “아니오!” 입니다.

자바 프로그래밍에서 ‘HashMap’ 의 키 값은 ‘int’ 형일 필요는 없다고 합니다.

‘HashMap’ 은 키로서 어떠한 객체도 사용할 수 있으며, 기는 자바의 ‘제네릭’ 을 통해 다양한 유형의 객체를 키로 사용할 수 있게 해준다고 합니다.
(오! “제네릭” 은 아직 안배웠지만 🥲 Swift에서 봐서 비슷한 느낌 같은데?!)

키 객체는 ‘Object’ 클래스의 ‘hashCode()’ 메소드와 ‘equals()’ 메소드를 적절히 구현해야 합니다.
(‘Object’ 클래스는 무엇이고,  ‘hashCode()’ 메소드와 ‘equals()’ 메소드는 무엇인가?!! 🤪)

이는 ‘HashMap’ 이 키의 해시 코드를 사용하여 데이터를 저장하고 검색하기 때문입니다.
(도통 무슨 소리인지 몰라서 아래 “제네릭”. “Object 클래스”, “hashCode()”, “equals()”를 정리했어요 ㅎㅎ)

‘HashMap’ 을 사용할 때, 키로 사용되는 객체의 ‘hashCode()’ 메소드가 효율적이고 일관성 있는 값을 반환해야 합니다.
또한, ‘equalse()’ 메소드는 객체의 동등성을 정확하게 판단할 수 있어야 합니다.
이 두 메소드의 구현이 적절히 이루어져야 ‘HashMap’ 이 키의 중복 없이 정확하게 데이터를 관리할 수 있습니다.

예시 - String 객체를 키로 사용하는 ‘HashMap’
import java.util.HashMap;

public class Example {
    public static void main(String[] args) {
        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        map.put("one", 1);
        map.put("two", 2);
        map.put("three", 3);
        
        System.out.println(map.get("two")); // 출력: 2
    }
}



  위 예시에서 보듯, ‘String’ 외에도 사용자가 정의한 어떠한 객체든 ‘hashCode()’ 와 ‘equals()’ 가 적절히 구현되어 있다면 키로 사용할 수 있습니다.
    
      따라서 ‘int’ 만을 키로 사용해야 하는 것은 아닙니다.
    
  




1️⃣ 제네릭(Generic).
자바에서 ‘제네릭(Generic)’ 은 클래스, 인터페이스, 메소드를 정의할 때 타입(Type)을 하나의 매개변수처럼 취급하여, 다양한 데이터 타입을 사용할 수 있도록 하는 프로그래밍 기법입니다.

제네릭을 사용하면 컴파일 시점에 타입 안정성을 제공하고, 타입 캐스팅을 줄여 코드를 더 간결하고 읽기 쉽게 만들 수 있습니다.

제네릭 기본 문법.
제네릭은 타입 매개변수를 사용하여 구현됩니다.

타입 매개변수는 보통 한 글자로 표현되며, 일반적으로 다음과 같은 문자를 사용합니다.


  ‘E’ : Element(컬렉션에서 사용되는 요소)
  ‘K’ : Key(키)
  ‘V’ : Value(값)
  ‘T’ : Type(일반적인 타입)
  ‘S’, ‘U’, ‘V’ 등 - 두 번째, 세 번째, 네 번째 타입을 나타내기 위해 사용


예시: 제네릭을 사용한 클래스와 메소드
// 제네릭 클래스 예시
public class Box&lt;T&gt; {
    private T t; // T는 이 클래스가 다루는 객체의 타입을 매개변수화합니다.
    
    public void set(T t) {
        this.t = t;
    }
    
    public T get() {
        return t;
    }
}

// 제네릭 메소드 예시
public static &lt;T&gt; void printArray(T[] inputArray) {
    for (T element : inputArray) {
        System.out.print(element + " ");
    }
    System.out.println();
}


  위 예시에서 ‘Box’ 클래스는 타입 매개변수 ‘T’ 를 사용하여 다양한 타입을 저장하고 반환할 수 있는 범용 컨테이너로 사용됩니다.
  ‘printArray’ 메소드는 어떤 배열 타입도 받아들일 수 있으며, 그 요소들을 출력합니다.




2️⃣ Object 클래스.
자바 프로그래밍에서 ‘Object’ 클래스는 자바의 클래스 계층 구조에서 가장 상위에 위치하는 클래스입니다.

모든 자바 클래스는 직접적이거나 간접적으로 ‘Object’ 클래스를 상속받습니다.

이는 ‘Object’ 클래스가 자바에서 모든 클래스의 근본(base)이라는 의미 입니다.

‘Object’ 클래스는 자바의 ‘java.lang’ 패키지에 포함되어 있으며, 모든 객체에 공통적으로 필요한 메서드를 제공합니다.

Object 클래스의 의의.
‘Object’ 클래스의 메서드들은 자바의 모든 클래스에 기본적인 기능을 제공합니다.

이로 인해, 개발자는 어떤 클래스를 만들 때도 이러한 기본적인 메서드들을 새로 작성하지 않고도, 필요에 따라 이를 상속받아 확장하거나 재정의할 수 있습니다.

‘Object’ 클래스는 자바의 모든 클래스와 객체에 공통적인 근복적인 메커니즘을 제공하는 중추적인 역할을 합니다.



3️⃣ Object 클래스의 hashCode() 메소드.
자바의 ‘Object’ 클래스에서 ‘hashCode()’ 메소드는 객체의 메모리 주소를 기반으로 계산된 정수 값을 반환하는 메소드입니다.

이 메소드는 객체의 해시 코드를 제공하며, 해시 기반 컬렉션(예: ‘HashMap’, ‘HashSet’, ‘Hashtable’ 등)에서 객체를 효율적으로 관리하기 위해 사용됩니다.

hashCode() 메소드의 주요 용도

  1. 해시 테이블 사용 : ‘hashCode()’ 는 특히 해시 테이블을 사용하는 자료 구조에서 중요합니다.
    
      객체의 해시 코드를 사용하여, 해당 객체가 저장되거나 검색될 해시 버킷을 결정합니다.
        
          이로 인해 데이터의 삽입, 검색, 삭제 작업이 빠르게 수행될 수 있습니다.
        
      
    
  
  2. 객체의 동등성의 빠른 검증 : ‘hashCode()’ 메소드는 ‘equals()’ 메소드와 함께 사용되어 객체의 동등성을 검사합니다.
    
      두 객체가 같다면 반드시 같은 해시 코드를 반환해야 합니다.
        
          따라서, 해시 코드가 다른 두 객체는 결코 같을 수 없으므로, ‘equals()’ 호출 전에 해시 코드를 먼저 확인함으로써 불필요한 비교를 줄일 수 있습니다.
        
      
    
  




4️⃣ Object 클래스의 equals() 메소드.
자바 프로그래밍에서 ‘Object’ 클래스의 ‘equals()’ 메소드는 두 객체가 동등한지 비교하는데 사용됩니다.

이 메소드는 ‘Object’ 클래스에서 모든 클래스로 상속되며, 특히 객체의 동등성을 판단할 때 중요한 역할을 합니다.

기본적으로, ‘Object’ 클래스의 ‘equals()’ 메소드는 두 객체의 참조가 같은지 확인합니다.

즉, 두 객체가 메모리상에서 같은 위치를 가리키는지 검사합니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-CollectionFramework.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-CollectionFramework.html"><h1 class="title_post">☕️[Java] 컬렉션 프레임워크</h1></a>
                        <a href="/Backend/Java/2024-05-13-CollectionFramework.html" class="txt_post">
                            1️⃣ 컬렉션 프레임워크

1. 컬렉션 프레임워크(Collection Framework)
자바 컬렉션 프레임워크는 자료 구조를 효율적으로 관리하고 조작할 수 있는 방법을 제공하는 통합 아키텍처입니다.
이 프레임워크는 다양한 인터페이스와 구현을 포함하며, 다양한 종류의 컬렉션들을 제어하고, 데이터 집합을 효율적으로 관리하기 위한 알고리즘을 제공합니다.

1.2 컬렉션 프레임워크의 구요 구성 요소.

  1. 인터페이스(Interface) : 컬렉션 프레임워크의 핵심 인터페이스로는 ‘Collection’, ‘List’, ‘Queue’ 등이 있으며 각각 다른 형태의 데이터 집합을 추상화합니다.
    
      예를 들어, ‘List’ 는 순서가 있는 데이터 집합을, ‘Set’ 은 중복을 허용하지 않는 데이터 집합을 나타냅니다.
    
  
  2. 구현(Implementation) : 이러한 인터페이스를 실제로 구현한 클래스들로, ‘ArrayList’, ‘LinkedList’, ‘HashSet’, ‘TreeSet’, ‘PriorityQueue’ 등이 포함됩니다.
    
      각 클래스는 컬렉션 인터페이스를 구현하며, 데이터의 특성에 따라 선택하여 사용할 수 있습니다.
    
  
  3. 알고리즘(Algorithm) : 컬렉션 데이터를 처리하는 데 필요한 다양한 알고리즘이 제공됩니다.
    
      이 알고리즘은 정렬, 검색, 순환 및 변환 등을 포함하며, 이들은 대부분 ‘Collections’ 클래스에 정적 메소드로 제공됩니다.
    
  


1.3 📝 정리.
컬렉션 프레임워크를 사용하면 데이터를 보다 효율적으로 처리할 수 있고, 기능의 재사용성 및 유지 보수성이 향상됩니다.
또한, 자바 개발자로서 다양한 데이터 컬렉션을 쉽게 처리하고, 표준화된 방법으로 데이터를 조작할 수 있는 능력을 갖추게 됩니다.



2. List 인터페이스.
자바 프로그래밍에서 ‘List’ 인터페이스는 ‘java.util’ 패키지의 일부로, 순서가 있는 컬렉션을 나타냅니다.
이 인터페이스를 사용하면 사용자가 목록의 특정 위치에 접근, 삽입, 삭제를 할 수 있는 동시에, 목록의 요소들이 입력된 순서대로 저장 및 관리됩니다.
‘List’ 는 중복된 요소의 저장을 허용하기 때문에, 같은 값을 가진 요소를 여러 개 포함할 수 있습니다.

2.1 List 인터페이스의 주요 메서드.

  add(E e) : 리스트의 끝에 요소를 추가합니다.
  add(int index, E element) : 리스트의 특정 위치에 요소를 삽입합니다.
  remove(Object o) : 리스트에서 지정된 요소를 삭제합니다.
  remove(int index) : 리스트에서 지정된 위치의 요소를 삭제합니다.
  get(int index) : 지정된 위치에 있는 요소를 반환합니다.
  set(int index, E element) : 리스트의 특정 위치에 요소를 설정(교체)합니다.
  indexOf(Object o) : 객체를 찾고, 리스트 내의 첫 번째 등장 위치를 반환합니다.
  size() : 리스트에 있는 요소의 수를 반환합니다.
  clear() : 리스트에서 모든 요소를 제거합니다.


2.3 가장 널리 사용되는 구현체.
‘List’ 인터페이스는 다양한 구현체를 가지고 있으며, 가장 널리 사용되는 구현체는 ‘ArrayList’, ‘LinkedList’ 그리고 ‘Vector’ 입니다.

각 구현체는 내부적인 데이터 관리 방식이 다르므로, 사용 상황에 따라 적합한 구현체를 선택할 수 있습니다.


  ‘ArrayList’ : 내부적으로 배열을 사용하여 요소들을 관리합니다. 인덱스를 통한 빠른 접근이 가능하지만, 크기 조정이 필요할 때 비용이 많이 들 수 있습니다.
  ‘LinkedList :’ 내부적으로 양방향 연결 리스트를 사용합니다. 데이터의 삽입과 삭제가 빈번하게 일어나는 경우 유용합니다.
  Vector : ‘ArrayList’ 와 비슷하지만, 모든 메소드가 동기화되어 있어 멀티스레드 환경에서 사용하기에 안전합니다.


2.4 📝 정리.
이러한 특성들로 인해 ‘List’ 인터페이스는 자바에서 데이터를 순차적으로 처리할 필요가 있는 다양한 애플리케이션에서 중요하게 사용됩니다.



3. Set 인터페이스.
자바 프로그래밍에서 ‘Set’ 인터페이스는 ‘java.util’ 패키지의 일부이며, 중복을 허용하지 않는 요소의 컬렉션을 나타냅니다.

‘Set’ 은 ‘Collection’ 인터페이스를 확장하는 인터페이스로서, 집합의 개념을 구현합니다.
이는 각 요소가 컬렉션 내에서 유일하게 존재해야 함을 의미합니다.

인덱스로 요소를 관리하는 ‘List’ 인터페이스와 달리, ‘Set’ 은 요소의 순서를 유지하지 않습니다.

3.1 Set의 주요 특징.

  중복 불허 : 같은 요소의 중복을 허용하지 않으며, 이미 ‘Set’ 에 존재하는 요소를 추가하려고 시도하면 그 요소는 컬렉션에 추가되지 않습니다.
  순서 보장 없음 : 대부분의 ‘Set’ 구현체는 요소의 저장 순서를 유지하지 않습니다. 그러나 ‘LinkedHashSet’ 과 같은 특정 구현체는 요소의 삽입 순서를 유지할 수 있습니다.
  값에 의한 접근 : ‘Set’ 은 인덱스를 사용하지 않고 값에 의해 요소에 접근합니다.


3.2 주요 메서드.
‘Set’ 인터페이스는 ‘Collection’ 인터페이스에서 상속받은 다양한 메소드를 포함합니다.
주요 메서드는 다음과 같습니다.


  add(E e): 요소 e를 Set에 추가합니다. 이미 존재하는 요소를 추가하려는 경우, 요소는 추가되지 않고 false를 반환합니다.
  remove(Object o): 지정된 객체 o를 Set에서 제거합니다.
  contains(Object o): Set이 지정된 객체 o를 포함하고 있는지 여부를 반환합니다.
  size(): Set의 요소 개수를 반환합니다.
  isEmpty(): Set이 비어 있는지 여부를 반환합니다.
  clear(): Set의 모든 요소를 제거합니다


3.3 주요 구현체.
‘Set’ 인터페이스는 여러 가지 방법으로 구현될 수 있으며, 각 구현체는 다른 특성을 가집니다.


  HashSet : 가장 널리 사용되는 ‘Set’ 구현체로, 해시 테이블을 사용하여 요소를 저장합니다. 요소의 삽입, 삭제, 검색 작업은 평균적으로 상수 시간(O(1))이 걸립니다.
  LinkedHashSet : ‘HashSet’ 의 확장으로, 요소의 삽입 순서를 유지합니다.
  TreeSet : 레드-블랙 트리 구조를 사용하여 요소를 저장합니다. 요소는 자연적 순서 또는 비교자에 의해 정렬됩니다.
    
      이로 인해 삽입, 삭제, 검색 작업에 로그 시간(O(log n))이 걸립니다.
    
  


3.4 📝 정리.
‘Set’ 인터페이스는 주로 중복을 허용하지 않는 데이터 컬렉션을 다루는 데 사용되며, 특히 요소의 유일성을 보장하는데 유용합니다.



4. Map 인터페이스.
자바에서 ‘Map’ 인터페이스는 ‘java.util’ 패키지에 속하며, 키(key)와 값(value) 쌍으로 이루어진 데이터를 저장하는 자료구조를 정의합니다.

‘Map’ 은 키의 중복을 허용하지 않으면서 각 키는 하나의 값에 매핑됩니다.

값은 중복될 수 있지만, 각 키는 유일해야 합니다.

이러한 특성 때문에 ‘Map’ 은 키를 통해 빠르게 데이터를 검색할 수 있는 효율적인 수단을 제공합니다.

4.1 Map의 주요 특징.

  키 기반 데이터 접근 : 키를 사용하여 데이터에 접근하므로, 키에 대한 빠른 검색, 삽입, 삭제가 가능합니다.
  키의 유일성 : 같은 키를 다시 ‘Map’ 에 추가하려고 하면 기존 키에 연결된 값이 새 값으로 대체됩니다.
  값의 중복 허용 : 같은 값을 가진 여러 키가 ‘Map’ 에 존재할 수 있습니다.


4.2 주요 메서드
‘Map’ 인터페이스는 데이터를 관리하기 위해 다음과 같은 주요 메소드를 제공합니다.


  put(K key, V value): 키와 값을 Map에 추가합니다. 이미 키가 존재하면, 해당 키의 값이 새로운 값으로 업데이트 됩니다.
  get(Object key): 지정된 키에 연결된 값을 반환합니다. 키가 존재하지 않는 경우, null을 반환합니다.
  remove(Object key): 지정된 키와 그 키에 매핑된 값을 Map에서 제거합니다.
  containsKey(Object key): Map에 특정 키가 있는지 검사합니다.
  containsValue(Object value): Map에 특정 값이 하나 이상 있는지 검사합니다.
  keySet(): Map의 모든 키를 Set 형태로 반환합니다.
  values(): Map의 모든 값을 컬렉션 형태로 반환합니다.
  entrySet(): Map의 모든 “키-값” 쌍을 Set 형태의 Map.Entry 객체로 반환합니다.
  size(): Map에 저장된 “키-값” 쌍의 개수를 반환합니다.
  clear(): Map의 모든 요소를 제거합니다.


4.3 주요 구현체
‘Map’ 인터페이스의 주요 구현체로는 다음과 같은 클래스들이 있습니다.

  HashMap : 가장 일반적으로 사용되는 ‘Map’ 구현체로, 해시 테이블을 사용합니다.
    
      요소의 순서를 보장하지 않으며, 키와 값에 ‘null’ 을 허용합니다.
    
  
  LinkedHashMap : ‘HashMap’ 을 상속받아 구현된 클래스로, 요소의 삽입 순서를 유지합니다.
    
      이는 순회 시 삽인된 순서대로 요소를 얻을 수 있게 해줍니다.
    
  
  TreeMap : 레드-블랙 트리를 기반으로 하는 ‘Map’ 구현체로, 모든 키가 자연적 순서대로 정렬됩니다.
    
      정렬된 순서로의 접근이 필요할 때 유용합니다.
    
  
  Hashtable : ‘HashMap’ 과 유사하지만, 모든 메소드가 동기화되어 있어 멀티스레드 환경에서 사용하기에 안전합니다.
    
      그러나 성능이 ‘HashMap’ 보다 느리고, 키와 값에 ‘null’ 을 허용하지 않습니다.
    
  


4.4 📝 정리.
‘Map’ 인터페이스는 다양한 애플리케이션에서 설정, 프로파일, 사용자 세션 등의 데이터를 키와 값의 형태로 관리할 때 유용하게 사용됩니다.


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-lambdaIsOnlyOne.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-lambdaIsOnlyOne.html"><h1 class="title_post">☕️[Java] 람다식은 하나만!</h1></a>
                        <a href="/Backend/Java/2024-05-13-lambdaIsOnlyOne.html" class="txt_post">
                            람다식은 하나만!😆
자바에서는 “하나의 추상 메소드를 갖는 인터페에스에 대해서만 람다식을 직접 사용할 수 있습니다.”
이를 함수형 인터페이스라고 부르며, 람다식은 이런 함수형 인터페이스의 구현을 간단히 할 수 있는 방법을 제공합니다.

하지만 아래의 코드와 같이 인터페이스 내에 두 개의 추상 메서드 (‘plus’, ‘minus’)가 있기 때문에, 이 인터페이스를 람다식으로 직접 구현하는 것은 불가능합니다.

interface Carculator {
    public abstract int plus(int x, int y);
    public abstract int minus(int x, int y);
}


람다식을 사용하려면 함수형 인터페이스가 필요하므로, 두 메소드 각각을 위한 두 개의 별도의 인터페이스를 정의하거나 기존 인터페이스 중 하나를 수정해야 합니다.

아래의 코드는 이를 위해 각 메소드를 분리하여 두 개의 함수형 인터페이스를 만든 예시입니다.
interface Calculator {
  public abstract int operation(int x, int y);
}
public class Main {

  public static void main(String[] args) {
    Calculator plus = (x, y) -&gt; { return x + y; };
    System.out.println(plus.operation(10,2)); // 12
    Calculator minus = (x, y) -&gt; { return x - y; };
    System.out.println(minus.operation(10,2)); // 8
  }
}


위 코드는 각 연산을 람다식으로 간단히 구현하고 있습니다.
만약 원래의 ‘Carculator’ 인터페이스를 유지고하고 싶다면 이를 직접적으로 람다식으로 구현할 수는 없으며, 대신 익명 클래스나 정규 클래스를 사용해야 합니다.

아래의 코드는 익명 클래스를 사용하는 방법을 보여줍니다.
Calculator calclator = new Calculator() {
    @Override
    public int plus(int x, int y) {
        return x + y;
    }
    
    @Override
    public int minus(int x, int y) {
        return x - y;
    }
}


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-13-lambda.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-13-lambda.html"><h1 class="title_post">☕️[Java] 람다식</h1></a>
                        <a href="/Backend/Java/2024-05-13-lambda.html" class="txt_post">
                            1️⃣ 람다식.

1. 람다 표현식(Lambda Expression)
자바 프로그래밍에서 람다식 또는 람다 표현식(Lambda Expression)은 간결한 방식으로 익명 함수(anonymous function)를 제공하는 기능입니다.

자바 8부터 도입된 이 기능은 함수형 프로그래밍의 일부 개념을 자바에 도입하여, 코드를 더 간결하고 명료하게 만들어 주며 특히 컬렉션의 요소를 처리할 때 유용하게 사용됩니다.

1.2 람다식의 특징.

  익명성 : 람다는 이름이 없기 때문에 익명으로 처리됩니다.
  함수 : 람다는 메서드와 유사하지만, 독립적으로 존재할 수 있는 함수입니다.
  전달성 : 람다 표현식은 메서드 인자로 전달되거나 변수에 저장될 수 있습니다.
  간결성 : 코드의 간결성을 높여, 불필요한 반복을 줄여줍니다.


1.3 람다 표현식의 기본 구조.
람타 표현식은 주로 매개 변수를 받아들여 결과를 반환하는 식의 형태로 작성됩니다.

일반적인 형태는 다음과 같습니다.
(parameters) -&gt; expression
또는
(parameters) -&gt; { statements; }


  매개 변수 : 괄호 안에 정의되며, 매개 변수의 타입을 명시할 수도 있고 생략할 수도 있습니다.
    
      매개 변수가 하나뿐인 경우, 괄호도 생략할 수 있습니다.
    
  
  
    화살표(-&gt;) : 매개 변수와 몸체를 구분짓는 역할을 합니다.
  
  몸체 : 람다의 실행 로직을 담고 있으며, 식(expression) 또는 문장(statements)이 올 수 있습니다.
    
      식은 단일 실행 결과를 반환하며, 중괄호는 생략할 수 있습니다.
      문장은 중괄호 안에 작성되며, 여러 줄의 코드를 포함할 수 있습니다.
    
  


1.4 예시

  Thread 실행하기
    new Thread(() -&gt; System.out.println("Hello from a thread")).start();
    
  
  리스트의 각 요소 출력하기
    List&lt;String&gt; list = Arrays.asList("Apple", "Banana", "Cherry");
list.forEach(item -&gt; System.out.println(item));
    
  
  Comparator를 통한 정렬
    List&lt;String&gt; cities = Arrays.asList("Seoul", "New York", "London");
Collections.sort(cities, (s1, s2) -&gt; s1.compareTo(s2));
    
  


1.5 📝 정리.
람다 표현식은 이벤트 리스너, 스레드의 실행 코드 등 여러 곳에서 기존에 익명 클래스를 사용하던 부분을 대체하여 코드를 더 간결하게 만들 수 있습니다.

또한, 스트림 API와 함께 사용될 때 강력한 데이터 처리 기능을 제공하여 복잡한 컬렉션 처리를 단순화시킬 수 있습니다.



2. 람다식의 장점.
자바에서 람다식(Lambda Expression)을 사용하는 것은 여러 가지 장점을 제공합니다.

이러한 장점들은 프로그래밍 스타일, 코드의 간결성, 효율성 및 기능성 측면에서 특히 두드러집니다.

2.1 람다식의 주요 장점들.

  1. 코드의 간결성 : 람다식을 사용하면 복잡한 익명 클래스를 사용할 필요가 없어지므로 코드를 훨씬 간결하게 작성할 수 있습니다.
    
      예를 들어, 스레드를 실행하거나 이벤트 리스너를 설정할 때 몇 줄의 코드로 작성할 수 있습니다.
    
  
  2. 가독성 향상 : 람다식은 기존의 익명 클래스보다 훨씬 읽기 쉽고 이해하기 쉬운 코드를 작성할 수 있게 합니다.
    
      이는 유지보수 시간을 줄이고 코드의 질을 향상시키는 데 도움이 됩니다.
    
  
  3. 함수형 프로그래밍 지원 : 람다식은 자바에 함수형 프로그래밍 스타일을 도입하였습니다.
    
      이는 데이터 처리와 조작을 보다 선언적으로 표현할 수 있게 해, 복잡한 데이터 처리 로직을 간결하고 효율적으로 작성할 수 있도록 합니다.
    
  
  4. 코드의 재사용성 증가 : 람다식을 사용하면 특정 동작을 수행하는 코드 블록을 쉽게 재사용할 수 있습니다.
    
      람다식은 변수처럼 취급될 수 있어, 메소드에 인자로 전달하거나 변수에 할당하여 다른 위치에서 사용할 수 있습니다.
    
  
  5. 병렬 실행 용이 : 자바 8 이후로 스트림 API와 결합된 람다식은 컬렉션 처리를 병렬로 쉽게 수행할 수 있게 해줍니다.
    
      이는 ‘parallelStream()’ 과 같은 메소드를 사용하여 멀티코어 프로세서의 이점을 쉽게 활용할 수 있게 합니다.
    
  
  6. 지연 실행(Lazy Evaluation) : 람다식은 지연 실행을 가능하게 합니다.
    
      예를 들어, 조건이 충족될 때까지 코드 실행을 지연시키거나, 필요할 때만 데이터를 처리하도록 할 수 있습니다.
        
          이는 성능 최적화에 도움을 줄 수 있습니다.
        
      
    
  
  7. 함수 인터페이스와의 호환성 : 람다식은 단일 추상 메소드를 가진 인터페이스(함수 인터페이스)와 호환됩니다.
    
      이는 많은 내장 함수 인터페이스(‘Runnable’, ‘Callable’, ‘Comparator’ 등)와 사용자 정의 함수 인터페이스에 람다식을 적용할 수 있음을 의미합니다.
    
  


2.2 📝 정리.
이러한 장점들로 인해 람다식은 자바 프로그래머들 사이에서 매우 인기 있는 기능이 되었으며, 모던 자바 코드에서는 필수적인 요소로 자리 잡고 있습니다.



3. 람다식의 단점.
자바에서 람다식을 사용하면 여러 가지 장점이 있지만, 몇 가지 단점 또는 주의할 점도 있습니다.

3.1 람다식의 사용과 관련된 단점.

  1. 디버깅의 어려움 : 람다식은 익명 함수이기 때문에 디버깅이 더 복잡할 수 있습니다.
    
      스택 트레이스에서 람다식이 어디에 위치하는지 명확하게 표시되지 않아 오류를 추적하기 어려울 수 있습니다.
    
  
  2. 코드의 남용 : 람다식을 과도하게 사용하면 코드가 오히려 더 복잡해지고 이해하기 어려워질 수 있습니다.
    
      특히 람다 내부에 긴 로직이나 조건문을 넣을 경우 가독성이 떨어질 수 있습니다.
    
  
  3. 람다 캡처링 오버헤드 : 람다식은 주변 환경의 변수를 캡처(Capture)할 수 있습니다.
    
      이 때, 람다가 외부 변수를 캡처 할 경우 추가적인 비용이 발생할 수 있으며, 이는 성능에 영향을 줄 수 있습니다.
    
  
  4. 직렬화의 문제 : 람다식은 기본적으로 직렬화가 보장되지 않습니다.
    
      따라서 람다식을 사용하는 객체를 직렬화하려고 할 때 문제가 발생할 수 있습니다.
        
          이는 분산 시스템에서 특히 중요한 이슈가 될 수 있습니다.
        
      
    
  
  5. 학습 곡선 : 자바 8 이전의 버전에 익숙한 개발자들에게 람다식과 스트림 API는 새로운 패러다임을 익혀야 하는 도전과제를 제시합니다.
    
      이는 초기 학습 곡선을 가파르게 만들 수 있습니다.
    
  
  6. 타입 추론의 복잡성 : 람다식에서는 자바 컴파일러가 타입을 추론해야 하는데, 때때로 이 추론이 개발자의 의도와 다른게 이루어질 수 있습니다.
    
      이는 코드의 명확성을 떨어뜨릴 수 있습니다.
    
  
  7. 함수형 인터페이스의 제약 : 람다식은 단 하나의 추상 메소드를 가진 함수형 인터페이스와 함꼐 사용됩니다.
    
      때로는 이런 제약이 프로그램 설계를 더 복잡하게 만들 수 있습니다.
    
  


3.2 📝 정리.
람다식의 단점들은 주로 개발과 관련된 트레이드오프와 관련이 있으며, 이러한 단점을 이해하고 적절히 관리한다면 람다식을 효과적으로 사용할 수 있습니다.



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-12-ExceptionHandling.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-12-ExceptionHandling.html"><h1 class="title_post">☕️[Java] 예외 처리</h1></a>
                        <a href="/Backend/Java/2024-05-12-ExceptionHandling.html" class="txt_post">
                            1️⃣ 예외 처리

예외 처리가 무엇인지 이해하고, 예외 처리 방법에 대해 직접 구현

1. 예외(Exception)
자바 프로그래밍에서 “예외(Exception)” 란 프로그램 실행 중에 발생하는 비정상적인 조건 또는 오류를 의미합니다.
이는 프로그램의 정상적인 흐름을 방해하며, 적절히 처리하지 않으면 프로그램이 비정상적으로 종료될 수 있습니다.
자바에서는 이러한 예외를 효과적으로 처리하기 위해 강력한 예외 처리 메커니즘을 제공합니다.

1.2 예외의 유형.
자바에서 예외는 크게 두 가지 유형으로 나눌 수 있습니다.


  1. Checked Execptions
    
      컴파일 시간에 체크되는 예외로, 컴파일러가 해당 예외를 처리하도록 요구합니다.
      이 예외들은 주로 외부 시스템과의 상호 작요(파일 입출력, 네트워크 통신 등)에서 발생하며, 프로그래머가 이를 적절히 처리하도록 강제합니다.
    
  
  2. Unchecked Exceptions
    
      런타임에 발생하는 예외로, 주로 프로그래머의 실수로 인해 발생합니다.(예: 배령의 범위를 벗어나는 접근, null 참조 등.)
      이러한 예외는 컴파일러가 체크하지 않으므로, 개발자가 예측하고 적절히 처리할 필요가 있습니다.
    
  




2. 예외 처리(Exception Handling)
자바 프로그래밍에서 예외 처리는 프로그램 실행 중에 발생할 수 있는 예외적인 상황, 즉 오류나 문제를 안전하게 관리하고 대처하는 방법을 말합니다.
예외 처리를 통해 프로그램의 비정상적인 종료를 막고, 오류 발생 시 적절한 대응을 할 수 있도록 합니다.
이는 프로그램의 안정성과 신뢰성을 높이는 데 중요한 역할을 합니다.

2.1 예외 처리의 주요 구성 요소.


  1. try 블록
    
      예외가 발생할 가능성이 있는 코드를 이 블록 안에 넣습니다.
      만약 블록 안의 코드 실행 중에 예외가 발생하면, 즉시 해당 블록의 실행을 중단하고 ‘catch’ 블록으로 제어를 넘깁니다.
    
  
  2. catch 블록
    
      ‘try’ 블록에서 발생한 특정 유형의 예외를 처리합니다.
      프로그램이 예외를 안전하게 처리할 수 있도록 적절한 로직을 구현할 수 있습니다.
      하나의 ‘try’ 블록에 여러 ‘catch’ 블록을 사용하여 다양한 종류의 예외를 각각 다르게 처리할 수 있습니다.
    
  
  3. finally 블록
    
      이 블록은 예외의 발생 여부롸 관계없이 실행되는 코드를 포함합니다.
      주로 사용되는 목적은 자원 해제와 같은 정리 작업을 수행하기 위함입니다.
      예를 들어 파일이나 네트워크 자원을 닫거나 해제할 때 사용됩니다.
    
  
  4. throws 키워드
    
      메소드 선언 시 사용되며, 해당 메소드가 예외를 직접 처리하지 않고 호출한 메소드로 예외를 전파하겠다는 것을 나타냅니다.
      이를 통해 예외 처리의 책임을 메소드 호출자에게 넘길 수 있습니다.
    
  


2.2 예외 처리 예제.
public class ExceptionHandlingExample {
    public static void main(String[] args) {
        try {
            int result = divide(10, 0);
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            System.err.println("Arithmetic Exception: Division by zero is not allowed.");
        } finally {
            System.out.println("This block is always executed.");
        }
    }
    
    public static int divide(int numerator, in denominator) {
        return numerator / denominator; // This ca throw ArithmeticException if denominator is zero.
    }
}



  이 예제에서 ‘divide’ 메소드는 분모가 0일 때 ArithmeticException 을 발생시킬 수 있습니다.
    
      ‘try’ 블록 안에서 이 메소드를 호출하고, 예외가 발생하면 ‘catch’ 블록에서 이를 잡아서 적절한 오류 메시지를 출력합니다.
      또한, ‘finally’ 블록은 예외 발생 여부와 상관없이 실행되어 어떤 상황에서도 실행될 필요가 있는 코드를 포함할 수 있습니다.
    
  




3. throw 키워드.
자바 프로그래밍에서 ‘throw’ 키워드는 개발자가 의도적으로 예외를 발생시키기 위해 사용합니다.
이를 통해 특정 상황에서 프로그램의 흐름을 제어하거나, 특정 조건에서 오류를 발생시켜 예외 처리 메커니즘을 테스트하거나 강제할 수 있습니다.
‘throw’ 는 예외 객체를 생성하고 이를 던집니다(throw)
즉, 프로그램의 정상적인 실행 흐름을 중단하고 예외 처리 루틴으로 제어를 이동시킵니다.

3.1 ‘throw’ 사용법.
‘throw’ 를 사용할 때는 예외 객체를 생성해야 합니다.
이 객체는 ‘Throwable’ 클래스 또는 그 하위 클래스의 인스턴스여야 합니다.
자바에서는 대부분 ‘Exception’ 클래스 또는 그 서브클래스를 사용하여 예외를 생성하고 던집니다.

예제.
public class Main {
    public static void main(String[] args) {
        try {
            checkAge(17);
        } catch (Exception e) {
            System.out.println("Exception caught: " + e.getMessage());
        }
    }
    
    static void checkAge(int age) throws Execption {
        if (age &lt; 18) {
            throw new Exception("Access denied - You must be at least 18 years old.");
        }
        System.out.println("Access granted - You are old enough!");
    }
}


  이 예제에서 ‘checkAge’ 메소드는 나이를 확인하고, 18세 미만인 경우 예외를 던집니다.
    
      이 예외는 ‘throw new Exception(…)’ 을 통해 생성되고 던져집니다.
      메인 메소드에서는 이 메소드를 ‘try’ 블록 안에서 호출하고, ‘catch’ 블록을 통해 예외를 잡아서 처리합니다.
        
          결과적으로, 사용자가 18세 미만이면 “Access denided” 메시지를 포함하는 예외가 출력됩니다.
        
      
    
  


3.2 ‘throw’와 ‘throws’의 차이

  ‘throw’ : 예외를 실제로 발생시키는 행위입니다. 이는 메소드 내부에서 특정 조건에서 예외를 발생시킬 때 사용됩니다.
  ‘throws’ : 메소드 선언에 사용되며, 해당 메소드가 실행되는 동안 발생할 수 있는 예외를 명시적으로 선언합니다. 이는 호출자에게 해당 메소드를 사용할 때 적절한 예외 처리가 필요하다는 것을 알립니다.




4. throws 키워드.
자바 프로그래밍에서 ‘throws’ 키워드는 메소드 선언에 사용되며, 해당 메소드가 실행 도중 발생할 수 있는 특정 유형의 예외를 명시적으로 선언하는 데 사용됩니다.
‘throws’ 는 메소드가 예외를 직접 처리하지 않고, 대신 이를 호출한 메소드로 예외를 “던져”(전파하는) 사실을 알립니다.
이를 통해 예외 처리 책임을 메소드 호출자에게 넘기는 것입니다.

4.1 ‘throws’ 사용의 목적.

  명시성
    
      메소드가 발생시킬 수 있는 예외를 명시함으로써, 이 메소드를 사용하는 다른 개발자들에게 해당 메소드를 사용할 때 어떤 예외들을 처리해야 하는지 명확하게 알릴 수 있습니다.
    
  
  강제 예외 처리
    
      ‘throws’ 로 선언된 예외는 대부분 “checked exception” 이며, 이는 메소드를 호출하는 코드가 반드시 이 예외들을 처리하도록 강제합니다(try-catch 블록을 사용하거나, 또 다시 ‘throws’ 로 예외를 전파하도록 함).
    
  


4.2 ‘throws’ 사용법 예제.
아래 예제에서는 ‘throws’ 를 사용하여 ‘IOException’ 을 처리하는 방법을 보여줍니다.
이 예외는 파일 입출력 작업에서 자주 발생합니다.

import java.io.*;

public class Main {
    public static void main(String[] args) {
        try {
            readFile("example.txt");
        } catch (IOExecption e) {
            System.out.println("An error occurred: " + e.getMessage());
        }
    }
    
    public static void readFile(String filename) throws IOException {
        File file = new File(filename);
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(file);
            int content;
            while ((content = fis.read()) != -1) {
                // Process the content
                System.out.print((char) content);
            }
        } finally {
            if (fis != null) {
                fis.close();
            }
        }
    }
}



  이 예제에서 ‘readFile’ 메소드는 파일을 읽을 때 발생할 수 있는 IOException 을 처리하지 않고, 대신 ‘throws’ 키워드를 사용하여 이 예외를 메소드를 호출한 ‘main’ 메소드로 전달합니다.
    
      ‘main’ 메소드는 이 예외를 ‘catch’ 블록을 통해 처리합니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-12-Input-Ouput-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-12-Input-Ouput-2.html"><h1 class="title_post">☕️[Java] 입출력(2)</h1></a>
                        <a href="/Backend/Java/2024-05-12-Input-Ouput-2.html" class="txt_post">
                            1️⃣ 입출력(2)

1. 파일 출력.
자바 프로그래밍에서 파일 출력은 프로그램이 데이터를 쓰는 과정을 말합니다.
이 과정을 통해 프로그램은 실행 결과를 저장하거나, 사용자가 입력한 정보를 파일에 기록하고, 다른 프로그램이나 나중에 프로그램 자체가 다시 사용할 수 있는 형태로 데이터를 출력할 수 있습니다.

2. 파일 출력을 수행하기 위한 기본 방법들.

  1. FileOutputStream 사용
    
      ‘FileOutputStream’ 클래스는 바이트 단위의 출력을 파일에 직접 쓸 때 사용됩니다.
      이 클래스를 사용하면 이미지, 비디오 파일, 이진 데이터 등을 파일로 저장할 수 있습니다.
```java
import java.io.FileOutputStream;
import java.io.IOException;
    
  


public class FileOutputExample {
    public static void main(String[] args) {
        String data = “Hello, this is a test.”;
        try (FileOutputStream out = new FileOutputStream(“output.txt”)) {
            out.write(data.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

- **2. PrintWriter 사용**
    - **'PrintWriter'** 는 문자 데이터를 출력할 때 사용됩니다.
    - 이 클래스는 파일에 텍스트를 쓸 때 편리하며, 자동 플러싱 기능, 줄 단위 출력 등의 메소드를 제공합니다.
```java
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class PrintWriteExample {
    public static void main(String[] args) {
        try (PrintWriter writer = new PrintWriter(new FileWriter("output.txt", true))) {
            writer.println("Hello, this is a test.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



  3. FileWriter 사용
    
      ‘FileWriter’ 는 자바에서 파일에 텍스트 데이터를 쓰기 위한 간편한 방법 중 하나입니다.
      이 클래스는 내부적으로 문자 데이터를 파일에 쓸 수 있도록 ‘OutputStreamWriter’ 를 사용하여 바이트 스트림을 문자 스트림으로 변환합니다.
      ‘FileWriter’ 는 텍스트 파일을 쉽게 작성할 수 있도록 해주며, 생성자를 통해 다양한 방식으로 파일을 열 수 있습니다.
```java
import java.io.FileWriter;
import java.io.IOException;
    
  


public class FileWriterExample {
    pulbic static void main(String[] args) {
        try (FileWriter writer = new FileWriter(“output.txt”, true)) {
            writer.write(“Hello, this is a test.”);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

- **4. BufferedWriter 사용**
    - **'BufferedWrite'** 는 버퍼링을 통해 효율적으로 파일에 문자 데이터를 쓸 수 있도록 합니다.
    - **'FileWriter'** 와 함께 사용되어, 더 큰 데이터를 처리할 때 성능을 개선합니다.
```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedWriterExample {
    public static void main(String[] args) {
        String content = "Hello, this is a test.";
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {
            writer.write(content);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



2. 파일 입력.

자바 프로그래밍에서 파일 입력은 프로그램이 파일로부터 데이터를 읽어들이는 과정을 말합니다.

이 데이터는 텍스트나 바이너리 형태일 수 있으며, 파일에서 데이터를 읽어 프로그램 내에서 사용할 수 있도록 만드는 것이 목적입니다.

파일 입력을 위해 자바는 다양한 입출력 클래스를 제공합니다.

2.1 주로 사용되는 파일 입력 방법.


  1. FileInputStream 사용
    
      ‘FileInputStream’ 은 바이트 단위로 파일에서 데이터를 읽는 데 사용됩니다.
      이 클래스는 이미지, 비디오 파일, 실행 파일등의 이진 데이터 처리에 주로 사용됩니다.
```java
import java.io.FileInputStream;
import java.io.IOException;
    
  


public class FileInputStreamExample {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream(“input.dat”)) {
            int content;
            while ((content = fis.read()) != -1) {
                // content 변수에 한 바이트씩 읽어들인 데이터를 저장
                System.out.print((char) content);
            }
        } catch (IOExecption e) {
            e.printStackTrace();
        }
    }
}

- **2. BufferedRead** 와 **FileReader 사용**
    - **'BufferedReader'** 와 **'FileReader'** 는 텍스트 데이터를 효과적으로 읽기 위해 함께 사용됩니다.
    - **'FileReader'** 는 파일에서 문자 데이터를 읽어들이며, **'BufferedReader'** 는 버퍼링을 통해 읽기 성능을 향상 시킵니다.
```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedReaderExample {
    public static void main(String[] args) {
        try (BufferedReader br new BufferedReader(new FileReader("input.txt"))) {
            String line;
            while ((line = br.readline()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



  3. Scanner 사용
    
      ‘Scanner’ 클래스는 텍스트 파일을 읽을 때 유용하며, 특히 토큰화(tokenizing)된 데이터를 처리할 때 편리합니다.
      ‘Scanner’ 는 정규식을 사용하여 입력을 구분자로 분리하고, 다양한 타입으로 데이터를 읽어들일 수 있습니다.
```java
import java.io.File;
import java.util.Scanner;
    
  


public class ScannerExample {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(new File(“input.txt”))) {
            while (scanner.hasNextLine()) {
                System.out.println(scanner.nextLine());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

2.2 📝 정리.
이렇게 다양한 방법을 통해 파일로부터 데이터를 읽을 수 있으며, 각 방법은 사용하는 데이터 타입과 처리할 데이터의 양에 따라 선택할 수 있습니다.
파일에서 데이터를 읽는 것은 데이터를 처리하거나, 설정 정보를 불러오거나, 사용자 데이터를 읽는 등 다양한 목적으로 활용됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-11-Interface.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-11-Interface.html"><h1 class="title_post">☕️[Java] 인터페이스</h1></a>
                        <a href="/Backend/Java/2024-05-11-Interface.html" class="txt_post">
                            1️⃣ 인터페이스.

1. 인터페이스(Interface).
자바에서 인터페이스(Interface)는 메서드의 시그니처만을 정의하는 참조 타입입니다.

인터페이스는 클래스가 구현(implement) 해야 하는 동작의 설계를 제공하며, 구현하는 모든 클래스에 대해 특정 메소드들이 반드시 존재하도록 강제합니다.

이는 다형성을 지원하는 강력한 방법으로, 서로 다른 클래스들이 동일한 인터페이스를 구현함으로써 동일한 방식으로 처리될 수 있게 해 줍니다.

1.2 인터페이스의 주요 특징.

  1. 메소드 선언만 포함 : 인터페이스는 메소드의 구현을 포함하지 않습니다.(자바 8 이전까지는).
    
      메소드의 몸체는 인터페이스를 구현하는 클래스에서 제공됩니다.
    
  
  2. 상수만 포함 가능 : 인터페이스는 상수만을 멤버로 가질수 있습니다.
    
      모든 필드는 ‘public’, ‘static’, ‘final’ 로 선언됩니다.
    
  
  
    3. 다중 구현 지원 : 한 클래스는 여러 인터페이스를 구현할 수 있으며, 이를 통해 다중 상속의 이점을 얻을 수 있습니다.
  
  4. 디폴트 메소드와 정적 메소드 : 자바 8 이후부터는 인터페이스에 디폴트 메소드(구현을 포함하는 메소드)와 정적 메소드를 정의할 수 있게 되었습니다.
    
      이를 통해 더 유연한 설계가 가능해졌습니다.
    
  


1.3 인터페이스 정의 예시.
public interface Vehicle {
    void start();
    void stop();
}



  위 예제에서 ‘Vehicle’ 인터페이스는 ‘start’ 와 ‘stop’ 이라는 두 메소드를 정의합니다.
    
      이 인터페이스를 구현하는 모든 클래스는 이 두 메소드의 구체적인 구현을 제공해야 합니다.
    
  


1.4 인터페이스 구현 예.
public class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car starts.");
    }
    
    @Override
    public void stop() {
        System.out.println("Car stops.");
    }
}



  ‘Car’ 클래스는 ‘Vehicle’ 인터페이스를 구현합니다.
    
      이 클래스는 start 와 ‘stop’ 메소드를 구체적으로 구현해야 합니다.
    
  


1.5 결론.
인터페이스는 클래스와 다른 클래스 사이의 계약을 정의하고, 특정 작업을 수행하는 메소드의 시그니처를 강제합니다.
이는 코드의 상호 운용성을 높이고, 다형성을 통한 유연한 프로그래밍 설계를 가능하게 합니다.
인터페이스를 사용함으로써 다양한 구현체를 동일한 방식으로 처리할 수 있어, 코드의 유지보수성과 확장성이 향상됩니다.



2. 상수(constant).
자바 프로그래밍에서 상수(constant)는 값이 선언 후 변경될 수 없는 변수를 의미합니다.

상수는 일반적으로 프로그램 전체에서 변하지 않는 값에 사용되며, 이는 코드의 읽기 쉬움과 유지 관리를 돕습니다.

자바에서 상수를 선언하기 위해 ‘final’ 키워드를 변수 선언과 함께 사용합니다.

2.1 상수의 특징.

  1. 불변성 : 상수는 한 번 초기화되면 그 값이 변경될 수 없습니다.
  2. 명확성 : 코드 내에서 직접적인 값보다는 의미 있는 이름을 가진 상수를 사용함으로써 코드의 가독성과 유지보수성이 향상됩니다.
  3. 공용 사용 : 자주 사용되는 값이나 의미가 명확한 수치를 상수로 선언하여 코드 전바에 걸쳐 재사용할 수 있습니다.


2.2 상수 선언 예시.
상수를 선언하는 방법은 간단합니다.
‘final’ 키워드를 사용하여 변수를 선언하고, 초기화합니다.
일반적으로 상수의 이름은 대문자로 표기하며, 단어 간에는 언더스코어(‘_‘)를 사용합니다.
이는 상수임을 쉽게 식별할 수 있도록 도와줍니다.

public class Constants {
    public static final int MAX_WIDTH = 800;
    public static final int MAX_HEIGHT = 600;
    public static final String COMPANY_NAME = "MyCompany";
}


  위 예에서 ‘MAX_WIDTH’, ‘MAX_HEIGHT’, ‘COMPANY_NAME’ 은 모두 상수이며, 이들의 값은 선언된 후 변경될 수 없습니다.


2.3 상수 사용의 이점.

  오류 감소 : 값이 한 번 설정되면 변경되지 않기 때문에, 예상치 못한 곳에서 값이 변경되어 발생할 수 있는 버그를 줄일 수 있습니다.
  코드 재사용성 : 한 곳에서 값을 변경하면, 해당 상수를 사용하는 모든 위치에서 변경된 값이 적용됩니다. 이는 일관성 유지와 함께 코드 관리를 간소화합니다.
  컴파일 시간 최적화 : 상수 값은 컴파일 시간에 결정되므로, 런타임에 추가적인 계산 비용이 들지 않습니다.


2.4 결론.
상수는 프로그램 내에서 변하지 않는 값을 나타내며, 코드의 안정성과 유지보수성을 높이는 데 중요한 역할을 합니다.
자바에서는 ‘final’ 키워드를 사용하여 이러한 상수를 쉽게 생성할 수 있습니다.



3. 클래스의 상속과 인터페이스의 구현을 동시에 사용.
자바에서는 클래스의 상속과 인터페이스의 구현을 동시에 사용하여 “다중 상속“과 유사한 효과를 얻을 수 있습니다.

이는 자바의 설계에서 클래스는 단일 상속만을 허용하지만, 인터페이스는 다중으로 구현할 수 있게 함으로써 이루어집니다.

3.1 단일 상속과 다중 인터페이스 구현.

  단일 상속 : 자바에서 클래스는 단 하나의 상위 클래스만 상속받을 수 있습니다.
    
      이는 C++ 같은 언어에서 볼 수 있는 다중 상속의 복잡성과 관련된 문제(예: 다이아몬드 문제)를 피하기 위함입니다.
    
  
  다중 인터페이스 구현 : 한 클래스는 여러 인터페이스를 구현할 수 있습니다.
    
      이는 인터페이스가 구체적인 구현을 포함하지 않기 때문에(자바 8 이전까지, 자바 8 이후에는 디폴트 메소드를 통해 일부 구현을 포함할 수 있음), 클래스가 여러 인터페이스를 구현함으로써 다중 상속의 효과를 나타낼 수 있습니다.
    
  


3.2 예시.

  다음 예시에서 ‘Car’ 클래스는 ‘Vehicle’ 클래스를 상속받고, ‘Electric’ 및 ‘Autonomous’ 두 인터페이스를 구현하고 있습니다.
    
      이를 통해 ‘Car’ 클래스는 ‘Vehicle’ 클래스의 속성과 메소드를 상속받으며, 동시에 두 인터페이스의 메소드를 구현해야 합니다.
    
  


class Vehicle {
    void drive() {
        System.out.println("This vehicle is driving.");
    }
}

interface Electric {
    void charge();
}

interface Autonomous {
    void navigate();
}

class Car extends Vehicle implements Electric, Autonomous {
    @Override
    public void charge() {
        System.out.println("The car is charging.");
    }
    
    @Override
    public void navigate() {
        System.out.println("The car is navigating autonomously.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        myCar.drive();
        myCar.charge();
        myCar.navigate();
    }
}


3.4 결론.
자바에서는 한 클래스가 단일 상속을 통해 한 클래스의 기능을 상속받고, 동시에 여러 인터페이스를 구현함으로써 다중 상속의 효과를 얻을 수 있습니다.
이는 자바의 타입 시스템이 제공하는 유연성을 활용하는 좋은 예시로, 소프트웨어 설계에서 필요한 다양한 기능을 조합할 수 있게 해 줍니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-11-InnerClass.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-11-InnerClass.html"><h1 class="title_post">☕️[Java] 내부 클래스</h1></a>
                        <a href="/Backend/Java/2024-05-11-InnerClass.html" class="txt_post">
                            1️⃣ 내부 클래스.
내부 클래스의 개념과 종류 이해
익명 클래스 직접 구현

1. 내부 클래스(Inner Class).
자바 프로그래밍에서 내부 클래스(Inner Class)는 다른 클래스의 내부에 정의된 클래스를 말합니다.

내부 클래스는 주로 외부 클래스와 밀접한 관련이 있으며, 외부 클래스의 멤버들에 대한 접근을 용이하게 하기 위해 사용됩니다.

1.1 내부 클래스의 특징.
자바의 내부 클래스에는 몇 가지 특징이 있습니다.
이 특징들은 내부 클래스가 어떻게 사용되고, 그들이 주는 이점과 한계를 이해하는 데 도움이 됩니다.


  1. 접근성과 밀접성 : 내부 클래스는 외부 클래스의 모든 필드와 메소드(프라이빗 포함)에 접근할 수 있습니다. 이는 내부 클래스가 외부 클래스와 밀접한 작업을 수행할 때 매우 유용합니다.
    
      이러한 접근은 내부 클래스가 외부 클래스의 구현 세부사항에 깊이 연결될 수 있게 합니다.
    
  
  2. 캠슐화 증가 : 내부 클래스를 사용하면 관련 있는 부분만을 그룹화하여 외부에 불필요한 정보를 노출하지 않고도 복잡한 코드를 더 잘 구조화할 수 있습니다.
    
      이는 코드의 유지보수성과 가독성을 높이는 데 도움이 됩니다.
    
  
  
    3. 코드의 응집성 : 내부 클래스는 특정 외부 클래스와 매우 강하게 연결되어 있기 때문에, 그 기능이 외부 클래스와 밀접하게 관련된 기능을 수행할 때 코드의 응집력을 높일 수 있습니다.
  
  4. 더 나은 논리적 그룹핑 : 특정 기능을 내부 클래스에 구현함으로써, 관련 기능과 데이터를 함께 논리적으로 그룹화할 수 있습니다.
    
      이는 전체 코드베이스를 통해 일관성을 유지하고, 기능별로 코드를 정리하는 데 도움이 됩니다.
    
  
  
    5. 명시적인 컨텍스트 연결 : 내부 클래스는 명시적으로 그들의 외부 클래스의 인스턴스와 연결됩니다. 이는 그들이 외부 클래스의 상태와 행동에 따라 다르게 작동할 수 있음을 의미합니다.
  
  
    6. 다중 상속의 일종의 구현 : 자바는 다중 상속을 지원하지 않지만, 내부 클래스를 통해 비슷한 효과를 낼 수 있습니다. 외부 클래스가 하나 이상의 내부 클래스를 가질 수 있고, 각 내부 클래스는 다른 클래스를 상속받을 수 있으므로 다양한 기능을 조합할 수 있습니다.
  
  7. 메모리 및 성능 고려사항 : 내부 클래스는 외부 클래스의 인스턴스와 연결되어 있기 때문에, 외부 클래스의 인스턴스가 메모리에 남아 있는 동안에는 가비지 컬렉션에서 제거되지 않습니다. 이는 메모리 관리 측면에서 고려해야 할 사항입니다.


1.2 내부 클래스의 네 가지 유형.

  
    1. 비정적 중첩 클래스(Non-static Nested Class) 또는 내부 클래스(Inner Class) : 이 클래스는 외부 클래스의 인스턴스 멤버처럼 동작하며, 외부 클래스의 인스턴스에 대한 참조를 가지고 있습니다. 외부 클래스의 인스턴스 멤버와 메소드에 접근할 수 있습니다.
  
  
    2. 정적 중첩 클래스(Static Nested Class) : 이 클래스는 외부 클래스의 정적 멤버처럼 동작하며, 외부 클래스의 인스턴스 멤버에는 접근할 수 없지만, 정적 멤버에는 접근할 수 있습니다.
  
  
    3. 지역 클래스(Local Class) : 특정 메소드 또는 초기화 블록 내부에 정의된 클래스로, 선언된 영역 내에서만 사용할 수 있습니다. 지역 클래스는 해당 메소드 내에서만 사용되므로, 외부로 노출되지 않습니다.
  
  
    4. 익명 클래스(Anonymous Class) : 이름이 없는 클래스로, 일반적으로 단 한 번만 사용되며 주로 리스너(listener) 또는 작은 델리게이션 클래스로 사용됩니다. 클래스 선언과 인스턴스 생성이 동시에 이루어집니다.
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-11-Input-Output-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-11-Input-Output-1.html"><h1 class="title_post">☕️[Java] 입출력(1)</h1></a>
                        <a href="/Backend/Java/2024-05-11-Input-Output-1.html" class="txt_post">
                            1️⃣ 입출력(1)

콘솔 입출력 방법에 대해 직접 구현

1. 콘솔 입력
자바에서 콘솔 입력을 받는 방법은 여러 가지가 있습니다.

주로 사용되는 몇 가지 방법들을 소개하겠습니다.


  1. Scanner 클래스 사용
    
      ‘Scanner’ 클래스는 자바의 ‘java.util’ 패키지에 포함되어 있으며, 다양한 타입의 입력을 콘솔에서 받기 위해 널리 사용됩니다.
      ‘System.in’ 을 ‘Scanner’ 객체에 연결하여 사용자로부터 입력을 받을 수 있습니다.
```java
import java.util.Scanner;
    
  


public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println(“Enter your name: “);
        String name = scanner.nextLine();
        System.out.println(“Hello, “ + name);
        scanner.close();
    }
}

- **2. BufferedReader** 와 **InputStreamReader 사용**
    - 이 방법은 **'java.io'** 패키지를 사용합니다.
    - **'InputStreamReader'** 는 바이트 스트림을 문자 스트림으로 변환하는데 사용되고, **'BufferedReader'** 는 텍스트 읽기를 효율적으로 할 수 있게 해 줍니다.
        - 이 방법은 예외 처리를 필요로하며, 라인 단위로 입력을 받습니다.
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
            System.out.println("Enter your name: ");
            String name = reader.readLine();
            System.out.println("Hello, " + name);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



  3. Console 클래스 사용
    
      ‘Console’ 클래스는 자바 6 이상에서 사용할 수 있으며, 콘솔에서 비밀번호와 같은 민감한 데이터를 읽을 때 유용합니다.
      ‘System.console()’ 메소드를 통해 ‘Console’ 객체를 얻을 수 있으나, 이 방법은 IDE에서는 작동하지 않을 수 있습니다.(콘솔 환경에서만 사용 가능.)
```java
import java.io.Console;
    
  


public class Main {
    public static void main(String[] args) {
        Console console = System.console();
        if (console != null) {
            String name = console.readLine(“Enter your name: “);
            char[] password = console.readPassword(“Enter your password: “);
            console.printf(“Hello, %s\n”, name);
        } else {
            System.out.println(“No console available”);
        }
    }
}
```

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-11</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-10-polymorphism.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-10-polymorphism.html"><h1 class="title_post">☕️[Java] 다형성</h1></a>
                        <a href="/Backend/Java/2024-05-10-polymorphism.html" class="txt_post">
                            1️⃣ 다형성.

1. 다형성(Polymorphism)
자바에서 말하는 다형성(Polymorphism)은 객체가 여러 형태를 취할 수 있는 능력을 말합니다.

이는 같은 이름의 메소드 호출이 객체의 타입에 따라 다은 동작을 수행할 수 있게 해 주어 코드의 유연성과 재사용성을 증가시킵니다.

자바에서는 주로 두 가지 형태의 다형성을 지원하는데, 이는 컴파일 시간 다형성과 런타임 다형성입니다.

1.2. 컴파일 시간 다형성(정적 다형성).
컴파일 시간 다형성은 주로 메소드 오버로딩을 통해 구현됩니다.
메소드 오버로딩은 동일한 메소드 이름을 가지면서 매개변수 타입, 순서, 개수가 다른 여러 메소드를 같은 클래스 내에 선언하는 것을 의미합니다.
이러한 메소드들은 컴파일 시에 그 타입에 따라 구별되어 처리됩니다.

1.3 컴파일 시간 다형성 예시.
public class Display {
    public void print(int num) {
        System.out.println("Printing integer: " + num);
    }
    
    public void print(String str) {
        System.out.println("Printing string: " + str);
    }
}


1.4 런타임 다형성(동적 다형성).
런타임 다형성은 메소드 오버라이딩을 통해 구현됩니다.
이 경우 서브클래스에서 상속받은 부모 클래스의 메소드를 재정의하여 동일한 메소드 호출이 서로 다른 클래스 객체에 대해 다른 동작을 할 수 있도록 합니다.
이는 실행 중에 결정되므로 동적 다형성이라고 합니다.

1.5 런타임 다형성 예시.
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    void sound() {
        System.out.println("Cat meows");
    }
}

public class TestPolymorphism {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        myAnimal.sound(); // 출력: Dog barks
        
        myAnimal = new Cat();
        myAnimal.sound(); // 출력: Cat meows
    }
}


  여기서 ‘Animal’ 클래스의 ‘sound()’ 메소드는 ‘Dog’ 와 Cat 클래스에서 오버라이딩되었습니다.
    
      ‘myAnimal’ 참조 변수는 ‘Animal’ 타입이지만, 참조하는 객체의 실제 타입에 따라 적절한 ‘sound()’ 메소드가 호출됩니다.
    
  


1.6 다형성의 장점.

  유연성 : 다형성을 사용하면 프로그램을 더 유연하게 설계할 수 있습니다.
    
      예를 들어, 다양한 지식 클래스의 객체들을 부모 클래스 타입의 컬렉션에 저장하고, 각 객체에 대해 공통된 인터페이스를 통해 작업을 수행할 수 있습니다.
    
  
  코드 재사용과 유지 보수의 향상 : 공통 인터페이스를 사용함으로써 코드를 재사용하고, 새로운 클래스 타입을 추가하거나 기존 클래스를 수정할 때 유지 보수가 용이해집니다.


📝 정리.
이렇게 다형성은 객체 지향 프로그래밍의 중요한 특성 중 하나로, 프로그램의 다양한 부분에서 유용하게 활용됩니다.



2. instanceof
자바 프로그래밍에서 ‘instanceof’ 연산자는 특정 객체가 지정한 타입의 인스턴스인지를 검사하는 데 사용됩니다.
이 연산자는 객체의 타입을 확인할 때 유용하게 쓰이며, 주로 객체의 실제 타입을 판별하여 안전하게 형 변환을 하기 전이나 특정 타입에 따른 조건 분기를 실행할 때 사용됩니다.

2.1 instanceof 연산자의 사용법.
‘instanceof’ 는 구 개의 피 연산자를 비교합니다.

  왼쪽 피연산자는 객체를 나타내며, 오른쪽 피연산자는 타입(클래스나 인터페이스)을 나타냅니다.
  연산의 결과는 불리언 값입니다.
    
      만약 왼쪽 피연산자가 오른쪽 피연산자가 지정하는 타입의 인스턴스면 ‘true’ 를, 그렇지 않으면 ‘false’ 를 반환합니다.
    
  


기본 구조
if (object instanceof ClassName) {
    // 조건이 참일 때 실행될 코드
}


예시
class Animal {}
class Dog extends Animal {}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Dog dog = new Dog();
        Animal animalDog = new Dog();
        
        System.out.println(animal instanceof Animal); // true
        System.out.println(dog instanceof Animal); // true
        System.out.println(animalDog instanceof Animal); // true
        System.out.println(animal instanceof Dog); // false
    }
}



  이 예시에서 ‘dog instanceof Animal’ 은 ‘true’ 를 반환합니다.
    
      왜냐하면 ‘Dog’ 클래스가 ‘Animal’ 클래스의 서브클래스이기 때문입니다.
      하지만 ‘animal instanceof Dog’ 은 ‘false’ 를 반환하는데, 이는 ‘Animal’ 인스턴스가 ‘Dog’ 타입이 아니기 때문입니다.
    
  


2.2 instanceof의 주의점

  1. null 검사 : ‘instanceof’ 는 객체 참조가 ‘null’ 일 때 항상 ‘false’ 를 반환합니다.
    
      따라서 ‘null’ 값에 대한 추가적인 검사 없이도 안전하게 사용할 수 있습니다.
    
  
  2. 다운캐스팅 검증 : 객체를 하위 클래스 타입으로 다운캐스팅하기 전에 ‘instanceof’ 를 사용하여 해당 객체가 실제로 해당 하위 클래스의 인스턴스인지를 확인하는 것이 안전합니다.
    
      이를 통해 ‘ClassCastException’ 을 예발할 수 있습니다.
    
  
  3. 인터페이스 검사 : ‘instanceof’ 는 클래스 뿐만 아니라 인터페이스 타입에 대해서도 사용할 수 있습니다. 객체가 특정 인터페이스를 구현하는지 여부를 검사할 수 있습니다.


📝 정리.
‘instanceof’ 는 다형성을 사용하는 객체 지향 프로그램에서 객체의 타입을 안전하게 확인하고, 타입에 맞는 적절한 동작을 수행하도록 도와주는 중요한 도구입니다.



3. 업캐스팅(Upcasting).
자바 프로그래밍에서 업캐스팅(Upcasting)은 서브클래스의 객체를 슈퍼클래스 타입의 참조로 변환하는 과정을 말합니다.
이는 일반적으로 자동으로 수행되며, 명시적으로 타입을 지정할 필요가 없습니다.
업캐스팅은 객체 지향 프로그래밍의 다형성을 활용하는 데 핵심적인 역할을 합니다.

3.1 업캐스팅의 특징과 이점.

  1. 자동 형 변환 : 자바에서는 서브클래스의 객체를 슈퍼클래스 타입의 탐조 변수에 할당할 때 자동으로 업캐스팅이 발생합니다.
  2. 안전성 : 업캐스팅은 항상 안전하며, 데이터 손실이나 오류 없이 수행됩니다. 이는 서브클래스가 슈퍼클래스의 모든 특성을 상속받기 때문입니다.
  3. 다형적 행동 : 업캐스팅을 통해 서브클래스의 객체들을 슈퍼클래스 타입으로 다룰 수 있어, 다양한 타입의 객체들을 일관된 방식으로 처리할 수 있습니다. 이를 통해 코드의 유연성과 재사용성이 향상됩니다.


3.2 예시.
아래는 업캐스팅을 사용한 자바 코드 예시입니다.
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        Animal myAnimal = myDog; // Dog 객체를 Animal 타입으로 업캐스팅
        
        myAnimal.eat(); // 호출 가능
        // myAnimal.bark(); // 컴파일 에러, Animal 타입은 bark 메소드를 알지 못함
    }
}



  이 예시에서 ‘Dog’ 객체가 ‘Animal’ 타입으로 업캐스팅 되었습니다.
    
      ‘myAnimal’ 변수는 ‘Animal’ 클래스의 메소드만 호출할 수 있으며, ‘Dog’ 클래스의 ‘bark()’ 메소드는 호출할 수 없습니다.
    
  


3.3 업캐스팅 후의 제한사항.
업캐스팅을 한 후에는 원래 서브클래스의 특정 메소드나 속성에 접근할 수 없게 됩니다.
즉, 업캐스팅된 객체는 슈퍼클래스의 필드와 메소드만 사용할 수 있으며, 추가된 서브클래스의 특성은 사용할 수 없습니다.
이는 다형성의 한 예로서, 슈퍼 클래스 타입을 통해 다양한 서브클래스의 객체들을 통합적으로 다룰 수 있도록 해주며, 프로그램을 더 유연하고 확장 가능하게 만듭니다.



4. 다운캐스팅(Downcasting).
자바 프로그래밍에서 다운캐스팅(Downcasting)은 슈퍼클래스 타입의 객체 참조를 서브클래스 타입의 참조로 변환하는 과정을 말합니다.
다운캐스팅은 업캐스팅의 반대 과정으로, 업캐스팅된 객체를 다시 원래의 서브클래스 타입으로 변환할 때 사용됩니다.
다운캐스팅은 명시적으로 수행되어야 하며, 자바에서는 이 과정이 자동으로 이루어지지 않습니다.

4.1 다운캐스팅의 필요성.
업캐스팅을 통해 객체가 슈퍼클래스 타입으로 변환되면, 해당 객체는 슈퍼클래스의 메소드와 필드만 접근 가능합니다.
서브클래스에만 있는 메소드나 필드에 접근하려면 다운캐스팅을 사용하여 해당 객체를 다시 서브클래스 타입으로 변환해야 합니다.

4.2 다운캐스팅의 사용법과 주의사항.
다운캐스팅은 타입 캐스팅 연산자를 사용하여 수행되며, 반드시 ‘instanceof’ 연산자로 타입 체크를 먼저 수행하는 것이 안전합니다.
이는 변환하려는 객체가 실제로 해당 서브클래스의 인스턴스인지 확인하여 ‘ClassCastExecption’ 을 방지하기 위함입니다.

4.3 예시.
다운캐스팅을 사용하는 자바 코드 예시입니다.
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // 업캐스팅
        myAnimal.eat();
        
        // 다운캐스팅 전에 instanceof로 체크
        if (myAnimal instanceof Dog) {
            Dog myDog = (Dog) myAnimal; // 다운캐스팅
            myDog.bark(); // 이제 서브클래스의 메소드 호출 가능
        }
    }
}



  이 예시에서 ‘Animal’ 타입의 ‘myAnimal’ 객체는 ‘Dog’ 클래스의 인스턴스입니다.
    
      ‘myAnimal’ 을 ‘Dog’ 타입으로 다운캐스팅하여 ‘Dog’ 클래스의 ‘bark()’ 메소드에 접근할 수 있습니다.
      다운캐스팅을 수행하기 전에 ‘instanceof’ 를 사용해 ‘myAnimal’ 이 실제로 ‘Dog’ 의 인스턴스인지 확인함으로써 안정을 확보합니다.
    
  


4.4 주의사항.

  다운캐스팅은 객체의 실제 타입이 캐스팅하려는 클래스 타입과 일치할 때만 안전하게 수행됩니다.
  잘못된 다운캐스팅은 런타임에 ‘ClassCastException’ 을 발생시킬 수 있습니다.


📝 정리.
다운캐스팅은 특정 상황에서 필수적이며, 객체의 모든 기능을 활용하기 위해 사용되지만, 항상 타입 검사를 수행하고 신중하게 사용해야 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-10-abstractClass.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-10-abstractClass.html"><h1 class="title_post">☕️[Java] 추상클래스</h1></a>
                        <a href="/Backend/Java/2024-05-10-abstractClass.html" class="txt_post">
                            1️⃣ 추상클래스.
추상 클래스가 무엇인지 설명할 수 있음
abstract를 이용하여 추상 클래스 구현

1. 추상 메소드(Abstract Method)
자바 프로그래밍에서 추상 메소드(abstract method)는 선언만 있고 구현은 없는 메소드입니다.
이러한 메소드는 추상 클래스(abstract class)나 인터페이스(interface) 내부에서 선언될 수 있으며, 구체적인 행동은 하위 클래스에서 구현됩니다.

추상 메소드를 사용하는 주된 목적은 하위 클래스가 특정 메소드를 반드시 구현하도록 강제하는 것입니다.
이는 코드의 일관성을 유지하고, 다형성을 통한 유연한 프로그래밍 설계를 가능하게 합니다.

1.2 추상 메소드의 특징.

  선언만 있고 구현이 없음 : 메소드 본체가 없으며, 메소드 선언은 세미콜론(’;’) 으로 끝납니다.
  하위 클래스에서의 구현 필수 : 추상 메소드를 포함하는 클래스를 상속받는 모든 하위 클래스는 해당 메소드를 구현해야만 인스턴스 생성이 가능합니다.
  ‘abstract’ 키워드 사용 : 메소드 앞에 ‘abstract’ 키워드를 명시하여 추상 메소드임을 표시합니다.


1.3 추상 메소드 예시
다음은 추상 클래스와 추상 메소드의 간단한 예시입니다.
abstract class Animal {
    // 추상 메소드
    abstract void makeSound();
    
    void breathe() {
        System.out.println("Btrathing...");
    }
}

class Dog extends Animal {
    // 추상 메소드 구현
    void makeSound() {
        System.out.println("Bark!");
    }
}

class Cat extends Animal {
    // 추상 메소드 구현
    void makeSound() {
        System.out.println("Meow!");
    }
}



  위 예에서 ‘Animal’ 클래스는 ‘makeSound’ 라는 추상 메소드를 포함하고 있습니다.
  ‘Dog’ 와 ‘Cat’ 클래스는 ‘Animal’ 클래스를 상속받고 ‘makeSound’ 메소드를 각각 다르게 구현하고 있습니다.
    
      이는 다형성의 좋은 예로, ‘Animal’ 타입의 참조를 사용하여 각각의 하위 클래스 객체를 다룰 때 동일한 메소드(‘makeSound’)를 호출하더라도 서로 다른 행동(개는 짖고, 고양이는 울음)을 보여줍니다.
    
  


1.4 결론.
추상 메소드는 프로그램의 확장성과 유지보수성을 향상시키는 객체 지향 설계의 핵심 요소입니다.
다양한 상황에 맞춰 동일한 인터페이스에 여러 구현을 제공할 수 있어 유연한 코드 작성이 가능합니다.



2. 추상 클래스(abstract class)
자바에서 추상 클래스(abstract class)는 완전하지 않은 클래스로, 추상 클래스 자체로는 인스턴스를 생성할 수 없습니다.
추상 클래스의 주요 목적은 다른 클래스들의 기본이 되는 클래스를 제공하여 코드의 재사용성을 높이고, 일관된 설계를 유도하는 것입니다.
추상 클래스는 하나 이상의 추상 메소드를 포함할 수 있으며, 또한 구현된 메소드도 포함할 수 있습니다.

2.1 추상 클래스의 특징.

  1. 인스턴스 생성 불가 : 추상 클래스는 직접적으로 인스턴스를 생성할 수 없습니다. 반드시 상속을 통해 그 기능을 확장하고 구체적인 클래스에서 인스턴스를 생성해야 합니다.
  2. 추상 메소드 포함 가능 : 추상 클래스는 하나 이상의 메소드를 포함할 수 있습니다. 추상 메소드는 선언만 있고 구현은 없으며, 이를 상속받은 구체적인 클래스에서 구현해야 합니다.
  3. 구현된 메소드 포함 가능 : 추상 클래스는 구현된 메소드도 포함할 수 있어, 자식 클래스들이 이 메소드를 재사용하거나 오버라이드 할 수 있습니다.
  4. 생성자 및 필드 포함 가능 : 추상 클래스는 자신의 생성자와 필드(변수)를 가질 수 있으며, 이는 상속받은 클래스에서 사용할 수 있습니다.


2.2 추상 클래스의 사용 예시.
abstract class Animal {
    abstract void makeSound();
    
    void eat() {
        System.out.println("This animal is eating.");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark!");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow!");
    }
}



  이 예에서 ‘Animal’ 은 추상 클래스로, ‘makeSound()’ 메소드를 추상 메소드로 포함하고 있습니다.
    
      ‘Dog’ 와 ‘Cat’ 은 ‘Animal’ 클래스를 상속받아 ‘makeSound()’ 메소드를 각각 구현합니다.
      추상 클래스 ‘Animal’ 의 ‘eat()’ 메소드는 모든 동물이 공통적으로 사용할 수 있는 구현된 메소드입니다.
    
  


2.3 결론.
추상 클래스는 공통적인 특징을 가진 클래스들 사이의 일반적인 행동을 정의하고, 이를 상속받는 구체적인 클래스들이 이를 구현하도록 하는 데에 주로 사용됩니다.

이를 통해 코드의 재사용성과 유지보수성을 향상시키며, 객체 지향 설계의 일관성과 안정성을 보장할 수 있습니다.



3. 익명 클래스(anonymous class).
자바에서 익명 클래스(anonymous class)는 이름이 없는 클래스입니다.

이들은 주로 일회성 사용 목적으로 설계되며, 인터페이스나 추상 클래스를 간편하게 구현하거나, 기존 클래스를 임시로 확장하기 위해 사용됩니다.

익명 클래스는 일반적으로 이벤트 리스너나 작은 콜백 객체 같이 간단한 기능을 수행하는 데에 활용됩니다.

3.1 익명 클래스의 특징.

  1. 이름이 없음 : 익명 클래스는 이름을 가지지 않습니다. 인스턴스 생성 시점에 정의됩니다.
  2. 즉석에서 정의 및 사용 : 익명 클래스는 즉석에서 정의되어 바로 인스턴스가 생성됩니다. 보통 이들은 한 번만 사용되고 재사용되지 않습니다.
  3. 상속 및 구현 : 익명 클래스는 상쉬 클래스를 상속하거나 인터페이스를 구현할 수 있습니다. 그러나 다중 상속은 지원하지 않습니다.
  4. 오직 하나의 인스턴스만 생성 가능 : 익명 클래스로부터 직접적으로 두 개 이상의 객체를 생성할 수는 없습니다. 다시 사용하려면 클래스 정의를 반복해야 합니다.
  5. 지역 클래스 비슷 : 지역 변수처럼 동작하여 주변 스코프의 변수를 참조할 수 있습니다. 자바 8 이전에는 final 변수만 참조 가능했으나, 자바 8부터는 effectively final(명시적으로 final로 선언되지 않았어도 값이 변경되지 않는 변수) 변수도 참조할 수 있습니다.


3.2 익명 클래스의 사용 예.
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        System.out.println("버튼이 클릭되었습니다!");
    }
});


  위 예제에서 ‘ActionListener’ 인터페이스는 익명 클래스를 통해 구현되었습니다.
    
      ‘button.addActionListener’ 메소드에 직접 전달되면서 버튼 클릭 시 “버튼이 클릭되었습니다!”를 출력하는 ‘actionPerformed’ 메소드를 포함하고 있습니다.
    
  


3.3 결론.
익명 클래스는 특정 인터페이스나 상위 클래스의 메소드를 구현하거나 오버라이드할 때 사용됩니다.
짧고 간단한 기능을 구현하는 데 유용하며, 코드의 간결성을 유지할 수 있게 도와줍니다.
하지만 복잡한 로직이나 반복적으로 사용될 기능에 대해서는 일반 클래스나 지역 클래스를 사용하는 것이 더 적합할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-10</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-09-Inheritance.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-09-Inheritance.html"><h1 class="title_post">☕️[Java] 상속</h1></a>
                        <a href="/Backend/Java/2024-05-09-Inheritance.html" class="txt_post">
                            1️⃣ 상속.



1. 상속(Inheritance)
자바 프로그래밍에서의 상속(Inheritance)은 한 클래스가 다른 클래스의 속성과 메소드를 물려받는 기능을 말합니다.

상속을 사용하면 기존 코드를 재사용하고 확장하는 것이 용이해져, 소프트웨어의 설계와 유지 보수가 효율적으로 이루어질 수 있습니다.

1.2 상속의 주요 개념.

  1. 슈퍼클래스(부모 클래스) : 기능이 상속되는 클래스입니다.
    
      예를 들어, ‘Vehicle’ 클래스가 있을 때 클래스의 속성(예: 속도)과 메소드(예: start, stop)를 다른 클래스가 상속받을 수 있습니다.
    
  
  2. 서브클래스(자식 클래스) : 슈퍼클래스의 속성과 메소드를 상속받는 클래스입니다.
    
      서브클래스는 메소드를 그대로 사용할 수도 있고, 필요에 따라 재정의(오버라이드)할 수도 있습니다.
        
          예를 들어, ‘Car’ 클래스가 ‘Vehicle’ 클래스를 상속받는 경우, ‘Car’ 는 ‘Vehicle’ 의 모든 속성과 메소드를 사용할 수 있으며 추가적인 기능(예: 4륜 구동 기능)을 더할 수 있습니다.
        
      
    
  
  3. 메소드 오버라이딩(Method Overriding) : 서브클래스가 슈퍼클래스에서 상속받은 메소드를 재정의하여 사용하는 것 입니다.
    
      서브클래스는 상속받은 메소드를 자신의 필요에 맞게 변경할 수 있습니다.
    
  
  4. 생성자 상속 : 자바에서 생성자는 상속되지 않습니다. 서브클래스의 생성자가 호출될 때, 슈퍼클래스의 생성자도 자동으로 호출되어야 하는데, 이는 ‘super()’ 키워드를 통해 명시적으로 호출해야 합니다.


📝 정리.
상속을 사용하면 코드의 중복을 줄이고, 각 클래스의 기능을 명확하게 구분지어 설계할 수 있어 프로그램 전체의 구조가 개선됩니다.





class 자식 클래스명 extends 부모 클래스명 { // 다중 상속 불가능
    필드;
    메소드;
    ...
}


2. 상속과 접근제어자와의 관계.
자바에서 상속과 접근 제어자(Access modifiers)는 클래스와 클래스 멤버(필드, 메소드)의 접근성을 결정하는 데 중요한 역할을 합니다.
접근 제어자는 클래스의 데이터를 보호하고, 코드의 유지 보수를 용이하게 하며, 외부로부터의 불필요한 접근을 막는 기능을 합니다.

상속에서 접근 제어자는 어떤 멤버가 서브클래스에게 상속될 수 있는지, 그리고 상속받은 멤버를 서브클래스가 어떻게 활용할 수 있는지 결정짓는 요소입니다.

2.1 주요 네 가지 접근 제어자.

  1. private : 멤버가 선언된 클래스 내에서만 접근 가능합니다.
    
      ‘private’ 접근 제어자가 지정된 멤버는 상속되지 않습니다.
    
  
  2. default(package-private) : 접근 제어자를 명시하지 않으면, 기본적으로 ‘default’ 접근이 적용됩니다.
    
      이러한 멤버들은 같은 패키지 내의 다른 클래스에서 접근할 수 있지만, 다른 패키지의 서브클래스에서는 접근할 수 없습니다.
    
  
  3. protected : ‘protected’ 멤버는 같은 패키지 내의 모든 클래스와 다른 패키지의 서브클래스에서 접근할 수 있습니다.
    
      이 접근 제어자는 상속을 사용할 때 특히 유용하며, 서브클래스가 슈퍼클래스의 멤버를 활용하거나 수정할 수 있게 합니다.
    
  
  4, public : ‘public’ 멤버는 모든 클래스에서 접근할 수 있습니다.
    
      상속과 관련하여, ‘public’ 멤버는 서브클래스에 의해 자유롭게 상속되고 사용될 수 있습니다.
    
  


📝 정리.

  상속과 접근 제어자의 관계에서 중요한 점은, 서브클래스가 상속받은 멤버에 접근할 수 있는 권한은 슈퍼클래스에서 해당 멤버에 지정된 접근 제어자에 의해 결정된다는 것 입니다.
    
      예를 들어, 슈퍼클래스에서 ‘protected’ 로 선언된 메소드는 서브클래스에서 접근 가능하고 필요에 따라 오버라이딩할 수 있지만, ‘private’ 으로 선언된 메소드는 서브클래스에서 직접접으로 접근하거나 사용할 수 없습니다.
        
          이러한 제한은 객체 지향 프로그래밍에서 캡슐화와 정보 은닉을 강화하는 데 도움을 줍니다.
        
      
    
  




3. super와 super().

자바에서 ‘super’ 키워드와 ‘super()’ 생성자 호출은 상속을 사용할 때 매우 중요한 역할을 합니다.
이들은 서브클래스가 슈퍼클래스와 상호작용할 수 있게 해 줍니다.

3.1 super와 super() 키워드의 사용 방식.

3.1.1 super 키워드.

  ‘super’ 키워드는 슈퍼 클래스의 필드나 메소드에 접근할 때 사용됩니다.
    
      서브클래스에서 메소드를 어버라이드 했을 때, 슈퍼클래스의 버전을 호출하고 싶은 경우에 유용하게 사용할 수 있습니다.
      이는 슈퍼클래스의 구현을 활용하면서 추가적인 기능을 서브클래스에 구현할 때 필요합니다.
        
          예를 들어, 슈퍼클래스 ‘Vehicle’ 의 메소드 ‘start()’ 를 서브클래스 ‘Car’ 에서 오버라이드한 후, ‘Car’ 의 ‘start()’ 메소드에서 ‘super.start()’ 를 호출하면, ‘Vehicle’ 클래스의 ‘start()’ 메소드가 실행됩니다.
        
      
    
  


3.1.2 super() 생성자 호출.

  ‘super()’ 는 서브클래스의 생성자에서 슈퍼클래스의 생성자를 호출할 때 사용됩니다.
    
      자바에서는 모든 클래스가 생성자를 가지며, 서브클래스의 생성자가 호출될 때 슈퍼클래스의 생성자도 자동으로 호출됩니다.
      명시적으로 슈퍼클래스의 생성자를 호출하고자 할 때 ‘super()’ 를 사용합니다.
    
  
  이 호출은 서브클래스의 생성자의 첫 번째 명령어로 위치해야 합니다.
    
      슈퍼클래스의 생성자를 호출함으로써, 슈퍼 클래스의 인스턴스 변수들이 적절히 초기화될 수 있습니다.
    
  
  예를 들어, 슈퍼클래스 ‘Vehicle’ 에 ‘Vehicle(int speed)’ 라는 생성자가 있고, 서브클래스 ‘Car’ 에서 이를 상속 받을 때, ‘Car’ 의 생성자에서 ‘super(100)’ 을 호출하면 ‘Vehicle’ 의 생성자가 호출죄어 ‘speed’ 변수가 ‘100’ 으로 초기화됩니다.


📝 정리.
이 두 사용법은 객체지향 프로그래밍에서 클래스의 계층을 통해 기능을 확장하고 관리하는 데 필수적입니다.
‘super’ 의 사용은 상속 관계에 있는 클래스 간의 코드를 재사용하고, 유지 관리를 쉽게 하며, 다형성을 구현하는 데 중요한 역할을 합니다.



4. 오버라이딩(Overriding)
자바 프로그래밍에서 오버라이딩(Overriding)은 서브클래스가 상속받은 슈퍼클래스의 메소드를 자신의 요구에 맞게 재정의하는 과정을 말합니다.

오버라이딩은 객체 지향 프로그래밍의 핵심 개념 중 하나로, 다형성을 가능하게 하며, 상속 받은 메소드를 서브클래스에서 새로운 방식으로 구현할 수 있도록 해줍니다.

4.1 오버라이딩 규칙.
오버라이딩을 할 때는 몇 가지 규칙을 따라야 합니다.


  1. 메소드 이름과 시그니처 일치 : 오버라이딩할 메소드는 슈퍼클래스의 메소드와 동일한 이름, 매개변수 목록, 반환 타입을 가져야 합니다.
  2. 접근 제어 : 오버라이딩하는 메소드는 슈퍼클래스의 메소드보다 더 제한적인 접근 제어를 가질 수 없습니다.
    
      예를 들어, 슈퍼클래스의 메소드가 ‘public’ 이라면 서브클래스의 오버라이딩 메소드도 적어도 ‘public’ 이어야 합니다.
    
  
  3. 반환 타입 : 오버라이딩하는 메소드의 반환 타입은 슈퍼클래스의 메소드 반환 타입과 같거나 그 하위 타입이어야 합니다.(이것은 공변 반환 타입이라고 함.)


4.2 오버라이딩의 예.
슈퍼클래스 ‘Animal’ 에 다음과 같은 메소드가 있다고 가정해 봅시다.
public class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
}


이제 ‘Dog’ 클래스가 ‘Animal’ 클래스를 상속받고 ‘makeSound()’ 메소드를 오버라이드하여 다음과 같이 구현할 수 있습니다.
public class Dog extends Animal {
    @Override // 이 어노테이션은 선택적이지만, 오버라이딩임을 명시적으로 나타냅니다.
    public void makeSound() {
        System.out.println("Dog barks");
    }
}



  이 예에서 ‘Dog’ 클래스의 ‘makeSound()’ 메소드는 ‘Animal’ 의 makeSound() 메소드를 오버라이드하여 “Dog barks”를 출력하도록 재정의합니다.


4.3 오버라이딩의 중요성.
오버라이딩은 다음과 같은 이점을 제공합니다.

  유연성 : 같은 메소드 호출이지만, 다양한 서브클래스에서 서로 다른 동작을 구현할 수 있습니다.
  재사용성 : 기존의 코드를 변경하지 않고도, 상속받은 메소드를 새로운 요구에 맞게 확장할 수 있습니다.
  유지보수 : 코드의 중복을 줄이고, 유지보수를 간편하게 할 수 있습니다.


📝 정리.
오버라이딩은 프로그램의 다형성을 구현하는 데 필수적인 기능으로, 상속받은 메소드를 사용하는 대신 서브클래스에 맞게 특화된 기능을 구현할 수 있도록 합니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-08-ClassesAndObjects-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-08-ClassesAndObjects-2.html"><h1 class="title_post">☕️[Java] 클래스와 객체(2)</h1></a>
                        <a href="/Backend/Java/2024-05-08-ClassesAndObjects-2.html" class="txt_post">
                            1️⃣ 클래스와 객체(2)

1. 오버로딩(Overloading).
자바 프로그래밍에서 오버로딩(Overloading)은 같은 클래스 내에서 메소드 이름이 같지만 매개변수의 타입이나 개수가 다른 여러 메소드를 정의하는 것을 의미합니다.

오버로딩을 사용하면 같은 기능을 하는 메소드라도 다양한 입력에 대응하여 유연하게 메소드를 호출할 수 있습니다.

오버로딩은 메소드만 가능하며, 생성자에도 적용될 수 있습니다.

1.2. 오버로딩의 규칙.

  1. 메소드 이름이 같아야 합니다 : 오버로딩된 메소드들은 같은 이름을 공유합니다.
  2. 매개변수 목록이 달라야 합니다 : 매개변수의 개수나 타입, 혹은 그 순서가 달라야 합니다. 매개변수의 차이를 통해 자바 컴파일러는 호출할 적절한 메소드를 결정합니다.
  3. 반환 타입은 오버로딩을 구분하는 데 사용되지 않습니다 : 오버로딩된 메소드는 반환 타입이 다르더라도, 이는 오버로딩을 구분하는 데 사용되지 않습니다.
    
      즉, 반환 타입만 다른 메소드는 오버로딩이 아닙니다.
    
  
  4. 접근 제어자와 예외는 오버로딩을 구분하는 데 사용되지 않습니다 : 이 역시 메소드를 구별하는 데 사용되지 않습니다.


1.3. 오버로딩의 예.
public class Print {
    // 오버로딩 예제: 같은 메소드 이름, 다른 매개변수 타입
    public void display(int a) {
        System.out.println("Integer: " + a);
    }
    
    public void display(String a) {
        System.out.println("String: " + a);
    }
    
    // 오버로딩 예제: 같은 메소드 이름, 다른 매개변수 개수
    public void display(int a, int b) {
        System.out.println("Two integers: " + a + ", " + b);
    }
    
    // 오버로딩 예제: 같은 메소드 이름, 매개변수의 순서가 다름
    public void display(String a, int b) {
        System.out.println("String and integer: " + a + ", " + b);
    }
}

public class Test {
    public static void main(String[] args) {
        Print prt = new Print();
        prt.display(1); // 출력: Integer: 1
        prt.display("Hello"); // 출력: String: Hello
        prt.display(1, 2); // 출력: Two integers: 1, 2
        prt.display("Age", 30); // 출력: String and integer: Age, 30
    }
}



  이 예제에서 ‘Print’ 클래스는 ‘display’ 라는 메소드를 여러 번 오버로딩했습니다.
    
      매개변수의 타입, 개수, 순서에 따라 다른 메소드가 호출됩니다.
        
          이를 통해 다양한 타입과 개수의 입력을 유연하게 처리할 수 있습니다.
        
      
    
  


📝 정리.
오버로딩을 통해 프로그램의 가독성을 향상시키고, 유사한 기능을 하는 메소드들을 하나의 이름으로 그룹화함으로써 프로그램을 더욱 직관적으로 만들 수 있습니다.

이러한 방식은 프로그래밍의 복잡성을 줄이고, 코드의 유지보수를 용이하게 합니다.



2. 접근제어자(Access Modifiers).
자바 프로그래밍에서 접근 재어자(Access Modifiers)는 클래스, 메서드, 변수 등과 같은 멤버들에 대한 접근 권한을 제어하는 키워드입니다.

이러한 접근 제어자를 사용함으로써 클래스의 캡슐화를 강화할 수 있으며, 객체의 데이터와 메서드를 외부에서 직접접으로 접근하거나 수정하는 것을 제한할 수 있습니다.

접근 제어자는 클래스의 멤버(변수, 메서드, 생성자 등)와 클래스 자체에 적용될 수 있습니다.

2.1 자바에서 사용하는 주요 접근 제어자


  1. public : 어떤 클래스에서든 접근할 수 있도록 허용합니다.
    
      public으로 선언됩 멤버는 어디서든 접근이 가능합니다.
    
  




  2. protected : 같은 패키지 내의 클래스 또는 다른 패키지의 서브 클래스에서 접근할 수 있습니다.




  3. default(package-private) : 접근 제어자를 명시하지 않은 경우, 같은 패키지 냐의 클래스들만 접근할 수 있습니다. 이를 종종 package-private라고도 합니다.




  private : 해당 멤보를 선언한 클래스 내에서만 접근할 수 있습니다. 외부 클래스에서는 접근할 수 없어, 클래스 내부 구현을 숨기는 데 유용합니다.


2.2 접근 제어자의 사용 예제.

public class AccessExample {
    public int publicVar = 10; // 어디서든 접근 가능
    protected int protectedVar = 20; // 같은 패키지 또는 상속 받은 클래스에서 접근 가능
    int defaultVar = 30; // 같은 패키지 내에서만 접근 가능
    private int privateVar = 40; // 이 클래스 내에서만 접근 가능
    
    public void show() {
        System.out.println("publicVar: " + publicVar);
        System.out.println("protectedVar: " + pretectedVar);
        System.out.println("defaultVar: " + defaultVar);
        System.out.println("privateVar: " + privateVar);
    }
}

public class Test {
    public static void main(String[] args) {
        AccessExample example = new AccessExample();
        System.out.println(example.publicVar); // 접근 가능
        System.out.println(example.protectedVar); // 다른 패키지에 있지 않은 이상 접근 가능
        System.out.println(example.defaultVar); // 같은 패키지에 있을 경우 접근 가능
        // System.out.println(example.privateVar); // 컴파일 에러 발생, 접근 불가능
        example.show(); // 모든 변수 출력 가능
            
    }
}


  위 예제에서는 다양한 접근 제어자가 적용된 변수들을 선언하고, 이에 대한 접근 가능성을 보여줍니다.
  ‘publicVar’ 은 어디서든 접근할 수 있지만, ‘privateVar’ 는 오직 선언된 클래스 내부에서만 접근할 수 있습니다.
  ‘protectedVar’ 과 ‘defaultVar’ 는 좀 더 제한적인 접근을 허용합니다.


📝 정리.
이렇게 접근 제어자를 통해 자바에서는 데이터 보호 및 캡슐화, 객체의 정확한 사용을 보장하여 프로그램의 안정성과 유지보수성을 향상시킬 수 있습니다.



3. static 키워드.
자바 프로그래밍에서 ‘static’ 키워드는 클래스의 멤버(필드, 메서드, 블록 또는 내부 클래스)를 클래스 레벨에 소속 시키는 역할을 합니다.

이는 특정 인스턴스에 속하기보다는 클래스 자체에 속한다는 의미입니다.

‘static’ 멤버는 클래스의 모든 인스턴스에 의해 공유되며, 클래스가 메모리에 로드될 때 생성되고, 클래스가 언로드될 때 소멸됩니다.

3.1 static의 특징.

  1. 클래스 레벨에서 공유 : ‘static’ 필드는 클래스의 모든 인스턴스 간에 공유됩니다.
    
      이는 특정 데이터를 모든 객체가 공유해야 할 필요가 있을 때 유용합니다.
    
  
  2. 인스턴스 생성 없이 접근 기는 : ‘static’ 메서드나 필드는 객체의 인스턴스를 생성하지 않고도 클래스 이름을 통해 직접 접근할 수 있습니다.
  3. 정적 초기화 블록 : ‘static’ 키워드를 사용한 블록(정적 블록)은 클래스가 처음 메모리에 로그 될 때 단 한 번 실행됩니다.
    
      이는 ‘static’ 필드의 초기화에 사용할 수 있습니다.
    
  


3.2 static 필드와 메서드 사용 예.
public class Calculator {
    // 정적 필드
    public static int calculatorCount = 0;
    
    // 정적 블록
    static {
        System.out.println("Calculator 클래스 로딩!");
    }
    
    // 생성자
    public Calculator() {
        calculatorCount++; // 생성될 때마다 계산기의 수를 증가
    }
    
    // 정적 메서드
    public static int add(int a, int b) {
        return a + b;
    }
}

public class Test {
    public static void main(String[] args) {
        Calculator c1 = new Calculator();
        Calculator c2 = new Calculator();
        
        System.out.println("Created Calculators: " + Calculator.calculatorCount); // 2 출력
        System.out.println("Sum: " + Calculator.add(5,3)); // 8 출력
    }
}



  이 예제에서는 ‘Calculator’ 클래스의 인스턴스 생성 횟수를 추적하는 ‘static’ 필드 ‘calculatorCount’ 와 정적 메서드 ‘add’ 를 사용합니다.
    
      ‘calculatorCount’ 는 ‘Calculator’ 의 모든 인스턴스에 의해 공유되며, ‘add’ 메서드는 인스턴스를 생성하지 않고도 호출할 수 있습니다.
    
  


3.3 static 사용 시 주의점

  ‘static’ 메서드 내에서는 인스턴스 변수나 메서드를 직접 사용할 수 없습니다.
  ‘static’ 은 남용하면 객체지향의 원칙을 해칠 수 있습니다.
    
      예를 들어, 객체 간의 상태 공유가 과도하게 이루어져 객체 간의 결합도가 높아질 수 있습니다.
    
  
  ‘static’ 변수는 프로그램의 실행이 끝날 때까지 메모리에 남아 있으므로 메모리 사용에 주의해야 합니다.


3.4 static 메소드와 static 변수와의 관계성.
자바 프로그래밍에서 ‘static’ 메소드와 ‘static’ 변수는 두 가지 공통점을 가지고 있습니다.

둘 다 클래스 레벨에서 정의되며, 클래스의 모든 인스턴스 간에 공유됩니다.

이런 공통점 때문에, ‘static’ 메소드는 ‘static’ 변수에 직접 접근할 수 있지만, 일반 인스턴스 변수에는 접근할 수 없습니다.

3.5 static 변수.
‘static’ 변수는 클래스 변수라고도 하며, 특정 클래스의 모든 인스턴스에 의해 공유됩니다.
이 변수는 클래스가 메모리에 로드될 때 생성되고, 클래스가 언로드될 때까지 메모리에 존재합니다.
‘static’ 변수는 특히 클래스의 인스턴스들이 공통적으로 사용해야 하는 데이터를 저장하는데 유용합니다.
예를 들어, 모든 계산기 객체가 공유해야 하는 ‘calculatorCount’ 와 같은 경우에 사용됩니다.

3.6 static 메소드
‘static’ 메소드 역시 클래스 레벨에 정의되며, 이 메소드는 인스턴스 생성 없이 클래스 이름을 통해 직접 호출할 수 있습니다.

‘static’ 메소드는 인스턴스 필드나 메소드에 접근할 수 없습니다.

그 이유는 ‘static’ 메소드가 호출될 때 해당 클래스의 인스턴스가 존재하지 않을 수 있기 때문입니다.
따라서 ‘static’ 메소드는 오로지 ‘static’ 변수나 다른 ‘static’ 메소드에만 접근할 수 있습니다.

3.7 두 요소의 상호작용.
‘static’ 메소드에는 ‘static’ 변수에 자유롭게 접근하고 수정할 수 있습니다.
이는 ‘static’ 변수가 클래스에 속하고 메소드도 클래스 레벨에서 실행되기 때문입니다.
예를 들어, 어떤 클래스의 모든 인스턴스가 사용할 설정 값을 ‘static’ 변수에 저장하고, 이 값을 설정하거나 조회하는 ‘static’ 메소드를 제공할 수 있습니다.

3.8 예제
public class Counter {
    public static int count = 0; // 'static' 변수
    
    public static void increment() { // 'static' 메소드
        count++; // 'static' 변수에 접근하여 값을 증가
    }
    
    public static void displayCount() {
        System.out.println("Count: " + count); // 'static' 변수의 현재 값을 출력
    }
}

public class Test {
    public static void main(String[] args) {
        Counter.increment();
        Counter.increment();
        Countet.displayCount(); // 출력: Count: 2
    }
}



  
    이 예제에서 ‘Counter’ 클래스는 ‘static’ 변수 ‘count’ 를 가지고 있으며, increment 메소드를 통해 이 변수의 값을 증가시키고, ‘displayCount’ 메소드를 통해 값을 출력합니다.
  
  
    모든 ‘Counter’ 객체가 ‘count’ 값을 공유하며, ‘static’ 메소드를 통해 이 값을 조작할 수 있습니다.
  


📝 정리.
‘static’ 은 전역 변수나 전역 메서드와 유사한 효과를 제공하지만, 자바의 객체지향적 특성과 일관성을 유지하기 위해 적절히 사용되어야 합니다.

‘static’ 메소드와 ‘static’ 변수는 클래스 레벨에서 관리되어 클래스의 모든 인스턴스에 의해 공유되는 특성을 가지고 있습니다.

이를 통해 클래스 전체에 영향을 미치는 작업을 수행할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-08</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-07-MultidimensionalArray.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-07-MultidimensionalArray.html"><h1 class="title_post">☕️[Java] 다차원 배열</h1></a>
                        <a href="/Backend/Java/2024-05-07-MultidimensionalArray.html" class="txt_post">
                            1️⃣ 다차원 배열.
자바 프로그래밍에서 다차원 배열이란, 배열의 배열을 의미합니다.
이는 데이터를 행렬이나 그리드 형태로 구성할 수 있게 해주며, 주로 2차원 이상의 데이터 구조를 필요로 할 때 사용됩니다.
가장 흔한 형태는 2차원 배열이지만, 3차원 이상의 배열도 만들 수 있습니다.

1. 2차원 배열.
2차원 배열은 행렬과 비슷하게 생각할 수 있으며, 각 행과 열에 데이터를 저장합니다.

  예를 들어, 숫자로 이루어진 표를 저장하거나 정보를 격자 형태로 관리할 때 유용합니다.


1.2 2차원 배열의 초기화
자바에서 이차원 배열을 초기화하는 방법은 크게 세 가지로 나눌 수 있습니다.
배열을 선언할 때 크기만 지정해 두거나, 선언과 동시에 특정 값을 사용하여 초기화하거나, 나중에 각 요소에 값을 할당할 수 있습니다.

아래는 각 방법에 대한 설명과 예제입니다.

1.1.1 크기만 지정하여 배열 선언하기.
이 방법은 배열의 행과 열의 크기를 지정해 초기화하지만, 배열의 각 요소는 자동으로 기본 값으로 설정됩니다.(예: int의 경우 0).

inu[][] array = new int[3][4]; // 3행 4열의 배열 생성


  이렇게 선언된 배열은 모든 요소가 0으로 초기화됩니다.


1.1.2 선언과 동시에 초기값을 제공하여 배열 초기화하기.
배열을 선언하면서 동시에 초기값을 제공할 수 있습니다.
이 방법은 배열의 내용을 명확히 알고 있을 때 유용합니다.
int[][] array = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
}; // 각 행에 대한 값들을 중괄호로 묶어서 초기화


  이 예제에서 배열은 3행 4열의 구조로, 각 행의 값이 명시적으로 초기화되어 있습니다.


1.1.3 반복문을 사용하여 배열 초기화하기.
반복문을 사용하면 배열의 각 요소를 동적으로 초기화할 수 있습니다.
이 방법은 런타임에 따라 배열 값을 설정해야 할 때 유용합니다.
int[][] array = new int[3][4];
for (int i = 0; i &lt; array.length; i++) {
    for (int j = 0; j &lt; array[i].length; j++) {
        array[i][j] = (i + 1) * (j + 1); // 각 요소를 행 인덱스와 열 인덱스의 곱으로 초기화
    }
}



  이 방법은 배열의 각 위치에 i와 j 인덱스에 의존하는 계산 결과를 저장합니다.


📝 정리.
이 세 가지 방법은 상황에 따라 각기 다른 이점을 제공하므로, 요구 사항에 맞게 선택하여 사용할 수 있습니다.

2. 3차원 배열.
3차원 배열은 데이터를 3차원 공간으로 구성하여 저장합니다.
이는 비디오 게임의 공간 데이터, 과학 실험 데이터 등 복잡한 정보를 구조화하는 데 사용될 수 있습니다.

2.1. 3차원 배열의 초기화.
자바에서 3차원 배열을 초기화하는 방법은 2차원 배열과 유사합니다.
크게 세 가지 방법으로 나눌 수 있습니다.


  크기만 지정하여 선언하기.
  선언과 동시에 구체적인 값으로 초기화하기
  반복문을 사용하여 동적으로 초기화하기


아해는 각 방법에 대한 설명과 예시입니다.

2.1.1. 크기만 지정하여 배열 선언하기.
이 방법은 삼차원 배열의 각 차원의 크기를 지정합니다.
각 요소는 자동으로 기본값으로 설정됩니다.(예: ‘int’ 의 경우 0).

int[][][] array = new int[3][4][5] // 3개의 4x5 행렬을 갖는 삼차원 배열



  이 배열은 3개의 2차원 배열을 가지며, 각 2차원 배열은 4행 5열 구조입니다.


2.1.2. 선언과 동시에 초기값을 제공하여 배열 초기화하기.
삼차원 배열을 선언하면서 바로 값을 지정할 수 있습니다.
이 방법은 각 요소의 초기값을 명확히 알고 있을 때 매우 유용합니다.
int [][][] array = {
    {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15},
        {16, 17, 18, 19, 20}  
    },
    {
        {21, 22, 23, 24, 25},
        {26, 27, 28, 29, 30},
        {31, 32, 33, 34, 35},
        {36, 37, 38, 39, 40}
    },
    {
        {41, 42, 43, 44, 45},
        {46, 47, 48, 49, 50},
        {51, 52, 53, 54, 55},
        {56, 57, 58, 59, 60}
    }
}; // 각 행렬 및 행에 대한 값들을 중괄호로 묶어서 초기화


2.1.3. 반복문을 사용하여 배열 초기화하기
반복문을 사용해 삼차원 배열의 각 요소를 동적으로 초기화할 수 있습니다.
이 방법은 프로그램 실행 중에 배열 값을 설정해야 할 때 매우 유용합니다.
int[][][] array = new int[3][4][5];

for (int i = 0; i &lt; array.length; i++) {
    for (int j = 0; j &lt; array[i].length; j++) {
        for (int k = 0; k &lt; array[i][j].length; k++) {
            array[i][j][k] = (i + 1) * (j + 1) * (k + 1) // 각 요소를 i, j, k 인덱스의 곱으로 초기화
        }
    }
}



  이 예제에서는 각 위치에 해당하는 인덱스의 곱을 저장하여 배열을 초기화하고 있습니다.
    
      이러한 초기화 방법은 특히 배열의 구조가 복잡할 때 배열을 효과적으로 관리할 수 있게 도와줍니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-07-ClassesAndObjects-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-07-ClassesAndObjects-1.html"><h1 class="title_post">☕️[Java] 클래스와 객체(1)</h1></a>
                        <a href="/Backend/Java/2024-05-07-ClassesAndObjects-1.html" class="txt_post">
                            1️⃣ 클래스와 객체(1)

1. 클래스(Class)
자바 프로그래밍 언어에서 클래스는 객체를 생성하기 위한 설계도 혹은 템플릿입니다.
클래스는 객체의 상태를 정의하는 필드(변수)와 객체의 행동을 정의하는 메서드(함수)로 구성됩니다.

클래스를 사용하는 주된 목적은 데이터와 그 데이터를 조작하는 방법들은 하나의 장소에 묶어 관리하기 위함입니다.
이를 통해 데이터 추상화, 캡슐화, 상속, 다형성 등의 객체지향 프로그래밍의 주요 개념들을 구현할 수 있습니다.

1.2 클래스의 구성 요소.

  1. 필드(Field) : 객체의 데이터 또는 상태를 저장하는 변수입니다.
  2. 메서드(Method) : 객체가 수행할 수 있는 행동을 정의한 코드 블록입니다.
    
      메서드는 필드의 값을 처리하거나 다른 메서드를 호출할 수 있습니다.
    
  
  3. 생성자(Constructor) : 클래스로부터 객체를 생성할 때 초기화를 담당하는 특별한 종류의 메서드입니다.
    
      생성자는 클래스 이름과 같은 이름을 가집니다.
    
  


1.3 클래스 예제
자바에서의 간단한 클래스 예제를 살펴보겠습니다.
public class Car {
    // 필드(변수)
    private String color;
    private String model;
    
    // 생성자
    public Car(String color, String model) {
        this.color = color;
        this.model = model;
    }
    
    // 메서드
    public void drive() {
        System.out.println(model + " 색상의 " + color + " 자동차가 주행 중입니다.");
    
    }
}

// 객체 생성 및 사용
public class Test {
    public static void main(String[] args) {
        Car myCar = new Car("레드", "테슬라");
        myCar.drive();
    }
}



  위의 예제에서 ‘Car’ 클래스는 ‘color’와 ‘model’이라는 두 개의 필드를 가지며, 이는 각각 자동차의 색상과 모델을 나타냅니다.
  ‘Car’ 클래스의 객체를 생성할 때는 ‘new’ 키워드와 함께 생성자를 호출하여 초기 상태를 설정합니다.
  ‘drive’ 메서드는 자동차가 주행하고 있음을 시뮬레이션하는 기능을 합니다.


📝 정리.
클래스를 사용함으로써 코드의 재사용성, 관리성 및 확장성이 향상되며, 대규모 소프트웨어 개발에서 필수적인 요소가 됩니다.



2. 객체(Object)와 인스턴스(Instance).
자바 프로그래밍에서 “객체(Object)”와 “인스턴스(Instance)”는 매우 중요한 개념입니다.
이 두 용어는 종종 서로 바꿔 쓰이지만, 각각의 의미에는 약간의 차이가 있습니다.

2.1 객체(Object).
객체는 소프트웨어 세계의 구성 요소로, 실제 세계의 객체를 모방한 것입니다.
객체는 데이터(속성)와 그 데이터를 조작할 수 있는 함수(메서드)를 캡슐화합니다.
객체는 클래스에 정의된 속성과 기능을 실제로 사용할 수 있도록 메모리상에 할당된 구조입니다.
객체의 개념은 클래스의 특성을 실제로 구현하는 것입니다.

2.2 인스턴스(Instance).
인스턴스는 클래스 타입에 따라 생성된 객체를 의미합니다.
예를 들어, ‘Car’ 클래스의 구체적인 객체(예: 빨간색 테슬라 자동차, 파란색 현대 자동차 등)는 모두 ‘Car’ 클래스의 인스턴스입니다.
즉, 인스턴스는 특정 클래스의 구현체입니다.
인스턴스라는 용어는 주로 객체가 메모리에 할당되어 실제로 생성되었음을 강조할 때 사용됩니다.

2.3 객체와 인스턴스의 관계.
간단히 말해, 모든 인스턴스는 객체입니다, 하지만 사용된 맥락에 따라 ‘인스턴스’라는 용어는 그 객체가 특정 클래스의 구현체임을 명시적으로 나타낼 때 사용됩니다.
예를 들어, 우리가 ‘new Car(“blue”, “Hyundai”)’ 를 통해 생성한 객체는 ‘Car’ 클래스의 인스턴스입니다.

2.4 예제 코드.
public class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void speak() {
        System.out.println(name + " makes a noise.");
    }
}

public class Test {
    public static void main(String[] args) {
        // 여기서 'dog'는 Animal 클래스의 객체이자 인스턴스입니다.
        Animal dog = new Animal("Dog");
        dog.speak();
    }
}



  위 예제에서 ‘Animal’ 클래스가 있고, ‘main’ 메서드에서 ‘Animal’ 클래스의 새 객체를 생성합니다.
    
      여기서 ‘dog’ 는 ‘Animal’ 클래스의 인스턴스이며 객체입니다.
        
          ‘dog’ 는 ‘Animal’ 클래스에 정의된 메서드와 필드를 사용할 수 있습니다.
        
      
    
  


📝 정리.
요약하면, 객체는 속성과 메서드를 갖는 소프트웨어의 기본 구성 단위이고, 인스턴스는 그 객체가 특정 클래스의 실제 구현체임을 의미합니다.
이 두 용어는 프로그래밍에서 클래스 기반의 객체를 생성하고 다룰 때 핵심적인 역할을 합니다.

클래스와 객체의 관계를 이해
기본 사용 방법과 생성자 및 this의



3. 메소드(Method).
자바 프로그래밍에서 메소드(Method)는 클래스에 속한 함수로서, 특정 작업을 수행하는 코드 블록입니다.
메소드는 객체의 행동을 정의하며, 클래스 내에서 정의된 데이터나 상태(필드)를 조작하는 데 사용됩니다.

메소드를 통해 객체지향 프로그래밍의 중요한 특징인 캡슐화와 추상화를 구현할 수 있습니다.

3.1 메소드의 주요 특징.

  1. 재사용성 : 메소드는 코드의 재사용성을 증가시킵니다. 한 번 정의된 메소드는 여러 위치에서 호출되어 사용될 수 있습니다.
  2. 모듈성 : 메소드를 사용함으로써 큰 프로그램을 작은 단위로 나누어 관리할 수 있습니다. 이는 코드의 가독성과 유지보수성을 향상시킵니다.
  3. 정보 은닉 : 메소드를 통해 구현 세부사항을 숨기고 사용자에게 필요한 기능만을 제공할 수 있습니다.


3.2 메소드의 구성 요소.

  1. 메소드 이름 : 메소드를 식별하는 데 사용되며, 메소드가 수행하는 작업을 설명하는 명확한 이름을 가집니다.
  2. 매개변수 목록(Parameter List) : 메소드에 전달되는 인자의 타입, 순서, 그리고 개수를 정의합니다. 매개변수는 선택적일 수 있습니다.
  3. 반환 타입 : 메소드가 작업을 수행한 후 반환하는 데이터의 타입입니다. 반환할 데이터가 없으면 ‘void’ 로 지정됩니다.
  4. 메소드 바디 : 실제로 메소드가 수행할 작업을 구현하는 코드 블록입니다.


3.3 예제.
자바에서 간단한 메소드 예제를 보여드리겠습니다.
public class Calculator {
    // 메소드 정의: 두 정수의 합을 반환
    public int add(int num1, int num2) {
        return num1 + num2;
    }
    
    // 메소드 정의: 두 정수의 차를 반환
    public int subtract(int num1, int num2) {
        return num1 - num2;
    }
}

public class Test {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        int result1 = calc.add(5, 3); // 8 반환
        int result2 = calc.subtract(5, 3); // 2 반환
        System.out.println("Addition Result: " + result1);
        System.out.println("Subtraction Result: " + result2);
    }
}



  이 예제에서 ‘Calculator’ 클래스는 두 개의 메소드 ‘add’ 와 ‘subtract’ 를 가지고 있습니다.
    
      각각의 메소드는 두 개의 정수를 받아 그 결과를 반환합니다.
        
          이렇게 메소드를 사용하면 코드를 효율적으로 관리할 수 있으며, 필요에 따라 재사용할 수 있습니다.
        
      
    
  


📝 정리.
메소드는 자바 프로그래밍에서 기능을 모듈화하고 코드의 재사용을 가능하게 하는 핵심 요소입니다.



4. 접근 제어자(Access Modifiers)
자바 프로그래밍에서 접근 제어자(Access Modifiers)는 클래스, 메서드, 변수 등과 같은 멤버들에 대한 접근 권한을 제어하는 키워드입니다.

이러한 접근 제어자를 사용함으로써 클래스의 캡슐화를 강화할 수 있으며, 객체의 데이터와 메서드를 외부에서 직접적으로 접근하거나 수정하는 것을 제한할 수 있습니다.

접근 제어자는 클래스의 멤버(변수, 메서드, 생성자 등)와 클래스 자체에 적용될 수 있습니다.

4.1 자바에서 사용하는 주요 접근 제어자.

  1. public : 어떤 클래스에서든 접근할 수 있도록 허용합니다.
    
      public으로 선언된 멤버는 어디서든 접근이 가능합니다.
    
  
  
    2. protected : 같은 패키지 내의 클래스 또는 다른 패키지의 서브 클래스에서 접근할 수 있습니다.
  
  3. default(package-private) : 접근 제어자를 명시하지 않은 경우, 같은 패키지 내의 클래스들만 접근할 수 있습니다.
    
      이를 종종 package-private라고도 합니다.
    
  
  4. private : 해당 멤버를 선언한 클래스 내에서만 접근할 수 있습니다.
    
      외부 클래스에서는 접근할 수 없어, 클래스 내부 구현을 숨기는 데 유용합니다.
    
  


4.2 접근 제어자의 사용 예제.
public class AccessExample {
    public int publicVar = 10; // 어디서든 접근 가능
    protexted int protectedVar = 20; // 같은 패키지 또는 상속받은 클래스에서 접근 가능
    int defaultVar = 30; // 같은 패키지 내에서만 접근 가능
    private int privateVar = 40; // 이 클래스 내에서만 접근 가능
    
    public void show() {
        System.out.println("publicVar: " + publicVar);
        System.out.println("protectedVar: " + protectedVar);
        System.out.println("defaultVar: " + defaultVar);
        System.out.println("privateVar: " + privateVar);
    }
}

public class Test {
    public static void main(String[] args) {
        AccessExample example = new AccessExample();
        System.out.println(example.publicVar); // 접근 가능
        System.out.println(example.protectedVar); // 다른 패키지에 있지 않은 이상 접근 가능
        System.out.println(example.defaultVar); // 같은 패키지에 있을 경우 접근 가능
        // System.out.println(example.privateVar); // 컴파일 에러 발생, 접근 불가능
        example.show(); // 모든 변수 출력 가능
    }
}



  위 예제에서는 다양한 접근 제어자가 적용된 변수들을 선언하고, 이에 대한 접근 가능성을 보여줍니다.
    
      ‘publicVar’ 은 어디서든 접근할 수 있지만, ‘privateVar’ 는 오직 선언된 클래스 내부에서만 접근할 수 있습니다.
      ‘protectedVar’ 과 ‘defaultVar’ 는 좀 더 제한적인 접근을 허용합니다.
    
  


📝 정리.
이렇게 접근 제어자를 통해 자바에서는 데이터 보호 및 캡슐화, 객체의 정확한 사용을 보장하여 프로그램의 안정성과 유지보수성을 향상시킬 수 있습니다.



5. static 키워드.
자바 프로그래밍에서 ‘static’ 키워드는 특정 필드나 메소드, 또는 중첩 클래스를 클래스의 인스턴스가 아닌 클래스 자체에 소속되게 합니다.

이를 사용함으로써 해당 멤버는 클래스의 모든 인스턴스에 걸쳐 공유되며, 인스턴스 생성 없이 클래스 이름을 통해 직접 접근할 수 있습니다.

5.1 static의 주요 사용 사례.

  1. 정적 필드(Static Fields) : 모든 인스턴스에 의해 공유되는 클래스 변수입니다.
    
      예를 들어, 회사의 모든 직원이 같은 회사 이름을 공유할 때 사용할 수 있습니다.
    
  
  2. 정적 메소드(Static Methods) : 인스턴스 변수에 접근할 필요 없이, 클래스 이름을 통해 직접 호출할 수 있는 메소드입니다.
    
      유틸리티 함수나 핼퍼 함수를 작성할 때 자주 사용됩니다.
    
  
  
    3. 정적 초기화 블록(Static Initialization Blocks) : 클래스가 처음 로딩될 때 한 번 실행되며, 정적 변수를 초기화하는 데 사용됩니다.
  
  4. 정적 중첩 클래스(Static Nested Classes) : 다른 클래스 내부에 위치하면서도 독립적으로 사용될 수 있는 클래스입니다.


5.2 static 키워드의 장점과 단점.
장점.

  메모리 효율성 : static 멤버는 클래스 로드 시 메모리에 한 번만 할당되고 모든 인스턴스가 공유하기 때문에 메모리 사용을 최소화할 수 있습니다.
  편리성 : 객체 생성 없이 바로 접근할 수 있어, 유틸리티 함수 같은 공통 기능 구현에 유용합니다.


단점.

  과도한 사용은 객체지향 원칙에 어긋남 : 객체 간의 결합도가 높아지고, 객체의 상태 관리가 어려워질 수 있습니다.
  테스트가 어려워질 수 있슴 : static 메소드는 오버라이드가 불가능하며, 상태를 공유하기 때문에 병렬 테스트 환경에서 문제를 일으킬 수 있습니다.


5.3 예제.
public class Company {
    // 정적 필드
    public static String companyName = "Global Tech";
    
    // 정적 메소드
    public static void printCompanyName() {
        System.out.println("Company Name: " + companyName);
    }
}

public class Test {
    public static void main(String[] args) {
        // 객체 생성 없이 정적 메소드 호출
        Company.printCompanyName();
    }
}



  이 예제에서 ‘Company’ 클래스에는 정적 필드 ‘companyName’ 과 정적 메소드 ‘printCompanyName()’ 이 있습니다.
    
      ‘main’ 메소드에서는 ‘Company’ 클래스의 객체를 생성하지 않고도 ‘printCompanyName()’ 메소드를 호출하려 회사 이름을 출력합니다.
    
  


📝 정리.
정적 멤버는 클래스와 관련된, 변하지 않는 값이나, 모든 인스턴스가 공유해야 하는 정보를 관리할 때 유용하게 사용됩니다.



6. 생성자(Constructor)
자바 프로그래밍에서 생성자(Constructor)는 클래스로부터 객체가 생성될 때 호출되는 특별한 유형의 메서드입니다.
생성자의 주요 목적은 새로 생성된 객체를 초기화하는 것으로, 객체의 기본 상태를 설정하는 데 사용됩니다.

생성자는 메서드처럼 보일 수 있지만, 리턴 타입이 없고 클래스 이름과 동일한 이름을 가집니다.

6.1 생성자 특징.

  1. 클래스 이름과 동일 : 생성자의 이름은 항상 선언된 클래스의 이름과 동일해야 합니다.
  2. 리턴 타입 없음 : 생성자는 값을 반환하지 않으며, 리턴 타입도 선언하지 않습니다.
  3. 자동 호출 : 객체가 생성될 때 자동으로 호출됩니다.
    
      이는 객체의 필드를 초기화하거나, 객체 생성 시 실행해야 할 다른 시작 루틴을 실행하는 데 사용할 수 있습니다.
    
  
  4. 오버로딩 가능 : 하나의 클래스에 여러 생성자를 정의할 수 있습니다.
    
      이를 생성자 오버로딩이라고 하며, 파라미터의 수나 타입에 따라 다른 생성자를 호출할 수 있습니다.
    
  


6.2 생성자의 유형.

  1. 기본 생성자(Default Constructor) : 개발자가 명시적으로 생성자를 정의하지 않으면, 자바 컴파일러는 매개변수가 없는 기본 생성자를 제공합니다.
    
      이 기본 생성자는 객체의 필드를 기본값으로 초기화합니다.
    
  
  2. 매개변수가 있는 생성자(Parameterized Constructor) : 하나 이상의 매개변수를 받아 객체의 초기 상태를 세팅 할 수 있도록 해줍니다.


6.3 예제.
public class Person {
    private String name;
    private int age;
    
    // 기본 생성자
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }
    
    // 매개변수가 있는 생성자
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void displayInfo() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}

public class Test {
    public static void main(String[] args) {
        // 기본 생성자를 사용하여 객체 생성
        Person person1 = new Person();
        person1.displayInfo(); // 출력: Name: Unknown, Age: 0
        
        // 매개변수가 있는 생성자를 사용하여 객체 생성
        Person person2 = new Person("Jhon", 25);
        person2.displayInfo(); // 출력: Name: Jhon, Age: 25
    }
}


  이 예제에서 ‘Person’ 클래스는 두 가지 유형의 생성자를 가집니다.
    
      하나는 매개변수가 없어 기본값으로 객체를 초기화하고, 다른 하나는 이름과 나이를 받아 객체를 초기화합니다.
    
  


📝 정리.
생성자를 사용함으로써 클래스의 인스턴스가 유효한 상태로 시작될 수 있도록 보장하며, 필요한 초기 설정을 자동으로 수행할 수 있습니다.
이는 객체 지향 프로그래밍에서 객체의 무결성을 유지하는 중요한 방법입니다.



7. this 키워드와 this() 생성자 호출.
자바에서 ‘this’ 키워드와 ‘this()’ 생성자 호출은 객체 자신을 참조하고 객체의 생성자를 호출하는 데 사용되는 중요한 요소입니다.

이들은 객체 내부에서 사용되며, 클래스의 멤버(필드, 메서드, 생성자)와 관련된 동작을 명확히 하는 데 유용합니다.

7.1 this 키워드.
‘this’ 키워드는 현재 객체, 즉 메서드나 생성자를 호출하는 인스턴스를 참조하는 데 사용됩니다.

주로 다음과 같은 상황에서 사용됩니다.


  
    1. 필드와 매개변수 이름이 같을 때 구분 : 메서드나 생성자의 매개변수와 클래스의 필드 이름이 같을 때, 필드와 매개변수를 구분하기 위해 사용됩니다.
  
  
    2. 메서드 체이닝 : 객체의 메서드를 연속적으로 호출할 때 ‘this’ 를 반환함으로써 메서드 체이닝을 구현할 수 있습니다.
  
  
    3. 현재 객체를 다른 메서드에 전달 : 현재 객체의 참조를 다른 메서드에 전달할 때 사용됩니다.
  


7.2 this() 생성자 호출.
‘this()’ 는 같은 클래스의 다른 생성자를 호출하는 데 사용됩니다.
주로 생성자 오버로딩이 있을 때, 중복 코드를 최소화하고, 하나의 생성자에서 다른 생성자를 호출하여 필드 초기화 등의 공통 작업을 중앙집중적으로 관리할 수 있게 해줍니다.


  
    1. 생성자 오버로딩 처리 : 클래스에 여러 생성자가 있을 때,  ‘this()’ 를 사용하여 한 생성자에서 다른 생성자를 호출함으로써 공통 코드를 재사용할 수 있습니다.
  
  
    2. 코드 간결성 유지 : 필수적인 초기화 작업을 주 생성자에만 명시하고, 나머지 생성자는 이 주 생성자를 호출하게 함으로써 코드의 간결성을 유지합니다.
  


7.3 예제.
public class Rectangle {
    private int width;
    private int height;
    
    // 주 생성자
    public Rectangle(int width, int height) {
        this.width = width; // 'this'로 필드와 매개변수 구분
        this.height = height;
    }
    
    // 부 생성자
    public Rectangle() {
        this(10, 10) // 'this()' 로 다른 생성자 호출
    }
    
    public void displaySize() {
        System.out.println("Width: " + this.width + ", Height: " + this.height);
    }
}

public class Test {
    public static void main(String[] args) {
        Rectangle rect1 = new Rectangle(30, 40);
        rect1.displaySize(); // 출력: Width: 30, Height: 40
        
        Rectangle rect2 = new Rectangle();
        rect2.displaySize(); // 출력: Width: 10, Height: 10
    }
}



  이 예제에서 ‘Rectangle’ 클래스는 두 개의 생성자를 가지고 있습니다.
    
      기본 생성자는 ‘this()’ 를 사용하여 주 생성자를 호출하고, 주 생성자에서는 ‘this’ 키워드를 사용하여 클래스 필드와 생성자 매개변수를 구분합니다.
        
          이렇게 ‘this’ 와 ‘this()’ 를 사용함으로써 코드의 중복을 줄이고, 초기화 로직을 하나의 생성자에 집중할 수 있습니다.
        
      
    
  


📝 정리.
이처럼 ‘this’ 와 ‘this()’ 는 자바에서 클래스의 인스턴스 자신을 참조하거나 클래스 내 다른 생성자를 호출하는 데 매우 유용한 도구입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-07</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-06-loopStatement.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-06-loopStatement.html"><h1 class="title_post">☕️[Java] 반복문</h1></a>
                        <a href="/Backend/Java/2024-05-06-loopStatement.html" class="txt_post">
                            1️⃣ 반복문

1. for 반복문.
자바 프로그래밍에서 ‘for’ 반복문은 특정 조건을 만족하는 동안 코드 블록을 반복해서 실행하도록 설계된 제어 구조입니다.
‘for’ 문은 초기화, 조건 검사, 반복 후 실행할 작업(일반적으로 증감)을 한 줄에 명시하여 코드의 가독성과 관리를 용이하게 합니다.
이는 반복 실행이 필요한 많은 상황에서 유용하게 사용됩니다.

1.2 for 반복문의 기본 구조.
‘for’ 문의 기본 구조는 다음과 같습니다.

for (초기화; 조건; 증감) {
    // 반복해서 실행할 코드
}


  초기화 : 반복문이 시작할 때 한 번 실행되는 부분으로, 반복문의 제어 변수를 초기 설정합니다.
  조건 : 이 조건이 참(‘true’) 인 동안 반복문 내의 코드가 실행 됩니다. 조건이 거짓(‘false’)이 되면 반복문은 종료됩니다.
  증감 : 각 반복의 끝에서 실행되며, 주로 제어 변수의 값을 증가시키거나 감소시키는데 사용됩니다.


1.3 for 반복문의 예시
기본 예시

for (int i = 0; i &lt; 5; i++) {
    System.out.println("i의 값은: " + i);
}



  이 예제에서는 ‘i’ 를 0부터 시작하여 ‘i’ 가 5미만일 동안 반복하여, 매 반복마다 ‘i’ 를 1씩 증가시킵니다.
    
      따라서 “i의 값은: 0” 부터 “i의 값은: 4” 까지 총 다섯 번의 출력을 하게 됩니다.
    
  


확장된 예시: 다중 제어 변수
for (int i = 0, j = 10; i &lt; j; i++, j--) {
    System.out.println("i = " + i + ". j = " + j);
}



  이 예제에서는 두 개의 제어 변수 ‘i’ 와 ‘j’ 를 사용합니다.
    
      ‘i’ 는 증가하고 ‘j’ 는 감소하며, ‘i’ 가 ‘j’ 와 같거나 ‘j’ 보다 크게 되면 반복이 종료됩니다.
        
          이런 패턴은 복잡한 반복 조건이 필요한 경우 유용하게 사용됩니다.
        
      
    
  


1.4 사용 사례
‘for’ 반복문은 배열이나 컬렉션과 같은 데이터 구조를 순회할 때 매우 유용합니다.
예를 들어, 배열의 모든 요소를 처리하거나 조작할 때 자주 사용됩니다.
int[] numbers = {1,2,3,4,5};
for (int i = 0; i &lt; numbers.length; i++) {
    System.out.println("배열 요소: " + numbers[i]);
}



  여기서 ‘numbers.length’ 는 배열의 길이를 반환하며, ‘i’ 는 0에서 시작하여 배열의 크기 미만이 될 때까지 증가하면서 배열의 각 요소에 접근합니다.


📝 정리
‘for’ 반복문은 코드를 간결하게 하면서 반복적인 작업을 효과적으로 처리할 수 있도록 도와줍니다.



2. while 반복문.
자바 프로그래밍에서 ‘while’ 반복문은 특정 조건이 참(‘true’)인 동간 주어진 코드 블록을 반복적으로 실행하는 구조 입니다.
‘while’ 문은 주로 반복 횟수가 불확실할 때 또는 반복 횟수를 사전에 정확히 알 수 없을 때 사용됩니다.

2.1 while 반복문의 기본 구조.
‘while’ 문의 기본 구조는 다음과 같습니다.

while (조건) {
    // 조건이 참인 동안 반복 실행될 코드
}


  여기서 ‘조건’ 은 각 반복 이전에 평가되며, 이 조건이 참(‘true’)일 때 반복 블록 내의 코드가 실행됩니다. 조건이 거짓(‘false’)이 되면 반복문은 종료됩니다.


2.2 while 반복문 예시.
간단한 예
int i = 0;
while (i &lt; 5) {
    System.out.println("i의 값은: " + i);
    i++; // i 값을 증가시켜 조건이 eventually 거짓이 되도록 함
}



  이 예제에서는 ‘i’ 가 0부터 시작하여 5미만인 동안 반복문을 실행합니다.
    
      반복문 내에서 ‘i’ 를 1씩 증가시켜 eventually 조건이 거짓이 되도록 합니다.
        
          결과적으로 ‘i’ 의 값은 0부터 4까지 콘솔에 출력됩니다.
        
      
    
  


사용자 입력 받기
‘while’ 문은 사용자 입력을 받고, 그 입력에 따라 반복을 계속할지 여부를 결정할 때 유용하게 사용될 수 있습니다.
예를 들어, 사용자가 특정 문자를 입력할 때까지 입력을 계속 받는 프로그램은 다음과 같이 작성할 수 있습니다.
Scanner scanner = new Scanner(System.in);
String input = "";
while (!input.equals("종료")) {
    System.out.println("문자열을 입력하세요. 종료하려면 '종료'를 입력하세요: ");
    input = scanner.nextLine();
}
scanner.close();


2.3 주의사항.
‘while’ 반복문을 사용할 때는 반복문 내에서 조건이 eventually(결국) 거짓이 될 수 있도록 조치를 취해야 합니다.
그렇지 않으면, 조건이 항상 참으로 평가될 경우 무한 후프에 빠질 수 있습니다.
따라서 조건 변수를 적절히 조작하거나 적절한 로직을 구현하여 반복문이 적절한 시점에 종료될 수 있도록 해야 합니다.

📝 정리.
‘while’ 문은 그 구조가 간단하고 유연하여, 특정 조건 하에 반복 실행을 해야 할 때 매우 유용한 프로그래밍 도구입니다.



3. do-while 반복문.
자바 프로그래밍에서 ‘do-while’ 반복문은 조건을 검사하기 전에 최소 한 번은 코드 블록을 실행하는 반복문입니다.
이 구조는 ‘while’ 반복문과 비슷하지만, 조건의 참/거짓 여부에 관계없이 최소한 처음에는 반복문 내의 코드를 실행한다는 점이 다릅니다.
‘do-while’ 문은 주로 사용자 입력을 처리하거나, 조건이 반복문의 실행 후에 결정되어야 할 때 유용합니다.

3.1 do-while 반복문의 기본 구조.
‘do-while’ 문의 기본 구조는 다음과 같습니다.
do {
    // 최소 한 번은 실행될 코드
} while (조건);



  여기서 ‘조건’ 은 반복문의 끝에서 평가됩니다.
    
      조건이 참(‘true’)이면, 코드 블록이 반복적으로 실행됩니다. 조건이 거짓(‘false’)이면, 반복이 종료됩니다.
    
  


3.2 do-while 반복문의 예시.
기본 예
int i = 0;
do {
    System.out.println("i의 값은: " + i);
    i++;
} while (i &lt; 5);



  이 예제에서는 ‘i’ 가 0부터 시작하여 ‘i &lt; 5’ 인 동안 반복합니다.
    
      ‘do-while’ 문은 ‘i’ 의 초기 값에 상관없이 최소 한 번은 “i의 값은: 0”을 출력하고 시작합니다. 그 후 ‘i’ 가 5미만인 동안 계속해서 반복됩니다.
    
  


사용자 입력 받기
사용자로부터 입력을 받고, 특정 조겅(“종료” 문자열 입력)을 만족할 때까지 계속 입력을 받는 프로그램을 구현할 때 ‘do-while’ 문이 유용하게 사용됩니다.

Scanner scanner = new Scanner(System.in);
String input;
do {
    System.out.println("문자열을 입력하세요. 종료하려면 '종료'를 입력하세요:");
    input = scanner.nextLine();
} while (!input.equals("종료"));
scanner.close();


  이 코드는 사용자가 “종료”를 입력할 때까지 계속해서 입력을 받습니다.
    
      입력을 받는 동작은 최소 한 번은 실행되며, 이는 ‘do-while’ 문이 최조 실행을 보장하기 때문입니다.
    
  


3.3 주의사항.
‘do-while’ 반복문을 사용할 때, 조건을 적절히 설정하여 반복문이 적절한 시점에 종료되도록 해야 합니다. 그렇지 않으면 무한 루프에 빠질 수 있습니다.
또한, 조건 검사가 반복문의 끝에서 이루어지므로, 조건이 매우 빨리 거짓이 되어도 코드 블록이 한 번은 실행됨을 기억해야 합니다.

📝 정리.
‘do-while’ 문은 조건이 반복 블록 실행 후에만 알 수 있거나, 반복 블록을 적어도 한 번은 실행해야 하는 경우 특히 유용한 도구입니다.



4. continue.
자바 프로그래밍에서 ‘continue’ 문은 반복문 내에서 사용되며, 그것이 실행될 때 현재 반복의 나머지 부분을 건너뛰고 즉시 다음 반복으로 넘어가도록 합니다.
이를 통해 특정 조건에서 반복문의 다음 순환을 즉시 시작할 수 있게 해줍니다.
‘continue’ 는 주로 반복문 내에서 특정 조건에 대한 예외 처리나 불필요한 처리를 건너뛰기 위해 사용됩니다.

4.1 continue 기본 사용법
‘continue’ 문은 주로 ‘for’, ‘while’, 또는 ‘do-while’ 반복문 내에서 사용됩니다.
간단하게는 ‘continue’ 를 실행하면 반복문의 현재 순회에서 남은 코드를 실행하기 않고, 다음 반복으로 진행합니다.

4.2 continue 예시
‘for’ 반복문에서의 사용
for (int i = 0; i &lt; 10; i++) {
    if (i % 2 == 0) {
        continue; // 짝수인 경우, 출력을 건너뛰고 다음 반복으로 넘어감
    }
    System.out.println(i); // 홀수만 출력
}



  이 코드는 0부터 9까지의 숫자 중에서 홀수만 출력합니다.
    
      ‘i’ 가 짝수일 경우, ‘continue’ 문이 실행되어 ‘System.out.println(i);’ 줄을 건너뛰고 다음 반복으로 넘어갑니다.
    
  


‘while’ 반복문에서의 사용
int i = 0;
while (i &lt; 10) {
    i++;
    if (i % 2 == 0) {
        continue; // 짝수인 경우, 아래의 출력을 건너뛰고 다음 반복으로 넘어감
    }
    System.out.println(i); // 홀수만 출력
}



  이 예제에서도 ‘continue’ 는 짝수를 확인하는 조건에서 참일 경우 나머지 코드를 건너뛰고 다음 반복을 계속 진행하도록 합니다.


4.3 continue 특징 및 주의사항.

  ‘continue’ 문은 현재 수행 중인 반복의 나머지 부분을 건너뛰고, 반복문의 조건 검사로 직접 이동하여 다음 반복을 시작합니다.
  ‘continue’ 문을 사용할 때는 반복문이 무한 루프에 빠지지 않도록 주의해야 합니다.
    
      예를 들어, ‘continue’ 문이 반복문의 변수 값을 변경하는 코드를 건너뛰면 그 변수의 값이 업데이트되지 않아 무한 루프가 발생할 수 있습니다.
    
  
  ‘continue’ 는 루프의 흐름을 제어하고, 코드의 읽기 어려움을 증가시킬 수 있으므로, 사용할 때는 명확한 이유가 있어야 합니다.


📝 정리.
‘continue’ 문은 코드를 보다 효율적으로 만들고, 필요 없는 조건을 빠르게 건너뛸 수 있게 도와줍니다.
그러나 코드의 가독성과 유지 관리에 영향을 줄 수 있으므로 신중하게 사용해야 합니다.



5. break문.
자바 프로그래밍에서 ‘break’ 문은 반복문(‘for’, ‘while’, ‘do-while’) 또는 ‘switch’ 문에서 현재 블록의 실행을 즉시 종료하고, 해당 블록의 바깥으로 제어를 이동시키는 역할을 합니다.

이는 반복문 또는 ‘switch’ 문 내에서 특정 조건을 만족할 때 추가적인 처리 없이 루프나 선택 구조를 벗어나기 위해 사용됩니다.

5.1 break 기본 사용법.

  반복문에서의 사용 : ‘break’ 를 사용하여 무한 루프를 종료하거나 특정 조건이 만족될 때 반복문을 조기에 종료할 수 있습니다.
  ‘switch’ 문에서의 사용 : 각 ‘case’ 블록 뒤에 ‘break’ 를 사용하여 ‘switch’ 문을 종료하고, 다음 ‘case’ 로 넘어가지 않도록 합니다.


5.2 break 예시
반복문에서의 ‘break’
for (int i = 0; i &lt; 10; i++) {
    if (i == 5) {
        break; // i가 5가 되면 for 루프를 종료
    }
    System.out.println(i);
}


  이 코드에서는 ‘i’ 가 5에 도달하면 ‘break’ 문이 실행되어 ‘for’ 루프가 즉시 종료됩니다.
    
      결과적으로, 0부터 4까지의 숫자만 출력됩니다.
    
  


‘while’ 반복문에서의 ‘break’
int i = 0;
while (true) { // 무한 루프
    if (i == 5) {
        break; // i가 5가 되면 while 루프를 종료
    }
    System.out.println(i);
    i++;
}


  이 예제에서도 ‘i’ 가 5일 때 ‘break’ 문을 사용하여 무한 루프를 종료합니다.


‘switch’ 문에서의 ‘break’
int number = 2;
switch (number) {
    case 1:
        System.out.println("Number is 1");
        break;
    case 2:
        System.out.println("Number is 2");
        break;
    case 3:
        System.out.println("Number is 3");
        break;
    default:
        System.out.println("Number is not 1, 2, or 3");
}



  ‘switch’ 문에서 ‘number’ 가 2일 때 해당하는 ‘case’ 블록이 실행되고, ‘break’ 문으로 인해 ‘switch’ 문을 벗어나게 됩니다.


5.3 break문 특징 및 주의사항

  ‘break’ 문은 코드 실행을 즉시 중단시키므로, 효과적인 프로그램 흐름 제어를 가능하게 합니다.
  반복문이나 ‘switch’ 문 내에서만 ‘break’ 문을 사용할 수 있습니다.
  ‘break’ 문을 사용할 때는 코드의 흐름을 명확히 이해하고 있어야 하며, 무분별한 사용은 코드의 가독성과 유지보수를 어렵게 만들 수 있습니다.


📝 정리.
‘break’ 는 코드의 복잡성을 줄이고 특정 조건에서 즉시 반복문을 종료할 수 있는 강력한 도구입니다.
그러나 그 사용은 코드의 구조를 명확하게 유지하는 방식으로 신중하게 이루어져야 합니다.



6. for-each문.
자바 프로그래밍에서 ‘for-each’ 문, 또는 강화된 ‘for’ 문(enhanced for loop)은 배열이나 컬렉션 프레임워크에 저장된 각 요소를 순회하기 위해 사용되는 구문입니다.

기존의 ‘for’ 문보다 간결하며, 코드를 읽고 작성하기가 더 쉬워 배열이나 컬렉션의 모든 요소에 접근할 때 일반적으로 권장되는 방식입니다.

6.1 for-each문 기본 구조.
‘for-each’ 문의 기본 구조는 다음과 같습니다.
for (타입 변수명 : 배열 또는 컬렉션) {
    // 변수명을 사용한 코드
}



  여기서 ‘타입’ 은 배열 또는 컬렉션에 저장된 요소의 타입을 말하고, ‘변수명’ 은 반복되는 각 요소를 참조하는 데 사용되는 변수 이름입니다.
  ‘배열 또는 컬렉션’ 은 순회할 배열이나 컬렉션 객체를 지정합니다.


6.2 for-each문 예시
배열 사용 예
int[] numbers = {1,2,3,4,5};
for(int number: numbers) {
    System.out.println(number);
}


  이 코드에서 ‘for-each’ 문은 ‘numbers’ 배열의 모든 요소를 순회합니다.
    
      각 반복에서 ‘number’ 변수에 배열의 요소가 할당되며, 그 값을 출력합니다.
    
  


컬렉션 사용 예
List&lt;String&gt; names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name);
}


  이 예에서는 ‘names’ 리스트의 모든 요소를 순회합니다.
    
      각 요소는 ‘name’ 변수에 할당되고, ‘System.out.println’ 을 통해 출력됩니다.
    
  


6.3 for-each문의 장점.

  가독성 향상: ‘for-each’ 문은 간결하고 이해하기 쉬워, 코드의 가독성을 크게 향상시킵니다.
  오류 감소: 전통적인 ‘for’ 문에서 발생할 수 있는 인덱스 관련 실수나 경계 조건 오류를 방지할 수 있습니다.
  향상된 추상화: 컬렉션의 내부 구조나 크기를 몰라도 각 요소에 접근할 수 있습니다.


6.4 for-each문의 제한사항.

  컬렉션 수정 불가: ‘for-each’ 문을 사용하는 동안 컬렉션을 수정할 수 없습니다.
    
      예를 들어, 순회 중인 컬렉션에서 요소를 추가하거나 제거할 수 없습니다.
    
  
  인덱스 접근 불가: ‘for-each’ 문은 각 요소에 대한 인덱스를 제공하지 않습니다.
    
      특정 인덱스의 요소에 접근하거나 인덱스를 활용한 복잡한 로직이 필요한 경우에는 전통적인 ‘for’ 문을 사용해야 합니다.
    
  


📝 정리.
‘for-each’ 문은 자바에서 컬렉션과 배열을 효율적으로 처리할 수 있는 강력하고 사용하기 쉬운 도구입니다.
이를 통해 코드를 더욱 간결하고 안전하게 만들 수 있습니다.



                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-05-conditionalStatement.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-05-conditionalStatement.html"><h1 class="title_post">☕️[Java] 조건문</h1></a>
                        <a href="/Backend/Java/2024-05-05-conditionalStatement.html" class="txt_post">
                            1️⃣ 조건문

1. if문.
자바 프로그래밍에서 ‘if’ 문은 조건부 실행을 제어하는 기본적인 제어 구문입니다.
이를 통해 프로그램은 주어진 조건이 참(‘true’)인지 거짓(‘false’)인지에 따라 다른 행동을 취할 수 있습니다.

1.1 if문 기본 구조.
‘if’ 문의 기본 구조는 다음과 같습니다.
if (조건) {
    // 조건이 참일 때 실행될 코드
}


  여기서 ‘조건’ 은 boolean 타입의 표현식으로, 평가 결과가 ‘true’ 또는 ‘false’ 가 됩니다.
    
      조건이 ‘true’ 일 때만 중괄호 ’{}’ 내부의 코드가 실행됩니다.
    
  


1.2 예시
예를 들어, 사용자의 나이가 성인 기준을 만족하는지를 확인하는 코드는 다음과 같습니다.
int age = 20;
if (age &gt;= 18) {
    System.out.println("성인입니다.");
}


  이 코드에서 ‘age &gt;= 18’ 이라는 조건이 참이면 “성인입니다.” 라는 메시지를 출력합니다.


1.3 ‘else’와 ‘else if’ 확장
‘if’ 문은 종종 ‘else’ 와 ‘else if’ 와 함께 사용되어 보다 복잡한 조건 로직을 구현할 수 있습니다.
if (조건1) {
    // 조건1이 참일 때 실행될 코드
} else if (조건2) {
    // 조건1이 거짓이고 조건2가 참일 때 실행될 코드
} else {
    // 위의 모든 조건이 거짓일 때 실행될 코드
}


예를 들어, 점수에 따라 학점을 출력하는 코드는 다음과 같습니다.

int score = 85;
if (score &gt;= 90) {
    System.out.println("학점 A");
} else if (score &gt;= 80) {
    System.out.println("학점 B");
} else if (score &gt;= 70) {
    System.out.println("학점 C");
} else {
    System.out.println("학점 D");
}



  이 예제에서 ‘score’ 변수의 값에 따른 다른 학점을 출력합니다.
    
      ‘if’, ‘else if’, ‘else’ 구문은 점수 범위에 따라 조건적으로 실행되며, 가장 먼저 만족하는 조건의 블록만 실행됩니다.
    
  


📝 정리.
‘if’ 문은 프로그래밍에서 결정을 내리는 데 필수적인 구조이며, 다양한 조건에 따라 코드의 실행 흐름을 제어하는 데 사용됩니다.



2. switch문.
자바 프로그래밍에서 ‘switch’ 문은 다수의 조건 중 하나를 선택해 실행할 때 사용하는 조건문입니다.
이는 ‘if-else’ 조건문의 대안으로, 변수의 값에 따라 여러 실행 경로 중 하나를 선택할 수 있도록 해줍니다.
‘switch’ 문은 특히 특정 변수가 취할 수 있는 명확한 값들을 기반으로 다양한 케이스를 처리할 때 유용하게 사용됩니다.

2.1 switch문의 기본 구조.
‘switch’ 문의 기본 구조는 다음과 같습니다.
switch (표현식) {
    case 값1:
        // 표현식 결과가 값1과 일치할 때 실행할 코드
        break;
    case 값2:
        // 표현식 결과가 값2와 일치할 때 실행할 코드
        break;
    // 추가적인 case들을 더 정의할 수 있습니다.
    default:
        // 어떤 case도 일치하지 않을 때 실행할 코드
}


2.2 switch 문의 주요 특징.

  1. 표현식 은 주로 정수, 문자형 또는 열거형(enum) 데이터를 사용합니다. 자바 7 이상에서는 문자열(String)도 지원합니다.
  2. case 라벨은 ‘switch’ 문 내에서 표현식의 결과와 일치하는 값을 가지며, 해당 값에 대한 실행 코드를 포함합니다.
  3. break 문은 ‘switch’ 문을 종료하고 다음 코드로 넘어가도록 합니다. ‘break’ 가 없으면 다음 ‘case’ 로 계속 진행되어 “fall-through” 현상이 발생합니다.
  4. default 섹션은 선택적으로 사용되며, 어떤 ‘case’ 도 일치하지 않을 때 실행됩니다.


2.3 switch 문 예시.
학생의 점수에 따라 학점을 부여하는 간단한 예를 들어보겠습니다.
int score = 92;
String grade;

switch (score / 10) {
    case 10:
    case 9:
        grade = "A";
        break;
    case 8:
        grade = "B";
        break;
    case 7:
        grade = "C";
        break;
    case 6:
        grade = "D";
        break;
    default:
        greade = F;
}

System.out.println("학점: " + grade);



  이 코드에서 ‘score / 10’ 의 결과값에 따라 다른 ‘case’ 블록이 실행됩니다.
  ‘92/10’ 은 ‘9’ 이므로, ‘grade’ 는 “A” 가 됩니다.
  각 ‘case’ 는 ‘break’ 문으로 종료되므로, 해당 ‘case’ 실행 후, ‘switch’ 문을 벗어납니다.


📝 정리.
‘switch’ 문은 코드의 가독성을 높이고, 많은 조건 분기를 간결하게 처리할 수 있는 방법을 제공합니다.
이는 특히 각 조건이 명확할 때 더욱 유용하며, 코드의 구조를 명확하게 표현할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-05-VariousOperators-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-05-VariousOperators-1.html"><h1 class="title_post">☕️[Java] 여러가지 연산자(1)</h1></a>
                        <a href="/Backend/Java/2024-05-05-VariousOperators-1.html" class="txt_post">
                            1️⃣ 각각의 연산자에 대한 이해

1. 항과 연산자.

1.1 단항 연산자(Unary Operator).
자바 프로그래밍에서 단항 연산자(Unary Operator)는 오직 한 개의 피연산자(operand)를 가지고 연산을 수행하는 연산자를 말합니다.

이들은 변수나 값에 직접 적용되며, 표현식의 결과를 반환합니다.

단항 연산자는 특히 간단한 수학 연산, 값의 부정, 또는 값의 증감 등에서 유용하게 사용됩니다.

1.2 자바에서 사용되는 주요 단항 연산자.

  1. 부정 연산자('!')
    
      불리언 값을 반전시킵니다.
        
          예를 들어, '!true' 는 'false' 가 됩니다.
        
      
    
  
  2. 단항 플러스 및 마이너스 연산자('+', '-')
    
      '+' 는 일반적으로 숫자의 부호를 그대로 두지만, 명시적으로 사용할 수 있습니다.
      '-' 는 숫자의 부호를 반전시킵니다.
        
          예를 들어, '-5' 는 양수 '5' 를 음수로 변환합니다.
        
      
    
  
  3. 증가 및 감소 연산자('++', '--')
    
      '++' 연산자는 변수의 값을 1만큼 증가시킵니다.
      '--' 연산자는 변수의 값을 1만틈 감소시킵니다.
      이 연산자들은 전위(prefix) 형태(예: '++x')와 후위(postfix) 형태(예: 'x++')로 사용될 수 있습니다.
        
          전위 형태는 변수를 증가시키고 표현식의 값을 반환하기 전에 증가된 값을 사용하고, 후위 형태는 표현식의 값을 반환한 후 변수를 증가시킵니다.
        
      
    
  
  4. 비트 반전 연산자('~')
    
      정수형 변수는 모든 비트를 반전시킵니다.
        
          예를 들어, '~00000000' 은 '11111111' 이 됩니다.
            
              이는 정수에 대해 비트 단위 NOT 연산을 수행합니다.
            
          
        
      
    
  


1.3 예제 사용.

public class UnaryDemo {
    public static void main(String[] args) {
        boolean a = false;
        System.out.println(!a); // true

        int num = 5;
        System.out.println(-num); // -5
        System.out.println(++num); // 6
        System.out.println(num++); // 6, 그리고 num이 7이 됨
        System.out.println(--num); // 6
        System.out.println(num--); // 6, 그리고 num이 5가 됨

        int b = 0b00000000; // 이진수로 0
        System.out.println(~b); // 모든 비트가 1로 반전
    }
}



  이 예제에서는 다양한 단항 연산자들의 사용 방법과 그 효과를 보여줍니다.
    
      단항 연산자들은 자바 프로그래밍에서 변수를 조작하거나 특정 연산을 더 간결하게 수행하는데 매우 유용합니다.
    
  




2.1 이항 연산자(Binary Operator)
자바 프로그래밍에서 이항 연산자(Binary Operator)는 두 개의 피연산자(operand)를 취해 연산을 수행하고 결과를 반환하는 연산자를 말합니다.

이항 연산자는 수학적 계산, 논리 비교, 값의 할당 등 다양한 작업에 사용됩니다.

2.2 자바에서 사용되는 주요 이항 연산자의 종류.

  1. 산술 연산자.
    
      ’+’ (덧셈)
      ’-‘ (뺄셈)
      ‘*‘ (곱셈)
      ’/’ (나눗셈)
      ’%’ (나머지)
    
  
  2. 비교 연산자.
    
      ’==’ (동등)
      ’!=’ (부등)
      ’&gt;’ (크다)
      ’&lt;’ (작다)
      ’&gt;=’ (크거나 같다)
      ’&lt;=’ (작거나 같다)
    
  
  3. 논리 연산자.
    
      ‘&amp;&amp;’ (논리적 AND)
      
        
          
            
              **’
               
              ‘** (논리적 OR)
            
          
        
      
    
  
  4. 비트 연산자
    
      ‘&amp;’ (비트 AND)
      
        
          
            
              **’
              ‘** (비트 OR)
            
          
        
      
      ’^’ (비트 XOR)
    
  
  5. 할당 연산자
    
      ’=’ (기본 할당)
      ’+=’, ‘-=’, ‘*=’, ‘/=’, ‘%=’ (복합 할당 연산자)
      
        
          
            
              **‘&amp;=’, ‘
              =’, ‘^=’, ‘«=’, ‘»=’, ‘»&gt;=’** (비트 복합 할당 연산자)
            
          
        
      
    
  
  6. 시프트 연산자
    
      ’«‘ (왼쪽 시프트)
      ’»‘ (오른쪽 시프트, 부호 유지)
      ’»&gt;’ (오른쪽 시프트, 부호 비트 없음)
    
  


2.3 예제 코드

public class BinaryOperatorsExample {
    public static void main(String[] args) {
        int a = 10, b = 5;
        int sum = a + b; // 15
        int difference = a - b; // 5
        boolean isEqual = (a == b); // false
        boolean isGreater = (a &gt; b); // true

        int bitAnd = a &amp; b; // 비트 AND 연산
        int shiftedLeft = a &lt;&lt; 2; // 왼쪽으로 2 비트 시프트

        System.out.println("Sum: " + sum);
        System.out.println("Difference: " + difference);
        System.out.println("Is Equal: " + isEqual);
        System.out.println("Is Greater: " + isGreater);
        System.out.println("Bitwise AND: " + bitAnd);
        System.out.println("Left Shifted: " + shiftedLeft);
    }
}


  이항 연산자들은 기본적인 산술 연산부터 복잡한 논리 연산에 이르기까지 프로그래밍에서 광범위하게 사용됩니다.
    
      이를 통해 효과적으로 데이터를 조작하고, 조건을 평가하며, 복잡한 문제를 해결할 수 있습니다.
    
  




3.1 삼항 연산자(Ternary Operator).
자바 프로그래밍에서 삼항 연산자(Ternary Operator), 또는 조건 연산자(Conditional Operator)라고 불리는 ’?:’ 는 세 개의 피연산자를 사용하는 유일한 연산자입니다.

이 연산자는 간결한 조건문을 구현할 때 사용되며, 간단한 조건식을 기반으로 두 가지 선택지 중 하나를 반환합니다.

3.2 삼항 연산자의 구조.

조건식 ? 값1 : 값2



  1. 조건식 : 이 부분은 ‘true’ 또는 ‘false’ 를 반환하는 불리언 식입니다.
  2. 값2 : 조건식이 ‘true’ 일 때 반환됩니다.
  3. 값3 : 조건식이 ‘false’ 일 때 반환됩니다.


조건식의 평가 결과에 따라 ‘값1’ 또는 값2 중 하나가 결과값으로 선택되어 반환됩니다.

이 연산자는 일반적으로 간단한 조건에 따라 변수에 값을 할당하거나 특정 표현식의 결과를 결정할 때 유용하게 사용됩니다.

3.3 예제 사용.

public class TernaryExample {
    public static void main(String[] args) {
        int a = 10, b = 5;
        int max = (a &gt; b) ? a : b; // a와 b 중 큰 값을 max에 할당.
        System.out.println("Max value: " + max);
        
        String response = (a &gt; b) ? "a is greater than b" : " b is greater or equal to a";
        System.out.println(response);
    }
}


  이 예제에서 삼항 연산자를 사용하여 두 숫자 중 더 큰 숫자를 결정하고, 문자열 메시지도 조건에 따라 선택합니다.
    
      이러한 사용은 코드를 더 간결하게 만들고, ‘if-else’ 구조를 보다 간단하게 대체할 수 있게 해 줍니다.
    
  
  삼항 연산자는 그 효율성과 간결함 때문에 자바 프로그래밍에서 자주 사용되는 유용한 도구입니다.
    
      그러나 복잡한 로직이나 여러 조건이 연속적으로 필요한 경우에는 가독성을 위해 전통적인 ‘if-else’ 문을 사용하는 것이 더 나을 수 있습니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-05-VariousOperator-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-05-VariousOperator-2.html"><h1 class="title_post">☕️[Java] 여러가지 연산자(2)</h1></a>
                        <a href="/Backend/Java/2024-05-05-VariousOperator-2.html" class="txt_post">
                            1️⃣ 비트 연산자에 대한 이해

1. 2진법.
자바 프로그래밍에서의 이진법은 컴퓨터의 지본 숫자 시스템을 참조하는 것입니다.
컴퓨터는 데이터를 0과 1의 형태, 즉 이진수로 처리합니다.
자바에서도 이러한 이진법을 사용하여 데이터를 저장, 처리하며 다양한 연산을 수행할 수 있습니다.

1.1 자바에서 2진법을 사용하는 예.

  1. 이진 리터럴 : 자바 7 이상부터는 정수를 이진 리터럴로 직접 표현할 수 있습니다.
    
      예를 들어, ‘int x = 0b1010;’ 은 이진수 ‘1010’ 이고, 십진수로 10입니다.
    
  
  2. 비트 연산자 : 자바는 비트 연산을 수행할 수 있는 여러 연산자를 제공합니다.
    
      예를 들어, 다음과 같습니다.
        
          '&amp;' (AND 연산자)
          '|' (OR 연산자)
          '^' (XOR 연산자)
          '~' (NOT 연산자)
          '&lt;&lt;' (왼쪽 시프트)
          '&gt;&gt;' (오른쪽 시프트)
          '&gt;&gt;&gt;' (부호 없는 오른쪽 시프트)
            
              이들 연산자는 주로 효율적인 수치 계산, 저수준 프로그래밍, 암호와 작업 등에 사용됩니다.
            
          
        
      
    
  
  3. 이진 데이터 조작 : 파일이나 네트워크를 통해 바이트 단위로 데이터를 읽고 쓸 때, 이진 형식으로 데이터를 처리합니다.
    
      자바에서는 'byte' 자료형을 이용하여 이진 데이터를 직접 다룰 수 있습니다.
    
  


📝 정리
이진법을 사용하는 주된 이유는 컴퓨터 하드웨어가 전기 신호로 작동하기 때문에 0과 1, 즉 이진 상태를 나타내는 전기의 켜짐과 꺼짐 상태로 모든 데이터를 표현하기 편리하기 때문입니다.
이렇게 함으로써, 프로그래밍에서 더욱 직접적이고 효율적인 하드웨어 조작이 가능해집니다.



2. 2의 보수.
자바 프로그래밍에서의 2의 보수(2’s complement)는 음수를 표현하기 위한 방법입니다.
컴퓨터 시스템은 보통 이진법을 사용하여 데이터를 저장하고 처리하는데, 이진법에서 음수를 표현하기 위해 가장 널리 사용되는 방법이 2의 보수입니다.

2.1 2의 보수 생성 과정.

  1. 원래 숫자의 이진 표현을 얻습니다.
    
      예를 들어, 5의 이진 표현은 ‘0101’ 입니다.
    
  
  2. 이진 표현의 모든 비트를 반전시킵니다.
    
      즉, 0은 1로, 1은 0으로 변경합니다.
      5의 경우 ‘0101’ 이 ‘1010’ 이 됩니다.
    
  
  3. 반전된 값에 1을 더합니다.
    
      이렇게 하면 ‘1011’ 이됩니다.
    
  


이렇게 생성된 ‘1011’ 은 -5를 나타냅니다.
이 방법은 자바를 포함한 대부분의 프로그래밍 언어와 컴퓨터 시스템에서 음수를 표현하는 표준 방법입니다.

2.2 2의 보수의 장점.

  덧셈 연산만으로 뺄셈을 할 수 있습니다.
    
      예를 들어, 5-5를 계산하려면 5와 -5의 2의 보수를 더하면 됩니다.
        
          이진법으로는 ‘1010 + 1011 = 10000’ 이고, 최상위 비트(캐리 비트)는 무시합니다.
            
              따라서 결과는 ‘0000’ 이 됩니다.
            
          
        
      
    
  
  오버플로 처리가 간단합니다.
    
      캐리 비트는 무시하면서 자연스럽게 오버플로를 처리할 수 있습니다.
    
  


2.3 자바에서의 활용.
자바에서는 정수형 타입(‘int’, ‘long’, ‘short’, ‘byte’) 이 이진법으로 2의 보수 형태로 저장되고 처리됩니다.
이는 자바의 모든 정수 연산에 내장된 메커니즘입니다.
예를 들어, 자바에서 ‘-5’ 를 선언하면 내부적으로는 ‘5’ 의 2의 보수인 ‘111…11011’ (32비트 시스템에서의 표현)으로 저장됩니다.

📝 정리
2의 보수 방식은 음수를 다루기 위한 효과적인 방법이며, 프로그래머가 별도의 조치를 취하지 않아도 시스템이 자동으로 처리해 주기 때문에 매우 편리합니다.



3. 비트 논리연산자.
자바 프로그래밍에서 비트 논리연산자는 비트 단위로 논리 연산을 수행하는 연산자입니다.
이들 연산자는 주로 정수 타입의 변수에 사용되며, 각 비트를 독립적으로 비교하여 결과를 반환합니다.
비트 논리연산자는 주로 저수준 프로그래밍, 효율적인 데이터 처리, 상태 플래그 관리, 암호화 등의 작업에 활용됩니다.

자바에서 사용되는 주요 비트 논리 연산자는 다음과 같습니다.


  1. AND 연산자(‘&amp;’) : 두 피연산자의 비트가 모두 1일 경우에만 결과의 해당 비트를 1로 설정합니다.
    
      예를 들어, ‘5 &amp; 3’ 은 이진수로 ‘0101 &amp; 0011’ 을 계산하여 ‘0001’ 이 되므로, 결과는 ‘1’ 입니다.
    
  
  
    
      
        
          **2. OR 연산자(‘
          ’) :** 두 피연산자 중 하나라도 비트가 1이면 결과의 해당 비트를 1로 설정합니다.
        
      
    
    
      
        
          
            
              예를 들어, **‘5
              3’** 은 이진수로 **‘0101
              0011’** 을 계산하여 ‘0111’ 이 되므로, 결과는 ‘7’ 입니다.
            
          
        
      
    
  
  3. XOR 연산자(‘^’) : 두 피연산자의 비트가 서로 다를 경우 결과의 해당 비트를 1로 설정합니다.
    
      예를 들어, ‘5 ^ 3’ 은 이진수로 ‘0101 ^ 0011’ 을 계산하여 ‘0110’ 이 되므로, 결과는 ‘6’ 입니다.
    
  
  4. NOT 연산자(‘~’) : 피연산자의 모든 비트를 반전시킵니다.(1은 0으로, 0은 1로).
    
      예를 들어, ‘~5’ 는 이진수로 ‘~0101’ 을 계산하여 ‘…1010’(무한히 많은 1 다음에 1010)이 되고, 이는 보통 32비트 시스템에서 ‘-6’ 으로 해석됩니다.
    
  
  5. 왼쪽 시프트(‘«’) : 모든 비트를 왼쪽으로 지정된 수만틈 이동시키고, 오른쪽은 0으로 채웁니다.
    
      예를 들어.‘3 « 2’ 는 ‘0011’ 을 왼쪽으로 2비트 이동하여 ‘1100’ 이 되므로, 결과는 ‘12’ 입니다.
    
  
  6. 오른쪽 시프트(‘»’) : 모든 비트를 오른쪽으로 지정된 수만큼 이동시키고, 왼쪽은 최상위 비트(부호 비트)의 값으로 채웁니다.
    
      예를 들어, ‘-8 » 2’ 는 ‘11111000’ 을 오른쪽으로 2비트 이동하여 ‘11111110’ 이 되므로, 결과는 ‘-2’ 입니다.
    
  
  7. 부호 없는 오른쪽 시프트(‘»&gt;’) : 모든 비트를 오른쪽으로 지정된 수만큼 이동시키고, 왼쪽은 0으로 채웁니다. 이는 부호 비트를 무시하고, 순수하게 비트를 오른쪽으로 이동시키기 때문에 음수에 사용했을 때 결과가 달라집니다.


📝 정리

이러한 비트 논리 연산자들은 데이터의 특정 비트를 직접 조작할 필요가 있는 경우에 유용하며, 자바 프로그래밍에서 중요한 도구입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-05</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html"><h1 class="title_post">☕️[Java] 변수와 자료형(4)</h1></a>
                        <a href="/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html" class="txt_post">
                            변수와 자료형(4)

1️⃣ 자료형에 대한 이해

1. List
자바 프로그래밍에서 List 는 일련의 요소를 저장하는 데 사용되는 순차적인 컬렉션을 나타냅니다.
이는 자바의 java.util.List 인터페이스를 통해 제공되며, 이는 주문된 컬렉션을 관리하기 위한 다양한 메소드를 제공합니다.
List 는 중복된 요소를 포함할 수 있고, 각 요소는 리스트 내에서 특정 위치를 가집니다.
사용자는 이 위치를 인덱스로 사용하여 리스트의 요소에 접근할 수 있습니다.

List 인터페이스의 주요 특징은 다음과 같습니다.


  1. 순서 보장 : 리스트는 요소들이 추가된 순서를 유지하며, 각 요소는 특정 인덱스를 통해 접근할 수 있습니다.
  2. 요소의 중복 허용 : 같은 값을 가진 요소를 여러 개 포함할 수 있습니다.
  3. 동적 배열 : 리스트의 크기는 고정되어 있지 않고, 요소를 추가하거나 삭제함에 따라 동적으로 조절됩니다.


자바에서는 List 인터페이스를 구현하는 몇 가지 클래스가 있습니다.
가장 흔히 사용되는 구현체는 다음과 같습니다.


  'ArrayList' : 내부적으로 배열을 사용하여 요소를 저장합니다.
    
      요소의 추가와 인덱스를 통한 접근이 매우 빠르지만, 크기 조절이 필요할 때는 비용이 많이 들 수 있습니다.
    
  
  'LinkedList' : 각 요소가 다음 요소에 대한 참조와 함께 저장되는 연결 리스트를 사용합니다.
    
      요소의 추가와 삭제는 빠르지만, 인덱스를 통한 요소 접근은 시작부터 요소를 찾을 때까지 순차적으로 검색해야 하므로 시간이 더 걸립니다.
    
  
  'Vector' : 'ArrayList' 와 비슷하지만, 다중 스레드 환경에서 안전하게 사용할 수 있도록 동기화된 메소드를 제공합니다.


📝 정리.
'List' 는 자바 컬렉션 프레임워크의 일부이며, 데이터를 관리하고 처리하는 데 매우 유용합니다.
프로그래머는 이러한 컬렉션을 사용하여 데이터를 유연하게 조작할 수 있습니다.

1.2 List의 주요 메서드.
자바의 'List' 인터페이스에는 여러 가지 중요한 메서드들이 포함되어 있으며, 이를 통해 리스트 내의 요소들을 조작하고 접근할 수 있습니다.

다음은 'List' 인터체이스에서 제공하는 몇 가지 주요 메서드들입니다.


  'add(E e)': 리스트의 끝에 요소를 추가합니다.
  'add(int index, E element)': 지정된 위치에 요소를 삽입합니다.
  'addAll(Collection&lt;? extends E&gt; c)': 지정된 컬렉션의 모든 요소를 리스트의 끝에 추가합니다.
  'addAll(int index, Collection&lt;? extends E&gt; c)': 지정된 위치부터 컬렉션의 모든 요소를 리스트에 추가합니다.
  'clear()': 리스트에서 모든 요소를 제거합니다.
  'contains(Object o)': 리스트가 특정 요소를 포함하고 있는지 확인합니다.
  'get(int index)': 지정된 위치의 요소를 반환합니다.
  'indexOf(Object o)': 주어진 요소의 첫 번째 인덱스를 반환합니다. 요소가 리스트에 없는 경우 -1을 반환합니다.
  'lastIndexOf(Object o)': 주어진 요소의 마지막 인덱스를 반환합니다. 요소가 리스트에 없는 경우 -1을 반환합니다.
  'isEmpty()': 리스트가 비어 있는지 확인합니다.
  'iterator()': 리스트의 요소에 대한 반복자를 반환합니다.
  'listIterator()': 리스트의 요소를 리스트 순서대로 반복하는 리스트 반복자를 반환합니다.
  'remove(Object o)': 주어진 요소를 리스트에서 처음 발견되는 위치에서 제거하고, 그 결과를 반환합니다.
  'remove(int index)': 지정된 위치에 있는 요소를 리스트에서 제거하고, 그 요소를 반환합니다.
  'replaceAll(UnaryOperator&lt;E&gt; operator)': 주어진 연산자를 사용하여 리스트의 모든 요소를 대체합니다.
  'size()': 리스트에 있는 요소의 수를 반환합니다.
  'sort(Comparator&lt;? super E&gt; c)': 주어진 비교자를 사용하여 리스트를 정렬합니다.
  'subList(int fromIndex, int toIndex)': 지정된 범위의 부분 리스트를 반환합니다.
  'toArray()': 리스트 요소를 배열로 반환합니다.


📝 정리.
이 메서드들을 통해 리스트를 생성, 조회, 수정 및 관리하는 다양한 작업을 수행할 수 있습니다.
List 인터페이스를 사용함으로써 데이터를 효율적으로 처리하고 구조화할 수 있습니다.



2. Map
자바 프로그래밍에서 'Map' 은 키(key)와 값(value)의 쌍을 저장하는 객체입니다.
이는 키를 기반으로 빠르게 값을 검색할 수 있게 해주는 데이터 구조로, 각 키는 고유해야 합니다.(즉, 중복된 키를 가질 수 없습니다.)
'Map' 은 'java.util.Map' 인터페이스를 통해 정의되며, ‘HashMap‘, ‘TreeMap‘, ‘LinkedHashMap‘ 등 다양한 구현체를 가집니다.

자바의 ‘Map‘ 인터페이스는 키-값 쌍으로 데이터를 저장하고 관리하는 데 중점을 두는 데이터 구조로서, 특히 다음과 같은 주요 특징을 가지고 있습니다.


  1. 키에 의한 값 접근 : ‘Map‘ 은 각 값에 고유한 키를 할당하며, 이 키를 사용하여 빠르게 해당 값을 검색할 수 있습니다.
    
      이는 데이터베이스의 인덱스와 유사한 방식으로 작동합니다.
    
  
  2. 키의 유일성 : 맵 내에서 모든 키는 고유해야 합니다.
    
      즉, 같은 키가 두 번 이상 존재할 수 없으며, 새로운 키-값 쌍을 추가할 때 이미 존재하는 키를 사용하면 기존의 값이 새 값으로 대체됩니다.
    
  
  3. 값의 중복 허용 : 키는 유일해야 하지만 값은 중복될 수 있습니다.
    
      다른 키가 동일한 값을 가리킬 수 있습니다.
    
  
  4. 순서의 유무 : 일반적인 ‘Map‘ 구현체들은 키-값 쌍의 순서를 보장하지 않습니다.
    
      그러나 ‘LinkedHashMap‘ 과 같은 일부 구현체는 요소가 추가된 순서대로 반복할 수 있는 기능을 제공합니다.
      ‘TreeMap‘ 은 키에 따라 정렬된 순서를 유지합니다.
    
  
  5. 비동기화 및 동기화 : 기본적으로 대부분의 ‘Map‘ 구현체는 동기화되지 않습니다.(‘HashMap‘). 이는 멀티 스레드 환경에서 동시 수정이 발생할 경우 안전하지 않을 수 있음을 의미합니다.
    
      반면에 ‘Hashtable‘ 과 같은 구현체는 기본적으로 동기화가 되어 있어 멀티 스레드 환경에서 안전합니다.
      또한, ‘Collections.synchronizeMap‘ 메소드를 사용하여 맵을 동기화된 맵으로 변환할 수 있습니다.
    
  
  6. Null 허용 : 대부분의 ‘Map‘ 구현체는 키와 값으로 ‘null‘ 을 허용합니다.(‘HashMap‘, ‘LinkeHashMap‘).
    
      하지만 ‘Hashtable‘ 은 ‘null‘ 키나 값을 허용하지 않으며, ‘TreeMap‘ 은 자연 정렬 또는 ‘Comparator‘ 가 ‘null‘ 을 처리할 수 있는 경우에만 ‘null‘ 키를 허용합니다.
    
  


📝 정리.
이러한 특징들로 인해 ‘Map‘ 은 다양한 애플리케이션에서 유연하고 효율적인 데이터 관리를 가능하게 합니다.
데이터를 쉽게 추가, 검색, 삭제할 수 있어 데이터 관리의 복잡성을 줄이고 성능을 최적화하는 데 기여합니다.



3. Generics.
자바 프로그래밍에서 제네릭스(Generics)는 클래스나 메소드에서 사용될 데이터 타입을 추상화하여 코드 작성 시점에는 구체적인 타입을 명시하지 않고, 객체 생성이나 메소드 호출 시점에 실제 사용할 타입을 지정할 수 있도록 하는 프로그래밍 기법입니다.

제네릭스(Generics)는 코드의 재사용성을 높이고, 타입 안정성을 강화하며, 캐스팅에 대한 오류 가능성을 줄이는 데 도움을 줍니다.

3.1 제네릭스(Generics)의 주요 특징.

  
    1. 타입 안전성(Type Safety) : 제네릭스를 사용하면 컴파일 시점에 타입 체크가 가능하여, 실행 시점에서 발생할 수 있는 'ClassCastException' 과 같은 오류를 사전에 방지할 수 있습니다.
  
  2. 재사용성(Reusability) : 하나의 코드를 다양한 타입에 대해 재사용할 수 있습니다.
    
      예를 들어, 제네릭 클래스나 메소드를 정의하면, 다양한 타입의 객체를 저장하거나 처리하는 로직을 단 한번만 작성하여 여러 타입에 걸쳐 사용할 수 있습니다.
    
  
  3. 코드 간결성(Code Clarity) : 캐스팅을 줄여 코드가 더욱 간결하고 읽기 쉬워집니다.


3.2 제네릭스의 기본 문법.

  클래스 선언 : 클래스 이름 뒤에 '&lt;T&gt;' 를 추가하여 제네릭 클래스를 선언합니다.
    
      ‘T’ 는 타입 파라미터를 나타내며, 이는 클래스 내에서 사용될 데이터 타입을 대체하는 플레이스홀더 역할을 합니다.
    
  


public class Box&lt;T&gt; {
    private T t; // T 타입의 객체를 위한 변수
    
    public void set(T t) {
        this.t = t;
    }
    
    public T get() {
        return t;
    }
}



  메소드 선언 : 메소드 반환 타입 앞에 ’&lt;T&gt;‘ 를 추가하여 제네릭 메소드를 선언합니다.


public &lt;T&gt; T genericMethod(T t) {
    return t;
}



  제네릭 타입 제한(Bounded Type Parameters) : 특정 클래스의 하위 클래스만 타입 파라미터로 받도록 제한할 수 있습니다.
    
      이는 'extends' 키워드를 사용하여 지정합니다.
    
  


public class Box&lt;T extends Number&gt; {
    private T t;
    
    public void set(T t) {
        this.t = t;
    }
    
    public T get() {
        return t;
    }
}


📝 정리.
제네릭스(Generics)를 사용함으로써 개발자는 보다 타입-안전하고 유지보수가 용이한 코드를 작성할 수 있으며, 실행 시 타입 관련 문제를 효과적으로 줄일 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-04</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html"><h1 class="title_post">☕️[Java] 변수와 자료형(3)</h1></a>
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html" class="txt_post">
                            변수와 자료형(3).

1️⃣ 자료형에 대한 이해.

1. String.
String 클래스는 불변(immutable)의 문자열을 다룹니다.

  이는 한 번 생성된 String 객체의 내용이 변경될 수 없다는 것을 의미합니다.
  문자열을 변경하려고 할 때마다 실제로 새로운 String 객체가 생성되고, 기존 객체는 변경되지 않습니다.


1.1 String의 주요 메소드.

  charAt(int index) : 지정된 위치의 문자를 반환합니다.
  concat(String str) : 현재 문자열의 끝에 지정된 문자열을 붙여 새로운 문자열을 반환합니다.
  contains(CharSequence s) : 특정 문자열이 포함되어 있는지 확인합니다.
  startsWith(String prefix) : 문자열이 특정 문자열로 시작하는지 확인합니다.
  endsWith(String suffix) : 문자열이 특정 문자열로 끝나는지 확인합니다.
  equals(Object anObject) : 문자열이 주어진 객체와 동일한지 비교합니다.
  indexOf(int ch), indexOf(String str) : 주어진 문자 또는 문자열의 위치를 찾습니다.
  length() : 문자열의 길이를 반환합니다.
  replace(char oldChar, char newChar) : 문자열 중 일부 문자를 다른 문자로 대체합니다.
  substring(int beginIndex, int endIndex) : 문자열의 부분을 추출합니다.
  toLowerCase(), toUpperCase() : 문자열을 소문자 또는 대문자로 변환합니다.
  trim() : 문자열의 앞뒤 공백을 제거합니다.


2. StringBuffer.
StringBuffer 클래스는 가변(mutable)의 문자열을 다루며, 문자열 변경 작업이 빈번할 때 사용하면 효율적입니다.

  StringBuffer 객체는 내용을 직접 변경할 수 있어, 새로운 객체를 계속 생성하지 않아도 됩니다.


2.1 StringBuffer의 주요 메소드.

  append(String str): 문자열의 끝에 주어진 문자열을 추가합니다.
  delete(int start, int end): 문자열의 시작 인덱스부터 종료 인덱스 전까지의 부분을 삭제합니다.
  deleteCharAt(int index): 지정된 위치의 문자를 삭제합니다.
  insert(int offset, String str): 지정된 위치에 문자열을 삽입합니다.
  replace(int start, int end, String str): 시작 인덱스부터 종료 인덱스 전까지의 문자열을 새로운 문자열로 대체합니다.
  reverse(): 문자열의 순서를 뒤집습니다.
  length(): 문자열의 길이를 반환합니다.
  capacity(): 현재 버퍼의 크기를 반환합니다.
  setCharAt(int index, char ch): 지정된 위치의 문자를 다른 문자로 설정합니다.


📝 정리.
StringBuffer 는 스레드에 안전(thread-safe)합니다, 즉 멀티스레드 환경에서 동시에 접근해도 안전하게 사용할 수 있습니다.

  이는 내부적으로 메소드들이 동기화되어 있기 때문입니다.


반면, StringBuilder 는 StringBuffer 와 유사하지만 멀티스레드 환경에서의 동기화 자원이 없어 단일 스레드에서 더 빠르게 작동합니다.

이처럼 String 과 StringBuffer 는 각각의 특성에 맞게 선택하여 사용할 수 있으며, 성능과 사용상황에 따라 적절히 활용하면 됩니다.



3. Array.
자바 프로그래밍에서 배열(Array)은 동일한 타입의 여러 데이터를 연속적인 메모리 위치에 저장하기 위한 자료구조입니다.
배열은 고정된 크기를 가지며, 배열의 각 요소는 같은 데이터 타입을 가집니다.
배열을 사용하면 여러 데이터를 하나의 변수 이름으로 관리할 수 있어 코드를 간결하게 작성할 수 있습니다.

3.1 배열의 특징.

  고정된 크기 : 배열은 생성 시 지정된 크기를 변경할 수 없습니다.
    
      배열의 크기는 프로그램 실행 도중에 변경할 수 없으며, 더 많은 데이터를 저장해야 할 경우 새로운 배열을 생성하고 데이터를 복사해야 합니다.
    
  
  인덱스 접근 : 배열의 각 요소는 인덱스를 통해 접근할 수 있습니다.
    
      인덱스는 0부터 시작하여 배열의 크기 -1까지 번호가 할당됩니다.
    
  
  동일 타입 : 모든 배열 요소는 동일한 데이터 타입을 가져야 합니다.
    
      예를 들어, int 타입의 배열은 int 타입의 값만을 요소로 가질 수 있습니다.
    
  


3.2 배열의 선언과 초기화.
배열을 선언하고 사용하기 위해서는 다음 단계를 따라야 합니다.


  1. 배열 선언 : 데이터 타입 뒤에 대괄호 [] 를 사용하여 배열을 선언합니다.


int[] myArray;
String[] stringArray;



  2. 배열 생성 : new 키워드를 사용하여 배열을 생성하고, 배열의 크기를 지정합니다.


myArray = new int[10]; // 10개의 정수를 저장할 수 있는 배열
stringArray = new String[5]; // 5개의 문자열을 저장할 수 있는 배열



  3. 배열 초기화 : 배열의 각 요소에 값을 할당합니다.
    
      인덱스를 사용하여 접근할 수 있습니다.
    
  


myArray[0] = 50;
myArray[1] = 100;
stringArray[0] = "Hello";
stringArray[1] = "World";


3.3 배열 사용 예.
다음은 자바에서 int 배열을 선언, 생성, 초기화하는 예제 코드입니다.

public class ArrayExample {
    public static void main(Stringp[] args) {
        // 배열 선언과 동시에 생성
        int[] numbers = new int[3];
        
        // 배열 초기화
        numbers[0] = 7;
        numbers[1] = 20;
        numbers[2] = 33;
        
        // 배열 사용
        System.out.println("첫 번째 숫자: " + numbers[0]);
        System.out.println("두 번째 숫자: " + numbers[1]);
        System.out.println("세 번째 숫자: " + numbers[2]);
    }
}

📝 정리
이 예제에서는 numbers 라는 이름의 int 배열을 생성하고, 세 개의 정수를 저장한 후 출력합니다.
배열을 사용하는 이점 중 하나는 이처럼 단일한 이름으로 여러 데이터를 효율적으로 관리할 수 있다는 것입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-03-TypeComparison.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-03-TypeComparison.html"><h1 class="title_post">☕️[Java] 타입 비교.</h1></a>
                        <a href="/Backend/Java/2024-05-03-TypeComparison.html" class="txt_post">
                            타입 비교.
자바 프로그래밍에서 두 변수의 타입이 같은지 비교하는 방법은 몇 가지 상황에 따라 다릅니다.
여기서는 변수가 기본형(Primitive types) 인 경우와 참조형(Reference types) 인 경우로 나누어 설명하겠습니다.

1️⃣ 기본형 변수의 타입 비교.
기본형 변수의 경우, 자바는 정적 타입 언어이기 때문에 변수의 타입이 코드 작성 시 결정됩니다.
두 변수가 같은 기본형 타입인지 비교하는 일반적인 상황은 적으며, 주로 타입을 확인하거나 변환할 때 컴파일러가 자동으로 처리합니다.
그러나 명시적으로 확인하고 싶다면, 두 변수의 타입을 직접 코드에서 확인할 수 있습니다.
이는 일반적인 코딩 상황보다는 주로 제네릭 코드나 리플렉션을 사용할 때 발생합니다.

2️⃣ 참조형 변수의 타입 비교.
참조형 변수의 경우 타입 비교는 다음 두 가지 방법으로 이루어질 수 있습니다.

2.1 instanceof 연산자 사용.
instanceof 연산자는 특정 객체가 지정된 클래스의 인스턴스이거나 그 서브클래스의 인스턴스인지를 검사합니다.

  이 방법은 주로 객체의 타입을 확인할 때 사용됩니다.


Object a = "Hello";
Object b = new String("Hello");

if (a instanceof String &amp;&amp; b instanceof String) {
    System.out.println("두 객체는 같은 타입입니다.");
}


2.2 getClass() 메서드 사용.
객체의 정확한 클래스를 알고 싶을 때 getClass() 메서드를 사용할 수 있습니다.
이 메서드는 객체의 런타임 클래스를 리턴합니다.

  두 객체의 클래스가 정확히 같은지 비교할 때 유용합니다.


Object a = new Integer(5);
Object b = new Double(5.0);

if (a.getClass().equals(b.getClass())) {
    System.out.println("두 객체는 같은 클래스입니다.")
} else {
    System.out.println("두 객체는 다른 클래스입니다.")
}


📝 마무리.
이 방법들은 객체의 타입을 정확히 확인할 수 있으며, 특히 다형석을 활용하는 객체지향 프로그래밍에서 유용하게 사용됩니다.
또한, 테스트 코드나 동적 타입 처리가 필요한 상황에서 자주 사용됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html"><h1 class="title_post">☕️[Java] 자바 - 변수와 자료형(2)</h1></a>
                        <a href="/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html" class="txt_post">
                            ☕️ 자바 - 변수와 자료형(2)

1. 자료형에 대한 이해
자바 프로그래밍에서 사용되는 자료형은 크게 기본형(Primitive types) 과 참조형(Reference types) 두 가지로 나눌 수 있습니다.
각각의 자료형에 대해 설명드리겠습니다.

1️⃣ 기본형(Primitive types)
기본형 자료형은 실제 값을 저장하는 타입으로, 총 8가지가 있습니다.


  정수형
    
      byte : 8비트 정수형, 값의 범위는 -128에서 127까지.
      short : 16비트 정수형, 값의 범위는 -32,768에서 32,767까지.
      int : 32비트 정수형, 값의 범위는 약 -2.14억에서 2.14억까지.
      long : 64비트 정수형, 값의 범위는 약 -9.22경에서 9.22경까지
    
  
  실수형
    
      float : 32비트 부동 소수점 형. 부정확할 수 있으며, 대략 6~7 자리의 정밀도를 가짐.
      double : 64비트 부동 소수점 형. float보다 더 정밀하며, 대략 15자리의 정밀도를 가짐.
    
  
  문자형
    
      char : 단일 16비트 유니코드 문자를 저장.
    
  
  논리형
    
      boolean : true 또는 false 값만을 가짐.
    
  


2️⃣ 참조형(Reference types)
참조형 자료형은 객체의 참조(메모리 주소)를 저장합니다.
기본형과 달리 메모리의 특정 위치를 가리키는 포인터를 저장하므로, 객체의 크기에 관계없이 참조 변수 크기는 항상 일정합니다.
참조형의 예를 들면 다음과 같습니다.


  클래스(Class)
    
      예: String, Integer, File 등
    
  
  인터페이스(Interface)
    
      예: List, Map, Serializable 등
    
  
  배열(Array)
    
      예: int[], double[], String[] 등
    
  




1.1 인터페이스(Interface)?
자바에서 인터페이스(Interface)는 특정 클래스가 구현해야 할 메소드를 정의하는 “계약”의 역할을 합니다.
이는 클래스가 인터페이스에 정의된 모든 메소드를 반드시 구현하도록 강제합니다.
인터페이스는 메소드의 실제 구현을 포함하지 않고, 메소드의 시그니처(이름, 매개변수 리스트, 반환 유형)만을 정의합니다.
인터페이스를 사용하는 주된 목적은 다음과 같습니다.


  1. 추상화(Abstraction) : 인터페이스를 통해 구현의 세부 사항을 숨기고, 사용자에게 필요한 기능만을 제공할 수 있습니다.
    
      이렇게 함으로써 코드의 복잡성을 줄이고, 유지 관리가 쉬워집니다.
    
  
  2. 다형성(Polymorphism) : 다양한 클래스들이 동일한 인터페이스를 구현함으로써, 다양한 타입의 객체를 동일한 방식으로 처리할 수 있습니다.
    
      이는 코드의 유연성과 재사용성을 높입니다.
    
  
  3. 결합도 감소(Decoupling) : 인터페이스를 통해 서로 다른 코드 부분 간의 결합도를 낮추어, 각 부분을 독립적으로 개발하고 테스트할 수 있게 합니다.


👉 인터페이스 예시

  예를 들어, List 인터페이스는 add ,remove, get, size 등의 메소드를 정의하며, 이 인터페이스를 구현하는 ArrayList, LinkedList 등의 클래스는 이 메소드들을 실제로 구현해야 합니다.
    
      이를 통해 사용자는 구체적인 리스트의 구현 방법을 몰라도 이 인터페이스를 통해 리스트를 사용할 수 있습니다.
        
          이런 방식으로 인터페이스는 참조형 자료형 중 하나로서, 객체의 행동을 정의하고 다양한 구현을 가능하게 합니다.
        
      
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html"><h1 class="title_post">☕️[Java] 자바 - 변수와 자료형(1)</h1></a>
                        <a href="/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html" class="txt_post">
                            변수와 자료형(1)

🙋‍♂️ 변수 이름 규칙
자바 프로그래밍에서 변수를 명명할 때 따라야 할 몇 가지 기본적인 규칙과 관례가 있습니다.
이러한 규칙을 준수하는 것은 코드의 가독성과 유지보수성을 높이는 데 중요합니다.
다음은 자바에서 변수 이름을 지정할 때 고려해야 할 주요 규칙들 입니다.

1️⃣ 기본 규칙.

  **문자와 숫자, (Underscore), $ 사용가능 :** 변수 이름은 문자(letter) 나 밑줄(, Underscore) 또는 $(달러 기호)로 시작할 수 있습니다.
    
      그러나 숫자로 시작할 수는 없습니다.
    
  
  숫자로 시작할 수 없다 : 첫 글자로는 숫자로 변수 이름을 시작할 수 없습니다.
    
      그러나 첫 글자 이후에는 숫자가 포함될 수 있습니다.
    
  
  대문자와 소문자를 구분함 : 변수 이름을 명명시, 대문자와 소문자를 구분합니다.
    
      예를 들어 int apple = 1;, int Apple = 2;, int APPLE = 3;은 모두 다른 변수로 취급됩니다.
    
  
  공백을 허용하지 않음 : 변수 이름을 명명시 공백이 들어가서는 않됩니다.
    
      예를 들어 int my friends = 7;과 같이 공백이 들어가서는 안됩니다.
    
  
  특수 문자 제한 : ‘_(underscore)’와 ‘$’를 제외한 특수 문자는 변수명으로 사용할 수 없습니다.
    
      예를 들어 ‘@’, ‘#’, ‘%’ 등은 변수 이름으로 사용할 수 없습니다.
    
  
  자바 예약어 사용 금지 : int, class, static 등 자바에서 이미 의미를 갖는 예약어는 변수 이름으로 사용할 수 없습니다.


2️⃣ 표기법 및 관례(컨벤션)

  카멜 케이스 : 첫 단어는 소문자로 시작하고, 이어지는 각 단어의 첫 글자는 대문자로 시작합니다.
    
      예를 들어, firstName, totalAmount 등 입니다.
    
  
  파스칼 케이스 : 각 문자의 첫 문자를 대문자로 표기합니다.
    
      예를 들어, MyFriends, ToTalCount 등 입니다.
    
  
  의미 있는 이름 : 변수 이름은 그 변수가 무엇을 의미하는지 명확하게 표현해야 합니다.
    
      예를 들어, numberOfStudents 는 학생 수를, temperature는 온도를 나타내는 등의 명확한 이름을 사용하는 것이 좋습니다.
    
  
  상수 이름 규칙 : 상수(변하지 않는 값)는 모두 대문자를 사용하며, 단어 사이는 밑줄(‘_‘)로 구분합니다.
    
      예를 들어 MAX_HEIGHT, TOTAL_COUNT 등 입니다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-2.html"><h1 class="title_post">☕️[Java] 코테 맛보기(2) - 코테를 위한 자료구조와 알고리즘 개념 구현 방법 숙지</h1></a>
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-2.html" class="txt_post">
                            😋 코테 맛보기.

코딩 테스트를 준비하기 위해서 자료구조와 알고리즘은 매우 중요한 영역입니다.
이 분야들에 대한 깊이 있는 이해와 숙지는 테스트에서 성공적인 성과를 내는 데 결정적인 역할을 합니다.
다음은 코딩 테스트를 위해 필요한 자료구조와 알고리즘의 개념 및 구현 방법에 대한 가이드입니다.

1️⃣ 자료구조.

  기본 자료구조 : 배열, 스택, 큐, 링크드 리스트.
    
      이러한 자료구조들은 다양한 문제에서 데이터를 효율적으로 관리하는 기본적인 방법을 제공합니다.
    
  
  고급 자료구조 : 트리(특히 이진 검색 트리), 힙, 그래프, 해시 테이블, 집합 등
    
      이들은 보다 복잡한 데이터 관계를 다루는 데 사용되며, 특정 유형의 문제를 해결하는 데 특화되어 있습니다.
    
  
  응용 자료구조 : 트라이, 세그먼트 트리, 유니온 파인드, 비트마스크 등.
    
      이들은 특정 알고리즘 문제에 최적화된 솔루션을 제공합니다.
    
  


2️⃣ 알고리즘.

  정렬 알고리즘 : 버블 정렬, 삽입 정렬, 선택 정렬, 퀵 정렬, 병합 정렬 등.
    
      정렬은 많은 문제에서 데이터를 조작하는 기본적인 방법입니다.
    
  
  검색 알고리즘 : 선형 검색, 이진 검색 등
    
      데이터 내에서 특정 항목을 찾는 방법입니다.
    
  
  재귀 알고리즘과 백트래킹 : 문제를 더 작은 문제로 나누어 해결하는 기법입니다.
  동적 프로그래밍 : 복잡한 문제를 간단한 하위 문제로 나누어 해결하고, 그 결과를 저장하여 효율적으로 최종 결과를 도출합니다.
  그래프 알고리즘 : 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS), 최단 경로 문제(다익스트라, 플로이드-워셜), 최소 신장 트리(크루스칼, 프림) 등을 포함합니다.


3️⃣ 코테 준비 방법.

  이론 학습 : 자료구조와 알고리즘의 이론을 철저히 학습합니다.
    
      이론적인 이해는 효과적인 구현의 기초가 됩니다.
    
  
  실습 연습 : 이론을 바탕으로 다양한 문제를 실제로 코딩해 봄으로써 실력을 키웁니다.
    
      LeetCode, HackerRank, Codeforces, 백준, 프로그래머스 등의 플랫폼에서 문제를 풀어봅니다.
    
  
  알고리즘 패턴 학습 : 자주 출제되는 문제 유형과 그에 대한 표준적인 해결 방법을 익힙니다.
  시간 관리 연습 : 코딩 테스트에서는 제한된 시간 내에 문제를 해결해야 하므로, 시간 관리 능력을 향상시킬 필요가 있습니다.


📝 정리.
코테를 위한 준비 과정에서 이러한 자료구조와 알고리즘에 대한 이해와 숙련도는 문제를 정확하고 효율적으로 해결할 수 있는 능력을 직접적으로 높여 줍니다.
따라서, 이 분야에 대한 철저한 준비와 연습을 통해 자신감을 갖고 테스트에 임할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-1.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-1.html"><h1 class="title_post">☕️[Java] 코테 맛보기(1) - 코테를 위한 자바 프로그래밍 언어 사용 숙련도</h1></a>
                        <a href="/Backend/Java/2024-05-02-TasteTheCodingTest-1.html" class="txt_post">
                            😋 코테 맛보기.

코딩 테스트를 위해 자바 프로그래밍 언어를 사용하려면 몇 가지 중요한 요소에 숙력도를 갖추어야 합니다.
자바는 많은 기업들이 코딩 테스트에 사용하는 언어 중 하나이며, 효과적인 문제 해결을 위해 다음과 같은 능력을 개발하는 것이 중요합니다.
효과적인 문제 해결을 위해 다음과 같은 능력을 개발하는 것이 중요합니다.

1️⃣ 기본 문법 숙지.

  자바의 기본 문법과 프로그래밍 구조에 익숙해져야 합니다.
    
      변수, 데이터 타입, 연산자, 제어문(if, for, while 등), 메소드 호출 등 기본적인 구성 요소를 이해하고 사용할 수 있어야 합니다.
    
  


2️⃣ 객체 지향 프로그래밍(OOP)이해.

  자바는 객체 지향 프로그래밍 언어입니다.
    
      클래스, 객체, 상속, 다형성, 캡슐화 등의 객체 지향 개념을 이해하고 이를 문제 해결에 적절히 적용할 수 있어야 합니다.
      OOP 개념은 코드의 재사용성과 모듈성을 높여줘 효율적인 프로그래밍을 가능하게 합니다.
    
  


3️⃣ 표준 라이브러리 사용.

  자바의 표준 라이브러리에는 다양한 자료구조와 알고리즘이 구현되어 있습니다.
    
      java.util 패키지 내의 컬렉션 프레임워크(리스트, 맵, 셋 등)를 비롯해, 유용한 유틸리티 클래스들을 활용할 줄 알아야 합니다.
        
          이러한 라이브러리들은 코딩 테스트에서 효율적인 코드 작성을 돕습니다.
        
      
    
  


4️⃣ 알고리즘과 자료구조.

  다양한 알고리즘과 자료구조에 대한 이해가 중요합니다.
    
      정렬, 탐색, 그래프 이론, 동적 프로그래밍 등의 알고리즘과 배열, 스택, 큐, 링크드 리스트, 트리 등의 자료구조에 대한 깊은 이해가 필요합니다.
        
          이는 문제를 효과적으로 분석하고 최적의 해결책을 구현하는 데 결정적입니다.
        
      
    
  


5️⃣ 문제 해결 능력.

  실제 코딩 테스트에서는 다양한 유형의 문제가 제시됩니다.
    
      문제를 빠르게 이해하고 효과적인 해결책을 설계할 수 있는 능력이 필요합니다.
        
          이는 실전 연습을 통해 향상시킬 수 있으며, 온라인 코딩 플랫폼에서 다양한 문제를 풀어 보는 것이 좋습니다.
        
      
    
  


6️⃣ 테스트와 디버깅

  코드가 예상대로 동작하는지 검증하고, 오류를 찾아 수정할 수 있는 능력도 중요합니다.
    
      자바에서 제공하는 디버깅 도구를 사용하여 코드를 단계별로 실행하고, 변순의 상태를 확인하며 문제를 진단할 수 있어야 합니다.
    
  


📝 정리.
코딩 테스트를 위한 자바 숙련도는 이론적 지식과 실제 적용 능력의 조합을 요구합니다.
이를 위해 개념 학습과 함께 많은 실습을 병행하는 것이 중요합니다.
시간을 정해두고 실전처럼 문제를 풀어보는 연습을 꾸준히 하면, 효과적으로 자바를 활용하여 코딩 테스트에서 좋은 성과를 낼 수 있을 것입니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-02-IntroJava.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-02-IntroJava.html"><h1 class="title_post">☕️[Java] 자바 - 소개</h1></a>
                        <a href="/Backend/Java/2024-05-02-IntroJava.html" class="txt_post">
                            자바 - 소개

🙋‍♂️ 1. 자바의 특징.
자바는 세계적으로 널리 사용되는 프로그래밍 언어로, 웹 개발, 모바일 애플리케이션, 대규모 시스템 구축 등 다양한 분야에 활용됩니다.
자바의 주요 특징들은 다음과 같습니다.

1️⃣ 플랫폼 독립성.

  “Write Once, Run Anywhere”(WORA) : 자바 프로그램은 자바 가상 머신(JVM) 위에서 실행되기 때문에, 한 번 작성하면 어떤 플랫폼에서도 실행할 수 있습니다.
    
      이는 자바 컴파일러가 소스 코드를 플랫폼 독립적인 바이트코드로 변환하기 때문입니다.
    
  


2️⃣ 객체 지향 프로그래밍(OOP).

  자바는 객체 지향 프로그래밍 언어로, 캡슐화, 상속, 다형성 등을 완전히 지원합니다.
    
      이는 코드 재사용, 유지 관리의 용이성 및 시스템 모듈화를 가능하게 합니다.
    
  


3️⃣ 강력한 표준 라이브러리.

  자바는 방대한 표준 라이브러리를 제공하여, 네트워킹, 파일 시스템 접근, 그래픽 인터페이스 제작 등 다양한 작업을 쉽게 처리할 수 있도록 돕습니다.


4️⃣ 메모리 관리.

  자동 가비지 컬렉션
    
      자바는 사용하지 않는 객체를 자동으로 감지하고 메모리에서 제거하는 가비지 컬렉터를 내장하고 있습니다. 이는 개발자가 메모리 누수에 대해 걱정할 필요가 적어지게 해줍니다.
    
  


5️⃣ 보안.

  자바는 샌드박스 환경에서 애플리케이션을 실행하여 시스템 리소스에 대한 무단 접근을 방지합니다.
    
      또한, 클래스 로더, 바이트코드 검증기 등을 통해 애플리케이션이 안전하게 실행될 수 있도록 합니다.
    
  


6️⃣ 멀티스레딩.

  자바는 내장된 멀티스레딩 기능을 지원하여, 여러 스레드가 동시에 실행되도록 하여 애플리케이션의 효율성을 높입니다.
    
      이는 특히 네트워크 서버와 실시간 시스템에서 큰 장점입니다.
    
  


7️⃣ 로버스트와 포터빌리티.

  자바 프로그램은 다른 플랫폼으로의 이동성이 뛰어나며, 높은 수준의 안정성을 제공합니다.
    
      예외 처리 기능을 통해 오류를 쉽게 관리하고, 시스템의 안정성을 높일 수 있습니다.
    
  


📝 마무리.
자바의 이러한 특징들은 그것을 매우 유연하고, 다양한 애플리케이션 개발에 적합하게 만듭니다.
이로 인해 자바는 세계적으로 인기 있는 프로그래밍 언어 중 하나로 자리 잡게 되었습니다.



🙋‍♂️ 2. 자바 프로그램의 작성과 실행과정.



1️⃣ 소스 코드 작성.

  개발자는 자바의 문법에 맞추어 .java 확장자 파일에 소스 코드를 작성합니다.
    
      이 파일에는 하나 이상의 클래스가 포함되며, 각 클래스는 데이터와 메서드를 정의합니다.
    
  


2️⃣ 컴파일.

  소스 코드 파일을 자바 컴파일러(javac)를 사용하여 컴파일합니다.
    
      컴파일러는 소스 코드를 읽고, 문법 오류를 검사한 후, 바이트코드라는 중간 형태의 코드로 변환합니다.
        
          이 바이트 코드는 .class 파일로 저장됩니다.
        
      
    
  
  바이트코드는 플랫폼 독립적이기 때문에, 한 번 컴파일된 .class 파일은 다양한 운영 체제에서 실행될 수 있습니다.


3️⃣ 로딩.

  자바 가상 머신(JVM)은 .class 파일을 로드합니다.
    
      클래스 로더(component of JVM)가 이 작업을 수행하며, 필요한 클래스 파일들을 메모리에 로드합니다.
    
  


4️⃣ 링킹.

  로드된 클래스 파일들은 링킹 과정을 거칩니다. 링킹은 검증, 준비, 그리고(선택적으로) 해석 단계를 포함합니다.
    
      검증 : 로드된 바이트코드가 올바르게 포맷되었는지, 안전한지 검사합니다.
      준비 : 클래스 변수와 기본값을 위한 메모리를 할당합니다.
      해석 : 심볼릭 메모리 참조를 직접 참조로 변환합니다(선택적).
    
  


5️⃣ 초기화.

  클래스 초기화 단계에서 정적 변수들에 대한 초기화가 수행되며, 정적 블록이 실행됩니다.


6️⃣ 실행.

  프로그램 실행 동안 JVM 내부에서 가비지 컬렉터가 사용되지 않는 객체를 자동으로 감지하고, 할당된 메모리를 해제하여 메모리를 관리합니다.


📝 마무리.
자바의 이러한 실행 과정은 코드의 플랫폼 독립성을 보장하고, 안정적이며 보안적인 실행 환경을 제공합니다.
이 모든 과정은 개발자로부터 대부분 숨겨져 있으며, 개발자는 주로 소스 코드 작성과 일부 디버깅에 집중할 수 있습니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-02</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Backend/Java/2024-05-01-AboutJava.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/JV.jpeg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Backend/Java/2024-05-01-AboutJava.html"><h1 class="title_post">☕️[Java] 자바란?</h1></a>
                        <a href="/Backend/Java/2024-05-01-AboutJava.html" class="txt_post">
                            자바란?
자바 언어 특징.

1. 타 언어에 비해 배우기 쉽습니다.
2. 플랫폼에 독립적입니다.
- 자바 언어가 플랫폼에 독립적인 이유는 그 설계 철학과 메커니즘에 근거합니다.
- 자바는 "한 번 작성하면, 어디서든 실행된다(Write Once, Run Anywhere, WORA)" 라는 철학을 실현하기 위해 개발되었습니다.
    - 이를 가능하게 하는 핵심 요소는 자바 가상 머신(Java Virtual Machine, JVM)과 자바 바이트코드의 도입입니다.


자바의 플랫폼 독립성의 주요 요인
1. 자바 가상 머선(JVM)

  JVM은 자바 바이트 코드를 실행할 수 있는 런타임 환경을 제공합니다. 자바 프로그램이 컴파일되면, 플랫폼에 독립적인 바이트코드로 변환됩니다.
    
      이 바이트코드는 어떤 특정 하드웨어나 운영 체제의 기계어 코드가 아닌, JVM이 이해할 수 있는 중간 형태의 코드입니다.
    
  
  JVM은 바이트코드를 받아 각 플랫폼에 맞는 기계어 코드로 변환하고 실행합니다.
    
      따라서, 자바 애플리케이션은 다양한 운영 체제에서 JVM만 설치되어 있으면 실행될 수 있습니다.
2. 컴파일과 실행의 분리
    
  
  자바 프로그램은 소스 코드(.java 파일)에서 바이트코드(.class 파일)로 컴파일되는 과정과, 실행 시 바이트 코드가 실제로 실행되는 과정으로 나누어집니다. 이 두 단계의 분리는 프로그램을 한 번 컴파일하면, 그 컴파일된 코드가 다양한 환경의 JVM에서 실행될 수 있게 합니다.
3. 표준화된 API
  자바는 풍부하고 표준화된 API를 제공합니다. 이 API들은 플랫폼에 관계없이 일관된 방식으로 작동하므로, 개발자는 운영 체제의 특징을 신경 쓰지 않고도 애플리케이션을 개발할 수 있습니다. 예를 들어, 파일 시스템 접근, 네트워크 프로그래밍 등의 기능은 모든 플랫폼에서 동일한 자바 코드로 작동합니다.
4. 언어와 라이브러리의 독립성
  자바 언어와 표준 라이브러리는 플랫폼에 특화된 구현으로부터 독립적입니다.
    
      즉, 자바의 표준 라이브러리 구현은 다양한 하드웨어와 운영 체제에서 동일하게 작동하도록 설계되었습니다.
    
  


3. 객체지향 프로그래밍입니다.

  객체지향 프로그래밍?
    
      자바에서의 객체지향 프로그래밍(Object-Oriented Programming, OOP)은 소프트웨어를 설계하고 구현할 때 객체라는 개념을 중심으로 프로그래밍하는 방식을 말합니다.
        
          객체지향 프로그래밍은 코드의 재사용성, 확장성 및 관리 용이성을 높이는 데 도움이 됩니다.
          자바는 객체지향 언어의 특징을 강하게 반영하고 있으며, 다음과 같은 기본 원칙에 따라 프로그래밍 됩니다.
            
              1. 캡슐화(Encapsulation)
                
                  객체의 데이터(속성)와 그 데이터를 조작하는 메소드를 하나의 단위로 묶는 것을 말합니다.
                  캡슐화를 사용하면 객체의 세부 구현 내용을 외부에서 알 필요 없이 객체가 제공하는 기능만을 사용할 수 있으며, 이는 코드의 유지보수를 용이하게 합니다.
                
              
              2. 상속(Inheritance)
                
                  한 클래스가 다른 클래스의 특성을 상속 받아 사용할 수 있게 하는 것입니다.
                  이를 통해(상속을 통해) 기존 코드를 재사용하면서 확장할 수 있고, 코드의 중복을 줄이며 유지 보수가 쉬워집니다.
                
              
              3. 다형성(Polymorphism)
                
                  같은 이름의 메소드가 다른 작업을 수행할 수 있도록 하여 메소드의 오버라이딩(Overriding)이나 오버로딩(Overloading)을 가능하게 합니다.
                    
                      오버라이딩(Overriding) : 자식 클래스가 상속 받은 부모 클래스의 메소드를 재정의 하는 행위를 말합니다. 오버라이딩을 통해 자식 클래스는 상속 받은 메소드와 동일한 시그니처(메소드 이름, 매개변수 리스트)를 가지지만, 그 내용을 자신의 특정한 요구에 맞게 새롭게 구현할 수 있습니다. 오버라이딩된 메소드는 실행 시 다형성을 활용하여 해당 객체의 실제 타입에 따라 적절한 메소드가 호출됩니다.
                        
                          예시 코드
  java
      class Animal {
          void display() {
              System.out.println("This is an animal.");
          }
      }
      class Cat extends Animal {
          @Override
          void display() {
              System.out.println("This is a cat.")
          }
      }
     
                        
                      
                      오버로딩(Overloading) : 같은 클래스 내에서 같은 이름의 메소드를 여러 개 정의할 수 있도록 하지만, 매개변수의 타입, 개수 또는 순서가 달라야 합니다. 이를 통해 메소드에 다양한 입력 파라미터를 제공할 수 있으며, 프로그래머가 같은 동작을 하는 메소드에 대해 다양한 옵션을 제공할 수 있습니다. 오버로딩은 컴파일 시간에 결정되며, 메소드 호출 시 전달된 매개변수에 따라 적절한 메소드가 선택됩니다.
                        
                          예시 코드
                                  class Display {
          void show(int a) {
              System.out.println("Number: " + a);
          }
                                    
          void show(String a) {
              System.out.println("String: " + a);
          }
                                    
          void show(int a, int b) {
              System.out.println("Two numbers: " + a + ", " + b);
          }
      }
                            
                          
                          이처럼 오버라이딩과 오버로딩은 자바 프로그래밍에서 메소드의 기능을 확장하거나 변경할 때 유용하게 쓰이는 기법입니다.
                          오버라이딩은 주로 다형성을 활용한 동적 바인딩을 목적으로 하며, 오버로딩은 같은 이름의 메소드에 여러 입력 형태를 제공하기 위해 사용됩니다.
                        
                      
                    
                  
                
              
              4. 추상화(Abstraction)
                
                  복잡한 실제 상황을 단순화하는 과정에서 중요한 특징만을 추출하여 프로그램 코드에 반영하는 것을 의미합니다.
                  추상 클래스와 인터페이스를 통해 구현될 수 있습니다.
                    
                      이러한 원칙들은 자바를 사용하여 복잡한 시스템을 개발할 때 코드의 모듈화를 가능하게 하고, 이로 인해 대규모 소프트웨어 개발과 프로젝트 관리가 용이해집니다.
                        
                          코드의 모듈화(Modularization): 큰 프로그램을 작은 세부 모듈로 나누는 프로세스를 의미합니다. 이러한 모듈은 각각 독립적인 기능을 수행하며, 전체 시스템의 한 부분으로 기능합니다. 모듈화의 주요 목적은 프로그램의 관리를 용이하게 하고, 개발을 효율적으로 만들며, 코드의 재사용성을 높이는 것입니다.
                          모듈화의 주요 이점은 다음과 같습니다.
                            
                              1. 유지보수성
                                
                                  모듈화된 코드는 각 모듈이 분리되어 있기 때문에, 하나의 모듈에서 발생한 문제가 다른 모듈에 미치는 영향을 최소화할 수 있습니다. 따라서 개별 모듈을 독립적으로 수정, 업데이트, 테스트할 수 있어 전체 코드베이스의 유지보수가 더 쉬워 집니다.
                                    
                                      모듈(Module): 소프트웨어 설계에서 사용되는 기본 개념 중 하나로, 관련된 기능들을 논리적으로 그룹화하고 독립적으로 사용할 수 있는 코드의 단위를 의미합니다. 모듈은 프로그램의 특정 기능을 담당하며, 독립적인 개발, 테스트, 재사용이 가능하도록 설계됩니다. 모듈화된 코드는 대체로 명확하고 관리하기 쉬운 구조를 갖습니다.
                                      모듈의 특징으로는 다음과 같습니다.
                                        
                                          1. 독립성
                                            
                                              모듈은 가능한 한 다른 모듈과 독립적으로 동작할 수 있어야 하며, 이를 통해 시스템의 복잡성을 줄이고, 각 모듈의 재사용성을 높일 수 있습니다.
                                            
                                          
                                          2. 캡슐화
                                            
                                              모듈은 자신의 구현 세부사항을 숨기고, 필요한 기능만을 외부에 제공하는 인터페이스를 통해 상호작용합니다. 이로 인해 모듈 간의 상호 의존성이 줄어들고, 변경 관리가 용이해집니다.
                                            
                                          
                                          3. 인터페이스
                                            
                                              모듈은 정의된 인터페이스를 통해 외부와 통신합니다. 인터페이스는 모듈이 제공하는 기능과 해당 기능을 어떻게 접근할 수 있는지를 명시합니다.
                                            
                                          
                                        
                                      
                                      모듈의 예로는 다음으로 들 수 있습니다.
                                        
                                          라이브러리
                                            
                                              특정 기능을 제공하는 함수나 데이터 구조를 모아 놓은 코드 집합. 예를 들어, 수학 연산을 위한 수학 라이브러리, 데이터베이스 작업을 위한 데이터베이스 접근 라이브러리 등이 있습니다.
                                            
                                          
                                          클래스
                                            
                                              객체지향 프로그래밍에서 클래스는 속성(데이터)과 메소드(함수)를 캡슐화하여 모듈을 형성합니다. 클래스는 독립적으로 사용될 수 있으며, 다른 클래스와 상호작용할 수 있습니다.
                                            
                                          
                                          패키지
                                            
                                              관련된 여러 클래스나 모듈을 하나의 더 큰 단위로 그룹화한 것 입니다. 예를 들어, Java에서는 java.util 패키지가 여러 유틸리티 클래스와 인터페이스를 제공합니다.
                                                
                                                  모듈은 개발 과정을 체계화하고, 코드의 재사용성을 증가시키며, 유지 관리를 용이하게 하는 중요한 역할을 합니다.
                                                  모듈은 크기가 클 수도 있고 작을 수도 있으며, 프로젝트의 요구와 설계에 따라 그 범위와 기능이 결정됩니다.
                                                
                                              
                                            
                                          
                                        
                                      
                                    
                                  
                                
                              
                              2. 재사용성
                                
                                  잘 설계된 모듈은 다른 프로그램에서도 재사용할 수 있습니다. 이는 소프트웨어 개발 시간과 비용을 줄이는 데 도움이 되며, 일관된 기능을 여러 프로젝트에 걸쳐 사용할 수 있습니다.
                                
                              
                              3. 확장성
                                
                                  모듈화는 시스템의 확장성을 향상시킵니다. 새로운 기능이 필요할 때 기존 모듈을 수정하거나 새로운 모듈을 추가하기가 더 쉬워집니다. 이는 시스템의 유연성을 증가시키고, 변화하는 요구사항에 더 잘 대응할 수 있게 합니다.
                                
                              
                              4. 가독성
                                
                                  작은 모듈로 나뉘어진 코드는 각각의 모듈이 명확한 기능을 수행하기 때문에, 전체 코드의 구조를 이해하기가 더 쉽습니다. 개발자가 프로그램의 특정 부분만을 이해하고도 효과적으로 작업할 수 있습니다.
                                
                              
                              5. 팀 협업 향상
                                
                                  모듈화는 여러 개발자가 동시에 다른 모듈에서 작업할 수 있게 함으로써 팀 작업을 용이하게 합니다. 각 팀원이 특정 모듈에 집중할 수 있으며, 전체 프로젝트에 대한 의존성을 줄이면서 협업을 효율적으로 진행할 수 있습니다.
                                    
                                      이처럼 코드의 모듈화는 소프트웨어 개발 과정에서 중요한 역할을 하며, 특히 대규모 프로젝트나 복잡한 시스템 개발에 있어 필수적인 접근 방식입니다.
                                    
                                  
                                
                              
                            
                          
                        
                      
                    
                  
                
              
            
          
        
      
    
  


4. Garbage Collector로 사용되지 않는 메모리를 자동적으로 정리해줍니다.

  Garbage Collector(GC): 프로그램이 동적으로 할당한 메모리 영역 중에서 더 이상 사용하지 않는 부분을 자동으로 찾아서 해제하는 시스템을 말합니다. 이 과정을 통해 프로그램에서 발생할 수 있는 메모리 누수를 방지하고, 사용 가능한 메모리 리소스를 최적화합니다.
    
      프로그램이 동적으로 할당한 메모리 영역 : 프로그램 실행 중에 필요에 따라 할당되고 해제되는 메모리를 말합니다. 이는 프로그램의 런타임 중에 사용자의 요구나 데이터의 양에 따라 변화하는 메모리 요구 사항을 수용하기 위해 사용됩니다. 동적 메모리 할당은 프로그램이 시작할 때 필요한 메모리 양을 미리 알 수 없는 경우나, 실행 도중에 메모리 사용량이 변할 때 유용합니다.
        
          동적 메모리 할당의 특징은 아래와 같습니다.
            
              1. 유연성 : 동적 메모리 할당은 프로그램 실행 중에 필요한 메모리 크기를 조정할 수 있게 해줍니다. 이로 인해 프로그램은 사용자의 입력, 파일 크기, 또는 다른 실행 시 요소들에 따라 메모리 사용을 최적화할 수 있습니다.
              2. 효율성 : 필요할 때만 메모리를 할당하고, 더 이상 사용하지 않는 메모리를 해제함으로써 시스템 리소스를 보다 효율적으로 사용할 수 있습니다.
              3. 메모리 관리 : 동적 메모리는 일반적으로 힙(Heap) 영역에서 관리됩니다. 힙은 프로그램의 데이터 영역 중 하나로, 동적으로 할당되는 객체와 데이터에 사용됩니다. 힙 영역의 크기는 프로그램 실행 도중에 확장되거나 축소될 수 있습니다.
                
                  동적 메모리 할당의 예는 다음과 같습니다.
                    
                      자바에서는 new 키워드를 사용하여 객체를 생성할 때 동적 메모리 할당이 일어납니다. 예를 들어, new ArrayList() 를 호출하면, 자바 런타입은 필요한 메모리를 힙에서 할당하여 ArrayList 객체를 저장합니다.
                      객체 사용이 끝나면 자바의 GC가 더 이상 참조되지 않는 객체가 사용하던 메모리를 자동으로 해제합니다.
                        
                          동적 메모리 할당은 프로그램이 더 유연하고 효율적으로 동작하도록 돕지만, 관리가 제대로 이루어지지 않을 경우 메모리 누수나 성능 저하 같은 문제를 초래할 수 있습니다. 따라서 프로그래머는 동적 메모리 관리를 신중하게 수행해야 합니다.
                        
                      
                    
                  
                  GC의 주요 기능은 다음과 같습니다.
                    
                      1. 메모리 관리 자동화 : 프로그래머가 메모리 할당 및 해제를 직접 관리하는 대신 자바 런타입이 이를 자동으로 처리합니다. 이로 인해 개발자는 메모리 관리에 신경 쓰지 않고, 애플리케이션 로직 개발에 더 집중할 수 있습니다.
                      2. 메모리 누수 방지 : GC는 참조되지 않는 객체들을 정기적으로 청소하여 메모리 누수를 방지합니다. 객체가 더 이상 필요 없을 때 자동으로 메모리에서 제거됩니다.
                      3. 효율적인 메모리 사용 : 사용되지 않는 객체들을 정리함으로써 메모리를 효율적으로 사용하고, 애플리케이션의 성능을 유지할 수 있도록 도와줍니다.
                    
                  
                  GC의 작동 원리는 다음과 같습니다.
                    
                      GC은 크게 두 단계로 진행됩니다.
                        
                          1. 객체 탐지 : GC는 더 이상 어떤 객체에도 참조되지 않는 객체들을 탐지합니다. 이러한 객체들은 프로그램에서 더 이상 사용되지 않는 것으로 간주됩니다.
                          2. 메모리 회수 : 탐지된 객체들이 차지하고 있는 메모리를 해제합니다. 이 메모리는 다시 사용 가능한 상태가 되어, 새로운 객체를 위해 재할당될 수 있습니다.
                        
                      
                    
                  
                  GC 알고리즘
                    
                      자바는 다양한 GC 알고리즘을 제공합니다. 대표적인 몇 가지는 다음과 같습니다.
                        
                          Mark-and-Sweep : 사용 중인 객체를 “표시(mark)”하고, 표시되지 않은 객체를 “쓸어내는(sweep)” 방식입니다.
                          Generational GC : 객체를 세대별로 분류하여, 생성된지 얼마 되지 않은 객체들(Young Generation)과 오래된 객체들(Old Generation)을 다르게 관리합니다. 이 방식은 대부분의 객체가 생성 후 짧은 시간 내에 소멸된다는 관찰에 기반합니다.
                          Compacting : 사용 중인 객체들을 메모리의 한쪽으로 몰아넣어(Compact), 메모리의 연속성을 높이고, 메모리 단편화를 방지합니다.
                            
                              GC은 메모리 관리를 자동화하지만, 때로는 성능 저하를 일으킬 수 있습니다. 특히 GC가 실행되는 동안에는 프로그램의 다른 모든 작업이 일시적으로 중단(Stopping the world)될 수 있기 때문에, GC 동작 방식과 설정을 잘 이해하고 조절하는 것이 중요합니다.
                            
                          
                        
                      
                    
                  
                
              
            
          
        
      
    
  




JVM(Java Virtual Machine)
JVM은 자바 애플리케이션을 실행하기 위한 가상 머신으로, 자바 바이트코드를 로컬 기계 코드로 변환하여 실행하는 역할을 합니다.

  자바 바이트코드(Java Bytecode) : 자바 소스 코드가 컴파일된 후의 중간 형태입니다.
    
      자바 소스 파일(.java 파일)을 자바 컴파일러가 컴파일하면, 결과적으로 생성되는 것이 .class 파일로 저장되는 자바 바이트코드입니다.
      이 바이트코드는 기계어 코드는 아니지만, CPU가 직접 실행할 수는 없고, JVM이 이해하고 실행할 수 있는 명령어 세트로 구성되어 있습니다.
      바이트코드는 플랫폼에 독립적이기 때문에, 한 번 컴파일된 자바 프로램은 어떤 JVM이 설치된 시스템에서든 실행할 수 있습니다.
        
          이는 자바의 “한 번 작성하면, 어디서든 실행된다”라는 이점을 제공합니다.
        
      
    
  
  로컬 기계 코드(Local Machine Code) : 로컬 기계 코드는 특정 하드웨어 플랫폼의 CPU가 직접 이해하고 실행할 수 있는 명령어 코드입니다.
    
      이 코드는 플랫폼에 종속적이며, 다양한 운영 체제와 하드웨어 아키텍처는 각각의 기계어 코드를 가지고 있습니다.
      자바 바이트코드는 JVM을 통해 실행될 때, 두 가지 방법 중 하나로 실행될 수 있습니다.
        
          1. 인터프리터 : JVM은 바이트코드를 한 줄씩 읽고, 각 명령을 로컬 기계 코드로 변환하면서 실행합니다. 이 방법은 간단하지만, 실행 속도가 느릴 수 있습니다.
          2. JIT 컴파일러(Just-In-Time Compiler) : 이 방식에서는 JVM이 바이트코드 전체 또는 핵심 부분을 분석하여, 실행 전에 전체 코드를 로컬 기계 코드로 한번에 변환합니다. 이렇게 하면 프로그램의 실행 속도가 크게 향상됩니다.
            
              결국, 자바 바이트코드는 플랫폼 독립적인 중간 코드로서의 역할을 하며, 로컬 기계 코드는 실제 하드웨어에서 실행되기 위한 최종적인 코드 형태입니다. 이 두 코드의 변환과 실행은 JVM 내에서 처리되며, 사용자는 이 과정을 명시적으로 관리할 필요가 없습니다. 이것이 자바가 제공하는 큰 이점 중 하나입니다.
            
          
        
      
    
  


JVM은 자바의 “한 번 작성하면, 어디서든 실행된다(Write Once, Run Anywhere, WORA)” 라는 철학을 가능하게 하는 중요한 구성 요소입니다.

JVM 덕분에 자바 애플리케이션은 운영 체제나 하드웨어 플랫폼에 구애받지 않고 동일하게 실행될 수 있습니다.

JVM의 주요 기능.
1. 플랫폼 독립성 : 자바 프로그램은 JVM 위에서 실행되므로, JVM이 설치되어 있는 모든 운영 체제에서 같은 자바 프로그램을 실행할 수 있습니다.

  이는 JVM이 플랫폼에 특화된 코드로 바이트 코드를 변환하기 때문입니다.


2. 메모리 관리 : JVM은 자동 메모리 관리 기능을 제공합니다. 이는 GC를 통해 메모리 할당과 해제를 관리하여, 프로그래머가 메모리 누수 없이 효율적인 메모리 사용을 할 수 있도록 돕습니다.

3. 보안 : 자바 바이트코드는 JVM에 의해 검증되며 실행되기 전에 다양한 검사를 통해 안전성이 확보됩니다.

  이는 악의적인 코드 실행과 시스템 오류를 방지하는 데 도움이 됩니다.


4. 실행 환경 : JVM은 자바 애플리케이션에 필요한 실행 환경을 제공합니다.

  이 환경은 클래스 로더, 바이트코드 실행 엔진, 쓰레드 관리 등을 포함합니다.


JVM의 구성 요소.
1. 클래스 로더(Class Loader) : 클래스 파일들을 읽고 바이트코드를 JVM 메모리에 로드하는 역할을 합니다.
2. 실행 엔진(Excution Engine) : 로드된 클래스 파일의 바이트코드를 실행합니다. 이 엔진은 바이트코드를 해것하거나 필요에 따라 JTI(Just-In-Time) 컴파일러를 사용하여 바이트코드를 직접 기계 코드로 변환하여 실행 속도를 높일 수 있습니다.
3. 가비지 컬렉터(Garbage Collector) : JVM이 사용하지 않는 메모리 자원을 자동으로 회수합니다.
4. 메모리(Runtime Data Area) : JVM은 프로그램 실행을 위해 필요한 다양한 메모리 영역을 관리합니다. 이는 힙(Heap), 스택(Stack), 메소드 영역(Method Area), 프로그램 카운터(Program Counter) 등이 포함됩니다.

                        </a>
                        <div class="info-post">
                                <a href="/Backend" class="category">Backend</a>
                            
                                <span class="date">· 2024-05-01</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        
        </ul>
    
</div>
<div class="pagination">
    <nav class="pagination-container">
        <button class="pagination-button" id="prev-button" aria-label="Previous page" title="Previous page">
            &lt;
        </button>
    
        <div id="pagination-numbers"></div>
      
        <button class="pagination-button" id="next-button" aria-label="Next page" title="Next page">
            &gt;
        </button>
    </nav>
</div>
                
            </div>
        </div>
        <div id="search">
    <div class="wave"></div>
    <div class="wave"></div>
    <div class="wave"></div>

    <div class="search-box">
        <mark>Touch background to close</mark>
        <div class="input-box">
            <input id="search-input" type="search" tabindex="1" spellcheck="false" placeholder="Search...">
            <button id="btn-clear">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"></path></svg>
            </button>
        </div>
        <ul id="search-result"></ul>
    </div>
</div>
    </body>
    <script defer src="/assets/js/background.js"></script>
<script defer src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }

    gtag('js', new Date());
    gtag('config', '');
</script>
    
        <script src="/assets/js/subject.js"></script>
    
    <script src="/assets/js/common.js"></script>
    <script defer>
    var posts = [];

    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > AWS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/AWS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > CPP_DS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/CPP_DS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > CS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/CS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > DataStructure",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/DataStructure/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Database",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Database/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > HackTheSwift",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/HackTheSwift/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Leet-Code",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Leet-Code/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > MySQL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/MySQL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Network",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Network/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > OS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/OS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Read English Book",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Read%20English%20Book/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > SQL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/SQL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > TIL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/TIL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024 > Web",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/Web/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "2024",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2024/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > AWS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/AWS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > AnD",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/AnD/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > CS",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/CS/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > DB",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/DB/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > ENG",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/ENG/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Java多識",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Java%E5%A4%9A%E8%AD%98/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Math",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Math/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Network",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Network/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > Post",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/Post/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend > TIL",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/TIL/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Backend",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Backend/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Metacognition > Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Metacognition/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Metacognition",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Metacognition/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "👾 Day 1 - Variables",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift",
            'url'      : "/2024/HackTheSwift/2024-01-14-Variables.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-15"
        });
    

        posts.push({
            'title'    : "📝 스위프트에 왜 변수가 있을까?",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift, Article",
            'url'      : "/2024/HackTheSwift/2024-01-14-WhyDoseSwiftHaveVariables.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-15"
        });
    

        posts.push({
            'title'    : "📝 배열의 용량 vs 배열의 길이",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-16-ArrayCapacity-VS-Length.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-18"
        });
    

        posts.push({
            'title'    : "👾 Day 2 - String And Integers",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift, Programming",
            'url'      : "/2024/HackTheSwift/2024-01-18-StringAndIntegers.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-18"
        });
    

        posts.push({
            'title'    : "👾 Day 2 - Multi-line String",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "Swift",
            'url'      : "/2024/HackTheSwift/2024-01-18-Multi-line-String.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 기본 배열 작업",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-BasicArrayOperations.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 1(배열의 끝에 삽입하기-Inserting at the End of an Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAtTheEndOfAnArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 2(배열의 시작 부분에 삽입하기 - Inserting at the Start of an Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAtTheStartOfAnArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "📝 배열 삽입 3(배열의 아무 곳에나 삽입하기 - Inserting Anywhere in the Array)",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-19-InsertingAnywhereInTheArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-19"
        });
    

        posts.push({
            'title'    : "🆙 [LeetCode] 1089.Duplicate Zeros.",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-20-DuplicateZeros.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-20"
        });
    

        posts.push({
            'title'    : "🆙 [LeetCode] 88.Merge Sorted Array.",
            'path'     : "2024 > Leet-Code",
            'type'     : "post",
            'tags'     : "swift, algorithm, datastructure",
            'url'      : "/2024/Leet-Code/2024-01-22-MergeSortedArray.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-21"
        });
    

        posts.push({
            'title'    : "👾[Day 3] Doubles and Booleans",
            'path'     : "2024 > HackTheSwift",
            'type'     : "post",
            'tags'     : "swift, programming",
            'url'      : "/2024/HackTheSwift/2024-01-22-DoubleAndBool.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-22"
        });
    

        posts.push({
            'title'    : "🌐[Network] 웹소켓(WebSocket)",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Server, Back-end",
            'url'      : "/2024/Network/2024-01-22-webSocket.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "🌐[Network] HTTP 통신.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, HTTP",
            'url'      : "/2024/Network/2024-01-23-HTTP.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "🌐[Network] 패킷(Packet)",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-01-23-Packet.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-23"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea.",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-25-TheOldManAndTheSea.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-25"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (2).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-26-TheOldManAndTheSea2.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-26"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (3).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-27-TheOldManAndTheSea3.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-26"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (5).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-29-TheOldManAndTheSea5.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-28"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (4).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-01-28-TheOldManAndTheSea4.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-01-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수 선언.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java",
            'url'      : "/2024/Java/2024-02-01-VariableDeclaration.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-01"
        });
    

        posts.push({
            'title'    : "🌐 [AWS] IAM이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Cloud platform",
            'url'      : "/2024/AWS/post-01.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [AWS] VPC?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "VPC",
            'url'      : "/2024/AWS/post-04.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [Network, AWS] Subnet이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/2024/AWS/post-03.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "🌐 [Network, AWS] Routing Table이란?",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "Network, AWS",
            'url'      : "/2024/AWS/post-02.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-02"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (6).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-02-03-TheOldManAndTheSea6.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-03"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크 기초 용어.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-03-networkBasicTerm1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-04"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 컬럼명 변경, 순서변경, 타입변경, 추가.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-05-COLUMN1.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-05"
        });
    

        posts.push({
            'title'    : "🌐[Network] 시스템(System).",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-05-system.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "🌐[Network] 인터페이스(Interface).",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-05-interface.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "📚[Book] The old man and the sea (7).",
            'path'     : "2024 > Read English Book",
            'type'     : "post",
            'tags'     : "English, Book",
            'url'      : "/2024/Read%20English%20Book/2024-02-06-TheOldMadAndTheSea7.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "☕️[JAVA] Packaing 옵션.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "JAVA, Programming language",
            'url'      : "/2024/Java/2024-02-06-JavaFormat.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-06"
        });
    

        posts.push({
            'title'    : "☕️[JAVA] while문과 for문.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, programming language",
            'url'      : "/2024/Java/2024-02-07-loop.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스코프 존재 이유 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming language",
            'url'      : "/2024/Java/2024-02-07-scope1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-07"
        });
    

        posts.push({
            'title'    : "🌐[Network] 전송매체.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-08-TransmissionMedia.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 형변환 정리.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-09-typecasting.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-09"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 라이브러리 살펴보기",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framwork",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-09-springFramework1.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-09"
        });
    

        posts.push({
            'title'    : "🌐[Network] 프로토콜.",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-10-protocol.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "2024-02-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 향상된 for문",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-11-foreach.html",
            'image'    : "/assets/img/thumbnail/forloop.jpeg",
            'date'     : "2024-02-11"
        });
    

        posts.push({
            'title'    : "🍃[Spring Boot] 스프링?",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring Boot, Framework, Spring",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-13-Spring.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드(2)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-method2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드정의",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-method3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 반환타입.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-methodReturnType.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-13-methodStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 리펙토링 - 입.출금",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-14-JavaRefAccount1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-14"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-14-aboutNetwork.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-14"
        });
    

        posts.push({
            'title'    : "💾[Database] DBMS의 분류",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/2024/Database/2024-02-15-classificationOfDBMS.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "💾[Database] 데이터베이스의 정의와 특징",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/2024/Database/2024-02-15-databaseDefinition.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 파트 정리.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-15-methodSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스가 필요한 이유.",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-15-whyWeNeedClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 인터넷",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Internet",
            'url'      : "/2024/Network/2024-02-15-internet.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 표준화",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network, Standardization",
            'url'      : "/2024/Network/2024-02-15-standardization.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Route 53에 등록된 서브도메인 github page에 연결하기",
            'path'     : "2024 > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/2024/AWS/post-05.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "💾[Database] SQL의 개요",
            'path'     : "2024 > Database",
            'type'     : "post",
            'tags'     : "Database, SQL",
            'url'      : "/2024/Database/2024-02-16-IntroSQL.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-classIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스, 객체, 인스턴스 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-termSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 사용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-16-useObject.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] MySQL Server Start/Stop",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-16-trobleshootingMysql1.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 배열 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-17-arrayIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🍃[Spring] MVC와 템플릿 엔진",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-17-mvcAndTemplateEngine.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🍃[Spring] 정적 컨텐츠",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-17-staticContent.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-17"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 테이블에 데이터 입력 INSERT INTO",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-InsertInto.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] null 컬럼 변경하기.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-nullColumn.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] SELECT 조회 결과 LIMIT 1000 ROW 해제하기.",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-18-selectAndLimit.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🐋[MySQL] 테이블 삭제하기",
            'path'     : "2024 > MySQL",
            'type'     : "post",
            'tags'     : "MySQL",
            'url'      : "/2024/MySQL/2024-02-19-drop.html",
            'image'    : "/assets/img/thumbnail/mysql.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "🍃[Spring] API",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-18-apiSummary.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 배열 도입 - 리팩토링",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-19-arrayIntro-refactoring.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(1)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-20-referenceAndPrimitive.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(2) - 변수 대입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-20-referenceAndPrimitive2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] null",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-null.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형(3) - 메서드 호출",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-referenceAndPrimitive3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 참조형과 메서드 호출 - 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-referenceTypesAndMethodCalls.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 초기화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-21-variableAndInit.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "🌐[Network] 시스템의 구분",
            'path'     : "2024 > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/2024/Network/2024-02-21-systemClassification.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "🍃[Spring] Gradle과 Maven",
            'path'     : "2024 > Spring & Spring Boots",
            'type'     : "post",
            'tags'     : "Spring, Framework, Build System",
            'url'      : "/2024/Spring%20&%20Spring%20Boots/2024-02-21-buildSystem.html",
            'image'    : "/assets/img/thumbnail/spring.jpeg",
            'date'     : "2024-02-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] NullPointerException",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-22-NullPointerException.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(1)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-22-procedure-oriented-programming(1).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 지향 프로그래밍 vs 절차 지향 프로그래밍",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-OOPvsPOPsummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 메서드",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-classAndMethod.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 객체 지향 프로그래밍",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-object-oriented-programming.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(2)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-procedure-oriented-programming(2).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 절차 지향 프로그래밍(3)",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-23-procedure-oriented-programming(3).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 필요한 이유",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-init(1).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-init(2).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] this",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-24-this.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-24"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본 생성자",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-init(3).html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 생성자 - 오버로딩 this()",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-initOverloadingAndThis.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 - import",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-packageImport.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 - 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-25-packageStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 규칙",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-26-ruleOfpackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-26"
        });
    

        posts.push({
            'title'    : "☕️[Java] 패키지 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-26-usesOfPackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-26"
        });
    

        posts.push({
            'title'    : "🆙[Cpp DataStructure] 교환(Swap)과 정렬(Sort)",
            'path'     : "2024 > CPP_DS",
            'type'     : "post",
            'tags'     : "Cpp, DataStructure",
            'url'      : "/2024/CPP_DS/2024-02-27-SwapAndSort.html",
            'image'    : "/assets/img/thumbnail/cpp.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자 이해 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-27-accessModifier-1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자 이해 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-27-accessModifier-2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 종류",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 사용 - 필드, 메서드",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-4.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] 접근 제어자의 사용 - 클래스 레벨",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-02-28-accessModifier-5.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-02-28"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터의 구성",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-02-29-cs.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-02-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] 캡슐화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-01-Encapsulation.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 메모리 구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-JavaMemoryStructure.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택 영역",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-Stack.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택 영역과 힙 영역",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-StackAndHeap.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스택과 큐 자료구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-03-StackAndQueue.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-04-static1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-04-staticVariable1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticMethod1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticMethod2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticVariable2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 변수3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-05-staticVariable3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] static 메서드 3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-06-staticMethod3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-06"
        });
    

        posts.push({
            'title'    : "🆙[Cpp DataStructure] 안정성(stability) 확인",
            'path'     : "2024 > CPP_DS",
            'type'     : "post",
            'tags'     : "Cpp, DataStructure",
            'url'      : "/2024/CPP_DS/2024-03-07-stableAndUnstable.html",
            'image'    : "/assets/img/thumbnail/cpp.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 상수 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndConstant1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 상수 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndConstant2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] final 변수와 참조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-07-finalVariableAndReference.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 기능 추가",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-InheritanceAndAddingFeatures.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 메모리 구조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-InheritanceAndMemoryStructure.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속관계",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-extendRelationship.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속 - 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-08-extendStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 메서드 오버라이딩",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-09-InheritanceAndMethodOverriding.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속과 접근 제어",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-10-inheritanceAndAccessControl.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 메서드에 사용되는 final",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-finalUsedInClassesAndMethods.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] super - 부모 참조",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-super.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] super - 생성자",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-13-super2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-13"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 구조를 알아야 하는 이유",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-14-WhyYouNeedToKnowComputerArchitecture.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "💾 [CS] 패턴 매칭(Pattern Matching)과 표현 매칭(Expression Matching)",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-14-patternMatchingAndExpressionMatching.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성과 캐스팅",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-14-polymorphismAndCasting.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성(Polymorphism) 시작",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-14-polymorphismStart.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-14"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다운캐스팅과 주의점",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-DowncastingAndPrecaution.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 캐스팅의 종류",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-TypesOfCasting.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] instanceof",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-15-instanceof.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성과 메서드 오버라이딩",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-17-polymorphismAndMethodOverriding.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-17"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 구조의 큰 그림",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-18-TheBigPictureOfComputerArchitecture.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-18-TakeAdvantageOfPolymorphism2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-18"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 활용3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-19-TakeAdvantageOfPolymorphism3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상 클래스 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-20-AbstractClass1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상 클래스 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-20-AbstractClass2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-20"
        });
    

        posts.push({
            'title'    : "💾 [CS] 0과 1로 숫자를 표현하는 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-21-HowToRepresentNumbersWithZeroAndOne.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "💾 [CS] 컴퓨터 메모리를 16진수로 표시하는 이유",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-21-whyIsComputerMemoryExpressedInhex.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-21-Interface.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스 - 다중구현",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-22-Interface-MultipleImplementation.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 인터페이스 활용",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-22-UsingClassesAndInterfaces.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-22"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-23-Polymorphism-RoleImplementatioonExample1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 좋은 객체 지향 프로그래밍이란?",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-23-WhatIsGoodOOP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-23"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-24-Polymorphism-RoleImplementatioonExample2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-24"
        });
    

        posts.push({
            'title'    : "💾 [CS] 0과 1로 문자를 표현하는 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-03-25-HowToRepresentCharactersWithZeroAndOne.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] OCP(Open-Closed Principle) 원칙",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-25-OCP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성 - 역할 구현 예제 3",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-25-Polymorphism-RoleImplementatioonExample3.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-25"
        });
    

        posts.push({
            'title'    : "💉[SQL] 데이터베이스 모델링",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-27-DatabaseModeling.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "💉[SQL] 테이블과 컬럼, SQL",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-27-TableColumnsAndSQL.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "🌐[Web] 웹 브라우저 작동 원리",
            'path'     : "2024 > Web",
            'type'     : "post",
            'tags'     : "Web",
            'url'      : "/2024/Web/2024-03-27-HowWebBrowsersWork.html",
            'image'    : "/assets/img/thumbnail/sparta.jpg",
            'date'     : "2024-03-27"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-28-ObjectClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] java.lang 패키지 소개",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-28-java-langPackage.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 배열",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-ObjectArray.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 다형성",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-ObjectPolymorphism.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "☕️[Java] toString()",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-29-toString.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "💉[SQL] WHERE란?",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-29-WHERE.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-29"
        });
    

        posts.push({
            'title'    : "💉[SQL] AND, OR, NOT",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-30-ANDORNOT.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-30"
        });
    

        posts.push({
            'title'    : "💉[SQL] BETWEEN, IN, LIKE",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-30-BETWEENINLIKE.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-30"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object와 OCP",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-31-ObjectAndOCP.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] equals() - 1.동일성과 동등성",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-03-31-equals1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "💉[SQL] SQL 문의 기본 구조, SQL",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-03-31-sql.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-03-31"
        });
    

        posts.push({
            'title'    : "💾 [CS] 소스코드와 명령어",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-01-SourceCodeAndCommands.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] equals() - 2. 구현",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-01-equals2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "💉[SQL] SUM, AVG, COUNT, MIN, MAX",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-01-SUMAVGCOUNTMINMAX.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "💉[SQL] Query 작성시 플로우",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-01-sqlFlow.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 기본형과 참조형의 공유",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-02-SharingOfBasicTypesAndReferenceTypes.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "💉[SQL] GROUP BY",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-02-GROUPBY.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "💉[SQL] ORDER BY",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-02-ORDERBY.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 도입",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-03-ImmutableObjectsIntroduction.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 공유 참조와 사이드 이펙트",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-03-SharedReferencesAndSideEffects.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-03"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어의 구조",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-04-commandStructure.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 예제",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-04-ImmutableObjectExample.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "💉[SQL] REPLACE, SUBSTRING, CONCAT",
            'path'     : "2024 > SQL",
            'type'     : "post",
            'tags'     : "SQL",
            'url'      : "/2024/SQL/2024-04-04-ReplaceSubstringConcat.html",
            'image'    : "/assets/img/thumbnail/sql.jpeg",
            'date'     : "2024-04-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 값 변경",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-05-ImmutableObjectChangeValue.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 불변 객체 - 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-05-ImmutableObjectSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 기본",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-06-StringClassBasic.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-06"
        });
    

        posts.push({
            'title'    : "💾 [CS] ALU와 제어장치",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-08-ALUandControlUnit.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 비교",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-08-StringClassComparison.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 불변객체",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-09-StringClassImmutableObject.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 주요 메서드 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-09-StringClassMethod-1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] StringBuilder - 가변 String",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-10-StringBuilder.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 주요 메서드 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-10-StringClassMethod2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-10"
        });
    

        posts.push({
            'title'    : "💾 [CS] 레지스터",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-11-register.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 메서드 체이닝 - Method Chaining",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-11-MethodChaining.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 최적화",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-11-StringOptimization.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] String 클래스 - 정리",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-14-StringClassSummary.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-14"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어 사이클과 인터럽트",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-15-InstructionCycleAndIntrrupts.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 기본형의 한계 1",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-15-WrapperClass-LimitationsOfBaseTypes1.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240415 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-15-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 오토 박싱",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-AutoBoxing.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 자바 래퍼 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-JavaWrapperClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 기본형의 한계 2",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-17-WrapperClass-LimitationOfBaseTypes2.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240417 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 래퍼 클래스 - 주요 메서드와 성능",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-18-WrapperClass-MainMethodsAndPerformance.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240418 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-18"
        });
    

        posts.push({
            'title'    : "💾 [CS] 빠른 CPU를 위한 설계 기법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-19-DesignTechniquesForFastCPUs.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "💾 [CS] 명령어 병렬 처리 기법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-19-InstructionParallelProcessingTechnique.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] Class 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-19-Class.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "☕️[Java] System 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-19-SystemClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240419 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-19-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-19"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 변수",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 복합 자료 구조",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 배열",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-21-DataStructure3.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-21"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 문자열",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-22-DataStructure-2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 삽입 정렬",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-22-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "💻[Operating System] 커널(kernel)이란?",
            'path'     : "2024 > OS",
            'type'     : "post",
            'tags'     : "Operating System",
            'url'      : "/2024/OS/2024-04-22-OS-2.html",
            'image'    : "/assets/img/thumbnail/os.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "💻[Operating System] 리눅스와 우분투의 차이점",
            'path'     : "2024 > OS",
            'type'     : "post",
            'tags'     : "Operating System",
            'url'      : "/2024/OS/2024-04-22-OS.html",
            'image'    : "/assets/img/thumbnail/os.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240422 Today I Learned.",
            'path'     : "2024 > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/2024/TIL/2024-04-22-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-04-22"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 문제 정의와 선형 스캔",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-23-DataStructure-2.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-23"
        });
    

        posts.push({
            'title'    : "📦[DataStructure] 변수와 배열이 중요한 이유와 이진 탐색",
            'path'     : "2024 > DataStructure",
            'type'     : "post",
            'tags'     : "DataStructure",
            'url'      : "/2024/DataStructure/2024-04-23-DataStructure.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-04-23"
        });
    

        posts.push({
            'title'    : "💾 [CS] CISC와 RISC",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-04-25-CISCandRISC.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-04-25"
        });
    

        posts.push({
            'title'    : "☕️[Java] Math, Random 클래스",
            'path'     : "2024 > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language",
            'url'      : "/2024/Java/2024-04-26-MathAndRandomClass.html",
            'image'    : "/assets/img/thumbnail/java.jpeg",
            'date'     : "2024-04-26"
        });
    

        posts.push({
            'title'    : "[AnD] 두 수의 합.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "Algorithm, DataStructure",
            'url'      : "/Backend/AnD/2024-05-01-AnD-1.html",
            'image'    : "/assets/img/thumbnail/AnD.jpeg",
            'date'     : "2024-05-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바란?",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-01-AboutJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 소개",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-IntroJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 코테 맛보기(1) - 코테를 위한 자바 프로그래밍 언어 사용 숙련도",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-TasteTheCodingTest-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 코테 맛보기(2) - 코테를 위한 자료구조와 알고리즘 개념 구현 방법 숙지",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-TasteTheCodingTest-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 변수와 자료형(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-02-VariablesAndDataTypes-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "[Math] 기초수학 - 소개",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-02-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240502 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-02-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] 타입 비교.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-03-TypeComparison.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 자바 - 변수와 자료형(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-03-VariablesAndDataTypes-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 자료형(3)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-03-VariablesAndDataTypes-3.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240503 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-03-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-03"
        });
    

        posts.push({
            'title'    : "☕️[Java] 변수와 자료형(4)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-04-VariablesAndDataTypes-4.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-04"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240504 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-04-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] 여러가지 연산자(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-05-VariousOperator-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 여러가지 연산자(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-05-VariousOperators-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "☕️[Java] 조건문",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-05-conditionalStatement.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240505 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-05-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-05"
        });
    

        posts.push({
            'title'    : "💾 [CS] 메모리의 주소 공간",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-06-addressSpaceInMemory.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "☕️[Java] 반복문",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-06-loopStatement.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240506 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-06-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-06"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 객체(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-07-ClassesAndObjects-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다차원 배열",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-07-MultidimensionalArray.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240507 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-07-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 클래스와 객체(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-08-ClassesAndObjects-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-08"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240508 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-08-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] 상속",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-09-Inheritance.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-09"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240509 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-09-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 추상클래스",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-10-abstractClass.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-10-polymorphism.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240510 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-10-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-10"
        });
    

        posts.push({
            'title'    : "☕️[Java] 내부 클래스",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-11-InnerClass.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 입출력(1)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-11-Input-Output-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 인터페이스",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-11-Interface.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "📝[blog post] 프론트엔드와 백엔드는 무엇이 다를까?(+내가 백엔드 개발자가 되고 싶은 이유)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "제로베이스, 백엔드, Java, Spring, 개발자, 백엔드공부, 백엔드스쿨",
            'url'      : "/Backend/Post/2024-05-11-DifferenceFrontendAndBackend.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240511 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-11-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-11"
        });
    

        posts.push({
            'title'    : "☕️[Java] 예외 처리",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-12-ExceptionHandling.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 입출력(2)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-12-Input-Ouput-2.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240512 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-12-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-12"
        });
    

        posts.push({
            'title'    : "☕️[Java] 컬렉션 프레임워크",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-CollectionFramework.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] HashMap에 key 값은 항상 int 여야 할까요?",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-KeyValueInHashMapAlwaysBeInt.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 람다식",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-lambda.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 람다식은 하나만!",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-13-lambdaIsOnlyOne.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240513 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-13-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-13"
        });
    

        posts.push({
            'title'    : "☕️[Java] 스트림",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-14-Stream.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-14"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240514 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-14-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-14"
        });
    

        posts.push({
            'title'    : "📝[blog post] 연습 문제 풀이 정리(1)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging",
            'url'      : "/Backend/Post/2024-05-16-PracticeSummary-1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-16"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240516 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-16-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-16"
        });
    

        posts.push({
            'title'    : "☕️[Java] 예외 처리 - 트러블슈팅",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-17-ExceptionHandling-Troubleshooting.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "📝[blog post] 연습 문제 풀이 정리(2)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging",
            'url'      : "/Backend/Post/2024-05-17-PracticeSummary-2.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240517 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-17"
        });
    

        posts.push({
            'title'    : "☕️[Java] 문자열 비교 - 트러블슈팅",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-05-18-Troubleshooting-1.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-18-Math-1.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "[Math] 수학적 귀납법",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-05-18-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "📝[blog post] 나는 어떤 백엔드 개발자가 되고 싶은걸까?",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "제로베이스, 백엔드, Java, Spring, 개발자, 백엔드공부, 백엔드스쿨",
            'url'      : "/Backend/Post/2024-05-18-WhatKindOfBackendDevDoIWantToBe.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240518 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-18"
        });
    

        posts.push({
            'title'    : "💾 [CS] RAID의 정의와 종류",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-21-RAID.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 자료구조 소개",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-21-IntroDataStructureAndAlgorithm.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 선형 자료구조 - 배열",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-21-linearDS-Array.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240521 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-21-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-21"
        });
    

        posts.push({
            'title'    : "💾 [CS] 다양한 보조기억장치",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-22-VariousAuxiliaryMemoryDevices.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-22"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240522 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-22-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-22"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 큐(Queue)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-23-Queue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 원형 큐(Circular Queue)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-23-circularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240523 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-23-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-23"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 해시(Hash)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-24-Hash.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-24"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240524 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-24-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-24"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 해시 테이블(Hash Table)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-25-HashTable.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-25"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240525 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-25-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-25"
        });
    

        posts.push({
            'title'    : "💾 [CS] 장치 컨트롤러와 장치 드라이버",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-27-dviceControllerAndDeviceDriver.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 이진 트리(Binary Tree)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-BinaryTree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 완전 이진 트리(Complete Binary Tree)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-CompleteBinaryTree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 노드(Node)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-Node.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 트리(Tree)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-27-Tree.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240527 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-27-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-27"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 스택(Stack)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-28-Stack.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-28"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240528 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-28-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-28"
        });
    

        posts.push({
            'title'    : "💾 [CS] 다양한 입출력 방법",
            'path'     : "2024 > CS",
            'type'     : "post",
            'tags'     : "CS",
            'url'      : "/2024/CS/2024-05-30-VariousInputOutputMethods.html",
            'image'    : "/assets/img/thumbnail/cs.jpeg",
            'date'     : "2024-05-29"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240529 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-29-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-29"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 큐(Queue)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-05-30-Queue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-05-30"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240530 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-05-30-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-05-30"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 배열에서 특정 인덱스의 요소를 삭제하기.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-01-RemoveSpecificIndexFromArray.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-01"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240601 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-01-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-01"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Java의 배열.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-02-ArrayOfJava.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "📝[blog post] Java Docs 보는 방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend, blogging, Documentation",
            'url'      : "/Backend/Post/2024-06-02-HowToReadJavaDocs.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240602 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-02-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-02"
        });
    

        posts.push({
            'title'    : "☕️[Java] IntStream",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-03-IntStream.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-03"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240603 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-03-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-03"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Deque(데크, 덱)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-05-Deque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-05"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240605 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-05-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-05"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] ArrayDeque",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-06-ArrayDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-06"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240606 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-06-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-06"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] LinkedList를 사용한 Deque.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-07-LinkedListDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-07"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240607 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-07-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-07"
        });
    

        posts.push({
            'title'    : "☕️[Java] 제네릭(Generic)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-08-Generic.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "☕️[Java] Primitive Type과 Wrapper Class.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-08-PrimitiveAndWrapper.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240608 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-08-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-08"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)란?",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-09-CircularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "☕️[Java] 다형성(Polymorphism)",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-09-polymorphism.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240609 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-09-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-09"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Deque에서의 front와 rear의 변화.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-10-ChangeBetweenFrontAndRearInDeque.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-10"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240610 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-10-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-10"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240611 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-11-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-11"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)의 중간 지점 찾기.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-12-CircularQueueFindMiddleIndex.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-12"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240612 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-12-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-12"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] 알고리즘(Algorithm)",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-13-AboutAlgorithm.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📦[DS,Algorithm] Circular Queue(원형 큐)를 배열로 구현시 rear를 -1으로 설정하지 않는 이유.",
            'path'     : "Backend > AnD",
            'type'     : "post",
            'tags'     : "DataStructure, Algorithm",
            'url'      : "/Backend/AnD/2024-06-13-ReasonOfRearIsntSetToMinusOneInCircularQueue.html",
            'image'    : "/assets/img/thumbnail/ds.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240613 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-13-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-13"
        });
    

        posts.push({
            'title'    : "📚[ENG] 240616 Studing English through Newsletters",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study, Newsletters",
            'url'      : "/Backend/ENG/240616-ENG-STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-16"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240616 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-16-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-16"
        });
    

        posts.push({
            'title'    : "💭 [Metacognition] 240616 JAVA의 정석",
            'path'     : "Metacognition > Java",
            'type'     : "post",
            'tags'     : "Metacognition, Java",
            'url'      : "/Metacognition/Java/2024-06-16-Meta-Java-PrimitiveType.html",
            'image'    : "/assets/img/thumbnail/META.jpg",
            'date'     : "2024-06-16"
        });
    

        posts.push({
            'title'    : "[Math] 명제와 증명 - 논리적 사고의 기초: 필요조건과 충분 조건.",
            'path'     : "Backend > Math",
            'type'     : "post",
            'tags'     : "Math",
            'url'      : "/Backend/Math/2024-06-17-Math.html",
            'image'    : "/assets/img/thumbnail/Math.jpeg",
            'date'     : "2024-06-17"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240617 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-17-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-17"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 클라우드 컴퓨팅의 유형",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240615_Types_of_Clould_Computing.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📚[ENG] 제목만 해석하는 영어 공부 :) ",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study",
            'url'      : "/Backend/ENG/240618_ENG_STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📝 [TIL] 240618 Today I Learned.",
            'path'     : "Backend > TIL",
            'type'     : "post",
            'tags'     : "TIL",
            'url'      : "/Backend/TIL/2024-06-18-TIL.html",
            'image'    : "/assets/img/thumbnail/TIL.jpeg",
            'date'     : "2024-06-18"
        });
    

        posts.push({
            'title'    : "📚[ENG][240621] 제목만 해석하는 영어 공부 :)",
            'path'     : "Backend > ENG",
            'type'     : "post",
            'tags'     : "English, Study",
            'url'      : "/Backend/ENG/240621-ENG-STUDY.html",
            'image'    : "/assets/img/thumbnail/ENG.jpg",
            'date'     : "2024-06-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] 프로그래밍 언어와 자바",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-06-24-ProgrammingLanguageAndJava.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-06-24"
        });
    

        posts.push({
            'title'    : "📝[Post] 서버와 클라이언트의 개념(1)",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-06-27-ServerAndClient-1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-06-27"
        });
    

        posts.push({
            'title'    : "☁️[AWS] HOSTNAME 바꾸는 방법",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240709_AWS_HOSTNAME.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-09"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023 플랫폼에 MySQL 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240710_AWS_MYSQL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-10"
        });
    

        posts.push({
            'title'    : "📝[Post] Spring과 SpringBoot의 개념.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-07-11-SpringAndSpringBoot.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-11"
        });
    

        posts.push({
            'title'    : "☁️[AWS] .gradlew 빌드 실패시 확인해야 할 것들",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240714_AWS_GRADLEW.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-14"
        });
    

        posts.push({
            'title'    : "💾[Database] 데이터베이스의 정의와 특징.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/Backend/DB/2024-07-15-definitionAndCharacteristicsOfDatabase.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-07-15"
        });
    

        posts.push({
            'title'    : "☕️[Java] 프로그래밍 언어와 자바",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-16-Variable.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-16"
        });
    

        posts.push({
            'title'    : "📝[Post] 자바다식(Java多識) - 1",
            'path'     : "Backend > Java多識",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no1.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-19"
        });
    

        posts.push({
            'title'    : "📝[Post] 자바다식(Java多識) - 2",
            'path'     : "Backend > Java多識",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Java%E5%A4%9A%E8%AD%98/2024-07-19-no2.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023에 Java8 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240726_AWS_JAVA_INSTALL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-07-26"
        });
    

        posts.push({
            'title'    : "💾[Database] MySQL DB에 한글 삽입.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database, MySQL",
            'url'      : "/Backend/DB/2024-07-26-korean-mysql.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-07-26"
        });
    

        posts.push({
            'title'    : "📝[Post] 아이피와 포트",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-07-28-ipAndport.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-07-28"
        });
    

        posts.push({
            'title'    : "☕️[Java] @EntityListeners 어노테이션.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-31-EntityListeners.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] Main 클래스 생성 후 오류 대처.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-31-MainBuildFail.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "☕️[Java] attribute의 의미와 역할",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-07-31-attribute.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-07-31"
        });
    

        posts.push({
            'title'    : "💾[Database] 트랜잭션의 의미와 역할.",
            'path'     : "Backend > DB",
            'type'     : "post",
            'tags'     : "Database",
            'url'      : "/Backend/DB/2024-08-01-Transaction.html",
            'image'    : "/assets/img/thumbnail/database.jpeg",
            'date'     : "2024-08-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] ObjectMapper 클래스, 직렬화와 역직렬화",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-08-01-SerializationAndDeserialization.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-01"
        });
    

        posts.push({
            'title'    : "☕️[Java] @Transactional의 역할과 의미.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-08-02-Transactional.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-02"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2에 Java8 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240804_AWS_JAVA8_INSTALL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-04"
        });
    

        posts.push({
            'title'    : "☕️[Java] @RequiredArgsConstructor의 역할.",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-08-05-RequiredArgsConstructor.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-05"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 클라우드(Cloud)란?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240807_AWS_CLOUD.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 온프레미스(on-premise)란?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240807_AWS_ON-PREMISE.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "📝[Post] 정적 웹사이트와 동적 웹사이트.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-07-webpage.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-07"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 로컬 파일을 EC2 서버에 올리는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240809_AWS_EC2_UPLOAD.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-09"
        });
    

        posts.push({
            'title'    : "🌐[Network] CIDR이란?",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-09-network-cidr.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-09"
        });
    

        posts.push({
            'title'    : "📝[Post] Nginx 설치방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-11-Nginx.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-11"
        });
    

        posts.push({
            'title'    : "🌐[Network] IP주소(Address)는 네트워크의 번지(주소)",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-14-network-ip.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-14"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 서비스 제공 형태에 따른 클라우드 분류.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/2024_08_15_AWS_CLOULD_CLASSIFICATION.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Bastion Host란?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_BASTION_HOST.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 인바운드 규칙(Inbounds Rules)와 아웃바운드 규칙(Outbound Rules)",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_RULES.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 서버리스, 개방형 클라우드와 폐쇄형 클라우드",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_ServerlessAndOpenAndClosedClould.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 가상화",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240815_AWS_Virtualization.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크 기초 용어.",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-15-network-basic-term.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-15"
        });
    

        posts.push({
            'title'    : "☁️[AWS] CIDR(Classless Inter-Domain Routing) 블록으로 IP 주소 범위 결정.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_CIDR_BLOCK.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 도메인 이름과 IP 주소를 연결하는 DNS.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_DNS.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 방화벽에서 허용된 통신만 통과.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_FIREWALL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] IP 주소(Address)는 네트워크의 번지(주소)",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_IP_ADDRESS.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 부하 분산을 위해 여러 서버에 접속을 분배",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_LOAD_BALANCER.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 퍼블릭 IP 주소와 프라이빗 IP 주소",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_PUBLIC_IP_AND_PRIVATE_IP.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 라우팅 및 라우팅 테이블.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_Routing_And_Routing_Table.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "🌐[Network] 시스템 기초 용어.",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-16-system-basic-term.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-16"
        });
    

        posts.push({
            'title'    : "🌐[Network] OSI 7계층 모델.",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-18-OSI.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-18"
        });
    

        posts.push({
            'title'    : "🌐[Network] 구조적 모델",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-18-structural-model.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-18"
        });
    

        posts.push({
            'title'    : "📝[Post] OpenVPN 클라이언트의 IP 주소와 OpenVPN 서버에서 할당된 서브넷 정보 가져오는 방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-16-openvpn-client-ip.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-18"
        });
    

        posts.push({
            'title'    : "📝[Post] OpenVPN Password 변경방법.",
            'path'     : "Backend > Post",
            'type'     : "post",
            'tags'     : "Post, Backend",
            'url'      : "/Backend/Post/2024-08-18-openvpn-change-passwd.html",
            'image'    : "/assets/img/thumbnail/blog.jpeg",
            'date'     : "2024-08-18"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023에 nvm 설치와 node.js 버전 바꾸는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240816_AWS_NVM.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] NAT 게이트웨이.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_NAT_GATEWAY.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux 2023에 Nginx 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_Nginx_FireWalld.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 라우팅 정보를 설정해 인터넷과 통신.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_ROUTING_INFO.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 서브넷?",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_SUBNET.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 테넌시(Tenancy)",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_TENANCY.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] 가상 네트워크 Amazon VPC",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_VPC.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] VPC 접근 제어 및 통신 로그 확인.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_VPC_ACCESS_CONTROL.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] VPC 및 서브넷 생성.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240819_AWS_VPC_AND_SUBNET.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "🌐[Network] 네트워크 세그먼트(Network Segment).",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-19-Network-Segment.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "🌐[Network] 프로토콜과 인터페이스(Protocol and Interface)",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-19-protocol-and-interface.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-19"
        });
    

        posts.push({
            'title'    : "☁️[AWS] Amazon Linux CLI에 Gradle 설치하는 방법.",
            'path'     : "Backend > AWS",
            'type'     : "post",
            'tags'     : "AWS, Network",
            'url'      : "/Backend/AWS/240820_AWS_INSTALL_GRADLE.html",
            'image'    : "/assets/img/thumbnail/aws.jpeg",
            'date'     : "2024-08-20"
        });
    

        posts.push({
            'title'    : "🌐[Network] 인터넷의 계층 모델",
            'path'     : "Backend > Network",
            'type'     : "post",
            'tags'     : "Network",
            'url'      : "/Backend/Network/2024-08-20-Internet-layer-model.html",
            'image'    : "/assets/img/thumbnail/network.jpeg",
            'date'     : "2024-08-20"
        });
    

        posts.push({
            'title'    : "☕️[Java] java.lang 패키지",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-08-21-Java-lang.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-21"
        });
    

        posts.push({
            'title'    : "☕️[Java] Object 클래스",
            'path'     : "Backend > Java",
            'type'     : "post",
            'tags'     : "Java, Programming Language, Backend",
            'url'      : "/Backend/Java/2024-08-21-Object-Class.html",
            'image'    : "/assets/img/thumbnail/JV.jpeg",
            'date'     : "2024-08-21"
        });
    

    searchPost(posts);

    
</script>
</html>

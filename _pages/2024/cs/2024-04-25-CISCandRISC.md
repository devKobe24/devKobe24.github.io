---
title: "💾 [CS] CISC와 RISC"
tags:
    - CS
date: "2024-04-25"
thumbnail: "/assets/img/thumbnail/cs.jpeg"
---

# CISC와 RISC.

명령어 파이프라이닝과 슈퍼스칼라 기법을 실제로 CPU에 적용하려면 명령어가 파이프라이닝에 최적화되어 있어야 합니다.
쉽게 말해 CPU가 파이프라이닝과 슈퍼스칼라 기법을 효과적으로 사용하려면 CPU가 인출하고 해석하고 실행하는 명령어가 파이프라이닝 하기 쉽게 생겨야 합니다.

- '파이프라이닝 하기 쉬운 명령어'란 무엇일까요?
- 명령어가 어떻게 생겨야 파이프라이닝에 유리할까요?
    - 이와 관련해 CPU의 언어인 **ISA**와 각기 다른 성격의 ISA를 기반으로 설계된 **CISC**와 **RISC**를 알아봅시다.

## 명령어 집합
세상에는 수많은 CPU 제조사들이 있고, CPU마다 규격과 기능 만듦새가 다 다릅니다.
그러므로 CPU가 이해하고 실행하는 명령어들이 다 똑같지 않습니다.
- 물론 명령어의 기본적인 구조와 작동원리는 큰 틀에서 크게 벗어나지 않습니다.
    - 그러나 명령어의 세세한 생김새, 명령어로 할 수 있는 연산, 주소 지정 방식 등은 CPU마다 조금씩 차이가 있습니다.

- **명령어 집합(instruction set)** 또는 **명령어 집합 구조(ISA: Instruction Set Architecture) :** CPU가 이해할 수 있는 명령어들의 모음.
    - CPU마다 ISA가 다를 수 있습니다.

> 명령어 집합에 '구조'라는 단어가 붙은 이유는 CPU가 어떤 명령어를 이해하는지에 따라 컴퓨터 구조 및 설계 방식이 달라지기 때문입니다.

가령 인텔의 노트북 속 CPU는 x86 혹은 x86-64 ISA를 이해하고, 애플의 아이폰 속 CPU는 ARM ISA를 이해합니다.
- x86(x86-64)과 ARM은 다른 ISA이기 때문에 인텔 CPU를 사용하는 컴퓨터와 아이폰은 서로의 명령어를 이해할 수 없습니다.
    - 실행 파일은 명령어로 이루어져 있고 서로의 컴퓨터가 이해할 수 있는 명령어가 다르기 때문입니다.

> x86은 32비트용, x86-64는 64비트용 x86 ISA입니다.

어셈블리어는 명령어를 읽기 편하게 표현한 언어입니다.
- ISA가 다르다는 건 CPU가 이해할 수 있는 명령어가 다르다는 뜻입니다.
    - 명령어가 달라지면 어셈블리어도 달라집니다.
        - 다시 말해 같은 소스 코드로 만들어진 같은 프로그램이라 할지라도 ISA가 다르면 CPU가 이해할 수 있는 명령어도 어셈블리어도 달라진다는 것입니다.

예를 들어 보겠습니다.
- 동일한 소스 코드를 작성하고 ISA가 다른 컴퓨터에서 어셈블리어로 컴파일하면 아래와 같은 결과를 얻을 수 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%89%E1%85%A9%E1%84%89%E1%85%B3%E1%84%83%E1%85%A1%E1%84%85%E1%85%B3%E1%86%ABISA.png?raw=true">

- 왼쪽은 x86-64 ISA, 오른쪽은 ARM ISA입니다.
    - 똑같은 코드로 만든 프로그램임에도 CPU가 이해하고 실행할 수 있는 명령어가 달라 어셈블리어도 다른 것을 알 수 있습니다.
    - 참고로 사용한 컴파일러에 따라서도 어셈블리어가 달라질 수 있는데, 위 예시에서는 gcc 11.2라는 동일한 컴파일러를 이용했습니다.

ISA가 같은 CPU끼리는 서로의 명령어를 이해할 수 있지만, ISA가 다르면 서로의 명령어를 이해하지 못합니다.
- 이런 점에서 볼 때 ISA는 일종의 CPU의 언어인 샘입니다.

CPU가 이해하는 명령어들이 달라지면 비단 명령어의 생김새만 달라지는게 아닙니다
- ISA가 다르면 그에 따른 나비 효과로 많은 것이 달라집니다.
    - 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법 등 많은 것이 달라집니다.
        - 그리고 이는 곧 CPU 하드웨어 설계에도 큰 영향을 미칩니다.

ISA는 CPU의 언어임과 동시에 CPU를 비롯한 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이라고도 볼 수 있습니다.

앞서 명령어 병렬 처리 기법들을 학습했습니다.
- 이를 적용하기에 용이한 ISA가 있고, 그렇지 못한 ISA도 있습니다.
    - 다시 말해 명령어 파이프라인, 슈퍼스칼라, 비순차적 명령어 처리를 사용하기에 유리한 명령어 집합이 있고, 그렇지 못한 명령어 집합도 있습니다.

그렇다면 명령어 병렬 처리 기법들을 도입하기 유리한 ISA는 무엇일까요?
- 이와 관련해 현대 ISA의 양대 산맥인 CISC와 RISC에 대해 알아보겠습니다.

## CISC

- **CISC(Complex Instruction Set Computer) :** '복잡한 명령어 집합을 활용하는 컴퓨터'
    - 여기서 '컴퓨터'를 'CPU'라고 생각해도 좋습니다.
    - 이름 그대로 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식입니다.
    - ISA의 한 종류로 소개한 x86, x86-64는 대표적인 CISC 기반의 ISA입니다.
    - 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 **가변 길이 명령어**를 활용합니다.
    - 메모리에 접근하는 주소 지정 방식도 다양해서 아주 특별한 상황에서만 사용되는 독특한 주소 지정 방식들도 있습니다.
        - 다양하고 강력한 명령어를 활용한다는 말은 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다는 것을 의미합니다.

> 프로그램을 실행하는 명령어 수가 적다는 말은 '컴파일된 프로그램의 크기가 작다'는 것을 의미합니다.
> 같은 소스 코드를 컴파일해도 CPU마다 생성되는 실행 파일의 크기가 다를 수 있다는 것입니다.

이런 장점 덕분에 CISC는 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았습니다.
- '적은 수의 명령어만으로도 프로그램을 동작시킬 수 있다'는 점은 메모리 공간을 절약할 수 있다는 장점이기 때문입니다.

하지만 CISC에는 치명적인 단점이 있습니다.
- 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기와 실행되기까지의 시간이 일정하지 않습니다.
- 그리고 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 쿨럭 주기를 필요로 합니다.
    - 이는 명령어 파이프라인을 구현하는 데에 큰 걸림돌이 됩니다.

명령어 파이프라인 기법을 위한 이상적인 명령어는 다음 그림과 같이 각 단계에 소요되는 시간이 (가급적 1 클럭으로) 동일해야 합니다.
- 그래야 파이프라인이 마치 공장의 생산 라인처럼 결과를 내기 때문입니다.

<img src = "https://github.com/devKobe24/images/blob/main/CISC%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-1.png?raw=true">

하지만 CISC가 활용하는 명령어는 명령어 수행 시간이 길고 가지각색이기 때문에 파이프라인이 효율적으로 명령어를 처리할 수 없습니다.
- 한마디로 규격화되지 않은 명령어가 파이프라이닝을 어렵게 만든 셈입니다.
    - 명령어 파이프라인이 제대로 동작하지 않는다는 것은 현대 CPU에서 아주 치명적인 약점입니다.
        - 현대 CPU에서 명령어 파이프라인은 높은 성능을 내기 위해 절대 놓쳐서는 안 되는 핵심 기술이기 때문입니다.

<img src = "https://github.com/devKobe24/images/blob/main/CISC%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-2.png?raw=true">

게다가 CISC가 복잡하고 다양한 명령어를 활용할 수 있다고는 하지만, 사실 대다수의 복잡한 명령어는 그 사용 빈도가 낮습니다.

1974년 IBM 연구소의 존 코크(John Cocke)는 CISC 명령어 집합 중 불과 20% 정도의 명령어가 사용된 전체 명령어의 80%가량을 차지한다는 것을 증명하기도 했습니다.

CISC 명령어 집합이 다양하고 복잡한 기능을 지원하지만 실제로는 자주 사용되는 명령어만 쓰였다는 것입니다.

**정리하자면,** CISC 명령어 집합은 복잡하고 다양한 기능을 제공하기에 적은 수의 명령으로 프로그램을 동작시키고 메모리를 절약할 수 있지만, 명령어의 규격화가 어려워 파이프라이닝이 어렵습니다.

그리고 대다수의 복잡한 명령어는 그 사용 빈도가 낮습니다.

이러한 이유로 CISC 기반 CPU는 성장에 한계가 있습니다.

## RISC

CISC의 한계가 우리들에게 준 교훈은 크게 아래와 같습니다.

1. 빠른 처리를 위해 명령어 파이프라인을 십분 활용해야 한다. 원활한 파이프라이닝을 위해 '명령어 길이와 수행 시간이 짧고 규격화'되어 있어야 한다.
2. 어차피 자주 쓰이는 명령어만 줄곧 사용된다. 복잡한 기능을 지원하는 명령어를 추가하기보다는 '자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것'이 중요하다.

이런 원칙 하에 등장한 것이 RISC입니다.

- **RISC(Reduced Instruction Set Computer) :** 이름처럼 CISC에 비해 명령어의 종류가 적습니다. 그리고 CISC와는 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향합니다.
    - 즉, **고정 길이 명령어**를 활용합니다.

명령어가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에 RISC 명령어 집합은 명령어 파이프라이닝에 최적화되어 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/RISC%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-1.png?raw=true">

그리고 RISC는 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할 만큼 메모리 접근을 단순화하고 최소화를 추구합니다.
- 그렇기 때문에 CISC보다 주소 지정 방식의 종류가 적은 경우가 많습니다.

> 이런 점에서 RISC를 **load-store 구조**라고 부르기도 합니다.

RISC는 메모리 접근을 단순화, 최소화하는 대신 레지스터를 적극적으로 활용합니다.
- 그렇기에 CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많습니다.
    - 다만 사용 가능한 명령어 개수가 CISC보다 적기 때문에 RISC는 CISC보다 많은 명령으로 프로그램을 작동시킵니다.

<img src = "https://github.com/devKobe24/images/blob/main/CISC%E1%84%8B%E1%85%AARISC.png?raw=true">

## 키워드로 정리하는 핵심 포인트
- **ISA**는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속입니다.
- **CISC**는 복잡하고 다양한 종류의 가변 길이 명령어 집합을 활용합니다.
- **RISC**는 단순하고 적은 종류의 고정 길이 명령어 집합을 활용합니다.

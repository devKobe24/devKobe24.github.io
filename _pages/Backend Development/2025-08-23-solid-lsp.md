---
title: "ğŸ“š[Backend Development] ğŸš€ SOLID ì›ì¹™ - ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™(LSP) íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ê°€ì´ë“œ"
tags:
    - Backend Development
    - Spring Boot
    - Trouble Shooting
    - LSP
    - SOLID
date: "2025-08-23"
thumbnail: "/assets/img/thumbnail/BackendDevelopment.jpg"
---

# ğŸš€ SOLID ì›ì¹™ - ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™(LSP) íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ê°€ì´ë“œ

Spring Boot ê°œë°œì—ì„œ ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™(Liskov Substitution Principle)ì„ ì ìš©í•˜ëŠ” ê³¼ì •ì—ì„œ ìì£¼ ë°œìƒí•˜ëŠ” ë¬¸ì œì™€ í•´ê²° ë°©ë²•ì„ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.

---

## ğŸ” ë¬¸ì œ 1: ìì‹ í´ë˜ìŠ¤ì—ì„œ ì˜ˆì™¸ ë°œìƒìœ¼ë¡œ ì¸í•œ ëŸ°íƒ€ì„ ì˜¤ë¥˜

### ğŸ“‹ ì—ëŸ¬ ìƒí™©
ê²°ì œ ì‹œìŠ¤í…œì—ì„œ í¬ì¸íŠ¸ ê²°ì œë¥¼ ì¶”ê°€í–ˆëŠ”ë°, í™˜ë¶ˆ ê¸°ëŠ¥ í˜¸ì¶œ ì‹œ `UnsupportedOperationException`ì´ ë°œìƒí•˜ëŠ” ìƒí™©ì…ë‹ˆë‹¤.

```java
// ğŸ’¥ LSP ìœ„ë°˜ìœ¼ë¡œ ì¸í•œ ëŸ°íƒ€ì„ ì—ëŸ¬!
@Service
public class PaymentService {
    private final Map<String, PaymentProcessor> processors;

    public void processRefund(String type, double amount) {
        PaymentProcessor processor = processors.get(type);
        processor.refund(amount); // ğŸ’¥ í¬ì¸íŠ¸ ê²°ì œ ì‹œ ì˜ˆì™¸ ë°œìƒ!
    }
}

@Component("point")
public class PointPaymentProcessor implements PaymentProcessor {
    @Override
    public void refund(double amount) {
        // ğŸ˜± ë¶€ëª¨ì˜ í–‰ìœ„ ê·œì•½ ìœ„ë°˜!
        throw new UnsupportedOperationException("í¬ì¸íŠ¸ ê²°ì œëŠ” í™˜ë¶ˆì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.");
    }
}
```

### ğŸ¯ ì›ì¸ ë¶„ì„
**ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™(LSP)ì„ ìœ„ë°˜í•œ ì„¤ê³„ë¡œ, ìì‹ í´ë˜ìŠ¤ê°€ ë¶€ëª¨ì˜ ê³„ì•½ì„ ì§€í‚¤ì§€ ëª»í•´ ë‹¤í˜•ì„±ì´ ì•ˆì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.**

1. **ê³„ì•½ ìœ„ë°˜**: ìì‹ í´ë˜ìŠ¤ê°€ ë¶€ëª¨ ì¸í„°í˜ì´ìŠ¤ì˜ í–‰ìœ„ ê·œì•½ì„ ì§€í‚¤ì§€ ì•ŠìŒ
2. **íƒ€ì… ì•ˆì „ì„± ë¶€ì¡±**: í´ë¼ì´ì–¸íŠ¸ ì½”ë“œì—ì„œ êµ¬ì²´ íƒ€ì…ì„ í™•ì¸í•´ì•¼ í•¨
3. **ëŸ°íƒ€ì„ ì—ëŸ¬**: ì»´íŒŒì¼ ì‹œì ì— ë°œê²¬ë˜ì§€ ì•ŠëŠ” ì˜ˆì™¸ ë°œìƒ
4. **ë‹¤í˜•ì„± íŒŒê´´**: ë¶€ëª¨ íƒ€ì…ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì¹˜í™˜í•  ìˆ˜ ì—†ìŒ

### ğŸ”§ í•´ê²° ë°©ë²•

#### 1ë‹¨ê³„: ì—­í• ì— ë”°ë¥¸ ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬

```java
// ğŸ¯ ê²°ì œ ê¸°ë³¸ ê¸°ëŠ¥ë§Œ ì •ì˜
public interface Payable {
    void processPayment(double amount);
}

// ğŸ”„ í™˜ë¶ˆê¹Œì§€ í¬í•¨í•˜ëŠ” í™•ì¥ ì¸í„°í˜ì´ìŠ¤
public interface Refundable extends Payable {
    void refund(double amount);
}
```

**í•µì‹¬ í¬ì¸íŠ¸**
- `Payable`: ëª¨ë“  ê²°ì œ ìˆ˜ë‹¨ì˜ ìµœì†Œ ê³µí†µ ê¸°ëŠ¥
- `Refundable`: í™˜ë¶ˆê¹Œì§€ ì§€ì›í•˜ëŠ” ê²°ì œ ìˆ˜ë‹¨ì˜ í™•ì¥ ê¸°ëŠ¥

#### 2ë‹¨ê³„: ì—­í• ì— ë§ëŠ” êµ¬í˜„ì²´ ì‘ì„±

```java
// âœ… ì¹´ë“œ ê²°ì œ: ê²°ì œì™€ í™˜ë¶ˆ ëª¨ë‘ ê°€ëŠ¥
@Component("card")
public class CardPaymentProcessor implements Refundable {
    
    @Override
    public void processPayment(double amount) {
        System.out.println(amount + "ì›ì„ ì¹´ë“œë¡œ ê²°ì œí•©ë‹ˆë‹¤.");
        // ì¹´ë“œ ê²°ì œ API í˜¸ì¶œ
    }
    
    @Override
    public void refund(double amount) {
        System.out.println(amount + "ì›ì„ ì¹´ë“œë¡œ í™˜ë¶ˆí•©ë‹ˆë‹¤.");
        // ì¹´ë“œ í™˜ë¶ˆ API í˜¸ì¶œ - LSP ì¤€ìˆ˜!
    }
}

// âœ… í¬ì¸íŠ¸ ê²°ì œ: ê²°ì œë§Œ ê°€ëŠ¥ (ì˜ˆì™¸ ë°œìƒ ì—†ìŒ)
@Component("point")
public class PointPaymentProcessor implements Payable {
    
    @Override
    public void processPayment(double amount) {
        System.out.println(amount + " í¬ì¸íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ê²°ì œí•©ë‹ˆë‹¤.");
        // í¬ì¸íŠ¸ ì°¨ê° ë¡œì§ - LSP ì¤€ìˆ˜!
    }
    
    // ğŸ¯ refund() ë©”ì„œë“œê°€ ì—†ì–´ì„œ ì˜ˆì™¸ ë°œìƒ ìì²´ê°€ ë¶ˆê°€ëŠ¥!
}
```

#### 3ë‹¨ê³„: LSP ì¤€ìˆ˜í•˜ëŠ” ì•ˆì „í•œ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤

```java
// ğŸš€ íƒ€ì… ì•ˆì „ì„±ì´ ë³´ì¥ëœ ê²°ì œ ì„œë¹„ìŠ¤
@Service
@RequiredArgsConstructor
public class PaymentService {
    
    private final Map<String, Payable> payableProcessors;
    private final Map<String, Refundable> refundableProcessors;
    
    // âœ… ëª¨ë“  ê²°ì œ ìˆ˜ë‹¨ì—ì„œ ì•ˆì „í•˜ê²Œ ë™ì‘
    public void processPayment(String type, double amount) {
        Payable processor = payableProcessors.get(type);
        if (processor == null) {
            throw new IllegalArgumentException("ì§€ì›í•˜ì§€ ì•ŠëŠ” ê²°ì œ íƒ€ì…ì…ë‹ˆë‹¤: " + type);
        }
        processor.processPayment(amount); // LSP ë³´ì¥!
    }
    
    // âœ… í™˜ë¶ˆ ì§€ì› ê²°ì œ ìˆ˜ë‹¨ì—ì„œë§Œ ì•ˆì „í•˜ê²Œ ë™ì‘
    public void processRefund(String type, double amount) {
        Refundable processor = refundableProcessors.get(type);
        if (processor == null) {
            throw new UnsupportedOperationException("ì´ ê²°ì œ íƒ€ì…ì€ í™˜ë¶ˆì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: " + type);
        }
        processor.refund(amount); // LSP ë³´ì¥!
    }
}
```

### ğŸ“š LSP í•µì‹¬ ê°œë…

| ì›ì¹™ | ì˜ë¯¸ | Spring Boot êµ¬í˜„ ë°©ë²• |
|------|------|---------------------|
| **í–‰ìœ„ ê·œì•½ ì¤€ìˆ˜** | ìì‹ì€ ë¶€ëª¨ì˜ ê³„ì•½ì„ ì§€ì¼œì•¼ í•¨ | ì¸í„°í˜ì´ìŠ¤ ë©”ì„œë“œì—ì„œ ì˜ˆì™¸ ë°œìƒ ê¸ˆì§€ |
| **ì•ˆì „í•œ ì¹˜í™˜** | ë¶€ëª¨ íƒ€ì…ìœ¼ë¡œ ì™„ì „ ëŒ€ì²´ ê°€ëŠ¥ | ì ì ˆí•œ ì¶”ìƒí™”ì™€ ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ |
| **ì‚¬ì „ì¡°ê±´ ê°•í™” ê¸ˆì§€** | ìì‹ì´ ë” ì—„ê²©í•œ ì¡°ê±´ ìš”êµ¬ ë¶ˆê°€ | íŒŒë¼ë¯¸í„° ê²€ì¦ ì™„í™”ë§Œ í—ˆìš© |
| **ì‚¬í›„ì¡°ê±´ ì•½í™” ê¸ˆì§€** | ìì‹ì´ ë” ì•½í•œ ê²°ê³¼ ë°˜í™˜ ë¶ˆê°€ | ë°˜í™˜ê°’ì˜ ê³„ì•½ ì¤€ìˆ˜ |

---

## ğŸ” ë¬¸ì œ 2: ìì‹ í´ë˜ìŠ¤ì˜ ì‚¬ì „ì¡°ê±´ ê°•í™”ë¡œ ì¸í•œ í˜¸í™˜ì„± ë¬¸ì œ

### ğŸ“‹ ì—ëŸ¬ ìƒí™©
ë„í˜• ê³„ì‚° ì‹œìŠ¤í…œì—ì„œ ì •ì‚¬ê°í˜•ì´ ì§ì‚¬ê°í˜•ì„ ìƒì†ë°›ì•˜ëŠ”ë°, ë„ˆë¹„ì™€ ë†’ì´ ì„¤ì •ì—ì„œ ì œì•½ì´ ìƒê¸°ëŠ” ìƒí™©ì…ë‹ˆë‹¤.

```java
// ğŸ˜± LSP ìœ„ë°˜: ìì‹ í´ë˜ìŠ¤ê°€ ë” ê°•í•œ ì‚¬ì „ì¡°ê±´ì„ ìš”êµ¬
@Component
public class Rectangle {
    protected double width;
    protected double height;
    
    public void setWidth(double width) {
        this.width = width;
    }
    
    public void setHeight(double height) {
        this.height = height;
    }
    
    public double getArea() {
        return width * height;
    }
}

@Component
public class Square extends Rectangle {
    
    @Override
    public void setWidth(double width) {
        // ğŸ’¥ ì‚¬ì „ì¡°ê±´ ê°•í™”! ë¶€ëª¨ë³´ë‹¤ ë” ì—„ê²©í•œ ì œì•½
        if (width != height && height != 0) {
            throw new IllegalArgumentException("ì •ì‚¬ê°í˜•ì€ ë„ˆë¹„ì™€ ë†’ì´ê°€ ê°™ì•„ì•¼ í•©ë‹ˆë‹¤!");
        }
        this.width = width;
        this.height = width; // ê°•ì œë¡œ ê°™ê²Œ ë§Œë“¦
    }
    
    @Override
    public void setHeight(double height) {
        // ğŸ’¥ ì‚¬ì „ì¡°ê±´ ê°•í™”! ë¶€ëª¨ë³´ë‹¤ ë” ì—„ê²©í•œ ì œì•½
        if (height != width && width != 0) {
            throw new IllegalArgumentException("ì •ì‚¬ê°í˜•ì€ ë„ˆë¹„ì™€ ë†’ì´ê°€ ê°™ì•„ì•¼ í•©ë‹ˆë‹¤!");
        }
        this.height = height;
        this.width = height; // ê°•ì œë¡œ ê°™ê²Œ ë§Œë“¦
    }
}
```

### ğŸ¯ ì›ì¸ ë¶„ì„
**ìì‹ í´ë˜ìŠ¤ê°€ ë¶€ëª¨ í´ë˜ìŠ¤ë³´ë‹¤ ê°•í™”ëœ ì‚¬ì „ì¡°ê±´ì„ ìš”êµ¬í•˜ì—¬ LSPë¥¼ ìœ„ë°˜í•©ë‹ˆë‹¤.**

1. **ì‚¬ì „ì¡°ê±´ ê°•í™”**: ì •ì‚¬ê°í˜•ì´ ì§ì‚¬ê°í˜•ë³´ë‹¤ ë” ì—„ê²©í•œ ì¡°ê±´ ìš”êµ¬
2. **ì˜ˆìƒì¹˜ ëª»í•œ ë™ì‘**: í´ë¼ì´ì–¸íŠ¸ ì½”ë“œê°€ ì˜ˆìƒê³¼ ë‹¤ë¥´ê²Œ ë™ì‘
3. **ë‹¤í˜•ì„± íŒŒê´´**: Rectangle íƒ€ì…ìœ¼ë¡œ Square ì‚¬ìš© ì‹œ ì˜ˆì™¸ ë°œìƒ
4. **ì„¤ê³„ ì˜¤ë¥˜**: "is-a" ê´€ê³„ë¥¼ ì˜ëª» ì ìš©

### ğŸ”§ í•´ê²° ë°©ë²•

#### 1ë‹¨ê³„: ë¶ˆë³€ ê°ì²´ íŒ¨í„´ìœ¼ë¡œ ì¬ì„¤ê³„

```java
// ğŸ¯ ë„í˜•ì˜ ê³µí†µ ê¸°ëŠ¥ë§Œ ì¶”ìƒí™”
public abstract class Shape {
    public abstract double getArea();
    public abstract double getPerimeter();
    public abstract String getShapeType();
}

// âœ… ë¶ˆë³€ ì§ì‚¬ê°í˜• - LSP ì¤€ìˆ˜
@Component
public class Rectangle extends Shape {
    private final double width;
    private final double height;
    
    public Rectangle(double width, double height) {
        if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("ë„ˆë¹„ì™€ ë†’ì´ëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.");
        }
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * (width + height);
    }
    
    @Override
    public String getShapeType() {
        return "Rectangle";
    }
    
    // Getterë§Œ ì œê³µ (ë¶ˆë³€ì„± ë³´ì¥)
    public double getWidth() { return width; }
    public double getHeight() { return height; }
}

// âœ… ë¶ˆë³€ ì •ì‚¬ê°í˜• - LSP ì¤€ìˆ˜
@Component
public class Square extends Shape {
    private final double side;
    
    public Square(double side) {
        if (side <= 0) {
            throw new IllegalArgumentException("í•œ ë³€ì˜ ê¸¸ì´ëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.");
        }
        this.side = side;
    }
    
    @Override
    public double getArea() {
        return side * side; // ë¶€ëª¨ì™€ ë™ì¼í•œ ê³„ì•½ ì¤€ìˆ˜
    }
    
    @Override
    public double getPerimeter() {
        return 4 * side; // ë¶€ëª¨ì™€ ë™ì¼í•œ ê³„ì•½ ì¤€ìˆ˜
    }
    
    @Override
    public String getShapeType() {
        return "Square";
    }
    
    public double getSide() { return side; }
}
```

#### 2ë‹¨ê³„: íŒ©í† ë¦¬ íŒ¨í„´ìœ¼ë¡œ ì•ˆì „í•œ ìƒì„±

```java
// ğŸ­ ë„í˜• ìƒì„±ì„ ìœ„í•œ íŒ©í† ë¦¬
@Service
public class ShapeFactory {
    
    public Rectangle createRectangle(double width, double height) {
        return new Rectangle(width, height);
    }
    
    public Square createSquare(double side) {
        return new Square(side);
    }
    
    // ğŸ¯ íƒ€ì…ì— ë”°ë¥¸ ì•ˆì „í•œ ë„í˜• ìƒì„±
    public Shape createShape(String type, double... dimensions) {
        return switch (type.toUpperCase()) {
            case "RECTANGLE" -> {
                if (dimensions.length != 2) {
                    throw new IllegalArgumentException("ì§ì‚¬ê°í˜•ì€ ë„ˆë¹„ì™€ ë†’ì´ê°€ í•„ìš”í•©ë‹ˆë‹¤.");
                }
                yield createRectangle(dimensions[0], dimensions[1]);
            }
            case "SQUARE" -> {
                if (dimensions.length != 1) {
                    throw new IllegalArgumentException("ì •ì‚¬ê°í˜•ì€ í•œ ë³€ì˜ ê¸¸ì´ê°€ í•„ìš”í•©ë‹ˆë‹¤.");
                }
                yield createSquare(dimensions[0]);
            }
            default -> throw new IllegalArgumentException("ì§€ì›í•˜ì§€ ì•ŠëŠ” ë„í˜• íƒ€ì…: " + type);
        };
    }
}
```

#### 3ë‹¨ê³„: LSP ì¤€ìˆ˜í•˜ëŠ” ë„í˜• ê³„ì‚° ì„œë¹„ìŠ¤

```java
// ğŸ§® ëª¨ë“  ë„í˜•ì—ì„œ ì•ˆì „í•˜ê²Œ ë™ì‘í•˜ëŠ” ê³„ì‚° ì„œë¹„ìŠ¤
@Service
@RequiredArgsConstructor
public class ShapeCalculationService {
    
    private final ShapeFactory shapeFactory;
    
    // âœ… ëª¨ë“  Shape í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ ì•ˆì „í•˜ê²Œ ë™ì‘
    public double calculateTotalArea(List<Shape> shapes) {
        return shapes.stream()
                .mapToDouble(Shape::getArea) // LSP ë³´ì¥!
                .sum();
    }
    
    // âœ… ë„í˜• íƒ€ì…ì— ê´€ê³„ì—†ì´ ì•ˆì „í•˜ê²Œ ë™ì‘
    public String generateReport(List<Shape> shapes) {
        StringBuilder report = new StringBuilder();
        
        for (Shape shape : shapes) {
            report.append(String.format("%s - ë„“ì´: %.2f, ë‘˜ë ˆ: %.2f%n",
                    shape.getShapeType(), // LSP ë³´ì¥!
                    shape.getArea(),      // LSP ë³´ì¥!
                    shape.getPerimeter()  // LSP ë³´ì¥!
            ));
        }
        
        return report.toString();
    }
    
    // ğŸ¯ ë‹¤ì–‘í•œ ë„í˜• ì¡°í•© ê³„ì‚°
    public ShapeStatistics calculateStatistics(List<Shape> shapes) {
        return ShapeStatistics.builder()
                .totalShapes(shapes.size())
                .totalArea(calculateTotalArea(shapes))
                .averageArea(shapes.stream().mapToDouble(Shape::getArea).average().orElse(0))
                .largestArea(shapes.stream().mapToDouble(Shape::getArea).max().orElse(0))
                .build();
    }
}
```

---

## ğŸ” ë¬¸ì œ 3: ìƒì† ê³„ì¸µì—ì„œì˜ ë³µì¡í•œ LSP ìœ„ë°˜

### ğŸ“‹ ì—ëŸ¬ ìƒí™©
ìƒˆì™€ í­ê·„ì˜ ìƒì† ê´€ê³„ì—ì„œ `fly()` ë©”ì„œë“œ ë•Œë¬¸ì— LSPê°€ ìœ„ë°˜ë˜ëŠ” ë³µì¡í•œ ìƒí™©ì…ë‹ˆë‹¤.

```java
// ğŸ˜± LSP ìœ„ë°˜: ëª¨ë“  ìƒˆê°€ ë‚  ìˆ˜ ìˆë‹¤ëŠ” ì˜ëª»ëœ ì¶”ìƒí™”
public abstract class Bird {
    public abstract void fly();
    public abstract void eat();
}

public class Penguin extends Bird {
    @Override
    public void fly() {
        // ğŸ’¥ LSP ìœ„ë°˜! í­ê·„ì€ ë‚  ìˆ˜ ì—†ìŒ
        throw new UnsupportedOperationException("í­ê·„ì€ ë‚  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
    }
    
    @Override
    public void eat() {
        System.out.println("ë¬¼ê³ ê¸°ë¥¼ ë¨¹ìŠµë‹ˆë‹¤.");
    }
}
```

### ğŸ¯ ì›ì¸ ë¶„ì„
**ì˜ëª»ëœ ì¶”ìƒí™”ë¡œ ì¸í•´ ì¼ë¶€ ìì‹ í´ë˜ìŠ¤ê°€ ë¶€ëª¨ì˜ ëª¨ë“  ê¸°ëŠ¥ì„ ì§€ì›í•  ìˆ˜ ì—†ì–´ LSPë¥¼ ìœ„ë°˜í•©ë‹ˆë‹¤.**

1. **ê³¼ë„í•œ ì¶”ìƒí™”**: ëª¨ë“  ìƒˆê°€ ë‚  ìˆ˜ ìˆë‹¤ëŠ” ì˜ëª»ëœ ê°€ì •
2. **ê¸°ëŠ¥ë³„ ë¶„ë¦¬ ë¶€ì¡±**: ë¹„í–‰ ëŠ¥ë ¥ê³¼ ìƒˆ ìì²´ë¥¼ ë¶„ë¦¬í•˜ì§€ ëª»í•¨
3. **ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ ì›ì¹™ ìœ„ë°˜**: ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê¸°ëŠ¥ì„ ê°•ì œë¡œ êµ¬í˜„
4. **ë‹¤ì¤‘ ì±…ì„**: í•˜ë‚˜ì˜ í´ë˜ìŠ¤ê°€ ì—¬ëŸ¬ ëŠ¥ë ¥ì„ ëª¨ë‘ ì²˜ë¦¬

### ğŸ”§ í•´ê²° ë°©ë²•

#### 1ë‹¨ê³„: ëŠ¥ë ¥ë³„ ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬

```java
// ğŸ¦ ëª¨ë“  ìƒˆì˜ ê¸°ë³¸ ëŠ¥ë ¥
public interface Bird {
    void eat();
    void makeSound();
    String getSpecies();
}

// âœˆï¸ ë¹„í–‰ ëŠ¥ë ¥ (ë³„ë„ ì¸í„°í˜ì´ìŠ¤)
public interface Flyable {
    void fly();
    double getFlightSpeed();
    double getMaxAltitude();
}

// ğŸŠ ìˆ˜ì˜ ëŠ¥ë ¥ (ë³„ë„ ì¸í„°í˜ì´ìŠ¤)
public interface Swimmable {
    void swim();
    double getSwimmingSpeed();
    double getMaxDepth();
}

// ğŸš¶ ë³´í–‰ ëŠ¥ë ¥ (ë³„ë„ ì¸í„°í˜ì´ìŠ¤)
public interface Walkable {
    void walk();
    double getWalkingSpeed();
}
```

#### 2ë‹¨ê³„: ëŠ¥ë ¥ì— ë”°ë¥¸ êµ¬ì²´ì  êµ¬í˜„

```java
// ğŸ¦… ë…ìˆ˜ë¦¬: ë‚ ê³  ê±¸ì„ ìˆ˜ ìˆìŒ
@Component
public class Eagle implements Bird, Flyable, Walkable {
    
    @Override
    public void eat() {
        System.out.println("ì‘ì€ ë™ë¬¼ì„ ì¡ì•„ë¨¹ìŠµë‹ˆë‹¤.");
    }
    
    @Override
    public void makeSound() {
        System.out.println("ë¼ì•¼ì•…!");
    }
    
    @Override
    public String getSpecies() {
        return "ë…ìˆ˜ë¦¬";
    }
    
    @Override
    public void fly() {
        System.out.println("ë†’ì´ ë‚ ì•„ì˜¤ë¦…ë‹ˆë‹¤.");
    }
    
    @Override
    public double getFlightSpeed() {
        return 80.0; // km/h
    }
    
    @Override
    public double getMaxAltitude() {
        return 3000.0; // m
    }
    
    @Override
    public void walk() {
        System.out.println("ë•…ì—ì„œ ê±¸ì–´ë‹¤ë‹™ë‹ˆë‹¤.");
    }
    
    @Override
    public double getWalkingSpeed() {
        return 5.0; // km/h
    }
}

// ğŸ§ í­ê·„: ìˆ˜ì˜í•˜ê³  ê±¸ì„ ìˆ˜ ìˆìŒ (ë‚ ì§€ ëª»í•¨!)
@Component
public class Penguin implements Bird, Swimmable, Walkable {
    
    @Override
    public void eat() {
        System.out.println("ë¬¼ê³ ê¸°ë¥¼ ë¨¹ìŠµë‹ˆë‹¤.");
    }
    
    @Override
    public void makeSound() {
        System.out.println("ê½¥ê½¥!");
    }
    
    @Override
    public String getSpecies() {
        return "í­ê·„";
    }
    
    @Override
    public void swim() {
        System.out.println("ë¬¼ì†ì—ì„œ ë¹ ë¥´ê²Œ ìˆ˜ì˜í•©ë‹ˆë‹¤.");
    }
    
    @Override
    public double getSwimmingSpeed() {
        return 25.0; // km/h
    }
    
    @Override
    public double getMaxDepth() {
        return 500.0; // m
    }
    
    @Override
    public void walk() {
        System.out.println("ë’¤ëš±ë’¤ëš± ê±¸ì–´ë‹¤ë‹™ë‹ˆë‹¤.");
    }
    
    @Override
    public double getWalkingSpeed() {
        return 2.0; // km/h
    }
}

// ğŸ” ë‹­: ê±¸ì„ ìˆ˜ë§Œ ìˆìŒ (ë‚ ì§€ë„ í—¤ì—„ì¹˜ì§€ë„ ëª»í•¨!)
@Component
public class Chicken implements Bird, Walkable {
    
    @Override
    public void eat() {
        System.out.println("ê³¡ì‹ì„ ìª¼ì•„ë¨¹ìŠµë‹ˆë‹¤.");
    }
    
    @Override
    public void makeSound() {
        System.out.println("ê¼¬ë¼ì˜¤!");
    }
    
    @Override
    public String getSpecies() {
        return "ë‹­";
    }
    
    @Override
    public void walk() {
        System.out.println("ë•…ì—ì„œ ê±¸ì–´ë‹¤ë‹™ë‹ˆë‹¤.");
    }
    
    @Override
    public double getWalkingSpeed() {
        return 15.0; // km/h
    }
}
```

#### 3ë‹¨ê³„: LSP ì¤€ìˆ˜í•˜ëŠ” ìƒˆ ê´€ë¦¬ ì„œë¹„ìŠ¤

```java
// ğŸ¯ ëŠ¥ë ¥ë³„ë¡œ ì•ˆì „í•˜ê²Œ ìƒˆë“¤ì„ ê´€ë¦¬í•˜ëŠ” ì„œë¹„ìŠ¤
@Service
@RequiredArgsConstructor
public class BirdManagementService {
    
    private final List<Bird> allBirds;
    
    // âœ… ëª¨ë“  ìƒˆì—ì„œ ì•ˆì „í•˜ê²Œ ë™ì‘
    public void feedAllBirds() {
        allBirds.forEach(bird -> {
            System.out.println(bird.getSpecies() + "ì—ê²Œ ë¨¹ì´ë¥¼ ì¤ë‹ˆë‹¤.");
            bird.eat(); // LSP ë³´ì¥!
        });
    }
    
    // âœ… ë¹„í–‰ ê°€ëŠ¥í•œ ìƒˆë“¤ë§Œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
    public void organizeFlightShow() {
        List<Flyable> flyingBirds = allBirds.stream()
                .filter(bird -> bird instanceof Flyable)
                .map(bird -> (Flyable) bird)
                .collect(Collectors.toList());
        
        flyingBirds.forEach(flyable -> {
            System.out.println("ë¹„í–‰ ì‡¼ ì‹œì‘!");
            flyable.fly(); // LSP ë³´ì¥!
        });
    }
    
    // âœ… ìˆ˜ì˜ ê°€ëŠ¥í•œ ìƒˆë“¤ë§Œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
    public void organizeSwimmingCompetition() {
        List<Swimmable> swimmingBirds = allBirds.stream()
                .filter(bird -> bird instanceof Swimmable)
                .map(bird -> (Swimmable) bird)
                .collect(Collectors.toList());
        
        swimmingBirds.forEach(swimmable -> {
            System.out.println("ìˆ˜ì˜ ëŒ€íšŒ ì‹œì‘!");
            swimmable.swim(); // LSP ë³´ì¥!
        });
    }
    
    // ğŸƒ ëª¨ë“  ìƒˆì˜ ë³´í–‰ ì‹œí•© (ëŒ€ë¶€ë¶„ì˜ ìƒˆê°€ ê±¸ì„ ìˆ˜ ìˆìŒ)
    public void organizeWalkingRace() {
        allBirds.stream()
                .filter(bird -> bird instanceof Walkable)
                .map(bird -> (Walkable) bird)
                .forEach(walkable -> {
                    System.out.println("ê±·ê¸° ì‹œí•© ì°¸ê°€!");
                    walkable.walk(); // LSP ë³´ì¥!
                });
    }
    
    // ğŸ“Š ìƒˆë“¤ì˜ ëŠ¥ë ¥ í†µê³„
    public BirdCapabilityStatistics getCapabilityStatistics() {
        long flyingCount = allBirds.stream().mapToLong(bird -> bird instanceof Flyable ? 1 : 0).sum();
        long swimmingCount = allBirds.stream().mapToLong(bird -> bird instanceof Swimmable ? 1 : 0).sum();
        long walkingCount = allBirds.stream().mapToLong(bird -> bird instanceof Walkable ? 1 : 0).sum();
        
        return BirdCapabilityStatistics.builder()
                .totalBirds(allBirds.size())
                .flyingBirds(flyingCount)
                .swimmingBirds(swimmingCount)
                .walkingBirds(walkingCount)
                .build();
    }
}
```

### ğŸ¨ LSP ì‹¤ë¬´ í™œìš© íŒ¨í„´

| ë¹„ì¦ˆë‹ˆìŠ¤ ë„ë©”ì¸ | ì˜ëª»ëœ ì¶”ìƒí™” | ì˜¬ë°”ë¥¸ LSP ì„¤ê³„ |
|----------------|----------------|------------------|
| **íŒŒì¼ ì²˜ë¦¬** | `FileProcessor.compress()` (ëª¨ë“  íŒŒì¼ì´ ì••ì¶• ê°€ëŠ¥?) | `Compressible` ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ |
| **ì‚¬ìš©ì ê¶Œí•œ** | `User.adminAction()` (ëª¨ë“  ì‚¬ìš©ìê°€ ê´€ë¦¬ì?) | `AdminUser`, `RegularUser` ë³„ë„ íƒ€ì… |
| **ê²°ì œ ìˆ˜ë‹¨** | `Payment.refund()` (ëª¨ë“  ê²°ì œê°€ í™˜ë¶ˆ ê°€ëŠ¥?) | `Refundable` ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ |
| **ìš´ì†¡ ìˆ˜ë‹¨** | `Vehicle.fly()` (ëª¨ë“  ìš´ì†¡ ìˆ˜ë‹¨ì´ ë¹„í–‰?) | `Flyable`, `Drivable` ëŠ¥ë ¥ë³„ ë¶„ë¦¬ |

---

## ğŸ“Š LSP ì²´í¬ë¦¬ìŠ¤íŠ¸

### âœ… ì„¤ê³„ ê²€ì¦
- [ ] ìì‹ í´ë˜ìŠ¤ì—ì„œ ë¶€ëª¨ ë©”ì„œë“œ í˜¸ì¶œ ì‹œ ì˜ˆì™¸ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ê°€?
- [ ] ìì‹ í´ë˜ìŠ¤ê°€ ë¶€ëª¨ë³´ë‹¤ ê°•í•œ ì‚¬ì „ì¡°ê±´ì„ ìš”êµ¬í•˜ì§€ ì•ŠëŠ”ê°€?
- [ ] ìì‹ í´ë˜ìŠ¤ê°€ ë¶€ëª¨ë³´ë‹¤ ì•½í•œ ì‚¬í›„ì¡°ê±´ì„ ì œê³µí•˜ì§€ ì•ŠëŠ”ê°€?
- [ ] `instanceof` ì²´í¬ ì—†ì´ ë‹¤í˜•ì„±ì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ê°€?

### âœ… êµ¬í˜„ í’ˆì§ˆ
- [ ] ì¸í„°í˜ì´ìŠ¤ê°€ í´ë¼ì´ì–¸íŠ¸ì˜ í•„ìš”ì— ë”°ë¼ ì ì ˆíˆ ë¶„ë¦¬ë˜ì—ˆëŠ”ê°€?
- [ ] ë¶ˆë³€ ê°ì²´ íŒ¨í„´ì„ í™œìš©í•˜ì—¬ ìƒíƒœ ë³€ê²½ ë¬¸ì œë¥¼ ë°©ì§€í–ˆëŠ”ê°€?
- [ ] íŒ©í† ë¦¬ íŒ¨í„´ìœ¼ë¡œ ê°ì²´ ìƒì„±ì„ ì•ˆì „í•˜ê²Œ ê´€ë¦¬í•˜ëŠ”ê°€?
- [ ] ê° í´ë˜ìŠ¤ê°€ ìì‹ ì˜ ì±…ì„ë§Œ ê°€ì§€ê³  ìˆëŠ”ê°€?

### âœ… í™•ì¥ì„± ê³ ë ¤
- [ ] ìƒˆë¡œìš´ í•˜ìœ„ íƒ€ì… ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œê°€ ê¹¨ì§€ì§€ ì•ŠëŠ”ê°€?
- [ ] ëŠ¥ë ¥ë³„ë¡œ ì¸í„°í˜ì´ìŠ¤ê°€ ë¶„ë¦¬ë˜ì–´ ìœ ì—°í•œ ì¡°í•©ì´ ê°€ëŠ¥í•œê°€?
- [ ] ì»´íŒŒì¼ íƒ€ì„ì— íƒ€ì… ì•ˆì „ì„±ì´ ë³´ì¥ë˜ëŠ”ê°€?

---

## ğŸ¯ ì‹¤ì „ í™œìš© ì˜ˆì‹œ

### E-commerce ìƒí’ˆ ê´€ë¦¬ ì‹œìŠ¤í…œì—ì„œì˜ LSP í™œìš©

```java
// ğŸ¯ ìƒí’ˆì˜ ê¸°ë³¸ ê¸°ëŠ¥
public interface Product {
    String getName();
    BigDecimal getPrice();
    String getDescription();
    boolean isAvailable();
}

// ğŸ“¦ ì‹¤ë¬¼ ìƒí’ˆ ëŠ¥ë ¥
public interface PhysicalProduct extends Product {
    double getWeight();
    Dimensions getDimensions();
    ShippingInfo calculateShipping(String destination);
}

// ğŸ’¾ ë””ì§€í„¸ ìƒí’ˆ ëŠ¥ë ¥
public interface DigitalProduct extends Product {
    String getDownloadUrl();
    long getFileSize();
    List<String> getSupportedFormats();
    void sendDownloadLink(String email);
}

// ğŸ“š êµ¬ë… ìƒí’ˆ ëŠ¥ë ¥
public interface SubscriptionProduct extends Product {
    Period getSubscriptionPeriod();
    BigDecimal getRecurringPrice();
    LocalDate getNextBillingDate();
    void renewSubscription();
}

// âœ… ì±… (ì‹¤ë¬¼ ìƒí’ˆ)
@Component
public class Book implements PhysicalProduct {
    
    private final String title;
    private final BigDecimal price;
    private final String author;
    private final double weight;
    private final Dimensions dimensions;
    
    // PhysicalProductì˜ ëª¨ë“  ë©”ì„œë“œë¥¼ ì™„ì „íˆ êµ¬í˜„ (LSP ì¤€ìˆ˜)
    @Override
    public String getName() { return title; }
    
    @Override
    public BigDecimal getPrice() { return price; }
    
    @Override
    public String getDescription() { 
        return String.format("ì €ì: %s", author); 
    }
    
    @Override
    public boolean isAvailable() { 
        return true; // ì¬ê³  í™•ì¸ ë¡œì§
    }
    
    @Override
    public double getWeight() { return weight; }
    
    @Override
    public Dimensions getDimensions() { return dimensions; }
    
    @Override
    public ShippingInfo calculateShipping(String destination) {
        // ì‹¤ì œ ë°°ì†¡ë¹„ ê³„ì‚° - LSP ì¤€ìˆ˜!
        return ShippingCalculator.calculate(weight, dimensions, destination);
    }
}

// âœ… ì „ìì±… (ë””ì§€í„¸ ìƒí’ˆ)
@Component
public class EBook implements DigitalProduct {
    
    private final String title;
    private final BigDecimal price;
    private final String downloadUrl;
    private final long fileSize;
    
    // DigitalProductì˜ ëª¨ë“  ë©”ì„œë“œë¥¼ ì™„ì „íˆ êµ¬í˜„ (LSP ì¤€ìˆ˜)
    @Override
    public String getName() { return title; }
    
    @Override
    public BigDecimal getPrice() { return price; }
    
    @Override
    public String getDescription() { 
        return String.format("íŒŒì¼ í¬ê¸°: %d MB", fileSize / 1024 / 1024); 
    }
    
    @Override
    public boolean isAvailable() { 
        return true; // ë””ì§€í„¸ ìƒí’ˆì€ í•­ìƒ ì‚¬ìš© ê°€ëŠ¥
    }
    
    @Override
    public String getDownloadUrl() { return downloadUrl; }
    
    @Override
    public long getFileSize() { return fileSize; }
    
    @Override
    public List<String> getSupportedFormats() { 
        return List.of("PDF", "EPUB", "MOBI"); 
    }
    
    @Override
    public void sendDownloadLink(String email) {
        // ì‹¤ì œ ì´ë©”ì¼ ë°œì†¡ - LSP ì¤€ìˆ˜!
        EmailService.sendDownloadLink(email, downloadUrl);
    }
}
```

#### LSP ì¤€ìˆ˜í•˜ëŠ” ìƒí’ˆ ê´€ë¦¬ ì„œë¹„ìŠ¤

```java
// ğŸ›’ íƒ€ì…ë³„ë¡œ ì•ˆì „í•˜ê²Œ ìƒí’ˆì„ ì²˜ë¦¬í•˜ëŠ” ì„œë¹„ìŠ¤
@Service
@RequiredArgsConstructor
public class ProductManagementService {
    
    private final List<Product> allProducts;
    private final ShippingService shippingService;
    private final EmailService emailService;
    
    // âœ… ëª¨ë“  ìƒí’ˆì—ì„œ ì•ˆì „í•˜ê²Œ ë™ì‘
    public List<ProductSummary> getAllProductSummaries() {
        return allProducts.stream()
                .map(product -> ProductSummary.builder()
                        .name(product.getName())        // LSP ë³´ì¥!
                        .price(product.getPrice())      // LSP ë³´ì¥!
                        .description(product.getDescription()) // LSP ë³´ì¥!
                        .available(product.isAvailable())      // LSP ë³´ì¥!
                        .build())
                .collect(Collectors.toList());
    }
    
    // âœ… ì‹¤ë¬¼ ìƒí’ˆë§Œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
    public List<ShippingEstimate> calculateShippingEstimates(String destination) {
        return allProducts.stream()
                .filter(product -> product instanceof PhysicalProduct)
                .map(product -> (PhysicalProduct) product)
                .map(physical -> ShippingEstimate.builder()
                        .productName(physical.getName())
                        .shippingInfo(physical.calculateShipping(destination)) // LSP ë³´ì¥!
                        .build())
                .collect(Collectors.toList());
    }
    
    // âœ… ë””ì§€í„¸ ìƒí’ˆë§Œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
    public void sendDigitalDeliveries(String customerEmail) {
        allProducts.stream()
                .filter(product -> product instanceof DigitalProduct)
                .map(product -> (DigitalProduct) product)
                .forEach(digital -> {
                    System.out.printf("ë””ì§€í„¸ ìƒí’ˆ ì „ë‹¬: %s%n", digital.getName());
                    digital.sendDownloadLink(customerEmail); // LSP ë³´ì¥!
                });
    }
    
    // ğŸ”„ êµ¬ë… ìƒí’ˆ ê°±ì‹ 
    public void renewSubscriptions() {
        allProducts.stream()
                .filter(product -> product instanceof SubscriptionProduct)
                .map(product -> (SubscriptionProduct) product)
                .forEach(subscription -> {
                    System.out.printf("êµ¬ë… ê°±ì‹ : %s%n", subscription.getName());
                    subscription.renewSubscription(); // LSP ë³´ì¥!
                });
    }
}
```

### ìƒˆë¡œìš´ ìƒí’ˆ íƒ€ì… ì¶”ê°€ - ë©¤ë²„ì‹­

```java
// ğŸ¯ ìƒˆë¡œìš´ ë©¤ë²„ì‹­ ìƒí’ˆ - ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì—†ì´ ì¶”ê°€!
@Component
public class MembershipProduct implements SubscriptionProduct {
    
    private final String membershipName;
    private final BigDecimal monthlyFee;
    private final List<String> benefits;
    
    // SubscriptionProductì˜ ëª¨ë“  ë©”ì„œë“œë¥¼ ì™„ì „íˆ êµ¬í˜„ (LSP ì¤€ìˆ˜)
    @Override
    public String getName() { return membershipName; }
    
    @Override
    public BigDecimal getPrice() { return monthlyFee; }
    
    @Override
    public String getDescription() {
        return String.format("í˜œíƒ: %s", String.join(", ", benefits));
    }
    
    @Override
    public boolean isAvailable() { return true; }
    
    @Override
    public Period getSubscriptionPeriod() { 
        return Period.ofMonths(1); 
    }
    
    @Override
    public BigDecimal getRecurringPrice() { 
        return monthlyFee; 
    }
    
    @Override
    public LocalDate getNextBillingDate() {
        return LocalDate.now().plusMonths(1);
    }
    
    @Override
    public void renewSubscription() {
        // ë©¤ë²„ì‹­ ê°±ì‹  ë¡œì§ - LSP ì¤€ìˆ˜!
        System.out.println("ë©¤ë²„ì‹­ì´ ìë™ìœ¼ë¡œ ê°±ì‹ ë˜ì—ˆìŠµë‹ˆë‹¤.");
        // ê²°ì œ ì²˜ë¦¬ ë° í˜œíƒ ì—°ì¥
    }
}
```

**ê²°ê³¼**: ê¸°ì¡´ `ProductManagementService`ë‚˜ ë‹¤ë¥¸ ìƒí’ˆ í´ë˜ìŠ¤ë“¤ì€ **ë‹¨ í•œ ì¤„ë„ ìˆ˜ì •í•˜ì§€ ì•Šê³ ** ìƒˆë¡œìš´ ë©¤ë²„ì‹­ ìƒí’ˆ ê¸°ëŠ¥ì´ ì™„ë²½í•˜ê²Œ ì¶”ê°€ë©ë‹ˆë‹¤! ğŸ‰

---

## ğŸ“ˆ ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

### âœ… ìµœì í™” íŒ
- [ ] `instanceof` ì²´í¬ë¥¼ ìµœì†Œí™”í•˜ì—¬ ëŸ°íƒ€ì„ ì„±ëŠ¥ í–¥ìƒ
- [ ] ì¸í„°í˜ì´ìŠ¤ë³„ Map í™œìš©ìœ¼ë¡œ O(1) ì¡°íšŒ êµ¬í˜„
- [ ] ìºì‹±ìœ¼ë¡œ ë°˜ë³µì ì¸ íƒ€ì… ì²´í¬ ë°©ì§€

```java
// ğŸš€ ì„±ëŠ¥ ìµœì í™”ëœ LSP êµ¬í˜„
@Service
@RequiredArgsConstructor
public class OptimizedProductService {
    
    // íƒ€ì…ë³„ë¡œ ë¯¸ë¦¬ ë¶„ë¥˜í•˜ì—¬ ì„±ëŠ¥ ìµœì í™”
    private final Map<Class<?>, List<Product>> productsByType;
    private final Map<String, PhysicalProduct> physicalProductsById;
    private final Map<String, DigitalProduct> digitalProductsById;
    
    @PostConstruct
    public void initializeProductMaps() {
        // ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹œ í•œ ë²ˆë§Œ ë¶„ë¥˜
        List<Product> allProducts = productRepository.findAll();
        
        this.productsByType = allProducts.stream()
                .collect(Collectors.groupingBy(Object::getClass));
        
        this.physicalProductsById = allProducts.stream()
                .filter(product -> product instanceof PhysicalProduct)
                .collect(Collectors.toMap(
                        Product::getId,
                        product -> (PhysicalProduct) product
                ));
                
        this.digitalProductsById = allProducts.stream()
                .filter(product -> product instanceof DigitalProduct)
                .collect(Collectors.toMap(
                        Product::getId,
                        product -> (DigitalProduct) product
                ));
    }
    
    // ğŸ¯ O(1) ì¡°íšŒë¡œ ë¹ ë¥¸ ë°°ì†¡ë¹„ ê³„ì‚°
    public ShippingInfo calculateShippingFast(String productId, String destination) {
        PhysicalProduct product = physicalProductsById.get(productId);
        if (product == null) {
            throw new IllegalArgumentException("ì‹¤ë¬¼ ìƒí’ˆì´ ì•„ë‹™ë‹ˆë‹¤: " + productId);
        }
        return product.calculateShipping(destination); // LSP ë³´ì¥!
    }
}
```

---

## ğŸ‰ ë§ˆë¬´ë¦¬

ì´ì œ SOLID LSP ì›ì¹™ì„ í™œìš©í•œ ì•ˆì „í•˜ê³  í™•ì¥ ê°€ëŠ¥í•œ Spring Boot ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤!

### ğŸš€ ë‹¤ìŒ ë‹¨ê³„ ê¶Œì¥ì‚¬í•­

1. **ë‹¤ë¥¸ SOLID ì›ì¹™ê³¼ì˜ ì¡°í•©**: SRP + LSP + ISPë¥¼ í•¨ê»˜ ì ìš©
2. **ë””ìì¸ íŒ¨í„´ í™œìš©**: Strategy, State, Template Method íŒ¨í„´ê³¼ LSP
3. **í…ŒìŠ¤íŠ¸ ì „ëµ**: LSP ì¤€ìˆ˜ë¥¼ ê²€ì¦í•˜ëŠ” ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

### ğŸ“ ì¶”ê°€ í•™ìŠµ ë¦¬ì†ŒìŠ¤
- Clean Architecture (Robert C. Martin): ì˜¬ë°”ë¥¸ ì¶”ìƒí™”ì™€ ê²½ê³„ ì„¤ì •
- Effective Java 3rd Edition: ìƒì†ë³´ë‹¤ëŠ” ì»´í¬ì§€ì…˜ í™œìš©ë²•
- Spring Boot Testing: LSP ì¤€ìˆ˜ë¥¼ ê²€ì¦í•˜ëŠ” í…ŒìŠ¤íŠ¸ ë°©ë²•

### ğŸ’¡ í•µì‹¬ ê¸°ì–µí•  ì 
LSPëŠ” **"ìì‹ì´ ë¶€ëª¨ì˜ ì•½ì†ì„ ë°˜ë“œì‹œ ì§€ì¼œì•¼ í•œë‹¤"**ëŠ” ì›ì¹™ì…ë‹ˆë‹¤. Spring Bootì˜ ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ì™€ DIë¥¼ í™œìš©í•˜ë©´ **íƒ€ì… ì•ˆì „í•˜ê³  ì˜ˆì¸¡ ê°€ëŠ¥í•œ ë‹¤í˜•ì„±**ì„ êµ¬í˜„í•  ìˆ˜ ìˆì–´ ê²¬ê³ í•œ ê°ì²´ ì§€í–¥ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!

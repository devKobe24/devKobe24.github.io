---
title: "💾 [CS] ALU와 제어장치"
tags:
    - CS
date: "2024-04-08"
thumbnail: "/assets/img/thumbnail/cs.jpeg"
---

# ALU와 제어장치.

- CPU: 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치
- ALU: CPU 내부에 계산을 담당
- 레지스터: 명령어를 읽어 들이고 해석하는 제어장치, 작은 임시 저장 장치

## ALU

<img src = "https://github.com/devKobe24/images/blob/main/ALU%E1%84%91%E1%85%AD%E1%84%92%E1%85%A7%E1%86%AB%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7.png?raw=true">

- ALU: 레지스터를 통해 **피연산자** 를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 **제어 신호** 를 받아 들입니다.
    - 레지스터와 제어장치로부터 받아들인 피연산자와 제어 신호로 산술 연산, 논리 연산 등 다양한 연산을 수행합니다.

### ALU가 내보내는 정보.
연산을 수행한 결과는 특정 숫자나 문자가 될 수도 있고, 메모리 주소가 될 수도 있습니다.
- 그리고 이 결괏값은 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장됩니다.

CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느립니다.
- ALU가 연산할 때마다 결과를 메모리에 저장한다면 당연하게도 CPU는 메모리에 자주 접근하게 되고, 이는 CPU가 프로그램 실행 속도를 늦출 수 있습니다.
    - 그래서 ALU의 결괏값을 메모리가 아닌 레지스터에 우선 저장하는 것 입니다.

ALU는 계산 결과와 더불어 **플래그**를 내보냅니다.
- ALU는 결괏값뿐만 아니라 연산 결과에 대한 추가적인 정보를 내보내야 할 때가 있습니다.
    - 연산 결과에 대한 추가적인 상태 정보를 **플래그(flag)** 라고 합니다.

ALU가 내보내는 대표적인 플래그는 아래와 같습니다.

<img src = "https://github.com/devKobe24/images/blob/main/ALU%E1%84%80%E1%85%A1%E1%84%82%E1%85%A2%E1%84%87%E1%85%A9%E1%84%82%E1%85%A2%E1%84%82%E1%85%B3%E1%86%AB%E1%84%83%E1%85%A2%E1%84%91%E1%85%AD%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%80%E1%85%B3.png?raw=true">

- 이러한 플래그는 CPU가 프로그램을 실행하는 도중 반드시 기억해야 하는 일종의 참고 정보입니다.
- 플래그들은 **플래그 레지스터** 라는 레지스터에 저장됩니다.
    - 플래그 값들을 저장하는 레지스터입니다.
        - 이 레지스터를 읽으면 연산 결과에 대한 추가적인 정보, 참고 정보를 얻을 수 있습니다.

### 플레그 레지스터 예시와 설명.
예를 들어 플래그 레지스터가 아래와 같은 구조를 가지고 있고, ALU가 연산을 수행한 직후 **부호 플래그**가 1이 되었다면 연산 결과는 음수임을 알 수 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%80%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5-%E1%84%8B%E1%85%B3%E1%86%B7%E1%84%89%E1%85%AE.png?raw=true">

또한 만약 ALU가 연산을 수행한 직후 플래그 레지스터가 아래와 같다면 **제로 플래그**가 1이 되었으니 연산 결과는 0임을 알 수 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%80%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5-%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%80%E1%85%B3.png?raw=true">

이 밖에도 ALU 내부에는 여러 계산을 위한 회로들이 있습니다.
대표적으로
- 덧셈을 위한 가산기
- 뺄셈을 위한 보수기
- 시프트 연산을 수행해 주는 시프터
- 오버플로우를 대비한 오버플로우 검출기
- 등등

## 제어장치.
- **제어장치**: 제어 신호를 내보내고, 해석하는 부품
- **제어 신호**: 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%8E%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7.png?raw=true">

### 제어장치가 받아들이는 정보.
**첫째. 제어장치는 클럭 신호를 받아들입니다.**
- **클럭(Clock)**: 컴퓨터의 모든 부품을 일사분란하게 움직일 수 있게하는 시간 단위
    - 클럭의 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동되거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어 들어는 것 입니다.
    - 다만, "컴퓨터의 모든 부품이 클럭 신호에 맞춰 작동한다" 라는 말을 "컴퓨터의 모든 부품이 한 클럭마다 작동한다"라고 이해하면 안됩니다.
        - 컴퓨터 부품들은 클럭이라는 박자에 맞춰 작동할 뿐 한 박자마다 작동하는 건 아닙니다.
            - 가령 다음 그림처럼 하나의 명령어가 여러 클럭에 걸쳐 실행될 수 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A5%E1%86%A8%E1%84%8C%E1%85%AE%E1%84%80%E1%85%B5.png?raw=true">

**둘째, 제어장치는 '해석해야 할 명령어'를 받아들입니다.**
- CPU가 해석해야 할 명령어는 **명령어 레지스터** 라는 특별한 레지스터에 저장됩니다.
- 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려줍니다.

**셋째, 제어장치는 플래그 레지스터 속 플래그 값을 받아들입니다.**
- 플래그는 ALU 연산에 대한 추가적인 상태 정보입니다.
- 제어장치는 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생 시킵니다.

**넷째, 제어장치는 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호를 받아들입니다.**
- 제어 신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있습니다.
- 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도 합니다.

### 제어장치가 내보내는 정보.
여기에는 크게 CPU 외부에 전달하는 제어 신호와 CPU 내부에 전달하는 제어 신호가 있습니다.
- 제어장치가 CPU 외부에 제어 신호를 전달한다는 말은 곧, 제어 버스로 제어 신호를 내보낸다는 말과 같습니다.
    - 이러한 제어 신호에는 크게 메모리에 전달하는 제어 신호와 입출력장치에 전달하는 제어 신호가 있습니다.

제어장치가 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶다면 메모리로 제어 신호를 내보냅니다.
- 그리고 제어장치가 입출력장치의 값을 읽거나 입출력장치에 새로운 값을 쓰고 싶을 때는 입출력장치로 제어 신호를 내보냅니다.

제어장치가 CPU 내부에 전달하는 제어 신호에는 크게 ALU에 전달하는 제어 신호와 레지스터에 전달하는 제어 신호가 있습니다.
- ALU에는 수행할 연산을 지시하기 위해, 레지스터에는 레지스터 간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해 제어 신호를 내보냅니다.

## 키워드로 정리하는 핵심 포인트
- **ALU**는 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어 신호를 받아들입니다.
- ALU는 연산 결과와 **플래그**를 내보냅니다.
- **제어장치**는 클럭, 현재 수행할 명령어, 플래그, 제어 신호를 받아들입니다.
- 제어장치는 CPU 내부와 외보루 **제어 신호** 를 내보냅니다.

## check point
- **이진수의 음수표현**
    - 2의 보수: 모든 0과 1을 뒤집고, 거기에 1을 더한 값

# Q1. ALU가 소프트웨어 개발, 특히 iOS 개발에 어떻게 적용될 수 있는지 설명해 주세요. 예를 들어, 어떻게 ALU가 앱의 성능에 영향을 미칠 수 있는지 구체적인 사례를 들어주세요.
iOS 앱 개발에서 ALU의 역할은 직접적으로 보이지 않지만, 앱의 성능 최적화에 중요합니다. 예를 들어, 이미지 처리나 데이터 암호화 같은 작업은 많은 산술 및 논리 연산을 필요로 하며, 이는 ALU에서 처리됩니다. 따라서, ALU의 효율적인 사용은 앱의 반응 속도와 전반적인 성능에 직접적인 영향을 미칩니다.

# Q2. ALU(산술 논리 장치)의 기본적인 기능은 무엇이며, 컴퓨터 프로세서 내에서 어떤 역할을 합니까?
ALU는 컴퓨터의 프로세서 내에 있는 하드웨어 구성 요소로, 기본적인 산술 연산(덧셈, 뺄셈, 곱셈, 나눗셈)과 논리 연산(AND, OR, XOR, NOT)을 수행합니다. 이는 모든 종류의 컴퓨터 프로그램 실행에 기본이 되는 연산이며, 프로세서가 복잡한 계산과 데이터 처리 작업을 수행할 수 있게 해줍니다.

# Q3. Java 애플리케이션의 성능 최적화와 관련하여, ALU의 역할과 중요성에 대해 설명해 주세요.
Java 애플리케이션의 성능 최적화에서 ALU의 역할은 중요합니다. ALU는 계산 작업의 실제 수행 장소이므로, ALU의 효율성은 애플리케이션의 처리 속도와 직접적인 관련이 있습니다. 특히, 고성능을 요구하는 애플리케이션에서는 ALU를 통해 수행되는 연산의 최적화가 애플리케이션 전체의 성능을 크게 향상시킬 수 있습니다.

# Q4. 멀티 쓰레딩 Java 애플리케이션에서 ALU의 처리 능력이 중요한 이유는 무엇이라고 생각하나요?
멀티 쓰레딩 애플리케이션에서는 여러 쓰레드가 동시에 연산을 수행할 수 있으므로, ALU의 처리 능력이 성능의 병목 현상을 방지하는 데 중요합니다. 효율적인 ALU 설계는 복수의 연산을 동시에 빠르게 처리할 수 있게 해주며, 이는 멀티 쓰레딩 환경에서 애플리케이션의 반응 속도와 처리량을 크게 향상시킬 수 있습니다.

# Q5. 현대의 CPU가 여러 ALU를 갖고 있는 경우, 이것이 Java 백엔드 시스템의 성능에 어떤 영향을 미칠 수 있나요?
여러 ALU를 갖는 프로세서는 동시에 여러 연산을 수행할 수 있으므로, Java 백엔드 시스템에서의 병렬 처리 능력을 크게 향상시킵니다. 이는 데이터베이스 쿼리 처리, 대규모 데이터 분석, 실시간 트랜잭션 처리 등 다양한 작업에서 성능 이점을 제공할 수 있습니다.

# Q6. Java 애플리케이션에서 복잡한 수학적 연산을 효율적으로 처리하기 위해 개발자가 고려해야 할 ALU와 관련된 측면은 무엇인가요?
개발자는 복잡한 수학적 연산을 효율적으로 처리하기 위해, ALU의 연산 처리 능력을 최대화하는 방법을 고려해야 합니다. 이는 알고리즘의 최적화, 복잡한 연산의 분할 및 정복 전략 적용, 필요한 경우 하드웨어 가속기(예: GPU) 사용 등을 포함할 수 있습니다.

# Q7. ALU의 한계를 넘어서서 Java 애플리케이션의 성능을 향상시키기 위해 사용할 수 있는 다른 하드웨어 기반 최적화 기술은 무엇이 있을까요?
ALU의 한계를 넘어서 Java 애플리케이션의 성능을 향상시키기 위해, 다중 코어 프로세싱, 병렬 처리, GPU 가속, FPGA(필드 프로그래밍 게이트 어레이)를 활용한 커스텀 하드웨어 가속 등의 기술을 활용할 수 있습니다. 이러한 기술들은 특정 유형의 작업에 대해 상당한 성능 향상을 제공할 수 있습니다.

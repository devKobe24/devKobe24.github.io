---
title: "☕️[Java] 여러가지 연산자(2)"
tags:
    - Java
    - Programming Language
    - Backend
date: "2024-05-05"
thumbnail: "/assets/img/thumbnail/JV.jpeg"
---

# 1️⃣ 비트 연산자에 대한 이해

## 1. 2진법.
자바 프로그래밍에서의 이진법은 컴퓨터의 지본 숫자 시스템을 참조하는 것입니다.
컴퓨터는 데이터를 0과 1의 형태, 즉 이진수로 처리합니다.
자바에서도 이러한 이진법을 사용하여 데이터를 저장, 처리하며 다양한 연산을 수행할 수 있습니다.

## 1.1 자바에서 2진법을 사용하는 예.
- **1. 이진 리터럴 :** 자바 7 이상부터는 정수를 이진 리터럴로 직접 표현할 수 있습니다.
    - 예를 들어, **'int x = 0b1010;'** 은 이진수 **'1010'** 이고, 십진수로 10입니다.
- **2. 비트 연산자 :** 자바는 비트 연산을 수행할 수 있는 여러 연산자를 제공합니다.
    - 예를 들어, 다음과 같습니다.
        - **`'&'`** (AND 연산자)
        - **`'|'`** (OR 연산자)
        - **`'^'`** (XOR 연산자)
        - **`'~'`** (NOT 연산자)
        - **`'<<'`** (왼쪽 시프트)
        - **`'>>'`** (오른쪽 시프트)
        - **`'>>>'`** (부호 없는 오른쪽 시프트)
            - 이들 연산자는 주로 효율적인 수치 계산, 저수준 프로그래밍, 암호와 작업 등에 사용됩니다.
- **3. 이진 데이터 조작 :** 파일이나 네트워크를 통해 바이트 단위로 데이터를 읽고 쓸 때, 이진 형식으로 데이터를 처리합니다.
    - 자바에서는 **`'byte'`** 자료형을 이용하여 이진 데이터를 직접 다룰 수 있습니다.

## 📝 정리
이진법을 사용하는 주된 이유는 컴퓨터 하드웨어가 전기 신호로 작동하기 때문에 0과 1, 즉 이진 상태를 나타내는 전기의 켜짐과 꺼짐 상태로 모든 데이터를 표현하기 편리하기 때문입니다.
이렇게 함으로써, 프로그래밍에서 더욱 직접적이고 효율적인 하드웨어 조작이 가능해집니다.

---

## 2. 2의 보수.
자바 프로그래밍에서의 2의 보수(2's complement)는 음수를 표현하기 위한 방법입니다.
컴퓨터 시스템은 보통 이진법을 사용하여 데이터를 저장하고 처리하는데, 이진법에서 음수를 표현하기 위해 가장 널리 사용되는 방법이 2의 보수입니다.

## 2.1 2의 보수 생성 과정.
- **1. 원래 숫자의 이진 표현을 얻습니다.**
    - 예를 들어, 5의 이진 표현은 **'0101'** 입니다.
- **2. 이진 표현의 모든 비트를 반전시킵니다.**
    - 즉, 0은 1로, 1은 0으로 변경합니다.
    - 5의 경우 **'0101'** 이 **'1010'** 이 됩니다.
- **3. 반전된 값에 1을 더합니다.**
    - 이렇게 하면 **'1011'** 이됩니다.

이렇게 생성된 **'1011'** 은 -5를 나타냅니다.
이 방법은 자바를 포함한 대부분의 프로그래밍 언어와 컴퓨터 시스템에서 음수를 표현하는 표준 방법입니다.

## 2.2 2의 보수의 장점.
- **덧셈 연산만으로 뺄셈을 할 수 있습니다.**
    - 예를 들어, 5-5를 계산하려면 5와 -5의 2의 보수를 더하면 됩니다.
        - 이진법으로는 **'1010 + 1011 = 10000'** 이고, 최상위 비트(캐리 비트)는 무시합니다.
            - 따라서 결과는 **'0000'** 이 됩니다.

- **오버플로 처리가 간단합니다.**
    - 캐리 비트는 무시하면서 자연스럽게 오버플로를 처리할 수 있습니다.

## 2.3 자바에서의 활용.
자바에서는 정수형 타입(**'int'**, **'long'**, **'short'**, **'byte'**) 이 이진법으로 2의 보수 형태로 저장되고 처리됩니다.
이는 자바의 모든 정수 연산에 내장된 메커니즘입니다.
예를 들어, 자바에서 **'-5'** 를 선언하면 내부적으로는 **'5'** 의 2의 보수인 **'111...11011'** (32비트 시스템에서의 표현)으로 저장됩니다.

## 📝 정리
2의 보수 방식은 음수를 다루기 위한 효과적인 방법이며, 프로그래머가 별도의 조치를 취하지 않아도 시스템이 자동으로 처리해 주기 때문에 매우 편리합니다.

---

## 3. 비트 논리연산자.
자바 프로그래밍에서 비트 논리연산자는 비트 단위로 논리 연산을 수행하는 연산자입니다.
이들 연산자는 주로 정수 타입의 변수에 사용되며, 각 비트를 독립적으로 비교하여 결과를 반환합니다.
비트 논리연산자는 주로 저수준 프로그래밍, 효율적인 데이터 처리, 상태 플래그 관리, 암호화 등의 작업에 활용됩니다.

자바에서 사용되는 주요 비트 논리 연산자는 다음과 같습니다.

- **1. AND 연산자('&') :** 두 피연산자의 비트가 모두 1일 경우에만 결과의 해당 비트를 1로 설정합니다.
    - 예를 들어, **'5 & 3'** 은 이진수로 **'0101 & 0011'** 을 계산하여 **'0001'** 이 되므로, 결과는 **'1'** 입니다.

- **2. OR 연산자('|') :** 두 피연산자 중 하나라도 비트가 1이면 결과의 해당 비트를 1로 설정합니다.
    - 예를 들어, **'5 | 3'** 은 이진수로 **'0101 | 0011'** 을 계산하여 **'0111'** 이 되므로, 결과는 **'7'** 입니다.

- **3. XOR 연산자('^') :** 두 피연산자의 비트가 서로 다를 경우 결과의 해당 비트를 1로 설정합니다.
    - 예를 들어, **'5 ^ 3'** 은 이진수로 **'0101 ^ 0011'** 을 계산하여 **'0110'** 이 되므로, 결과는 **'6'** 입니다.

- **4. NOT 연산자('~') :** 피연산자의 모든 비트를 반전시킵니다.(1은 0으로, 0은 1로).
    - 예를 들어, **'~5'** 는 이진수로 **'~0101'** 을 계산하여 **'...1010'**(무한히 많은 1 다음에 1010)이 되고, 이는 보통 32비트 시스템에서 **'-6'** 으로 해석됩니다.

- **5. 왼쪽 시프트('<<') :** 모든 비트를 왼쪽으로 지정된 수만틈 이동시키고, 오른쪽은 0으로 채웁니다.
    - 예를 들어.**'3 << 2'** 는 **'0011'** 을 왼쪽으로 2비트 이동하여 **'1100'** 이 되므로, 결과는 **'12'** 입니다.

- **6. 오른쪽 시프트('>>') :** 모든 비트를 오른쪽으로 지정된 수만큼 이동시키고, 왼쪽은 최상위 비트(부호 비트)의 값으로 채웁니다.
    - 예를 들어, **'-8 >> 2'** 는 **'11111000'** 을 오른쪽으로 2비트 이동하여 **'11111110'** 이 되므로, 결과는 **'-2'** 입니다.

- **7. 부호 없는 오른쪽 시프트('>>>') :** 모든 비트를 오른쪽으로 지정된 수만큼 이동시키고, 왼쪽은 0으로 채웁니다. 이는 부호 비트를 무시하고, 순수하게 비트를 오른쪽으로 이동시키기 때문에 음수에 사용했을 때 결과가 달라집니다.

## 📝 정리

이러한 비트 논리 연산자들은 데이터의 특정 비트를 직접 조작할 필요가 있는 경우에 유용하며, 자바 프로그래밍에서 중요한 도구입니다.

---
title: 💻[Code Review] `Member` 관련 클래스들에 대한 코드 리뷰.
tags:
    - Code review
    - OOP
    - SOLID
date: "2025-09-01"
thumbnail: "/assets/img/thumbnail/codereview.jpg"
---

# 💻[Code Review] `Member` 관련 클래스들에 대한 코드 리뷰.
## 🏛️ 아키텍처 및 설계 (Architecture & Design)
전체적으로 **계층형 아키텍처(Layerd Architecture)** 가 명확하게 분리되어 각자의 책임과 역할을 완벽하게 수행하고 있습니다.

* **Controller :** API End-point, 요청/응답 처리 담당
* **Service :** 비즈니스 로직 처리 담당
* **Repository :** 데이터 영속성(Persistence) 담당
* **Domain :** 핵심 비즈니스 규칙과 데이터 담당
* **DTO :** 계층 간 데이터 전송 담당

이러한 구조는 **SOLID의 단일 책임 원칙(SRP)** 과 **관심사의 분리(Separation of Concerns)** 원칙을 완벽하게 만족합니다.

---

## ✅ 클래스별 상세 리뷰 (Detailed Class Review)
```java
package com.kobe.productmanagement.domain;

import com.kobe.productmanagement.common.BaseTimeEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Member extends BaseTimeEntity {

	@Id
	@Column(length = 26)
	private String memberId;

	@NotBlank
	@Size(min = 10)
	@Column(nullable = false)
	private String memberPassword;

	@NotBlank
	@Column(nullable = false)
	private String memberName;

	@NotBlank
	@Email
	@Column(nullable = false)
	private String memberEmail;

	@NotBlank
	@Pattern(regexp = "^\\d{3}-\\d{3,4}-\\d{4}$", message = "휴대폰 번호 형식에 맞지 않습니다.")
	@Column(nullable = false)
	private String memberPhoneNumber;

	@NotBlank
	@Column(nullable = false)
	private String memberAddress;

	@Builder
	public Member(String memberId,
	              String memberPassword,
	              String memberName,
	              String memberEmail,
	              String memberPhoneNumber,
	              String memberAddress
	) {
		this.memberId = memberId;
		this.memberPassword = memberPassword;
		this.memberName = memberName;
		this.memberEmail = memberEmail;
		this.memberPhoneNumber = memberPhoneNumber;
		this.memberAddress = memberAddress;
	}

	public void updateMemberInfo(String memberName,
	                             String memberEmail,
	                             String memberPhoneNumber,
	                             String memberAddress) {
		if (memberName != null) {
			this.memberName = memberName;
		}
		if (memberEmail != null) {
			this.memberEmail = memberEmail;
		}
		if (memberPhoneNumber != null) {
			this.memberPhoneNumber = memberPhoneNumber;
		}
		if (memberAddress != null) {
			this.memberAddress = memberAddress;
		}
	}

	public void changePassword(String newPassword) {
		this.memberPassword = newPassword;
	}
}
```
### 1. `Member.java`(Domain Entity) - ⭐️ 핵심
* **OOP/SOLID :**
    * **가장 칭찬하고 싶은 부분!!**
    * 비즈니스 로직을 포함하는 **Rich Domain Model(풍부한 도메인 모델)** 을 성공적으로 구현했습니다.
    * 이로써 `Member` 객체는 자신의 상태를 스스로 책임지며, **캡슐화(Encapsulation)** 와 **단일 책임 원칙(SRP, Single Responsibility Principle)** 을 극대화했습니다.
* **Bean Validation :**
    * `@Email`, `@Pattern` 등을 활용하여 데이터 유효성 검증 규칙을 도메인 모델에 명시적으로 표현한 점이 매우 좋습니다.

```java
package com.kobe.productmanagement.controller;

import com.kobe.productmanagement.common.ApiResponse;
import com.kobe.productmanagement.dto.response.MemberResponse;
import com.kobe.productmanagement.service.MemberService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/admin/members")
public class MemberAdminController {
	private final MemberService memberService;

	@GetMapping
	public ResponseEntity<ApiResponse<List<MemberResponse>>> getAllMembers() {
		List<MemberResponse> memberResponses = memberService.getMembers();
		ApiResponse<List<MemberResponse>> response = ApiResponse.success("전체 회원 목록이 성공적으로 조회되었습니다.", memberResponses);
		return ResponseEntity.ok(response);
	}

	@GetMapping("/{memberId}")
	public ResponseEntity<ApiResponse<MemberResponse>> getMember(@PathVariable String memberId) {
		MemberResponse memberResponse = memberService.getMember(memberId);
		ApiResponse<MemberResponse> response = ApiResponse.success("회원 정보가 성공적으로 조회되었습니다.", memberResponse);
		return ResponseEntity.ok(response);
	}
}
```

### 2. `MemberAdminController.java`(Controller)
* **의존성 역전 원칙(DIP, Dependency Inversion Principle) :**
    * `MemberServiceImpl` 이라는 구체 클래스(Concrete Class)가 아닌 `Member Service` 인터페이스(Interface)에 의존하고 있습니다.
        * 이는 유연하고 확장 가능한 구조의 핵심입니다.
        * `@RequiredArgsConstructor`를 통핸 생성자 주입은 이를 더욱 깔끔하게 만들어 줍니다.
* **API 설계 :**
    * `ResponseEntity`와 `ApiResponse`를 함께 사용하여 HTTP 상태 코드, 응답 메시지, 데이터를 체계적으로 반환하는 방식은 **RESTful API**의 좋은 관례(Best Practice)입니다.

```java
package com.kobe.productmanagement.service;

import com.kobe.productmanagement.dto.response.MemberResponse;

import java.util.List;

public interface MemberService {
	List<MemberResponse> getMembers();
	MemberResponse getMember(String memberId);
}
```
```java

package com.kobe.productmanagement.service;

import com.kobe.productmanagement.domain.Member;
import com.kobe.productmanagement.dto.response.MemberResponse;
import com.kobe.productmanagement.repository.MemberRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional
public class MemberServiceImpl implements MemberService {

	private final MemberRepository memberRepository;

	@Override
	@Transactional(readOnly = true)
	public List<MemberResponse> getMembers() {
		return memberRepository.findAll().stream()
			.map(MemberResponse::from)
			.collect(Collectors.toList());
	}

	@Override
	@Transactional(readOnly = true)
	public MemberResponse getMember(String memberId) {
		Member member = memberRepository.findById(memberId)
			.orElseThrow(() -> new IllegalArgumentException("멤버 아이디: " + memberId + " 을 찾을 수 없습니다."));
		return MemberResponse.from(member);
	}
}
```
### 3. `MemberService.java` & `MemberServiceImpl.java` (Service)
* **역할 분리 :**
    * `MemberService` 인터페이스는 **"무엇을 하는가"(What)** 를 정의하고, `MemberServiceImpl`은 **"어떻게 하는가"(How)** 를 구현함으로써 역할을 완벽하게 분리했습니다.
        * 이는 **의존성 역전 원칙(DIP, Dependency Inversion Priciple)** 의 교과서적인 예시입니다.
* **트랜잭션 관리 :**
    * 클래스 레벨에 `@Transactional`을 선언하고, 조회 메서드에 `@Transactional(readOnly = true)`를 적용하여 성능 최적화까지 고려한 점이 훌륭합니다.
* **예외 처리 :**
    * `orElseThrow`를 사용하여 ID에 해당하는 멤버가 없을 경우 명확한 예외를 발생시키는 로직은 견고한 코드를 만듭니다.

```java
package com.kobe.productmanagement.repository;

import com.kobe.productmanagement.domain.Member;
import org.springframework.data.jpa.repository.JpaRepository;

public interface MemberRepository extends JpaRepository<Member, String> {
}
```
### 4. `MemberRepository.java` (Repository)
* Spring Data JPA의 장점을 잘 활용하고 있습니다.
    * `JpaRepository` 인터페이스를 상속받는 것만으로 기본적인 CRUD 기능을 확보하고, 필요에 따라 쿼리 메서드를 추가할 수 있는 확장성 높은 구조입니다.

```java
package com.kobe.productmanagement.dto.request;

import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@NoArgsConstructor
public class MemberRequest {
	private String memberPassword;
	private String memberName;
	private String memberEmail;
	private String memberPhoneNumber;
	private String memberAddress;

	@Builder
	public MemberRequest(String memberPassword,
	                     String memberName,
	                     String memberEmail,
	                     String memberPhoneNumber,
	                     String memberAddress
	) {
		this.memberPassword = memberPassword;
		this.memberName = memberName;
		this.memberEmail = memberEmail;
		this.memberPhoneNumber = memberPhoneNumber;
		this.memberAddress = memberAddress;
	}
}
```
```java
package com.kobe.productmanagement.dto.response;

import com.kobe.productmanagement.domain.Member;
import lombok.Getter;

import java.time.LocalDateTime;

@Getter
public class MemberResponse {
	private final String memberId;
	private final String memberName;
	private final String memberEmail;
	private final String memberPhoneNumber;
	private final String memberAddress;
	private final LocalDateTime createdAt;
	private final LocalDateTime updatedAt;

	public static MemberResponse from(Member member) {
		return new MemberResponse(
			member.getMemberId(),
			member.getMemberName(),
			member.getMemberEmail(),
			member.getMemberPhoneNumber(),
			member.getMemberAddress(),
			member.getCreatedAt(),
			member.getUpdatedAt()
		);
	}

	private MemberResponse(String memberId,
	                        String memberName,
	                        String memberEmail,
	                        String memberPhoneNumber,
	                        String memberAddress,
	                        LocalDateTime createdAt,
	                        LocalDateTime updatedAt
	) {
		this.memberId = memberId;
		this.memberName = memberName;
		this.memberEmail = memberEmail;
		this.memberPhoneNumber = memberPhoneNumber;
		this.memberAddress = memberAddress;
		this.createdAt = createdAt;
		this.updatedAt = updatedAt;
	}
}
```
### 5. `MemberRequest.java` & `MemberResponse.java` (DTOs)
* **계층 간 분리 :** 
    * DTO를 사용함으로써 **API 스펙과 도메인 모델을 완벽하게 분리**했습니다. 이는 매우 중요한 설계 원칙입니다.
        * 예를 들어, 나중에 `Member` 엔티티에 내부적으로만 사용하는 필드가 추가되더라도 `MemberResponse`를 수정하지 않는 한 API 응답에는 아무런 영향이 없습니다.
* **`MemberResponse`의 `from` 메서드 :**
    * 엔티티를 DTO로 변환하는 로직을 DTO 내의 정적 팩토리 메서드(`from`)로 캡슐화한 것은 매우 좋은 패턴입니다. 이는 변환 로직의 응집도를 높여줍니다.

---

## 🏆 총평

* 각 클래스는 자신의 책임에만 집중하고 있으며, 인터페이스를 통해 서로 유연하게 협력하고 있습니다.
    * 이 구조는 앞으로 새로운 기능을 추가하거나 기존 기능을 변경해야 할 때 그 장점을 명확하게 보여줄 것입니다.
* 이 설계와 구현 방식을 꾸준히 유지해 나가신다면, 성공적인 프로젝트가 될 것 입니다.

---
title: "💾 [CS] 레지스터"
tags:
    - CS
date: "2024-04-11"
thumbnail: "/assets/img/thumbnail/cs.jpeg"
---

# 레지스터.
- 프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장됩니다.
    - 따라서 레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름을 파악할 수 있습니다
        - 다시 말해 레지스터 속 값을 유심히 관찰하면 프로그램을 실행할 때 CPU 내에서 무슨 일이 벌어지고 있는지, 어떤 명령어가 어떻게 수행되는지 알 수 있습니다.

## 반드시 알아야 할 레지스터.

1. 프로그램 카운터
2. 명령어 레지스터
3. 메모리 주소 레지스터
4. 메모리 버퍼 레지스터
5. 플래스 레지스터
6. 범용 레지스터
7. 스택 포인터
8. 베이스 레지스터

### 프로그램 카운터.
- **프로그램 카운터(PC: Program Counter) :** 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장합니다.
    - 프로그램 카운터를 **명령어 포인터(IP: Instruction Pointer)** 라고 부르는 CPU도 있습니다.

### 명령어 레지스터.
- **명령어 레지스터(IR: Instruction Register) :** 해석할 명령어, 즉 방금 메로미에서 읽어 들인 명령어를 저장하는 레지스터입니다.
    - 제어장치는 명령어를 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보냅니다.

### 메모리 주소 레지스터.
- **메모리 주소 레지스터(MAR: Memory Address Register) :** 메모리 주소를 저장하는 레지스터입니다. CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 됩니다.

### 메모리 버퍼 레지스터.
- **메모리 버퍼 레지스터(MBR: Memory buffer register) :** 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터입니다.
    - 즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거칩니다.
        - CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거칩니다.
            - 메모리 버퍼 레지스터는 메모리 데이터 레지스터(MDR: Memory Data Register)라고도 불립니다.


메모리에 저장된 프로그램을 실행하는 과정에서 프로그램 카운터, 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터에 어떤 값들이 담기는지 알아봅시다.

## 1.
CPU로 실행할 프로그램이 1000번지부터 1500번지까지 저장되어 있다고 가정하겠습니다,
그리고 1000번지에는 1101₍₂₎이 저장되어 있다고 가정하겠습니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%85%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-1.png?raw=true">

## 2.
프로그램을 처음부터 실행하기 위해 프로그램 카운터에는 1000이 저장됩니다.
이는 메모리에서 가져올 명령어가 1000번지에 있다는 걸 의미합니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%85%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-2.png?raw=true">

## 3. 
1000번지를 읽어 들이기 위해서는 주소 버스로 100번지를 내보내야 합니다.
이를 위해 메모리 주소 레지스터에는 1000이 저장됩니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%85%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-3.png?raw=true">

## 4.
'메모리 읽기' 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내집니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%85%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-4.png?raw=true">

## 5.
메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 증가되어 다음 명령어를 읽어 들일 준비를 합니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%85%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-5.png?raw=true">

## 6.
메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동합니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%85%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-6.png?raw=true">

## 7.
제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킵니다.

**5단계에서** 프로그램 카운터 값이 증가한 것을 확인했습니다.
- 프로그램 카운터 값이 증가했으니 1000번지 명령어 처리가 끝나면 CPU는 다음 명령어(1001번지)를 읽어 들입니다.

이처럼 프로그램 카운터는 지속적으로 증가하며 계속해서 다음 명령어를 읽어 들일 준비를 합니다.
- 이 과정이 반복되면서 CPU는 프로그램을 차례대로 실행해 나갑니다.
    - 결국 CPU가 메모리 속 프로그램을 순차적으로 읽어 들이고 실행해 나갈 수 있는 이유는 CPU 속 프로그램 카운터가 꾸준히 증가하기 때문입니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%85%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-7.png?raw=true">

### 범용 레지스터
- **범용 레지스터(general purpose register) :** 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터입니다.
    - 메모리 버퍼 레지스터는 테이터 버스로 주고받을 값만 저장하고, 메모리 주소 레지스터는 주소 버스로 내보낼 주소값만 저장하지만, 범용 레지스터는 데이터와 주소를 모두 저장할 수 있습니다.
        - 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있고, 현대 대다수 CPU는 모두 범용 레지스터를 가지고 있습니다.

### 플레그 레지스터
- **플래그 레지스터(Flag register) :** 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터입니다.

# 특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식.
- **스택 주소 지정 방식 :** 스택과 스택 포인터를 이용한 주소 지정 방식
    - 스택은 한쪽 끝이 막혀 있는 통과 같은 저장 공간입니다.
        - 그래서 스택은 가장 최근에 저장하는 값부터 꺼낼 수 있습니다.
            - 여기서 **스택 포인터란** 스택의 꼭대기를 가리키는 레지스터입니다.
                - 즉, 스택 포인터는 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터입니다.

예를 들어 봅시다.

가령 다음과 같이 위에서부터 주소가 매겨져 있고 아래부터 차곡차곡 데이터가 저장되어 있는 스택이 있다고 가정해봅시다.
- 이때 스택 포인터는 스택의 제일 꼭대기 주소, 즉 4번지를 저장하고 있습니다.
    - 이는 '스택 포인터가 스택의 꼭대기를 가리키고 있다'고 볼 수 있겠죠.
        - 쉽게 말해, 스택 포인터는 스택의 어디까지 데이터가 캐워져 있는지에 대한 표시라고 보면 됩니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8%E1%84%91%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-1.png?raw=true"><br>


<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8%E1%84%91%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-2.png?raw=true">

그럼 이 스택에서 데이터를 꺼낼 때는 어떤 데이터부터 꺼내게 될까요?
 - 1 -> 2 -> 3 순서대로 꺼낼 수 있습니다.
     - 여기서 하나의 데이터를 꺼내면 스택에는 2와 3이 남고, 스택의 꼭대기 주소가 달라졌기 때문에 스택 포인터는 5번지를 가리킵니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8%E1%84%91%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-3.png?raw=true">

반대로 스택에 데이터를 추가한다면 어떻게 될까요?
- 현재 스텍세 4라는 데이터를 저장하면 스택의 꼭대기에 4가 저장됩니다.
    - 이때 스택의 꼭대기 주소가 달라졌기 때문에 스택 포인터는 4번지를 가리킵니다.

그런데 스택이라는 것은 도대체 어디에 있는 걸까요?
- 스택은 메모리 안에 있습니다.
    - 정확히는 메모리 안에 스택처럼 사용할 영역이 정해져 있습니다.
        - 이를 **스택 영역**이라고 합니다.
            - 이 영역은 다른 주소 공간과는 다르게 스택처럼 사용하기 암묵적으로 약속된 영역입니다.

# 특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%87%E1%85%A7%E1%86%AB%E1%84%8B%E1%85%B1%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-1.png?raw=true">

- **변위 주소 지정 방식(displacement addressing mode) :** 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식입니다.

그래서 변위 주소 지정방식을 사용하는 명령어는 다음 그림과 같이 연산 코드 필드, 어떤 레지스터의 값과 더할지를 나타내는 레지스터 필드, 그리고 주소를 담고있는 오퍼랜드 필드가 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%87%E1%85%A7%E1%86%AB%E1%84%8B%E1%85%B1%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-2.png?raw=true">

이때, 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 **상대 주소 지정 방식**, **베이스 레지스터 주소 지정 방식** 등으로 나뉩니다.

### 상대 주소 지정 방식
- **상대 주소 지정 방식(relative addressing mode) :** 오퍼랜드와 프로그램 카운터와 값을 더하여 유효 주소를 얻는 방식입니다.
    - 프로그램 카운터에는 읽어 들일 명령어의 주소가 저장되어 있습니다.
        - 만약 오퍼랜드가 음수, 가령 -3이였다면 CPU는 읽어 들이기로 한 명령어로부터 '세 번째 이전' 번지로 접근합니다.
            - 한마디로 실행하려는 명령어의 세 칸 이전 번지 명령어를 실행하는 것이지요

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%87%E1%85%A7%E1%86%AB%E1%84%8B%E1%85%B1%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-3.png?raw=true">

반면, 오퍼랜드가 양수, 가열 3이었다면 CPU는 읽어 들이기로 했던 명령어의 '세 번째 이후' 번지로 접근합니다.
- 즉, 실행하려는 명령어에서 세 칸 건너뛴 번지를 실행하는 겁니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%87%E1%85%A7%E1%86%AB%E1%84%8B%E1%85%B1%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-4.png?raw=true">

상대 주소 지정 방식은 프로그래밍 언어의 if문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용됩니다.

### 베이스 레지스터 주소 지정 방식
- **베이스 레지스터 주소 지정 방식(base-register addressing mode) :** 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식입니다.

여기서 베이스 레지스터는 '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리'로서의 역할을 합니다.
- 즉, 베이스 레지스터 주소 지정 방식은 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식입니다.

가령 베이스 레지스터에 200이라는 값이 있고 오퍼랜드가 40이라면 이는 "기준 주소 200번지로부터 40만큼 떨어진 240번지로 접근하라"를 의미합니다.

또 베이스 레지스터에 550이라는 값이 담겨 있고 오퍼랜드가 50이라면 이는 "기준 주소 550번지로부터 50만큼 떨어진 600번지로 접근하라"를 의미하는 명령어 입니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%87%E1%85%A7%E1%86%AB%E1%84%8B%E1%85%B1%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%E1%84%8C%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%E1%84%8B%E1%85%A8%E1%84%89%E1%85%B5%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7-5.png?raw=true">

## 키워드로 정리하는 핵심 포인트
- **프로그램 카운터** 는 메모리에서 가져올 명령어의 주소, **명령어 레지스터**는 해석할 명령어를 저장합니다.
- **메모리 주소 레지스터**는 메모리의 주소, **메모리 버퍼 레지스터**는 메모리와 주고받을 데이터를 저장합니다.
- **범용 레지스터**는 데이터와 주소를 모두 저장하고, **플래그 레지스터**는 연산 결과 혹은 CPU 상태에 대한 부가 정보를 저장합니다.
- **스택 포인터**는 스택 최상단의 위치를 저장합니다.
- **베이스 레지스터**에 저장된 주소는 기준 주소로서의 역할을 합니다.

**더 알아보기**
- **Jump**
   - Jump 명령어는 프로그램의 실행 흐름을 끊고 지정된 주소로 점프합니다.
- **Conditional Jump**
   - Conditional Jump 명령어는 특정 조건이 충족될 때에만 주어진 주소로 점프합니다.
- **Call**
   - Call 명령어는 현재 위치를 저장하고 지정된 주소로 이동합니다. 
   - 현재 위치를 저장하기 위해 스택을 사용합니다.
   - 주로 서브루틴(하위 루틴 또는 함수)을 호출할 때 사용됩니다.
- **Return**
   - Return 명령어는 서브루틴에서 호출자로 복귀합니다.
   - 호출된 서브루틴이 실행을 마치고 호출자로 돌아갈 때 사용됩니다.

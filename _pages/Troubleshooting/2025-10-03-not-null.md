---
title: "🔍[Troubleshooting] 🚀 Not-Null 제약 조건 위반"
tags:
    - Troubleshooting
    - Backend Development
    - Spring Boot
date: "2025-10-03"
thumbnail: "/assets/img/thumbnail/troubleshooting.jpg"
---

# 🚀 Not-Null 제약 조건 위반!

## 🚨 에러 메시지

```
org.hibernate.PropertyValueException: 
not-null property references a null or transient value: 
com.kobe.schoolmanagement.domain.entity.Student.major
```

### 최종 예외
```
DataIntegrityViolationException
```

---

## 🔍 핵심 원인

**`Student` 엔티티의 `major` 필드가 `null`인 상태로 저장을 시도했기 때문입니다.**

### 제약 조건 확인

```java
@Entity
public class Student {
    // ...
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(nullable = false, name = "major_id")  // ❌ null 허용 안 함
    private Major major;
}
```

`nullable = false` 설정으로 인해 `major` 필드는 **반드시 값이 있어야 합니다.**

---

## 📊 문제 발생 흐름

```
클라이언트 요청
    ↓
{"name": "강민성", "admissionYear": 2010, "majorName": "Computer"}
    ↓
StudentRequestDto 수신
    ↓
StudentService.createStudent() 호출
    ↓
requestDto.toEntity(studentId) 실행
    ↓
Student 엔티티 생성
    ├── name: "강민성" ✅
    ├── admissionYear: 2010 ✅
    └── major: null ❌  (Major 엔티티를 조회하지 않음!)
    ↓
studentRepository.save(student)
    ↓
Hibernate가 데이터베이스에 저장 시도
    ↓
NOT NULL 제약 조건 위반 감지
    ↓
PropertyValueException 발생
    ↓
DataIntegrityViolationException
```

---

## 💡 문제 상황 분석

### 누락된 로직

| 단계 | 현재 상황 | 필요한 작업 |
|------|----------|-------------|
| 1 | `majorName` 문자열 수신 | ✅ 완료 |
| 2 | `majorName`으로 `Major` 엔티티 조회 | ❌ **누락됨** |
| 3 | 조회한 `Major` 객체를 `Student`에 설정 | ❌ **누락됨** |
| 4 | `Student` 저장 | ✅ 시도했으나 실패 |

### 결과
```
majorName: "Computer" (String)
    ↓
❌ Major 엔티티 조회 로직 없음
    ↓
major 필드: null
    ↓
저장 실패!
```

---

## ✅ 해결 방안

3단계로 문제를 해결합니다.

---

### Step 1: MajorRepository 메서드 추가

`Major` 엔티티를 전공 이름으로 조회할 수 있는 메서드를 추가합니다.

```java
package com.kobe.schoolmanagement.repository;

import com.kobe.schoolmanagement.domain.entity.Major;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface MajorRepository extends JpaRepository<Major, Long> {
    
    Optional<Major> findByMajorNumber(String majorNumber);
    
    // ✅ 전공 이름으로 조회하는 메서드 추가
    Optional<Major> findByName(String name);
}
```

#### 💡 Spring Data JPA 쿼리 메서드
```java
findByName("Computer")
// ↓ 자동으로 다음 쿼리 생성
// SELECT * FROM major WHERE name = 'Computer'
```

---

### Step 2: StudentService 로직 수정

`Major` 엔티티를 조회하고 `Student`에 설정하는 로직을 추가합니다.

#### Before
```java
@Transactional
public StudentResponseDto createStudent(StudentRequestDto requestDto) {
    int admissionYear = requestDto.getAdmissionYear();
    String majorName = requestDto.getMajorName();
    
    // ❌ Major 엔티티 조회 없음
    
    long sequence = studentRepository.countByAdmissionYearAndMajorName(
        admissionYear, majorName) + 1;
    
    String studentId = createStudentNumber.generate(
        admissionYear, majorName, sequence);
    
    // ❌ major가 null인 상태로 엔티티 생성
    Student student = requestDto.toEntity(studentId);
    Student savedStudent = studentRepository.save(student);
    
    return StudentResponseDto.fromEntity(savedStudent);
}
```

#### After
```java
package com.kobe.schoolmanagement.service;

import com.kobe.schoolmanagement.common.CreateStudentNumber;
import com.kobe.schoolmanagement.domain.entity.Major;
import com.kobe.schoolmanagement.domain.entity.Student;
import com.kobe.schoolmanagement.dto.request.StudentRequestDto;
import com.kobe.schoolmanagement.dto.response.StudentResponseDto;
import com.kobe.schoolmanagement.repository.MajorRepository;
import com.kobe.schoolmanagement.repository.StudentRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class StudentService {
    
    private final StudentRepository studentRepository;
    private final MajorRepository majorRepository;  // ✅ 의존성 주입
    private final CreateStudentNumber createStudentNumber;

    @Transactional
    public StudentResponseDto createStudent(StudentRequestDto requestDto) {
        // 1. DTO로부터 필요한 정보 추출
        int admissionYear = requestDto.getAdmissionYear();
        String majorName = requestDto.getMajorName();

        // ✅ 2. Major 엔티티 조회 (핵심 수정)
        Major major = majorRepository.findByName(majorName)
                .orElseThrow(() -> new IllegalArgumentException(
                    "존재하지 않는 전공입니다: " + majorName));

        // 3. 학생 수 카운트
        long sequence = studentRepository.countByAdmissionYearAndMajorName(
            admissionYear, majorName) + 1;

        // 4. 학번 생성
        String studentId = createStudentNumber.generate(
            admissionYear, majorName, sequence);

        // 5. 학번 중복 검사
        studentRepository.findByStudentId(studentId).ifPresent(s -> {
            throw new IllegalStateException("학번 생성 충돌 발생. 다시 시도해주세요");
        });

        // ✅ 6. major 객체를 함께 전달하여 엔티티 생성
        Student student = requestDto.toEntity(studentId, major);
        Student savedStudent = studentRepository.save(student);

        return StudentResponseDto.fromEntity(savedStudent);
    }

    @Transactional(readOnly = true)
    public StudentResponseDto getStudent(String studentId) {
        Student student = studentRepository.findByStudentId(studentId)
            .orElseThrow(() -> new IllegalArgumentException(
                "존재하지 않는 학생입니다."));

        return StudentResponseDto.fromEntity(student);
    }
}
```

#### 💡 주요 변경사항
```java
// 1. MajorRepository 주입 추가
private final MajorRepository majorRepository;

// 2. Major 엔티티 조회
Major major = majorRepository.findByName(majorName)
    .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 전공입니다"));

// 3. toEntity()에 major 전달
Student student = requestDto.toEntity(studentId, major);
```

---

### Step 3: StudentRequestDto.toEntity() 메서드 수정

`toEntity` 메서드가 `Major` 객체를 받아서 설정하도록 수정합니다.

#### Before
```java
public class StudentRequestDto {
    private String name;
    private int admissionYear;
    private String majorName;
    
    public Student toEntity(String studentId) {
        return Student.builder()
                .name(this.name)
                .studentId(studentId)
                .admissionYear(this.admissionYear)
                // ❌ major 필드 설정 없음 (null로 남음)
                .build();
    }
}
```

#### After
```java
public class StudentRequestDto {
    private String name;
    private int admissionYear;
    private String majorName;
    
    // ✅ Major 객체를 파라미터로 받도록 수정
    public Student toEntity(String studentId, Major major) {
        return Student.builder()
                .name(this.name)
                .studentId(studentId)
                .admissionYear(this.admissionYear)
                .major(major)  // ✅ Major 객체 설정
                .build();
    }
}
```

---

## 🔄 수정 후 데이터 흐름

```
클라이언트 요청
    ↓
{"name": "강민성", "admissionYear": 2010, "majorName": "Computer"}
    ↓
StudentService.createStudent()
    ↓
majorRepository.findByName("Computer")  ✅ 추가됨
    ↓
Major 엔티티 조회 성공
    └── id: 1
    └── majorNumber: "31513162120518"
    └── name: "Computer"
    ↓
requestDto.toEntity(studentId, major)  ✅ major 전달
    ↓
Student 엔티티 생성
    ├── name: "강민성" ✅
    ├── admissionYear: 2010 ✅
    └── major: Major 객체 ✅ (null 아님!)
    ↓
studentRepository.save(student)
    ↓
저장 성공! ✅
```

---

## 📋 전체 수정 요약

| 파일 | 수정 내용 | 목적 |
|------|----------|------|
| **MajorRepository** | `findByName()` 메서드 추가 | 전공 이름으로 조회 |
| **StudentService** | `majorRepository` 주입<br>`Major` 조회 로직 추가<br>`toEntity()`에 `major` 전달 | Major 엔티티 조회 및 설정 |
| **StudentRequestDto** | `toEntity()` 시그니처 변경<br>`major` 필드 설정 추가 | Major 객체를 받아서 설정 |

---

## ✅ 테스트

### Postman 요청
```json
POST http://localhost:8080/api/v1/students

{
    "name": "강민성",
    "admissionYear": 2010,
    "majorName": "Computer"
}
```

### 예상 응답
```json
{
    "name": "강민성",
    "admissionYear": 2010,
    "major_info": {
        "id": 1,
        "majorNumber": "31513162120518",
        "name": "Computer"
    }
}
```

### 데이터베이스 확인
```sql
-- Student 테이블
SELECT * FROM student;
```
| id | name | student_id | admission_year | major_id |
|----|------|------------|----------------|----------|
| 1 | 강민성 | 1003001 | 2010 | 1 ✅ |

---

## ⚠️ 주의사항

### 1. 존재하지 않는 전공명 처리

```java
Major major = majorRepository.findByName(majorName)
    .orElseThrow(() -> new IllegalArgumentException(
        "존재하지 않는 전공입니다: " + majorName));
```

- 존재하지 않는 `majorName`을 받으면 예외 발생
- 사전에 `Major` 데이터가 DB에 있어야 함

### 2. Major 데이터 사전 등록

```java
// Major 엔티티를 미리 저장해야 함
Major computerMajor = Major.builder()
    .majorNumber("31513162120518")
    .name("Computer")
    .build();
majorRepository.save(computerMajor);
```

---

## 📌 Best Practices

### 1. DTO에서 엔티티 참조 설정

```java
// ❌ 나쁜 예: DTO에서 직접 조회
public Student toEntity(String studentId) {
    Major major = majorRepository.findByName(this.majorName).orElseThrow();
    // DTO가 Repository에 의존하게 됨!
}

// ✅ 좋은 예: 파라미터로 받기
public Student toEntity(String studentId, Major major) {
    // 의존성이 명확하고 테스트하기 쉬움
}
```

### 2. 예외 메시지에 컨텍스트 포함

```java
// ❌ 나쁜 예
throw new IllegalArgumentException("존재하지 않는 전공입니다.");

// ✅ 좋은 예
throw new IllegalArgumentException("존재하지 않는 전공입니다: " + majorName);
```

### 3. 엔티티 제약 조건 확인

```java
@JoinColumn(nullable = false, name = "major_id")
// └─ nullable = false 설정 확인
//    필수 필드는 반드시 값을 설정해야 함
```

---

## 🔧 트러블슈팅

### Q1. "존재하지 않는 전공입니다" 예외가 계속 발생해요

**원인**: Major 데이터가 DB에 없음

**해결**:
```sql
-- Major 데이터 확인
SELECT * FROM major WHERE name = 'Computer';

-- 데이터가 없다면 삽입
INSERT INTO major (major_number, name) 
VALUES ('31513162120518', 'Computer');
```

### Q2. major_id가 null로 저장되어요

**원인**: `Student.builder()`에서 `major()` 메서드 호출 누락

**해결**:
```java
Student.builder()
    .name(this.name)
    .studentId(studentId)
    .admissionYear(this.admissionYear)
    .major(major)  // ✅ 이 줄 추가 확인
    .build();
```

### Q3. LazyInitializationException이 발생해요

**원인**: `FetchType.LAZY`로 설정된 major를 트랜잭션 밖에서 접근

**해결**:
```java
@Transactional(readOnly = true)  // ✅ 트랜잭션 범위 확인
public StudentResponseDto getStudent(String studentId) {
    Student student = studentRepository.findByStudentId(studentId)
        .orElseThrow();
    return StudentResponseDto.fromEntity(student);  // 트랜잭션 내에서 변환
}
```
